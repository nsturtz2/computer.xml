<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>Wikipedia</sitename>
    <dbname>enwiki</dbname>
    <base>https://en.wikipedia.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.35.0-wmf.30</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Wikipedia</namespace>
      <namespace key="5" case="first-letter">Wikipedia talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="100" case="first-letter">Portal</namespace>
      <namespace key="101" case="first-letter">Portal talk</namespace>
      <namespace key="108" case="first-letter">Book</namespace>
      <namespace key="109" case="first-letter">Book talk</namespace>
      <namespace key="118" case="first-letter">Draft</namespace>
      <namespace key="119" case="first-letter">Draft talk</namespace>
      <namespace key="446" case="first-letter">Education Program</namespace>
      <namespace key="447" case="first-letter">Education Program talk</namespace>
      <namespace key="710" case="first-letter">TimedText</namespace>
      <namespace key="711" case="first-letter">TimedText talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Computer</title>
    <ns>0</ns>
    <id>7878457</id>
    <revision>
      <id>954337387</id>
      <parentid>954334232</parentid>
      <timestamp>2020-05-01T22:20:13Z</timestamp>
      <contributor>
        <username>Deacon Vorbis</username>
        <id>29330520</id>
      </contributor>
      <comment>Undid revision 954334232 by [[Special:Contributions/PBZE|PBZE]] ([[User talk:PBZE|talk]]) [[MOS:OL]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="119159" xml:space="preserve">{{Other uses|Computer (disambiguation)}}
{{Pp-semi-indef}}
{{Pp-move-indef}}
{{short description|Automatic general-purpose device for performing arithmetic or logical operations}}
{{Infobox|title = Computer
|image = &lt;div style="white-space:nowrap;"&gt;
[[File:Acer Aspire 8920 Gemstone by Georgy.JPG|x81px]][[File:Columbia Supercomputer - NASA Advanced Supercomputing Facility.jpg|x81px]][[File:Intertec Superbrain.jpg|x81px]]&lt;br /&gt;[[File:2010-01-26-technikkrempel-by-RalfR-05.jpg|x79px]][[File:Thinking Machines Connection Machine CM-5 Frostburg 2.jpg|x79px]][[File:G5 supplying Wikipedia via Gigabit at the Lange Nacht der Wissenschaften 2006 in Dresden.JPG|x79px]]&lt;br /&gt;[[File:DM IBM S360.jpg|x77px]][[File:Acorn BBC Master Series Microcomputer.jpg|x77px]][[File:Dell PowerEdge Servers.jpg|x77px]]&lt;/div&gt;
|caption = Computers and computing devices from different eras}}

A '''computer''' is a machine that can be instructed to carry out [[sequence]]s of [[arithmetic]] or [[Boolean algebra|logical]] operations automatically via [[computer programming]]. Modern computers have the ability to follow generalized sets of operations, called ''[[Computer program|programs]].'' These programs enable computers to perform an extremely wide range of tasks. A "complete" computer including the [[Computer hardware|hardware]], the [[operating system]] (main [[software]]), and [[peripheral]] equipment required and used for "full" operation can be referred to as a '''computer system'''. This term may as well be used for a group of computers that are connected and work together, in particular a [[computer network]] or [[computer cluster]].

Computers are used as [[control system]]s for a wide variety of [[Programmable logic controller|industrial]] and [[Consumer electronics|consumer devices]]. This includes simple special purpose devices like [[microwave oven]]s and [[remote control]]s, factory devices such as [[industrial robot]]s and [[computer-aided design]], and also general purpose devices like [[personal computer]]s and [[mobile device]]s such as [[smartphone]]s. The [[Internet]] is run on computers and it connects hundreds of millions of other computers and their users.

Early computers were only conceived as calculating devices. Since ancient times, simple manual devices like the [[abacus]] aided people in doing calculations. Early in the [[Industrial Revolution]], some mechanical devices were built to automate long tedious tasks, such as guiding patterns for [[loom]]s. More sophisticated electrical [[machine]]s did specialized [[analogue electronics|analog]] calculations in the early 20th century. The first [[Digital data|digital]] electronic calculating machines were developed during [[World War II]]. The first [[semiconductor]] [[transistors]] in the late 1940s were followed by the [[silicon]]-based [[MOSFET]] (MOS transistor) and [[monolithic integrated circuit]] (IC) chip technologies in the late 1950s, leading to the [[microprocessor]] and the [[microcomputer revolution]] in the 1970s. The speed, power and versatility of computers have been increasing dramatically ever since then, with [[Transistor count|MOS transistor counts]] increasing at a rapid pace (as predicted by [[Moore's law]]), leading to the [[Digital Revolution]] during the late 20th to early 21st centuries.

Conventionally, a modern computer consists of at least one [[processing element]], typically a [[central processing unit]] (CPU) in the form of a [[metal-oxide-semiconductor]] (MOS) [[microprocessor]], along with some type of [[computer memory]], typically MOS [[semiconductor memory]] chips. The processing element carries out arithmetic and logical operations, and a sequencing and control unit can change the order of operations in response to stored [[data|information]]. [[Peripheral]] devices include input devices (keyboards, mice, joystick, etc.), output devices (monitor screens, printers, etc.), and input/output devices that perform both functions (e.g., the 2000s-era [[touchscreen]]). [[Peripheral|Peripheral devices]] allow information to be retrieved from an external source and they enable the result of operations to be saved and retrieved.
{{TOC limit|3}}

== Etymology ==
[[File:X-4 with Female Computer - GPN-2000-001932.jpg|thumb|A female computer, with microscope and calculator, 1952|alt=A human computer.]]
According to the ''Oxford English Dictionary'', the first known use of the word "computer" was in 1613 in a book called ''The Yong Mans Gleanings'' by English writer Richard Braithwait: "I haue [sic] read the truest computer of Times, and the best Arithmetician that euer [sic] breathed, and he reduceth thy dayes into a short number." This usage of the term referred to a [[human computer]], a person who carried out calculations or computations. The word continued with the same meaning until the middle of the 20th century. During the latter part of this period women were often hired as computers because they could be paid less than their male counterparts.{{Sfn|Evans|2018|p=23}} By 1943, most human computers were women.{{Sfn|Smith|2013|p=6}}

The ''Online Etymology Dictionary'' gives the first attested use of "computer" in the 1640s, meaning "one who calculates"; this is an "agent noun from compute (v.)". The ''Online Etymology Dictionary'' states that the use of the term to mean {{"'}}calculating machine' (of any type) is from 1897."  The ''Online Etymology Dictionary'' indicates that the "modern use" of the term, to mean "programmable digital electronic computer" dates from "1945 under this name; [in a] theoretical [sense] from 1937, as ''[[Turing machine]]''".&lt;ref&gt;{{cite web|url=http://www.etymonline.com/index.php?term=computer|title=computer (n.)|website=Online Etymology Dictionary}}&lt;/ref&gt;

== History ==
{{Main|History of computing hardware}}

=== Pre-20th century ===
[[File:Os d'Ishango IRSNB.JPG|thumb|upright=0.45|The [[Ishango bone]], a [[bone tool]] dating back to [[prehistoric Africa]].]]
Devices have been used to aid computation for thousands of years, mostly using [[one-to-one correspondence]] with [[finger counting|fingers]]. The earliest counting device was probably a form of [[tally stick]]. Later record keeping aids throughout the [[Fertile Crescent]] included calculi (clay spheres, cones, etc.) which represented counts of items, probably livestock or grains, sealed in hollow unbaked clay containers.&lt;ref&gt;According to {{harvnb|Schmandt-Besserat|1981}}, these clay containers contained tokens, the total of which were the count of objects being transferred. The containers thus served as something of a [[bill of lading]] or an accounts book. In order to avoid breaking open the containers, first, clay impressions of the tokens were placed on the outside of the containers, for the count; the shapes of the impressions were abstracted into stylized marks; finally, the abstract marks were systematically used as numerals; these numerals were finally formalized as numbers. Eventually ([http://www.laits.utexas.edu/ghazal/Chap1/dsb/chapter1.html Schmandt-Besserat estimates it took 4000 years] {{webarchive |url=https://web.archive.org/web/20120130084757/http://www.laits.utexas.edu/ghazal/Chap1/dsb/chapter1.html |date=30 January 2012 }} ) the marks on the outside of the containers were all that were needed to convey the count, and the clay containers evolved into clay tablets with marks for the count.&lt;/ref&gt;&lt;ref&gt;{{Citation|first=Eleanor|last=Robson|author-link=Eleanor Robson|year=2008|title=Mathematics in Ancient Iraq|isbn=978-0-691-09182-2}}. p.&amp;nbsp;5: calculi were in use in Iraq for primitive accounting systems as early as 3200–3000 BCE, with commodity-specific counting representation systems. Balanced accounting was in use by 3000–2350 BCE, and a [[sexagesimal number system]] was in use 2350–2000 BCE.&lt;/ref&gt; The use of [[counting rods]] is one example.
[[File:Abacus 6.png|thumb|left|The Chinese [[suanpan]] (算盘). The number represented on this [[abacus]] is 6,302,715,408.]]
The [[abacus]] was initially used for arithmetic tasks. The [[Roman abacus]] was developed from devices used in [[Babylonia]] as early as 2400 BC. Since then, many other forms of reckoning boards or tables have been invented. In a medieval European [[counting house]], a checkered cloth would be placed on a table, and markers moved around on it according to certain rules, as an aid to calculating sums of money.

[[File:NAMA Machine d'Anticythère 1.jpg|thumb|150px|The [[Antikythera mechanism]], dating back to [[ancient Greece]] circa 150&amp;ndash;100 BC, is an early [[analog computing]] device.]]
The [[Antikythera mechanism]] is believed to be the earliest mechanical [[analog computer|analog "computer"]], according to [[Derek J. de Solla Price]].&lt;ref&gt;[http://www.antikythera-mechanism.gr/project/general/the-project.html ''The Antikythera Mechanism Research Project''] {{Webarchive|url=https://web.archive.org/web/20080428070448/http://www.antikythera-mechanism.gr/project/general/the-project.html |date=28 April 2008 }}, The Antikythera Mechanism Research Project. Retrieved 1 July 2007.&lt;/ref&gt; It was designed to calculate astronomical positions. It was discovered in 1901 in the [[Antikythera wreck]] off the Greek island of [[Antikythera]], between [[Kythera]] and [[Crete]], and has been dated to {{circa|100 BC}}. Devices of a level of complexity comparable to that of the Antikythera mechanism would not reappear until a thousand years later.

Many mechanical aids to calculation and measurement were constructed for astronomical and navigation use. The [[planisphere]] was a [[star chart]] invented by Abū Rayhān al-Bīrūnī in the early 11th century.&lt;ref name=Wiet&gt;G. Wiet, V. Elisseeff, P. Wolff, J. Naudu (1975). ''History of Mankind, Vol 3: The Great medieval Civilisations'', p. 649. George Allen &amp; Unwin Ltd, [[UNESCO]].&lt;/ref&gt; The [[astrolabe]] was invented in the [[Hellenistic civilization|Hellenistic world]] in either the 1st or 2nd centuries BC and is often attributed to [[Hipparchus]]. A combination of the planisphere and [[dioptra]], the astrolabe was effectively an analog computer capable of working out several different kinds of problems in [[spherical astronomy]]. An astrolabe incorporating a mechanical [[calendar]] computer&lt;ref&gt;Fuat Sezgin "Catalogue of the Exhibition of the Institute for the History of Arabic-Islamic Science (at the Johann Wolfgang Goethe University", Frankfurt, Germany) Frankfurt Book Fair 2004, pp.&amp;nbsp;35 &amp; 38.&lt;/ref&gt;&lt;ref&gt;{{cite journal |first=François |last=Charette |title=Archaeology: High tech from Ancient Greece |journal=Nature |volume=444 |issue=7119 |pages=551–552 |year=2006 |doi=10.1038/444551a|pmid=17136077 |bibcode=2006Natur.444..551C }}&lt;/ref&gt; and [[gear]]-wheels was invented by Abi Bakr of [[Isfahan]], [[Persia]] in 1235.&lt;ref&gt;{{cite journal|first1=Silvio A.|last1=Bedini|first2=Francis R.|last2=Maddison|year=1966|title=Mechanical Universe: The Astrarium of Giovanni de' Dondi|journal=Transactions of the American Philosophical Society|volume=56|issue=5|pages=1–69|jstor=1006002|doi=10.2307/1006002}}&lt;/ref&gt; [[Abū Rayhān al-Bīrūnī]] invented the first mechanical geared [[lunisolar calendar]] astrolabe,&lt;ref&gt;{{cite journal|first=Derek de S.|last=Price|authorlink=Derek J. de Solla Price|year=1984|title=A History of Calculating Machines|journal=IEEE Micro|volume=4|number=1|pages=22–52|doi=10.1109/MM.1984.291305}}&lt;/ref&gt; an early fixed-[[wire]]d knowledge processing [[machine]]&lt;ref name=Oren&gt;{{cite journal|first=Tuncer|last=Őren|authorlink=Tuncer Őren|year=2001|title=Advances in Computer and Information Sciences: From Abacus to Holonic Agents|url=http://www.site.uottawa.ca/~oren/pubs/pubs-2001-02-Tubitak.pdf|journal=Turk J Elec Engin|volume=9|number=1|pages=63–70}}&lt;/ref&gt; with a [[gear train]] and gear-wheels,&lt;ref&gt;[[Donald Routledge Hill]] (1985). "Al-Biruni's mechanical calendar", ''Annals of Science'' '''42''', pp.&amp;nbsp;139–163.&lt;/ref&gt; {{circa|1000 AD}}.

The [[Sector (instrument)|sector]], a calculating instrument used for solving problems in proportion, trigonometry, multiplication and division, and for various functions, such as squares and cube roots, was developed in the late 16th century and found application in gunnery, surveying and navigation.

The [[planimeter]] was a manual instrument to calculate the area of a closed figure by tracing over it with a mechanical linkage.

[[File:Sliderule 2005.png|thumb|A [[slide rule]].]]
The [[slide rule]] was invented around 1620–1630, shortly after the publication of the concept of the [[logarithm]]. It is a hand-operated analog computer for doing multiplication and division. As slide rule development progressed, added scales provided reciprocals, squares and square roots, cubes and cube roots, as well as [[transcendental function]]s such as logarithms and exponentials, circular and [[hyperbolic functions|hyperbolic]] [[trigonometry]] and other [[Function (mathematics)|functions]]. Slide rules with special scales are still used for quick performance of routine calculations, such as the [[E6B]] circular slide rule used for time and distance calculations on light aircraft.

In the 1770s, [[Pierre Jaquet-Droz]], a Swiss [[watchmaker]], built a mechanical doll ([[automata|automaton]]) that could write holding a quill pen. By switching the number and order of its internal wheels different letters, and hence different messages, could be produced. In effect, it could be mechanically "programmed" to read instructions. Along with two other complex machines, the doll is at the Musée d'Art et d'Histoire of [[Neuchâtel]], [[Switzerland]], and still operates.&lt;ref&gt;{{cite web|url=http://www.chonday.com/Videos/the-writer-automaton|title=The Writer Automaton, Switzerland|date=11 July 2013|publisher=chonday.com}}&lt;/ref&gt;

The [[tide-predicting machine]] invented by [[William Thomson, 1st Baron Kelvin|Sir William Thomson]] in 1872 was of great utility to navigation in shallow waters. It used a system of pulleys and wires to automatically calculate predicted tide levels for a set period at a particular location.

The [[differential analyser]], a mechanical analog computer designed to solve [[differential equations]] by [[integral|integration]], used wheel-and-disc mechanisms to perform the integration. In 1876, [[James Thomson (engineer)|Lord Kelvin]] had already discussed the possible construction of such calculators, but he had been stymied by the limited output torque of the [[ball-and-disk integrator]]s.&lt;ref name="scientific-computing.com"&gt;Ray Girvan, [http://www.scientific-computing.com/scwmayjun03computingmachines.html "The revealed grace of the mechanism: computing after Babbage"] {{webarchive |url=https://web.archive.org/web/20121103094710/http://www.scientific-computing.com/scwmayjun03computingmachines.html |date=3 November 2012 }}, ''Scientific Computing World'', May/June 2003&lt;/ref&gt; In a differential analyzer, the output of one integrator drove the input of the next integrator, or a graphing output. The [[torque amplifier]] was the advance that allowed these machines to work. Starting in the 1920s, [[Vannevar Bush]] and others developed mechanical differential analyzers.

=== First computing device ===
[[File:Difference engine plate 1853.jpg|thumb|A portion of [[Charles Babbage|Babbage's]] [[Difference engine]].]]
[[Charles Babbage]], an English mechanical engineer and [[polymath]], originated the concept of a programmable computer. Considered the "[[computer pioneer|father of the computer]]",&lt;ref&gt;{{cite book | author=Halacy, Daniel Stephen | title = Charles Babbage, Father of the Computer | url=https://archive.org/details/charlesbabbagefa00hala | url-access=registration | year = 1970 | publisher=Crowell-Collier Press | isbn = 978-0-02-741370-0 }}&lt;/ref&gt; he conceptualized and invented the first [[mechanical computer]] in the early 19th century. After working on his revolutionary [[difference engine]], designed to aid in navigational calculations, in 1833 he realized that a much more general design, an [[Analytical Engine]], was possible. The input of programs and data was to be provided to the machine via [[punched card]]s, a method being used at the time to direct mechanical [[loom]]s such as the [[Jacquard loom]]. For output, the machine would have a printer, a curve plotter and a bell. The machine would also be able to punch numbers onto cards to be read in later. The Engine incorporated an [[arithmetic logic unit]], [[control flow]] in the form of [[conditional branching]] and [[program loop#Loops|loops]], and integrated [[computer memory|memory]], making it the first design for a general-purpose computer that could be described in modern terms as [[Turing-complete]].&lt;ref name="babbageonline"&gt;{{cite web|url=http://www.sciencemuseum.org.uk/onlinestuff/stories/babbage.aspx?page=5|title=Babbage|work=Online stuff|publisher=Science Museum|date=19 January 2007 |accessdate=1 August 2012}}&lt;/ref&gt;&lt;ref&gt;{{cite web|url=https://www.newscientist.com/article/mg20827915.500-lets-build-babbages-ultimate-mechanical-computer.html|title=Let's build Babbage's ultimate mechanical computer|work=opinion|publisher=New Scientist|date = 23 December 2010|accessdate=1 August 2012}}&lt;/ref&gt;

The machine was about a century ahead of its time. All the parts for his machine had to be made by hand&amp;nbsp;– this was a major problem for a device with thousands of parts. Eventually, the project was dissolved with the decision of the [[British Government]] to cease funding. Babbage's failure to complete the analytical engine can be chiefly attributed to political and financial difficulties as well as his desire to develop an increasingly sophisticated computer and to move ahead faster than anyone else could follow. Nevertheless, his son, Henry Babbage, completed a simplified version of the analytical engine's computing unit (the ''mill'') in 1888. He gave a successful demonstration of its use in computing tables in 1906.

=== Analog computers ===
{{Main|Analog computer}}
[[File:099-tpm3-sk.jpg|thumb|left|upright=0.9|[[William Thomson, 1st Baron Kelvin|Sir William Thomson]]'s third tide-predicting machine design, 1879–81]]
During the first half of the 20th century, many scientific [[computing]] needs were met by increasingly sophisticated [[analog computer]]s, which used a direct mechanical or electrical model of the problem as a basis for [[computation]]. However, these were not programmable and generally lacked the versatility and accuracy of modern digital computers.&lt;ref name="stanf"&gt;{{cite book|url=http://plato.stanford.edu/entries/computing-history/|publisher=Stanford Encyclopedia of Philosophy|title=The Modern History of Computing|year=2017}}&lt;/ref&gt; The first modern analog computer was a [[tide-predicting machine]], invented by [[William Thomson, 1st Baron Kelvin|Sir William Thomson]] in 1872. The [[differential analyser]], a mechanical analog computer designed to solve differential equations by integration using wheel-and-disc mechanisms, was conceptualized in 1876 by [[James Thomson (engineer)|James Thomson]], the brother of the more famous Lord Kelvin.&lt;ref name="scientific-computing.com" /&gt;

The art of mechanical analog computing reached its zenith with the [[differential analyzer]], built by H. L. Hazen and [[Vannevar Bush]] at [[MIT]] starting in 1927. This built on the mechanical integrators of [[James Thomson (engineer)|James Thomson]] and the torque amplifiers invented by H. W. Nieman. A dozen of these devices were built before their obsolescence became obvious. By the 1950s, the success of digital electronic computers had spelled the end for most analog computing machines, but analog computers remained in use during the 1950s in some specialized applications such as education ([[control systems]]) and aircraft ([[slide rule]]).

=== Digital computers ===

==== Electromechanical ====
By 1938, the [[United States Navy]] had developed an electromechanical analog computer small enough to use aboard a [[submarine]]. This was the [[Torpedo Data Computer]], which used trigonometry to solve the problem of firing a torpedo at a moving target. During [[World War II]] similar devices were developed in other countries as well.

[[File:Z3 Deutsches Museum.JPG|thumb|left|upright=0.9|Replica of [[Konrad Zuse|Zuse]]'s [[Z3 (computer)|Z3]], the first fully automatic, digital (electromechanical) computer.]]
Early digital computers were electromechanical; electric switches drove mechanical relays to perform the calculation. These devices had a low operating speed and were eventually superseded by much faster all-electric computers, originally using [[vacuum tube]]s. The [[Z2 (computer)|Z2]], created by German engineer [[Konrad Zuse]] in 1939, was one of the earliest examples of an electromechanical relay computer.&lt;ref name="Part 4 Zuse"&gt;{{cite web|url=http://www.epemag.com/zuse/part4a.htm|title=Part 4: Konrad Zuse's Z1 and Z3 Computers|last=Zuse|first=Horst|work=The Life and Work of Konrad Zuse|publisher=EPE Online|accessdate=17 June 2008 |archiveurl = https://web.archive.org/web/20080601210541/http://www.epemag.com/zuse/part4a.htm |archivedate = 1 June 2008}}&lt;/ref&gt;

In 1941, Zuse followed his earlier machine up with the [[Z3 (computer)|Z3]], the world's first working [[electromechanical]] [[Computer programming|programmable]], fully automatic digital computer.&lt;ref&gt;{{Citation|last=Zuse|first=Konrad|author-link=Konrad Zuse|title=The Computer – My Life ''Translated by McKenna, Patricia and Ross, J. Andrew from:'' Der Computer, mein Lebenswerk (1984)|place=Berlin/Heidelberg|publisher=Springer-Verlag|origyear=1984|year=2010|language=English|isbn=978-3-642-08151-4}}&lt;/ref&gt;&lt;ref&gt;{{cite news|first=Peggy|last=Salz Trautman|title=A Computer Pioneer Rediscovered, 50 Years On|url=https://www.nytimes.com/1994/04/20/news/20iht-zuse.html|newspaper=The New York Times|date=20 April 1994}}&lt;/ref&gt; The Z3 was built with 2000 [[relay]]s, implementing a 22&amp;nbsp;[[bit]] [[Word (data type)|word length]] that operated at a [[clock frequency]] of about 5–10&amp;nbsp;[[Hertz|Hz]].&lt;ref&gt;{{cite book|last=Zuse|first=Konrad|authorlink=Konrad Zuse|title=Der Computer. Mein Lebenswerk.|edition=3rd|year=1993|publisher=Springer-Verlag|location=Berlin|language=German|isbn=978-3-540-56292-4|doi=|page=55}}&lt;/ref&gt; Program code was supplied on punched [[celluloid|film]] while data could be stored in 64 words of memory or supplied from the keyboard. It was quite similar to modern machines in some respects, pioneering numerous advances such as [[floating point number]]s. Rather than the harder-to-implement decimal system (used in [[Charles Babbage]]'s earlier design), using a [[binary numeral system|binary]] system meant that Zuse's machines were easier to build and potentially more reliable, given the technologies available at that time.&lt;ref&gt;{{cite web|url=https://goremotesupport.com/blog/crash-the-story-of-it-zuse|title=Crash! The Story of IT: Zuse|accessdate=1 June 2016|url-status=dead|archiveurl=https://web.archive.org/web/20160918203643/https://goremotesupport.com/blog/crash-the-story-of-it-zuse/|archivedate=18 September 2016|df=dmy-all}}&lt;/ref&gt; The Z3 was [[Turing complete]].&lt;ref name="rojas-ieee"&gt;{{cite journal|last=Rojas |first=R. |title=How to make Zuse's Z3 a universal computer |journal=IEEE Annals of the History of Computing |volume=20 |issue=3 |pages=51–54 |year=1998 |doi=10.1109/85.707574 |authorlink=Raúl Rojas|url=https://semanticscholar.org/paper/8f10576e61754165a4ada51bd965f71090c2ebd4 }}&lt;/ref&gt;&lt;ref name="rojas-universal"&gt;{{cite web |url=http://www.inf.fu-berlin.de/users/rojas/1997/Universal_Computer.pdf |title=How to Make Zuse's Z3 a Universal Computer |first=Raúl |last=Rojas}}&lt;/ref&gt;

==== Vacuum tubes and digital electronic circuits ====
{{Anchor|Digital computer|Digital}}
Purely [[electronic circuit]] elements soon replaced their mechanical and electromechanical equivalents, at the same time that digital calculation replaced analog. The engineer [[Tommy Flowers]], working at the [[Post Office Research Station]] in [[London]] in the 1930s, began to explore the possible use of electronics for the [[telephone exchange]]. Experimental equipment that he built in 1934 went into operation five years later, converting a portion of the [[telephone exchange]] network into an electronic data processing system, using thousands of [[vacuum tube]]s.&lt;ref name="stanf" /&gt; In the US, [[John Vincent Atanasoff]] and [[Clifford Berry|Clifford E. Berry]] of Iowa State University developed and tested the [[Atanasoff–Berry Computer]] (ABC) in 1942,&lt;ref&gt;15 January 1941 notice in the ''Des Moines Register'',&lt;/ref&gt; the first "automatic electronic digital computer".&lt;ref&gt;{{cite book|title=The First Electronic Computer|author=Arthur W. Burks|url=https://books.google.com/books?id=_Zja6hoP4psC&amp;printsec=frontcover#v=onepage&amp;q=%22Atanasoff%E2%80%93Berry%20Computer%22&amp;f=false|isbn=0472081047|year=1989}}&lt;/ref&gt; This design was also all-electronic and used about 300 vacuum tubes, with capacitors fixed in a mechanically rotating drum for memory.&lt;ref name=Copeland2006&gt;{{Citation|last=Copeland|first=Jack|year=2006|title=Colossus: The Secrets of Bletchley Park's Codebreaking Computers|location=Oxford|publisher=[[Oxford University Press]]|pages=101–115|isbn=978-0-19-284055-4}}&lt;/ref&gt;

[[File:Colossus.jpg|thumb|[[Colossus computer|Colossus]], the first [[Electronics|electronic]] [[Digital electronics|digital]] [[Computer programming|programmable]] computing device, was used to break German ciphers during World War II.|alt=Two women are seen by the Colossus computer.]]
During World War II, the British at [[Bletchley Park]] achieved a number of successes at breaking encrypted German military communications. The German encryption machine, [[Enigma (machine)|Enigma]], was first attacked with the help of the electro-mechanical [[bombe]]s which were often run by women.&lt;ref name=":0"&gt;{{Cite news|url=https://www.bbc.com/news/technology-29840653|title=The woman who cracked Enigma cyphers|last=Miller|first=Joe|date=November 10, 2014|work=BBC News|access-date=October 14, 2018|language=en-GB}}&lt;/ref&gt;&lt;ref&gt;{{Cite web|url=https://www.theguardian.com/careers/2018/jul/24/meet-the-female-codebreakers-of-bletchley-park|title=Meet the female codebreakers of Bletchley Park|last=Bearne|first=Suzanne|date=July 24, 2018|website=the Guardian|language=en|access-date=October 14, 2018}}&lt;/ref&gt; To crack the more sophisticated German [[Lorenz SZ 40/42]] machine, used for high-level Army communications, [[Max Newman]] and his colleagues commissioned Flowers to build the [[Colossus computer|Colossus]].&lt;ref name=Copeland2006 /&gt; He spent eleven months from early February 1943 designing and building the first Colossus.&lt;ref&gt;{{Citation|title=Bletchley's code-cracking Colossus|publisher=BBC News |date=2 February 2010|url=http://news.bbc.co.uk/1/hi/technology/8492762.stm|accessdate=19 October 2012}}&lt;/ref&gt; After a functional test in December 1943, Colossus was shipped to Bletchley Park, where it was delivered on 18 January 1944&lt;ref name="The Colossus Computer"&gt;{{cite web|url=http://www.tnmoc.org/colossus-rebuild-story|title=Colossus – The Rebuild Story|website=The National Museum of Computing|access-date=7 January 2014|archive-url=https://web.archive.org/web/20150418230306/http://www.tnmoc.org/colossus-rebuild-story|archive-date=18 April 2015|url-status=dead}}&lt;/ref&gt; and attacked its first message on 5 February.&lt;ref name="Copeland2006" /&gt;

Colossus was the world's first [[electronics|electronic]] [[Digital electronics|digital]] [[Computer programming|programmable]] computer.&lt;ref name="stanf" /&gt; It used a large number of valves (vacuum tubes). It had paper-tape input and was capable of being configured to perform a variety of [[boolean logic]]al operations on its data, but it was not [[Turing-complete]]. Nine Mk II Colossi were built (The Mk I was converted to a Mk II making ten machines in total). Colossus Mark I contained 1,500 thermionic valves (tubes), but Mark II with 2,400 valves, was both 5 times faster and simpler to operate than Mark I, greatly speeding the decoding process.&lt;ref&gt;{{Citation|last1=Randell|first1=Brian|author-link1=Brian Randell|last2=Fensom|first2=Harry|last3=Milne|first3=Frank A.|title=Obituary: Allen Coombs|newspaper=The Independent|date=15 March 1995|url=https://www.independent.co.uk/news/people/obituary-allen-coombs-1611270.html|accessdate=18 October 2012}}&lt;/ref&gt;&lt;ref&gt;{{Citation|last=Fensom|first=Jim|title=Harry Fensom obituary|date=8 November 2010|url=https://www.theguardian.com/theguardian/2010/nov/08/harry-fensom-obituary|accessdate=17 October 2012|newspaper=The Guardian}}&lt;/ref&gt;

[[File:Eniac.jpg|thumb|left|[[ENIAC]] was the first electronic, Turing-complete device, and performed ballistics trajectory calculations for the [[United States Army]].]]
The [[ENIAC]]&lt;ref&gt;John Presper Eckert Jr. and John W. Mauchly, Electronic Numerical Integrator and Computer, United States Patent Office, US Patent 3,120,606, filed 26 June 1947, issued 4 February 1964, and invalidated 19 October 1973 after court ruling on ''[[Honeywell v. Sperry Rand]]''.&lt;/ref&gt; (Electronic Numerical Integrator and Computer) was the first electronic programmable computer built in the U.S. Although the ENIAC was similar to the Colossus, it was much faster, more flexible, and it was [[Turing-complete]]. Like the Colossus, a "program" on the ENIAC was defined by the states of its patch cables and switches, a far cry from the [[stored program]] electronic machines that came later. Once a program was written, it had to be mechanically set into the machine with manual resetting of plugs and switches. The programmers of the ENIAC were six women, often known collectively as the "ENIAC girls".{{Sfn|Evans|2018|p=39}}{{Sfn|Light|1999|p=459}}

It combined the high speed of electronics with the ability to be programmed for many complex problems. It could add or subtract 5000 times a second, a thousand times faster than any other machine. It also had modules to multiply, divide, and square root. High speed memory was limited to 20 words (about 80 bytes). Built under the direction of [[John Mauchly]] and [[J. Presper Eckert]] at the University of Pennsylvania, ENIAC's development and construction lasted from 1943 to full operation at the end of 1945. The machine was huge, weighing 30 tons, using 200 kilowatts of electric power and contained over 18,000 vacuum tubes, 1,500 relays, and hundreds of thousands of resistors, capacitors, and inductors.&lt;ref name="Eniac"&gt;{{cite web|url=http://www.techiwarehouse.com/engine/a046ee08/Generations-of-Computer|title=Generations of Computer|publisher=techiwarehouse.com|access-date=7 January 2014|archive-url=https://web.archive.org/web/20150702211455/http://www.techiwarehouse.com/engine/a046ee08/Generations-of-Computer/|archive-date=2 July 2015|url-status=dead}}&lt;/ref&gt;

=== Modern computers ===

==== Concept of modern computer ====
The principle of the modern computer was proposed by [[Alan Turing]] in his seminal 1936 paper,&lt;ref&gt;{{cite journal|url=http://plms.oxfordjournals.org/cgi/reprint/s2-42/1/230|doi=10.1112/plms/s2-42.1.230|title=On Computable Numbers, with an Application to the Entscheidungsproblem|first=A. M.|last=Turing|journal=Proceedings of the London Mathematical Society|year=1937|series=2|volume=42|number=1|pages=230–265}}&lt;/ref&gt; ''On Computable Numbers''. Turing proposed a simple device that he called "Universal Computing machine" and that is now known as a [[universal Turing machine]]. He proved that such a machine is capable of computing anything that is computable by executing instructions (program) stored on tape, allowing the machine to be programmable. The fundamental concept of Turing's design is the [[stored program]], where all the instructions for computing are stored in memory. [[John von Neumann|Von Neumann]] acknowledged that the central concept of the modern computer was due to this paper.&lt;ref&gt;"von Neumann&amp;nbsp;... firmly emphasized to me, and to others I am sure, that the fundamental conception is owing to Turing—insofar as not anticipated by Babbage, Lovelace and others." Letter by [[Stanley Frankel]] to [[Brian Randell]], 1972, quoted in [[Jack Copeland]] (2004) ''The Essential Turing'', p22.&lt;/ref&gt; Turing machines are to this day a central object of study in [[theory of computation]]. Except for the limitations imposed by their finite memory stores, modern computers are said to be [[Turing-complete]], which is to say, they have [[algorithm]] execution capability equivalent to a universal Turing machine.

==== Stored programs ====
{{Main|Stored-program computer}}
[[File:SSEM Manchester museum close up.jpg|right|thumb|upright=1.15|alt=Three tall racks containing electronic circuit boards|A section of the [[Manchester Baby]], the first electronic [[stored-program computer]].]]
Early computing machines had fixed programs. Changing its function required the re-wiring and re-structuring of the machine.&lt;ref name="Copeland2006" /&gt; With the proposal of the stored-program computer this changed. A stored-program computer includes by design an [[instruction set]] and can store in memory a set of instructions (a [[computer program|program]]) that details the [[computation]]. The theoretical basis for the stored-program computer was laid by [[Alan Turing]] in his 1936 paper. In 1945, Turing joined the [[National Physical Laboratory (United Kingdom)|National Physical Laboratory]] and began work on developing an electronic stored-program digital computer. His 1945 report "Proposed Electronic Calculator" was the first specification for such a device. John von Neumann at the [[University of Pennsylvania]] also circulated his ''[[First Draft of a Report on the EDVAC]]'' in 1945.&lt;ref name="stanf" /&gt;

The [[Manchester Baby]] was the world's first [[stored-program computer]]. It was built at the [[Victoria University of Manchester]] by [[Frederic Calland Williams|Frederic C. Williams]], [[Tom Kilburn]] and [[Geoff Tootill]], and ran its first program on 21 June 1948.&lt;ref&gt;{{citation |last=Enticknap |first=Nicholas |title=Computing's Golden Jubilee |journal=Resurrection |issue=20 |date=Summer 1998 |url=http://www.cs.man.ac.uk/CCS/res/res20.htm#d |issn=0958-7403 |accessdate=19 April 2008 |archive-url=https://web.archive.org/web/20120109142655/http://www.cs.man.ac.uk/CCS/res/res20.htm#d |archive-date=9 January 2012 |url-status=dead }}&lt;/ref&gt; It was designed as a [[testbed]] for the [[Williams tube]], the first [[Random-access memory|random-access]] digital storage device.&lt;ref&gt;{{citation|title=Early computers at Manchester University|journal=Resurrection|volume=1|issue=4|date=Summer 1992|url=http://www.cs.man.ac.uk/CCS/res/res04.htm#g|issn=0958-7403|accessdate=7 July 2010|archive-url=https://web.archive.org/web/20170828010743/http://www.cs.man.ac.uk/CCS/res/res04.htm#g|archive-date=28 August 2017|url-status=dead|df=dmy-all}}&lt;/ref&gt; Although the computer was considered "small and primitive" by the standards of its time, it was the first working machine to contain all of the elements essential to a modern electronic computer.&lt;ref&gt;{{citation|url=http://www.computer50.org/mark1/contemporary.html|title=Early Electronic Computers (1946–51)|publisher=University of Manchester|accessdate=16 November 2008|url-status=dead|archiveurl=https://web.archive.org/web/20090105031620/http://www.computer50.org/mark1/contemporary.html|archivedate=5 January 2009|df=dmy-all}}&lt;/ref&gt; As soon as the Baby had demonstrated the feasibility of its design, a project was initiated at the university to develop it into a more usable computer, the [[Manchester Mark 1]]. [[Grace Hopper]] was the first person to develop a [[compiler]] for programming language.{{Sfn|Smith|2013|p=6}}

The Mark 1 in turn quickly became the prototype for the [[Ferranti Mark 1]], the world's first commercially available general-purpose computer.&lt;ref name=NapperMK1&gt;{{citation |last=Napper |first=R. B. E. |title=Introduction to the Mark 1 |url=http://www.computer50.org/mark1/mark1intro.html |publisher=The University of Manchester |accessdate=4 November 2008 |url-status=dead |archiveurl=https://web.archive.org/web/20081026080604/http://www.computer50.org/mark1/mark1intro.html |archivedate=26 October 2008 |df=dmy-all }}&lt;/ref&gt; Built by [[Ferranti]], it was delivered to the [[University of Manchester]] in February 1951. At least seven of these later machines were delivered between 1953 and 1957, one of them to [[Royal Dutch Shell|Shell]] labs in [[Amsterdam]].&lt;ref&gt;{{Citation|last=Computer Conservation Society|author-link=Computer Conservation Society|title=Our Computer Heritage Pilot Study: Deliveries of Ferranti Mark I and Mark I Star computers|url=http://www.ourcomputerheritage.org/wp/|archive-url=https://web.archive.org/web/20161211201840/http://www.ourcomputerheritage.org/wp/|url-status=dead|archive-date=11 December 2016|accessdate=9 January 2010}}&lt;/ref&gt; In October 1947, the directors of British catering company [[J. Lyons and Co.|J. Lyons &amp; Company]] decided to take an active role in promoting the commercial development of computers. The [[LEO computer|LEO I]] computer became operational in April 1951&lt;ref&gt;{{cite web | last = Lavington | first = Simon | title = A brief history of British computers: the first 25 years (1948–1973). | publisher = [[British Computer Society]] | url = http://www.bcs.org/server.php? | accessdate = 10 January 2010 }}&lt;/ref&gt; and ran the world's first regular routine office computer [[job (software)|job]].

==== Transistors ====
{{Main|Transistor|History of the transistor}}
{{See|Transistor computer|MOSFET}}
&lt;!-- [[Second generation of computers]] redirects here --&gt;
[[File:Transistor-die-KSY34.jpg|thumb|right|[[Bipolar junction transistor]] (BJT).]]
The concept of a [[field-effect transistor]] was proposed by [[Julius Edgar Lilienfeld]] in 1925. [[John Bardeen]] and [[Walter Brattain]], while working under [[William Shockley]] at [[Bell Labs]], built the first working [[transistor]], the [[point-contact transistor]], in 1947, which was followed by Shockley's [[bipolar junction transistor]] in 1948.&lt;ref name="Lee"&gt;{{cite book |last1=Lee |first1=Thomas H. |title=The Design of CMOS Radio-Frequency Integrated Circuits |date=2003 |publisher=[[Cambridge University Press]] |isbn=9781139643771 |url=https://web.stanford.edu/class/archive/ee/ee214/ee214.1032/Handouts/HO2.pdf}}&lt;/ref&gt;&lt;ref name="Puers"&gt;{{cite book |last1=Puers |first1=Robert |last2=Baldi |first2=Livio |last3=Voorde |first3=Marcel Van de |last4=Nooten |first4=Sebastiaan E. van |title=Nanoelectronics: Materials, Devices, Applications, 2 Volumes |date=2017 |publisher=[[John Wiley &amp; Sons]] |isbn=9783527340538 |page=14 |url=https://books.google.com/books?id=JOqVDgAAQBAJ&amp;pg=PA14}}&lt;/ref&gt; From 1955 onwards, transistors replaced [[vacuum tube]]s in computer designs, giving rise to the "second generation" of computers. Compared to vacuum tubes, transistors have many advantages: they are smaller, and require less power than vacuum tubes, so give off less heat. [[Junction transistor]]s were much more reliable than vacuum tubes and had longer, indefinite, service life. Transistorized computers could contain tens of thousands of binary logic circuits in a relatively compact space. However, early junction transistors were relatively bulky devices that were difficult to manufacture on a [[mass-production]] basis, which limited them to a number of specialised applications.&lt;ref name="Moskowitz"&gt;{{cite book |last1=Moskowitz |first1=Sanford L. |title=Advanced Materials Innovation: Managing Global Technology in the 21st century |date=2016 |publisher=[[John Wiley &amp; Sons]] |isbn=9780470508923 |pages=165–167 |url=https://books.google.com/books?id=2STRDAAAQBAJ&amp;pg=PA165}}&lt;/ref&gt;

At the [[University of Manchester]], a team under the leadership of [[Tom Kilburn]] designed and built a machine using the newly developed transistors instead of valves.&lt;ref&gt;{{Citation|last=Lavington|first=Simon|title=A History of Manchester Computers|year=1998|edition=2|publisher=The British Computer Society|location=Swindon|pages=34–35}}&lt;/ref&gt; Their first [[transistor computer|transistorised computer]] and the first in the world, was [[Manchester computers#Transistor Computer|operational by 1953]], and a second version was completed there in April 1955. However, the machine did make use of valves to generate its 125&amp;nbsp;kHz clock waveforms and in the circuitry to read and write on its magnetic [[drum memory]], so it was not the first completely transistorized computer. That distinction goes to the [[Harwell CADET]] of 1955,&lt;ref name="ieeexplore.ieee"&gt;{{citation |doi=10.1049/esej:19980301 |last=Cooke-Yarborough |first=E. H. |title=Some early transistor applications in the UK |journal=  Engineering Science &amp; Education Journal|volume=7 |issue=3 |pages=100–106 |date=June 1998 |url=https://ieeexplore.ieee.org/document/689507 |issn=0963-7346 |accessdate=7 June 2009}} {{subscription required}}&lt;/ref&gt; built by the electronics division of the [[Atomic Energy Research Establishment]] at [[Harwell, Oxfordshire|Harwell]].&lt;ref name="ieeexplore.ieee" /&gt;&lt;ref&gt;{{cite book | last = Cooke-Yarborough | first = E.H. | title = Introduction to Transistor Circuits | publisher = Oliver and Boyd | year = 1957 | location = Edinburgh | page = 139}}&lt;/ref&gt;

[[file:MOSFET Structure.png|thumb|right|[[MOSFET]] (MOS transistor), showing [[Metal gate|gate]] (G), body (B), source (S) and drain (D) terminals. The gate is separated from the body by an insulating layer (pink).]]

The [[MOSFET|metal–oxide–silicon field-effect transistor]] (MOSFET), also known as the MOS transistor, was invented by [[Mohamed M. Atalla]] and [[Dawon Kahng]] at Bell Labs in 1959.&lt;ref name="computerhistory"&gt;{{cite journal|url=https://www.computerhistory.org/siliconengine/metal-oxide-semiconductor-mos-transistor-demonstrated/|title=1960: Metal Oxide Semiconductor (MOS) Transistor Demonstrated|journal=The Silicon Engine: A Timeline of Semiconductors in Computers|publisher=[[Computer History Museum]] |accessdate=August 31, 2019}}&lt;/ref&gt; It was the first truly compact transistor that could be miniaturised and mass-produced for a wide range of uses.&lt;ref name="Moskowitz"/&gt; With its [[MOSFET scaling|high scalability]],&lt;ref&gt;{{cite journal |last1=Motoyoshi |first1=M. |title=Through-Silicon Via (TSV) |journal=Proceedings of the IEEE |date=2009 |volume=97 |issue=1 |pages=43–48 |doi=10.1109/JPROC.2008.2007462 |url=https://pdfs.semanticscholar.org/8a44/93b535463daa7d7317b08d8900a33b8cbaf4.pdf |issn=0018-9219}}&lt;/ref&gt; and much lower power consumption and higher density than bipolar junction transistors,&lt;ref&gt;{{cite news |title=Transistors Keep Moore's Law Alive |url=https://www.eetimes.com/author.asp?section_id=36&amp;doc_id=1334068 |accessdate=18 July 2019 |work=[[EETimes]] |date=12 December 2018}}&lt;/ref&gt; the MOSFET made it possible to build [[Very large-scale integration|high-density integrated circuits]].&lt;ref name="computerhistory-transistor"&gt;{{cite web |title=Who Invented the Transistor? |url=https://www.computerhistory.org/atchm/who-invented-the-transistor/ |website=[[Computer History Museum]] |date=4 December 2013 |accessdate=20 July 2019}}&lt;/ref&gt;&lt;ref name="Hittinger"&gt;{{cite journal |last1=Hittinger |first1=William C. |title=Metal-Oxide-Semiconductor Technology |journal=Scientific American |date=1973 |volume=229 |issue=2 |pages=48–59 |issn=0036-8733|jstor=24923169 |doi=10.1038/scientificamerican0873-48 |bibcode=1973SciAm.229b..48H }}&lt;/ref&gt; In addition to data processing, it also enabled the practical use of MOS transistors as [[memory cell (computing)|memory cell]] storage elements, leading to the development of MOS [[semiconductor memory]], which replaced earlier [[magnetic-core memory]] in computers.&lt;ref name="sciencedirect"&gt;{{cite web |title=Transistors - an overview |url=https://www.sciencedirect.com/topics/computer-science/transistors |website=[[ScienceDirect]] |accessdate=8 August 2019}}&lt;/ref&gt; The MOSFET led to the [[microcomputer revolution]],&lt;ref&gt;{{cite book |last1=Malmstadt |first1=Howard V. |last2=Enke |first2=Christie G. |last3=Crouch |first3=Stanley R. |title=Making the Right Connections: Microcomputers and Electronic Instrumentation |date=1994 |publisher=[[American Chemical Society]] |isbn=9780841228610 |page=389 |url=https://books.google.com/books?id=lyJGAQAAIAAJ |quote=The relative simplicity and low power requirements of MOSFETs have fostered today's microcomputer revolution.}}&lt;/ref&gt; and became the driving force behind the [[computer revolution]].&lt;ref&gt;{{cite book |last1=Fossum |first1=Jerry G. |last2=Trivedi |first2=Vishal P. |title=Fundamentals of Ultra-Thin-Body MOSFETs and FinFETs |date=2013 |publisher=[[Cambridge University Press]] |isbn=9781107434493 |page=vii |url=https://books.google.com/books?id=zZJfAAAAQBAJ&amp;pg=PR7}}&lt;/ref&gt;&lt;ref name="uspto"&gt;{{cite web |title=Remarks by Director Iancu at the 2019 International Intellectual Property Conference |url=https://www.uspto.gov/about-us/news-updates/remarks-director-iancu-2019-international-intellectual-property-conference |website=[[United States Patent and Trademark Office]] |date=June 10, 2019 |accessdate=20 July 2019}}&lt;/ref&gt; The MOSFET is the most widely used transistor in computers,&lt;ref name="kahng"&gt;{{cite web |title=Dawon Kahng |url=https://www.invent.org/inductees/dawon-kahng |website=[[National Inventors Hall of Fame]] |accessdate=27 June 2019}}&lt;/ref&gt;&lt;ref name="atalla"&gt;{{cite web|title=Martin Atalla in Inventors Hall of Fame, 2009|url=https://www.invent.org/inductees/martin-john-m-atalla|accessdate=21 June 2013}}&lt;/ref&gt; and is the fundamental building block of [[digital electronics]].&lt;ref name="triumph"&gt;{{cite web |title=Triumph of the MOS Transistor |url=https://www.youtube.com/watch?v=q6fBEjf9WPw |website=[[YouTube]] |publisher=[[Computer History Museum]] |accessdate=21 July 2019 |date=6 August 2010}}&lt;/ref&gt;

==== Integrated circuits ====
{{Main|Integrated circuit|Invention of the integrated circuit}}
{{See|Planar process|Microprocessor}}

The next great advance in computing power came with the advent of the [[integrated circuit]] (IC).
The idea of the integrated circuit was first conceived by a radar scientist working for the [[Royal Radar Establishment]] of the [[Ministry of Defence (United Kingdom)|Ministry of Defence]], [[Geoffrey Dummer|Geoffrey W.A. Dummer]]. Dummer presented the first public description of an integrated circuit at the Symposium on Progress in Quality Electronic Components in [[Washington, D.C.|Washington,&amp;nbsp;D.C.]] on 7 May 1952.&lt;ref&gt;[http://www.epn-online.com/page/22909/the-hapless-tale-of-geoffrey-dummer-this-is-the-sad-.html "The Hapless Tale of Geoffrey Dummer"] {{webarchive |url=https://web.archive.org/web/20130511181443/http://www.epn-online.com/page/22909/the-hapless-tale-of-geoffrey-dummer-this-is-the-sad-.html |date=11 May 2013 }}, (n.d.), (HTML), ''Electronic Product News'', accessed 8 July 2008.&lt;/ref&gt;

The first working ICs were invented by [[Jack Kilby]] at [[Texas Instruments]] and [[Robert Noyce]] at [[Fairchild Semiconductor]].&lt;ref&gt;{{Citation|first=Jack|last=Kilby|author-link=Jack Kilby|title=Nobel lecture|publisher=Nobel Foundation|year=2000|location=Stockholm|url=http://nobelprize.org/nobel_prizes/physics/laureates/2000/kilby-lecture.pdf|accessdate=15 May 2008}}&lt;/ref&gt; Kilby recorded his initial ideas concerning the integrated circuit in July 1958, successfully demonstrating the first working integrated example on 12 September 1958.&lt;ref name="TIJackBuilt"&gt;[http://www.ti.com/corp/docs/kilbyctr/jackbuilt.shtml ''The Chip that Jack Built''], (c. 2008), (HTML), Texas Instruments, Retrieved 29 May 2008.&lt;/ref&gt; In his patent application of 6 February 1959, Kilby described his new device as "a body of semiconductor material&amp;nbsp;... wherein all the components of the electronic circuit are completely integrated".&lt;ref&gt;Jack S. Kilby, Miniaturized Electronic Circuits, United States Patent Office, US Patent 3,138,743, filed 6 February 1959, issued 23 June 1964.&lt;/ref&gt;&lt;ref&gt;{{cite book| last = Winston| first = Brian| title = Media Technology and Society: A History : From the Telegraph to the Internet| url = https://books.google.com/?id=gfeCXlElJTwC&amp;pg=PA221| year = 1998| publisher = Routledge| isbn = 978-0-415-14230-4| page = 221 }}&lt;/ref&gt; However, Kilby's invention was a [[hybrid integrated circuit]] (hybrid IC), rather than a [[monolithic integrated circuit]] (IC) chip.&lt;ref name="Saxena140"&gt;{{cite book |last1=Saxena |first1=Arjun N. |title=Invention of Integrated Circuits: Untold Important Facts |date=2009 |publisher=[[World Scientific]] |isbn=9789812814456 |page=140 |url=https://books.google.com/books?id=-3lpDQAAQBAJ&amp;pg=PA140}}&lt;/ref&gt; Kilby's IC had external wire connections, which made it difficult to mass-produce.&lt;ref name="nasa"&gt;{{cite web |title=Integrated circuits |url=https://www.hq.nasa.gov/alsj/ic-pg3.html |website=[[NASA]] |accessdate=13 August 2019}}&lt;/ref&gt;

Noyce also came up with his own idea of an integrated circuit half a year later than Kilby.&lt;ref&gt;[[Robert Noyce]]'s Unitary circuit, {{Ref patent |country=US |number=2981877|status=patent|gdate=1961-04-25|title=Semiconductor device-and-lead structure |assign1 =[[Fairchild Semiconductor Corporation]]}}&lt;/ref&gt; Noyce's invention was the first true monolithic IC chip.&lt;ref name="computerhistory1959"&gt;{{cite web |title=1959: Practical Monolithic Integrated Circuit Concept Patented |url=https://www.computerhistory.org/siliconengine/practical-monolithic-integrated-circuit-concept-patented/ |website=[[Computer History Museum]] |accessdate=13 August 2019}}&lt;/ref&gt;&lt;ref name="nasa"/&gt; His chip solved many practical problems that Kilby's had not. Produced at Fairchild Semiconductor, it was made of [[silicon]], whereas Kilby's chip was made of [[germanium]]. Noyce's monolithic IC was [[semiconductor device fabrication|fabricated]] using the [[planar process]], developed by his colleague [[Jean Hoerni]] in early 1959. In turn, the planar process was based on the silicon [[surface passivation]] and [[thermal oxidation]] processes developed by [[Mohamed Atalla]] at [[Bell Labs]] in the late 1950s.&lt;ref name="Lojek120"&gt;{{cite book |last1=Lojek |first1=Bo |title=History of Semiconductor Engineering |date=2007 |publisher=[[Springer Science &amp; Business Media]] |isbn=9783540342588 |page=120}}&lt;/ref&gt;&lt;ref&gt;{{cite book |last1=Bassett |first1=Ross Knox |title=To the Digital Age: Research Labs, Start-up Companies, and the Rise of MOS Technology |date=2007 |publisher=Johns Hopkins University Press |isbn=9780801886393 |page=46 |url=https://books.google.com/books?id=UUbB3d2UnaAC&amp;pg=PA46}}&lt;/ref&gt;&lt;ref&gt;{{cite book |last1=Huff |first1=Howard R. |last2=Tsuya |first2=H. |last3=Gösele |first3=U. |title=Silicon Materials Science and Technology: Proceedings of the Eighth International Symposium on Silicon Materials Science and Technology |date=1998 |publisher=[[Electrochemical Society]] |pages=181–182 |url=https://books.google.com/books?id=SnQfAQAAIAAJ&amp;pg=PA181}}&lt;/ref&gt;

Modern monolithic ICs are predominantly MOS ([[metal-oxide-semiconductor]]) integrated circuits, built from [[MOSFET]]s (MOS transistors).&lt;ref name="Kuo"&gt;{{cite journal |last1=Kuo |first1=Yue |title=Thin Film Transistor Technology—Past, Present, and Future |journal=The Electrochemical Society Interface |date=1 January 2013 |volume=22 |issue=1 |pages=55–61 |doi=10.1149/2.F06131if |url=https://www.electrochem.org/dl/interface/spr/spr13/spr13_p055_061.pdf |issn=1064-8208}}&lt;/ref&gt; After the first MOSFET was invented by Mohamed Atalla and [[Dawon Kahng]] at Bell Labs in 1959,&lt;ref&gt;{{cite web |title=1960: Metal Oxide Semiconductor (MOS) Transistor Demonstrated |url=https://www.computerhistory.org/siliconengine/metal-oxide-semiconductor-mos-transistor-demonstrated/ |website=[[Computer History Museum]]}}&lt;/ref&gt; Atalla first proposed the concept of the MOS integrated circuit in 1960, followed by Kahng in 1961, both noting that the MOS transistor's ease of [[Semiconductor device fabrication|fabrication]] made it useful for integrated circuits.&lt;ref name="Moskowitz"/&gt;&lt;ref name="Bassett22"&gt;{{cite book |last1=Bassett |first1=Ross Knox |title=To the Digital Age: Research Labs, Start-up Companies, and the Rise of MOS Technology |date=2007 |publisher=[[Johns Hopkins University Press]] |isbn=9780801886393 |pages=22–25 |url=https://books.google.com/books?id=UUbB3d2UnaAC&amp;pg=PA22}}&lt;/ref&gt; The earliest experimental MOS IC to be fabricated was a 16-transistor chip built by Fred Heiman and Steven Hofstein at [[RCA]] in 1962.&lt;ref name="computerhistory-digital"&gt;{{cite web |title=Tortoise of Transistors Wins the Race - CHM Revolution |url=https://www.computerhistory.org/revolution/digital-logic/12/279 |website=[[Computer History Museum]] |accessdate=22 July 2019}}&lt;/ref&gt; [[General Microelectronics]] later introduced the first commercial MOS IC in 1964,&lt;ref&gt;{{cite web|url=http://www.computerhistory.org/semiconductor/timeline/1964-Commecial.html|title=1964 – First Commercial MOS IC Introduced|website=[[Computer History Museum]]}}&lt;/ref&gt; developed by Robert Norman.&lt;ref name="computerhistory-digital"/&gt; Following the development of the [[self-aligned gate]] (silicon-gate) MOS transistor by Robert Kerwin, Donald Klein and John Sarace at Bell Labs in 1967, the first [[silicon-gate]] MOS IC with [[self-aligned gate]]s was developed by [[Federico Faggin]] at Fairchild Semiconductor in 1968.&lt;ref&gt;{{cite web |title=1968: Silicon Gate Technology Developed for ICs |url=https://www.computerhistory.org/siliconengine/silicon-gate-technology-developed-for-ics/ |website=[[Computer History Museum]] |accessdate=22 July 2019}}&lt;/ref&gt; The MOSFET has since become the most critical device component in modern ICs.&lt;ref&gt;{{cite journal |last1=Kuo |first1=Yue |title=Thin Film Transistor Technology—Past, Present, and Future |journal=The Electrochemical Society Interface |date=1 January 2013 |volume=22 |issue=1 |pages=55–61 |doi=10.1149/2.F06131if |url=https://www.electrochem.org/dl/interface/spr/spr13/spr13_p055_061.pdf |issn=1064-8208}}&lt;/ref&gt;

The development of the MOS integrated circuit led to the invention of the [[microprocessor]],&lt;ref name="computerhistory1971"&gt;{{cite web |title=1971: Microprocessor Integrates CPU Function onto a Single Chip |url=https://www.computerhistory.org/siliconengine/microprocessor-integrates-cpu-function-onto-a-single-chip/ |website=[[Computer History Museum]] |accessdate=22 July 2019}}&lt;/ref&gt;&lt;ref name="Colinge2016"&gt;{{cite book |last1=Colinge |first1=Jean-Pierre |last2=Greer |first2=James C. |title=Nanowire Transistors: Physics of Devices and Materials in One Dimension |date=2016 |publisher=[[Cambridge University Press]] |isbn=9781107052406 |page=2 |url=https://books.google.com/books?id=FvjUCwAAQBAJ&amp;pg=PA2}}&lt;/ref&gt; and heralded an explosion in the commercial and personal use of computers. While the subject of exactly which device was the first microprocessor is contentious, partly due to lack of agreement on the exact definition of the term "microprocessor", it is largely undisputed that the first single-chip microprocessor was the [[Intel 4004]],&lt;ref&gt;{{Citation|title=Intel's First Microprocessor—the Intel 4004 |publisher=Intel Corp. |date=November 1971 |url=http://www.intel.com/museum/archives/4004.htm |accessdate=17 May 2008 |url-status=dead |archiveurl=https://web.archive.org/web/20080513221700/http://www.intel.com/museum/archives/4004.htm |archivedate=13 May 2008 }}&lt;/ref&gt; designed and realized by Federico Faggin with his silicon-gate MOS IC technology,&lt;ref name="computerhistory1971"/&gt; along with [[Marcian Hoff|Ted Hoff]], [[Masatoshi Shima]] and [[Stanley Mazor]] at [[Intel]].&lt;ref&gt;The Intel 4004 (1971) die was 12&amp;nbsp;mm&lt;sup&gt;2&lt;/sup&gt;, composed of 2300 transistors; by comparison, the Pentium Pro was 306&amp;nbsp;mm&lt;sup&gt;2&lt;/sup&gt;, composed of 5.5&amp;nbsp;million transistors, according to {{citation |last1= Patterson |first1= David |last2= Hennessy |first2= John |year= 1998 |title= Computer Organization and Design |location= San Francisco |publisher= [[Morgan Kaufmann]] |isbn= 978-1-55860-428-5 |pages= [https://archive.org/details/computerorganiz000henn/page/27 27–39] |url= https://archive.org/details/computerorganiz000henn/page/27 }}&lt;/ref&gt;&lt;ref name="ieee"&gt;[[Federico Faggin]], [http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4776530 The Making of the First Microprocessor], ''IEEE Solid-State Circuits Magazine'', Winter 2009, [[IEEE Xplore]]&lt;/ref&gt; In the early 1970s, MOS IC technology enabled the [[very large-scale integration|integration]] of more than 10,000 transistors on a single chip.&lt;ref name="Hittinger"/&gt;

[[System on a Chip]] (SoCs) are complete computers on a [[microchip]] (or chip) the size of a coin.&lt;ref name="networkworld.com"&gt;{{Cite web | url=https://www.networkworld.com/article/3154386/7-dazzling-smartphone-improvements-with-qualcomms-snapdragon-835-chip.html |title = 7 dazzling smartphone improvements with Qualcomm's Snapdragon 835 chip|date = 3 January 2017}}&lt;/ref&gt; They may or may not have integrated [[RAM]] and [[flash memory]]. If not integrated, The RAM is usually placed directly above (known as [[Package on package]]) or below (on the opposite side of the [[circuit board]]) the SoC, and the flash memory is usually placed right next to the SoC, this all done to improve data transfer speeds, as the data signals don't have to travel long distances. Since ENIAC in 1945, computers have advanced enormously, with modern SoCs being the size of a coin while also being hundreds of thousands of times more powerful than ENIAC, integrating billions of transistors, and consuming only a few watts of power.

=== Mobile computers ===

The first [[portable computer|mobile computers]] were heavy and ran from mains power. The 50lb [[IBM 5100]] was an early example. Later portables such as the [[Osborne 1]] and [[Compaq Portable]] were considerably lighter but still needed to be plugged in. The first [[laptop]]s, such as the [[Grid Compass]], removed this requirement by incorporating batteries – and with the continued miniaturization of computing resources and advancements in portable battery life, portable computers grew in popularity in the 2000s.&lt;ref&gt;{{cite news|url=https://arstechnica.com/uncategorized/2008/12/global-notebook-shipments-finally-overtake-desktops/|title=Global notebook shipments finally overtake desktops|work=Ars Technica|first=David|last=Chartier|date=23 December 2008}}&lt;/ref&gt; The same developments allowed manufacturers to integrate computing resources into cellular mobile phones by the early 2000s.

These [[smartphone]]s and [[tablet computer|tablets]] run on a variety of operating systems and recently became the dominant computing device on the market.&lt;ref&gt;{{cite web|author=IDC|title=Growth Accelerates in the Worldwide Mobile Phone and Smartphone Markets in the Second Quarter, According to IDC|date=25 July 2013|url=http://www.idc.com/getdoc.jsp?containerId=prUS24239313|url-status=dead|archive-url=https://web.archive.org/web/20140626022208/http://www.idc.com/getdoc.jsp?containerId=prUS24239313|archive-date=26 June 2014}}&lt;/ref&gt; These are powered by [[System on a Chip]] (SoCs), which are complete computers on a microchip the size of a coin.&lt;ref name="networkworld.com"/&gt;

== Types ==
Computers can be classified in a number of different ways, including:

=== By architecture ===
* [[Analog computer]]
* [[Digital computer]]
* [[Hybrid computer]]
* [[Harvard architecture]]
* [[Von Neumann architecture]]
* [[Reduced instruction set computer]]

=== By size and form-factor ===
* [[Mainframe computer]]
* [[Supercomputer]]
* [[Minicomputer]]
* [[Microcomputer]]
* [[Workstation]]
* [[Personal computer]]
* [[Laptop]]
* [[Tablet computer]]
* [[Smartphone]]
* [[Single-board computer]]

== Hardware ==
{{Main|Computer hardware|Personal computer hardware|Central processing unit|Microprocessor}}[[File:Computer Components.webm|thumb|Video demonstrating the standard components of a "slimline" computer]]

The term ''hardware'' covers all of those parts of a computer that are tangible physical objects. Circuits, computer chips, graphic cards, sound cards, memory (RAM), motherboard, displays, power supplies, cables, keyboards, printers and "mice" input devices are all hardware.

=== History of computing hardware ===
{{Main|History of computing hardware}}
&lt;!-- WARNING: Please be careful about modifying this table, especially if you are not familiar with Wikipedia table syntax. Make judicious use of the "Preview" button! --&gt;
{| class="wikitable"
|-
| rowspan="2" | First generation (mechanical/electromechanical) || Calculators || [[Pascal's calculator]], [[Arithmometer]], [[Difference engine]], [[Leonardo Torres y Quevedo#Analytical machines|Quevedo's analytical machines]]
|-
| Programmable devices || [[Jacquard loom]], [[Analytical engine]], [[Harvard Mark I|IBM ASCC/Harvard Mark I]], [[Harvard Mark II]], [[IBM SSEC]], [[Z1 (computer)|Z1]], [[Z2 (computer)|Z2]], [[Z3 (computer)|Z3]]
|-
| rowspan="2" | Second generation (vacuum tubes) || Calculators || [[Atanasoff–Berry Computer]], [[IBM 604]], [[Remington Rand 409|UNIVAC 60]], [[Remington Rand 409|UNIVAC 120]]
|-
| [[List of vacuum tube computers|Programmable devices]] || [[Colossus computer|Colossus]], [[ENIAC]], [[Manchester Baby]], [[Electronic Delay Storage Automatic Calculator|EDSAC]], [[Manchester Mark 1]], [[Ferranti Pegasus]], [[Ferranti Mercury]], [[CSIRAC]], [[EDVAC]], [[UNIVAC I]], [[IBM 701]], [[IBM 702]], [[IBM 650]], [[Z22 (computer)|Z22]]
|-
| rowspan="3" | Third generation (discrete [[transistor]]s and SSI, MSI, LSI [[integrated circuit]]s) || [[Mainframe computer|Mainframes]] || [[IBM 7090]], [[IBM 7080]], [[IBM System/360]], [[BUNCH]]
|-
| [[Minicomputer]] || [[HP 2100|HP 2116A]], [[IBM System/32]], [[IBM System/36]], [[LINC]], [[PDP-8]], [[PDP-11]]
|-
| [[Desktop Computer]] || [[HP 9100]]
|-
| rowspan="8" | Fourth generation ([[VLSI]] integrated circuits) || Minicomputer || [[VAX]], [[IBM System i]]
|-
| [[4-bit]] microcomputer || [[Intel 4004]], [[Intel 4040]]
|-
| [[8-bit]] microcomputer || [[Intel 8008]], [[Intel 8080]], [[Motorola 6800]], [[Motorola 6809]], [[MOS Technology 6502]], [[Zilog Z80]]
|-
| [[16-bit]] microcomputer || [[Intel 8088]], [[Zilog Z8000]], [[WDC 65816/65802]]
|-
| [[32-bit]] microcomputer || [[Intel 80386]], [[Pentium]], [[Motorola 68000]], [[ARMv7|ARM]]
|-
| [[64-bit]] microcomputer&lt;ref&gt;Most major 64-bit [[instruction set]] architectures are extensions of earlier designs. All of the architectures listed in this table, except for Alpha, existed in 32-bit forms before their 64-bit incarnations were introduced.&lt;/ref&gt;|| [[DEC Alpha|Alpha]], [[MIPS architecture|MIPS]], [[PA-RISC]], [[PowerPC]], [[SPARC]], [[x86-64]], [[ARMv8-A]]
|-
| [[Embedded system|Embedded computer]] || [[Intel 8048]], [[Intel 8051]]
|-
| Personal computer || [[Desktop computer]], [[Home computer]], [[Laptop]] computer, [[Personal digital assistant]] (PDA), [[Portable computer]], [[tablet computer|Tablet PC]], [[Wearable computer]]
|-
|| Theoretical/experimental || [[Quantum computer]], [[Chemical computer]], [[DNA computing]], [[Photonic computing|Optical computer]], [[Spintronics]]-based computer, [[Wetware computer|Wetware/Organic computer]]
|
|}

=== Other hardware topics ===

{| class="wikitable"
|-
| rowspan="3" | [[Peripheral]] device ([[input/output]]) || Input || [[Mouse (computing)|Mouse]], [[Keyboard (computing)|keyboard]], [[joystick]], [[image scanner]], [[webcam]], [[graphics tablet]], [[microphone]]
|-
| Output || [[computer monitor|Monitor]], [[Printer (computing)|printer]], [[Computer speaker|loudspeaker]]
|-
| Both || [[Floppy disk]] drive, [[hard disk drive]], [[optical disc]] drive, [[teleprinter]]
|-
| rowspan="2" | [[Bus (computing)|Computer buses]] || Short range || [[RS-232]], [[SCSI]], [[Conventional PCI|PCI]], [[USB]]
|-
| Long range ([[computer networking]]) || [[Ethernet]], [[Asynchronous Transfer Mode|ATM]], [[Fiber Distributed Data Interface|FDDI]]
|}

A general purpose computer has four main components: the [[arithmetic logic unit]] (ALU), the [[control unit]], the [[Computer data storage|memory]], and the [[input and output devices]] (collectively termed I/O). These parts are interconnected by [[bus (computing)|buses]], often made of groups of [[wire]]s.
Inside each of these parts are thousands to trillions of small [[electrical network|electrical circuits]] which can be turned off or on by means of an [[transistor|electronic switch]]. Each circuit represents a [[bit]] (binary digit) of information so that when the circuit is on it represents a "1", and when off it represents a "0" (in positive logic representation). The circuits are arranged in [[logic gate]]s so that one or more of the circuits may control the state of one or more of the other circuits.

=== Input devices ===
When unprocessed data is sent to the computer with the help of input devices, the data is processed and sent to output devices. The input devices may be hand-operated or automated. The act of processing is mainly regulated by the CPU. Some examples of input devices are:
* [[Computer keyboard]]
* [[Digital camera]]
* [[Digital video]]
* [[Graphics tablet]]
* [[Image scanner]]
* [[Joystick]]
* [[Microphone]]
* [[Mouse (computing)|Mouse]]
* [[Overlay keyboard]]
* [[Real-time clock]]
* [[Trackball]]
* [[Touchscreen]]

=== Output devices ===
The means through which computer gives output are known as output devices. Some examples of output devices are:
* [[Computer monitor]]
* [[Printer (computing)|Printer]]
* [[PC speaker]]
* [[Projector]]
* [[Sound card]]
* [[Video card]]

=== Control unit ===
{{Main|CPU design|Control unit}}
[[File:Mips32 addi.svg|thumb|right|Diagram showing how a particular [[MIPS architecture]] instruction would be decoded by the control system]]

The control unit (often called a control system or central controller) manages the computer's various components; it reads and interprets (decodes) the program instructions, transforming them into control signals that activate other parts of the computer.&lt;ref&gt;The control unit's role in interpreting instructions has varied somewhat in the past. Although the control unit is solely responsible for instruction interpretation in most modern computers, this is not always the case. Some computers have instructions that are partially interpreted by the control unit with further interpretation performed by another device. For example, [[EDVAC]], one of the earliest stored-program computers, used a central control unit that only interpreted four instructions. All of the arithmetic-related instructions were passed on to its arithmetic unit and further decoded there.&lt;/ref&gt; Control systems in advanced computers may change the order of execution of some instructions to improve performance.

A key component common to all CPUs is the [[program counter]], a special memory cell (a [[processor register|register]]) that keeps track of which location in memory the next instruction is to be read from.&lt;ref&gt;Instructions often occupy more than one memory address, therefore the program counter usually increases by the number of memory locations required to store one instruction.&lt;/ref&gt;

The control system's function is as follows—note that this is a simplified description, and some of these steps may be performed concurrently or in a different order depending on the type of CPU:

# Read the code for the next instruction from the cell indicated by the program counter.
# Decode the numerical code for the instruction into a set of commands or signals for each of the other systems.
# Increment the program counter so it points to the next instruction.
# Read whatever data the instruction requires from cells in memory (or perhaps from an input device). The location of this required data is typically stored within the instruction code.
# Provide the necessary data to an ALU or register.
# If the instruction requires an ALU or specialized hardware to complete, instruct the hardware to perform the requested operation.
# Write the result from the ALU back to a memory location or to a register or perhaps an output device.
# Jump back to step (1).

Since the program counter is (conceptually) just another set of memory cells, it can be changed by calculations done in the ALU. Adding 100 to the program counter would cause the next instruction to be read from a place 100 locations further down the program. Instructions that modify the program counter are often known as "jumps" and allow for loops (instructions that are repeated by the computer) and often conditional instruction execution (both examples of [[control flow]]).

The sequence of operations that the control unit goes through to process an instruction is in itself like a short computer program, and indeed, in some more complex CPU designs, there is another yet smaller computer called a [[microsequencer]], which runs a [[microcode]] program that causes all of these events to happen.

=== Central processing unit (CPU) ===
{{Main|Central processing unit|Microprocessor}}

The control unit, ALU, and registers are collectively known as a [[central processing unit]] (CPU). Early CPUs were composed of many separate components. Since the 1970s, CPUs have typically been constructed on a single [[MOS integrated circuit]] chip called a ''[[microprocessor]]''.

=== Arithmetic logic unit (ALU) ===
{{Main|Arithmetic logic unit}}

The ALU is capable of performing two classes of operations: arithmetic and logic.&lt;ref&gt;{{Cite book
 | title = The Most Complex Machine: A Survey of Computers and Computing
 | author = David J. Eck
 | publisher = A K Peters, Ltd.
 | year = 2000
 | isbn = 978-1-56881-128-4
 | page = 54
}}&lt;/ref&gt; The set of arithmetic operations that a particular ALU supports may be limited to addition and subtraction, or might include multiplication, division, [[trigonometry]] functions such as sine, cosine, etc., and [[square root]]s. Some can only operate on whole numbers ([[integer]]s) while others use [[floating point]] to represent [[real number]]s, albeit with limited precision. However, any computer that is capable of performing just the simplest operations can be programmed to break down the more complex operations into simple steps that it can perform. Therefore, any computer can be programmed to perform any arithmetic operation—although it will take more time to do so if its ALU does not directly support the operation. An ALU may also compare numbers and return [[Truth value|boolean truth values]] (true or false) depending on whether one is equal to, greater than or less than the other ("is 64 greater than 65?"). Logic operations involve [[Boolean logic]]: [[logical conjunction|AND]], [[logical disjunction|OR]], [[Exclusive or|XOR]], and [[Negation|NOT]]. These can be useful for creating complicated [[conditional (programming)|conditional statements]] and processing [[boolean logic]].

[[Superscalar]] computers may contain multiple ALUs, allowing them to process several instructions simultaneously.&lt;ref&gt;{{Cite book | title = Handbook of Parallel Computing and Statistics | author = Erricos John Kontoghiorghes | publisher = CRC Press | year = 2006 | isbn = 978-0-8247-4067-2 | page = 45 }}&lt;/ref&gt; [[Graphics processing unit|Graphics processors]] and computers with [[SIMD]] and [[MIMD]] features often contain ALUs that can perform arithmetic on [[Euclidean vector|vectors]] and [[Matrix (mathematics)|matrices]].

=== Memory ===
{{Main|Computer memory|Computer data storage}}
[[File:Magnetic core.jpg|thumb|right|[[Magnetic-core memory]] (using [[magnetic cores]]) was the [[computer memory]] of choice in the 1960s, until it was replaced by [[semiconductor memory]] (using [[MOSFET|MOS]] [[memory cell (computing)|memory cells]]).]]

A computer's memory can be viewed as a list of cells into which numbers can be placed or read. Each cell has a numbered "address" and can store a single number. The computer can be instructed to "put the number 123 into the cell numbered 1357" or to "add the number that is in cell 1357 to the number that is in cell 2468 and put the answer into cell 1595." The information stored in memory may represent practically anything. Letters, numbers, even computer instructions can be placed into memory with equal ease. Since the CPU does not differentiate between different types of information, it is the software's responsibility to give significance to what the memory sees as nothing but a series of numbers.

In almost all modern computers, each memory cell is set up to store [[binary numeral system|binary numbers]] in groups of eight bits (called a [[byte]]). Each byte is able to represent 256 different numbers (2&lt;sup&gt;8&lt;/sup&gt; = 256); either from 0 to 255 or −128 to +127. To store larger numbers, several consecutive bytes may be used (typically, two, four or eight). When negative numbers are required, they are usually stored in [[two's complement]] notation. Other arrangements are possible, but are usually not seen outside of specialized applications or historical contexts. A computer can store any kind of information in memory if it can be represented numerically. Modern computers have billions or even trillions of bytes of memory.

The CPU contains a special set of memory cells called [[Processor register|registers]] that can be read and written to much more rapidly than the main memory area. There are typically between two and one hundred registers depending on the type of CPU. Registers are used for the most frequently needed data items to avoid having to access main memory every time data is needed. As data is constantly being worked on, reducing the need to access main memory (which is often slow compared to the ALU and control units) greatly increases the computer's speed.

Computer main memory comes in two principal varieties:
* [[random-access memory]] or RAM
* [[read-only memory]] or ROM
RAM can be read and written to anytime the CPU commands it, but ROM is preloaded with data and software that never changes, therefore the CPU can only read from it. ROM is typically used to store the computer's initial start-up instructions. In general, the contents of RAM are erased when the power to the computer is turned off, but ROM retains its data indefinitely. In a PC, the ROM contains a specialized program called the [[BIOS]] that orchestrates loading the computer's [[operating system]] from the hard disk drive into RAM whenever the computer is turned on or reset. In [[embedded system|embedded computers]], which frequently do not have disk drives, all of the required software may be stored in ROM. Software stored in ROM is often called [[firmware]], because it is notionally more like hardware than software. [[Flash memory]] blurs the distinction between ROM and RAM, as it retains its data when turned off but is also rewritable. It is typically much slower than conventional ROM and RAM however, so its use is restricted to applications where high speed is unnecessary.&lt;ref&gt;Flash memory also may only be rewritten a limited number of times before wearing out, making it less useful for heavy random access usage. {{harv|Verma &amp; Mielke|1988}}&lt;/ref&gt;

In more sophisticated computers there may be one or more RAM [[CPU cache|cache memories]], which are slower than registers but faster than main memory. Generally computers with this sort of cache are designed to move frequently needed data into the cache automatically, often without the need for any intervention on the programmer's part.

=== Input/output (I/O) ===
{{Main|Input/output}}
[[File:HDDspin.JPG|thumb|right|[[Hard disk drive]]s are common storage devices used with computers.]]
I/O is the means by which a computer exchanges information with the outside world.&lt;ref&gt;{{Cite book | title = Introduction to the Basic Computer | author = Donald Eadie | year = 1968 | publisher = Prentice-Hall | page = 12 }}&lt;/ref&gt; Devices that provide input or output to the computer are called [[peripheral]]s.&lt;ref&gt;{{Cite book | title = Introduction to Microcomputers and the Microprocessors | author = Arpad Barna | author2 = Dan I. Porat | publisher = Wiley | year = 1976 | isbn = 978-0-471-05051-3 | page = [https://archive.org/details/introductiontomi0000barn/page/85 85] | url = https://archive.org/details/introductiontomi0000barn/page/85 }}&lt;/ref&gt; On a typical personal computer, peripherals include input devices like the keyboard and [[mouse (computing)|mouse]], and output devices such as the [[computer monitor|display]] and [[printer (computing)|printer]]. [[Hard disk drive]]s, [[floppy disk]] drives and [[optical disc drive]]s serve as both input and output devices. [[Computer networking]] is another form of I/O.
I/O devices are often complex computers in their own right, with their own CPU and memory. A [[graphics processing unit]] might contain fifty or more tiny computers that perform the calculations necessary to display [[3D computer graphics|3D graphics]].{{Citation needed|date=December 2007}} Modern [[desktop computer]]s contain many smaller computers that assist the main CPU in performing I/O. A 2016-era flat screen display contains its own computer circuitry.

=== Multitasking ===
{{Main|Computer multitasking}}
While a computer may be viewed as running one gigantic program stored in its main memory, in some systems it is necessary to give the appearance of running several programs simultaneously. This is achieved by multitasking i.e. having the computer switch rapidly between running each program in turn.&lt;ref&gt;{{Cite book | title = Learning the UNIX Operating System: A Concise Guide for the New User | author = Jerry Peek | author2 = Grace Todino | author3 = John Strang | publisher = O'Reilly | year = 2002 | isbn = 978-0-596-00261-9 | page = [https://archive.org/details/learningunixoper00jerr/page/130 130] | url = https://archive.org/details/learningunixoper00jerr/page/130 }}&lt;/ref&gt; One means by which this is done is with a special signal called an [[interrupt]], which can periodically cause the computer to stop executing instructions where it was and do something else instead. By remembering where it was executing prior to the interrupt, the computer can return to that task later. If several programs are running "at the same time". then the interrupt generator might be causing several hundred interrupts per second, causing a program switch each time. Since modern computers typically execute instructions several orders of magnitude faster than human perception, it may appear that many programs are running at the same time even though only one is ever executing in any given instant. This method of multitasking is sometimes termed "time-sharing" since each program is allocated a "slice" of time in turn.&lt;ref&gt;{{Cite book | title = Noise Reduction in Speech Applications | author = Gillian M. Davis | publisher = CRC Press | year = 2002 | isbn = 978-0-8493-0949-6 | page = 111 }}&lt;/ref&gt;

Before the era of inexpensive computers, the principal use for multitasking was to allow many people to share the same computer. Seemingly, multitasking would cause a computer that is switching between several programs to run more slowly, in direct proportion to the number of programs it is running, but most programs spend much of their time waiting for slow input/output devices to complete their tasks. If a program is waiting for the user to click on the mouse or press a key on the keyboard, then it will not take a "time slice" until the event it is waiting for has occurred. This frees up time for other programs to execute so that many programs may be run simultaneously without unacceptable speed loss.

=== Multiprocessing ===
{{Main|Multiprocessing}}
[[File:Cray 2 Arts et Metiers dsc03940.jpg|thumb|[[Cray]] designed many supercomputers that used multiprocessing heavily.]]
Some computers are designed to distribute their work across several CPUs in a multiprocessing configuration, a technique once employed only in large and powerful machines such as [[supercomputer]]s, [[mainframe computer]]s and [[server (computing)|servers]]. Multiprocessor and [[multi-core]] (multiple CPUs on a single integrated circuit) personal and laptop computers are now widely available, and are being increasingly used in lower-end markets as a result.

Supercomputers in particular often have highly unique architectures that differ significantly from the basic stored-program architecture and from general purpose computers.&lt;ref&gt;However, it is also very common to construct supercomputers out of many pieces of cheap commodity hardware; usually individual computers connected by networks. These so-called [[computer cluster]]s can often provide supercomputer performance at a much lower cost than customized designs. While custom architectures are still used for most of the most powerful supercomputers, there has been a proliferation of cluster computers in recent years. {{harv|TOP500|2006}}&lt;/ref&gt; They often feature thousands of CPUs, customized high-speed interconnects, and specialized computing hardware. Such designs tend to be useful only for specialized tasks due to the large scale of program organization required to successfully utilize most of the available resources at once. Supercomputers usually see usage in large-scale [[Computer simulation|simulation]], [[Rendering (computer graphics)|graphics rendering]], and [[cryptography]] applications, as well as with other so-called "[[embarrassingly parallel]]" tasks.

== Software ==
{{Main|Computer software}}
''Software'' refers to parts of the computer which do not have a material form, such as programs, data, protocols, etc. Software is that part of a computer system that consists of encoded information or computer instructions, in contrast to the physical [[Computer hardware|hardware]] from which the system is built. Computer software includes [[computer program]]s, [[Library (computing)|libraries]] and related non-executable [[Data (computing)|data]], such as [[Software documentation|online documentation]] or [[digital media]]. It is often divided into [[system software]] and [[application software]] Computer hardware and software require each other and neither can be realistically used on its own. When software is stored in hardware that cannot easily be modified, such as with [[BIOS]] [[Read-only memory|ROM]] in an [[IBM PC compatible]] computer, it is sometimes called "firmware".

{| class="wikitable"
|-
| rowspan="7" | [[Operating system]] /System Software
|| [[Unix]] and [[Berkeley Software Distribution|BSD]] || [[UNIX System V]], [[IBM AIX]], [[HP-UX]], [[Solaris (operating system)|Solaris]] ([[SunOS]]), [[IRIX]], [[List of BSD operating systems]]
|-
| [[GNU]]/[[Linux]] || [[List of Linux distributions]], [[Comparison of Linux distributions]]
|-
| [[Microsoft Windows]] || [[Windows 95]], [[Windows 98]], [[Windows NT]], [[Windows 2000]], [[Windows ME]], [[Windows XP]], [[Windows Vista]], [[Windows 7]], [[Windows 8]], [[Windows 8.1]], [[Windows 10]]
|-
| [[DOS]] || [[86-DOS]] (QDOS), [[IBM PC DOS]], [[MS-DOS]], [[DR-DOS]], [[FreeDOS]]
|-
| [[Macintosh operating systems]] || [[Classic Mac OS]], [[macOS]] (previously OS X and Mac OS X)
|-
| [[Embedded operating system|Embedded]] and [[Real-time operating system|real-time]] || [[List of operating systems#Embedded|List of embedded operating systems]]
|-
| Experimental || [[Amoeba (operating system)|Amoeba]], [[Oberon (operating system)|Oberon]]/[[Bluebottle OS|Bluebottle]], [[Plan 9 from Bell Labs]]
|-
| rowspan="2" | [[Library (computing)|Library]] || [[Multimedia]] || [[DirectX]], [[OpenGL]], [[OpenAL]], [[Vulkan (API)]]
|-
| Programming library || [[C standard library]], [[Standard Template Library]]
|-
| rowspan="2" | [[Data (computing)|Data]] || [[Protocol (computing)|Protocol]] || [[Internet protocol suite|TCP/IP]], [[Kermit (protocol)|Kermit]], [[File Transfer Protocol|FTP]], [[Hypertext Transfer Protocol|HTTP]], [[Simple Mail Transfer Protocol|SMTP]]
|-
| [[File format]] || [[HTML]], [[XML]], [[JPEG]], [[Moving Picture Experts Group|MPEG]], [[Portable Network Graphics|PNG]]
|-
| rowspan="2" | [[User interface]] || [[Graphical user interface]] ([[WIMP (computing)|WIMP]]) || [[Microsoft Windows]], [[GNOME]], [[KDE]], [[QNX]] Photon, [[Common Desktop Environment|CDE]], [[Graphics Environment Manager|GEM]], [[Aqua (user interface)|Aqua]]
|-
| [[Text-based (computing)|Text-based user interface]] || [[Command-line interface]], [[Text user interface]]
|-
| rowspan="9" | [[Application software|Application]] Software
|| [[Office suite]] || [[Word processing]], [[Desktop publishing]], [[Presentation program]], [[Database management system]], Scheduling &amp; Time management, [[Spreadsheet]], [[Accounting software]]
|-
| Internet Access || [[Web browser|Browser]], [[Email client]], [[Web server]], [[Mail transfer agent]], [[Instant messaging]]
|-
| Design and manufacturing || [[Computer-aided design]], [[Computer-aided manufacturing]], Plant management, Robotic manufacturing, Supply chain management
|-
| [[Computer graphics|Graphics]] || [[Raster graphics editor]], [[Vector graphics editor]], [[3D computer graphics software|3D modeler]], [[Computer animation|Animation editor]], [[3D computer graphics]], [[Video editing]], [[Image processing]]
|-
| [[Digital audio|Audio]] || [[Digital audio editor]], [[Audio player (software)|Audio playback]], [[Audio mixing|Mixing]], [[Software synthesizer|Audio synthesis]], [[Computer music]]
|-
| [[Software engineering]] || [[Compiler]], [[Assembler (computer programming)|Assembler]], [[Interpreter (computing)|Interpreter]], [[Debugger]], [[Text editor]], [[Integrated development environment]], [[Software performance analysis]], [[Revision control]], [[Software configuration management]]
|-
| Educational || [[Edutainment]], [[Educational game]], [[Serious game]], [[Flight simulator]]
|-
| [[Video game|Games]] || [[Strategy game|Strategy]], [[Arcade game|Arcade]], [[Puzzle video game|Puzzle]], [[Simulation video game|Simulation]], [[First-person shooter]], [[Platform game|Platform]], [[Massively multiplayer online game|Massively multiplayer]], [[Interactive fiction]]
|-
| Misc || [[Artificial intelligence]], [[Antivirus software]], [[Malware scanner]], [[Installation (computer programs)|Installer]]/[[Package management system]]s, [[File manager]]
|}

=== Languages ===
There are thousands of different programming languages—some intended to be general purpose, others useful only for highly specialized applications.

&lt;!-- ATTENTION! AUTHORS: Please do not add every programming language in existence into this table—there are vastly too many of them—and the right place for listing obscure languages is in the 'List of...' articles referenced below. Please only add very COMMONLY and CURRENTLY used or highly historically relevant languages to the lists below or else things will rapidly spiral out of control.
--&gt;
{| class="wikitable"
|+'''[[Programming language]]s'''
|| Lists of programming languages || [[Timeline of programming languages]], [[List of programming languages by category]], [[Generational list of programming languages]], [[List of programming languages]], [[Non-English-based programming languages]]
|-
|| Commonly used [[assembly language]]s || [[ARM architecture|ARM]], [[MIPS architecture|MIPS]], [[X86 assembly language|x86]]
|-
|| Commonly used [[high-level programming language]]s || [[Ada (programming language)|Ada]], [[BASIC]], [[C (programming language)|C]], [[C++]], [[C Sharp (programming language)|C#]], [[COBOL]], [[Fortran]], [[PL/I]], [[REXX]], [[Java (programming language)|Java]], [[Lisp (programming language)|Lisp]], [[Pascal (programming language)|Pascal]], [[Object Pascal]]
|-
|| Commonly used [[scripting language]]s || [[Bourne shell|Bourne script]], [[JavaScript]], [[Python (programming language)|Python]], [[Ruby (programming language)|Ruby]], [[PHP]], [[Perl]]
|}

=== Programs ===
The defining feature of modern computers which distinguishes them from all other machines is that they can be [[computer programming|programmed]]. That is to say that some type of [[Instruction (computer science)|instructions]] (the [[Computer program|program]]) can be given to the computer, and it will process them. Modern computers based on the [[von Neumann architecture]] often have machine code in the form of an [[imperative programming language]]. In practical terms, a computer program may be just a few instructions or extend to many millions of instructions, as do the programs for [[word processor]]s and [[web browser]]s for example. A typical modern computer can execute billions of instructions per second ([[FLOPS|gigaflops]]) and rarely makes a mistake over many years of operation. Large computer programs consisting of several million instructions may take teams of [[programmer]]s years to write, and due to the complexity of the task almost certainly contain errors.

==== Stored program architecture ====
{{Main|Computer program|Computer programming}}
[[File:SSEM Manchester museum.jpg|thumb|right|Replica of the [[Manchester Baby]], the world's first electronic [[stored-program computer]], at the [[Museum of Science and Industry (Manchester)|Museum of Science and Industry]] in Manchester, England]]
This section applies to most common [[RAM machine]]–based computers.

In most cases, computer instructions are simple: add one number to another, move some data from one location to another, send a message to some external device, etc. These instructions are read from the computer's [[Computer data storage|memory]] and are generally carried out ([[execution (computing)|executed]]) in the order they were given. However, there are usually specialized instructions to tell the computer to jump ahead or backwards to some other place in the program and to carry on executing from there. These are called "jump" instructions (or [[Branch (computer science)|branches]]). Furthermore, jump instructions may be made to happen [[conditional (programming)|conditionally]] so that different sequences of instructions may be used depending on the result of some previous calculation or some external event. Many computers directly support [[subroutine]]s by providing a type of jump that "remembers" the location it jumped from and another instruction to return to the instruction following that jump instruction.

Program execution might be likened to reading a book. While a person will normally read each word and line in sequence, they may at times jump back to an earlier place in the text or skip sections that are not of interest. Similarly, a computer may sometimes go back and repeat the instructions in some section of the program over and over again until some internal condition is met. This is called the [[control flow|flow of control]] within the program and it is what allows the computer to perform tasks repeatedly without human intervention.

Comparatively, a person using a pocket [[calculator]] can perform a basic arithmetic operation such as adding two numbers with just a few button presses. But to add together all of the numbers from 1 to 1,000 would take thousands of button presses and a lot of time, with a near certainty of making a mistake. On the other hand, a computer may be programmed to do this with just a few simple instructions. The following example is written in the [[MIPS architecture|MIPS assembly language]]:
{{Clear}}
&lt;syntaxhighlight lang="asm"&gt;
  begin:
  addi $8, $0, 0           # initialize sum to 0
  addi $9, $0, 1           # set first number to add = 1
  loop:
  slti $10, $9, 1000       # check if the number is less than 1000
  beq $10, $0, finish      # if odd number is greater than n then exit
  add $8, $8, $9           # update sum
  addi $9, $9, 1           # get next number
  j loop                   # repeat the summing process
  finish:
  add $2, $8, $0           # put sum in output register
&lt;/syntaxhighlight&gt;

Once told to run this program, the computer will perform the repetitive addition task without further human intervention. It will almost never make a mistake and a modern PC can complete the task in a fraction of a second.

==== Machine code ====
In most computers, individual instructions are stored as [[machine code]] with each instruction being given a unique number (its operation code or [[opcode]] for short). The command to add two numbers together would have one opcode; the command to multiply them would have a different opcode, and so on. The simplest computers are able to perform any of a handful of different instructions; the more complex computers have several hundred to choose from, each with a unique numerical code. Since the computer's memory is able to store numbers, it can also store the instruction codes. This leads to the important fact that entire programs (which are just lists of these instructions) can be represented as lists of numbers and can themselves be manipulated inside the computer in the same way as numeric data. The fundamental concept of storing programs in the computer's memory alongside the data they operate on is the crux of the von Neumann, or stored program{{citation needed|date=May 2014}}, architecture. In some cases, a computer might store some or all of its program in memory that is kept separate from the data it operates on. This is called the [[Harvard architecture]] after the [[Harvard Mark I]] computer. Modern von Neumann computers display some traits of the Harvard architecture in their designs, such as in [[CPU cache]]s.

While it is possible to write computer programs as long lists of numbers ([[machine code|machine language]]) and while this technique was used with many early computers,&lt;ref&gt;Even some later computers were commonly programmed directly in machine code. Some [[minicomputer]]s like the [[Digital Equipment Corporation|DEC]] [[PDP-8]] could be programmed directly from a panel of switches. However, this method was usually used only as part of the [[booting]] process. Most modern computers boot entirely automatically by reading a boot program from some [[non-volatile memory]].&lt;/ref&gt; it is extremely tedious and potentially error-prone to do so in practice, especially for complicated programs. Instead, each basic instruction can be given a short name that is indicative of its function and easy to remember&amp;nbsp;– a [[mnemonic]] such as ADD, SUB, MULT or JUMP. These mnemonics are collectively known as a computer's [[assembly language]]. Converting programs written in assembly language into something the computer can actually understand (machine language) is usually done by a computer program called an assembler.

[[File:FortranCardPROJ039.agr.jpg|thumb|right|A 1970s [[punched card]] containing one line from a [[Fortran]] program. The card reads: "Z(1) = Y + W(1)" and is labeled "PROJ039" for identification purposes.]]

==== Programming language ====
{{Main|Programming language}}
Programming languages provide various ways of specifying programs for computers to run. Unlike [[natural language]]s, programming languages are designed to permit no ambiguity and to be concise. They are purely written languages and are often difficult to read aloud. They are generally either translated into [[machine code]] by a [[compiler]] or an [[assembler (computer programming)|assembler]] before being run, or translated directly at run time by an [[interpreter (computing)|interpreter]]. Sometimes programs are executed by a hybrid method of the two techniques.

===== Low-level languages =====
{{Main|Low-level programming language}}
Machine languages and the assembly languages that represent them (collectively termed ''low-level programming languages'') are generally unique to the particular architecture of a computer's central processing unit ([[CPU]]). For instance, an [[ARM architecture]] CPU (such as may be found in a [[smartphone]] or a [[handheld video game|hand-held videogame]]) cannot understand the machine language of an [[x86]] CPU that might be in a [[Personal computer|PC]].&lt;ref&gt;However, there is sometimes some form of machine language compatibility between different computers. An [[x86-64]] compatible microprocessor like the [[Advanced Micro Devices|AMD]] [[Athlon 64]] is able to run most of the same programs that an [[Intel Core 2]] microprocessor can, as well as programs designed for earlier microprocessors like the Intel [[Pentium]]s and [[Intel 80486]]. This contrasts with very early commercial computers, which were often one-of-a-kind and totally incompatible with other computers.&lt;/ref&gt; Historically a significant number of other cpu architectures were created and saw extensive use, notably including the MOS Technology 6502 and 6510 in addition to the Zilog Z80.

===== High-level languages =====
{{Main|High-level programming language}}
Although considerably easier than in machine language, writing long programs in assembly language is often difficult and is also error prone. Therefore, most practical programs are written in more abstract [[high-level programming language]]s that are able to express the needs of the [[programmer]] more conveniently (and thereby help reduce programmer error). High level languages are usually "compiled" into machine language (or sometimes into assembly language and then into machine language) using another computer program called a [[compiler]].&lt;ref&gt;High level languages are also often [[interpreted language|interpreted]] rather than compiled. Interpreted languages are translated into machine code on the fly, while running, by another program called an [[interpreter (computing)|interpreter]].&lt;/ref&gt; High level languages are less related to the workings of the target computer than assembly language, and more related to the language and structure of the problem(s) to be solved by the final program. It is therefore often possible to use different compilers to translate the same high level language program into the machine language of many different types of computer. This is part of the means by which software like video games may be made available for different computer architectures such as personal computers and various [[video game console]]s.

==== Program design ====
{{unreferenced section|date=July 2012}}
Program design of small programs is relatively simple and involves the analysis of the problem, collection of inputs, using the programming constructs within languages, devising or using established procedures and algorithms, providing data for output devices and solutions to the problem as applicable. As problems become larger and more complex, features such as subprograms, modules, formal documentation, and new paradigms such as object-oriented programming are encountered. Large programs involving thousands of line of code and more require formal software methodologies.
The task of developing large [[Computer software|software]] systems presents a significant intellectual challenge. Producing software with an acceptably high reliability within a predictable schedule and budget has historically been difficult; the academic and professional discipline of [[software engineering]] concentrates specifically on this challenge.

==== Bugs ====
{{Main|Software bug}}
[[File:H96566k.jpg|thumb|The actual first computer bug, a moth found trapped on a relay of the Harvard Mark II computer]]
Errors in computer programs are called "[[Software bug|bugs]]". They may be benign and not affect the usefulness of the program, or have only subtle effects. But in some cases, they may cause the program or the entire system to "[[Hang (computing)|hang]]", becoming unresponsive to input such as [[Mouse (computing)|mouse]] clicks or keystrokes, to completely fail, or to [[Crash (computing)|crash]]. Otherwise benign bugs may sometimes be harnessed for malicious intent by an unscrupulous user writing an [[Exploit (computer security)|exploit]], code designed to take advantage of a bug and disrupt a computer's proper execution. Bugs are usually not the fault of the computer. Since computers merely execute the instructions they are given, bugs are nearly always the result of programmer error or an oversight made in the program's design.&lt;ref&gt;It is not universally true that bugs are solely due to programmer oversight. Computer hardware may fail or may itself have a fundamental problem that produces unexpected results in certain situations. For instance, the [[Pentium FDIV bug]] caused some [[Intel Corporation|Intel]] [[microprocessor]]s in the early 1990s to produce inaccurate results for certain [[floating point]] division operations. This was caused by a flaw in the microprocessor design and resulted in a partial recall of the affected devices.&lt;/ref&gt;
Admiral [[Grace Hopper]], an American computer scientist and developer of the first [[compiler]], is credited for having first used the term "bugs" in computing after a dead moth was found shorting a relay in the [[Harvard Mark II]] computer in September 1947.&lt;ref name="taylor84"&gt;{{cite news
|first = Alexander L., III
|last = Taylor
|url = http://www.time.com/time/printout/0,8816,954266,00.html
|title = The Wizard Inside the Machine
|work = [[Time (magazine)|TIME]]
|date = 16 April 1984
|accessdate =17 February 2007}} {{subscription required}}&lt;/ref&gt;

== Networking and the Internet ==
{{Main|Computer networking|Internet}}
[[File:Internet map 1024.jpg|thumb|left|Visualization of a portion of the [[Routing|routes]] on the Internet]]
Computers have been used to coordinate information between multiple locations since the 1950s. The U.S. military's [[Semi Automatic Ground Environment|SAGE]] system was the first large-scale example of such a system, which led to a number of special-purpose commercial systems such as [[Sabre (computer system)|Sabre]].&lt;ref&gt;{{Cite book | title = Systems, Experts, and Computers | author = Agatha C. Hughes | publisher = [[MIT Press]] | year = 2000 | isbn = 978-0-262-08285-3 | page = 161 | quote = The experience of SAGE helped make possible the first truly large-scale commercial real-time network: the SABRE computerized airline reservations system&amp;nbsp;...}}&lt;/ref&gt; In the 1970s, computer engineers at research institutions throughout the United States began to link their computers together using telecommunications technology. The effort was funded by ARPA (now [[DARPA]]), and the [[computer network]] that resulted was called the [[ARPANET]].&lt;ref&gt;{{cite journal|title=A Brief History of the Internet|url=http://www.isoc.org/internet/history/brief.shtml|publisher=[[Internet Society]]|accessdate=20 September 2008|bibcode=1999cs........1011L|last1=Leiner|first1=Barry M.|last2=Cerf|first2=Vinton G.|last3=Clark|first3=David D.|last4=Kahn|first4=Robert E.|last5=Kleinrock|first5=Leonard|last6=Lynch|first6=Daniel C.|last7=Postel|first7=Jon|last8=Roberts|first8=Larry G.|last9=Wolf|first9=Stephen|year=1999|arxiv=cs/9901011}}&lt;/ref&gt; The technologies that made the Arpanet possible spread and evolved.

In time, the network spread beyond academic and military institutions and became known as the Internet. The emergence of networking involved a redefinition of the nature and boundaries of the computer. Computer operating systems and applications were modified to include the ability to define and access the resources of other computers on the network, such as peripheral devices, stored information, and the like, as extensions of the resources of an individual computer. Initially these facilities were available primarily to people working in high-tech environments, but in the 1990s the spread of applications like e-mail and the [[World Wide Web]], combined with the development of cheap, fast networking technologies like [[Ethernet]] and [[Asymmetric digital subscriber line|ADSL]] saw computer networking become almost ubiquitous. In fact, the number of computers that are networked is growing phenomenally. A very large proportion of personal computers regularly connect to the Internet to communicate and receive information. "Wireless" networking, often utilizing mobile phone networks, has meant networking is becoming increasingly ubiquitous even in mobile computing environments.
{{Clear}}

== Unconventional computers ==
{{Main|Human computer}}
{{See also|Harvard Computers}}
A computer does not need to be [[electronics|electronic]], nor even have a [[Central processing unit|processor]], nor [[Random-access memory|RAM]], nor even a [[hard disk]]. While popular usage of the word "computer" is synonymous with a personal electronic computer, the modern&lt;ref&gt;According to the ''[[Shorter Oxford English Dictionary]]'' (6th ed, 2007), the word ''computer'' dates back to the mid 17th century, when it referred to "A person who makes calculations; specifically a person employed for this in an observatory etc."&lt;/ref&gt; definition of a computer is literally: "''A device that computes'', especially a programmable [usually] electronic machine that performs high-speed mathematical or logical operations or that assembles, stores, correlates, or otherwise processes information."&lt;ref&gt;{{cite web|url=http://thefreedictionary.com/computer |title=Definition of computer|publisher=Thefreedictionary.com |accessdate=29 January 2012}}&lt;/ref&gt; Any device which ''processes information'' qualifies as a computer, especially if the processing is purposeful.{{citation needed|date=September 2015}}

== Future ==
There is active research to make computers out of many promising new types of technology, such as [[optical computing|optical computers]], [[DNA computing|DNA computers]], [[wetware computer|neural computers]], and [[quantum computing|quantum computers]]. Most computers are universal, and are able to calculate any [[computable function]], and are limited only by their memory capacity and operating speed. However different designs of computers can give very different performance for particular problems; for example quantum computers can potentially break some modern encryption algorithms (by [[Shor's algorithm|quantum factoring]]) very quickly.

=== Computer architecture paradigms ===
There are many types of [[computer architecture]]s:
* [[Quantum computer]] vs. [[Chemical computer]]
* [[Scalar processor]] vs. [[Vector processor]]
* [[Non-Uniform Memory Access]] (NUMA) computers
* [[Register machine]] vs. [[Stack machine]]
* [[Harvard architecture]] vs. [[von Neumann architecture]]
* [[Cellular architecture]]

Of all these [[abstract machine]]s, a quantum computer holds the most promise for revolutionizing computing.&lt;ref&gt;{{cite book|last1=II|first1=Joseph D. Dumas|title=Computer Architecture: Fundamentals and Principles of Computer Design|date=2005|publisher=CRC Press|isbn=9780849327490|page=340|url=https://books.google.com/?id=ZWaUurOwMPQC&amp;q=quantum+computers&amp;q=quantum%20computers|language=en}}&lt;/ref&gt; [[Logic gates]] are a common abstraction which can apply to most of the above [[Digital data|digital]] or [[analog signal|analog]] paradigms. The ability to store and execute lists of instructions called [[Computer program|programs]] makes computers extremely versatile, distinguishing them from [[calculator]]s. The [[Church–Turing thesis]] is a mathematical statement of this versatility: any computer with a [[Turing-complete|minimum capability (being Turing-complete)]] is, in principle, capable of performing the same tasks that any other computer can perform. Therefore, any type of computer ([[netbook]], [[supercomputer]], [[cellular automaton]], etc.) is able to perform the same computational tasks, given enough time and storage capacity.

=== Artificial intelligence ===
A computer will solve problems in exactly the way it is programmed to, without regard to efficiency, alternative solutions, possible shortcuts, or possible errors in the code. Computer programs that learn and adapt are part of the emerging field of [[artificial intelligence]] and [[machine learning]]. Artificial intelligence based products generally fall into two major categories: [[rule based system]]s and [[pattern recognition]] systems. Rule based systems attempt to represent the rules used by human experts and tend to be expensive to develop. Pattern based systems use data about a problem to generate conclusions. Examples of pattern based systems include [[Speech recognition|voice recognition]], font recognition, translation and the emerging field of on-line marketing.

== Professions and organizations ==
As the use of computers has spread throughout society, there are an increasing number of careers involving computers.
{| class="wikitable"
|+[[:Category:Computer occupations|Computer-related professions]]
|-
| Hardware-related || [[Electrical engineering]], [[Electronic engineering]], [[Computer engineering]], [[Telecommunications engineering]], [[Optical engineering]], [[Nanoengineering]]
|-
| Software-related || [[Computer science]], [[Computer engineering]], [[Desktop publishing]], [[Human–computer interaction]], [[Information technology]], [[Information systems (discipline)|Information systems]], [[Computational science]], [[Software engineering]], [[Video game industry]], [[Web design]]
|}

The need for computers to work well together and to be able to exchange information has spawned the need for many standards organizations, clubs and societies of both a formal and informal nature.

{| class="wikitable"
|+[[:Category:Information technology organizations|Organizations]]
| Standards groups || [[American National Standards Institute|ANSI]], [[International Electrotechnical Commission|IEC]], [[Institute of Electrical and Electronics Engineers|IEEE]], [[Internet Engineering Task Force|IETF]], [[International Organization for Standardization|ISO]], [[World Wide Web Consortium|W3C]]
|-
| Professional societies || [[Association for Computing Machinery|ACM]], [[Association for Information Systems|AIS]], [[Institution of Engineering and Technology|IET]], [[International Federation for Information Processing|IFIP]], [[British Computer Society|BCS]]
|-
| [[Free software|Free]]/[[open source software]] groups || [[Free Software Foundation]], [[Mozilla Foundation]], [[Apache Software Foundation]]
|}

== See also ==

{{Div col|colwidth=30em}}
* [[Glossary of computers]]
* [[Computability theory]]
* [[Computer insecurity]]
* [[Computer security]]
* [[Glossary of computer hardware terms]]
* [[History of computer science]]
* [[List of computer term etymologies]]
* [[List of fictional computers]]
* [[List of pioneers in computer science]]
* [[Pulse computation]]
* [[TOP500]] (list of most powerful computers)
* [[Unconventional computing]]
{{div col end}}

== References ==
{{Reflist|30em}}

== Notes ==
{{Refbegin|30em}}
* {{Cite book|url=https://books.google.com/books?id=C8ouDwAAQBAJ&amp;lpg=PP1&amp;dq=9780735211759&amp;pg=PP1#v=onepage&amp;q=9780735211759|title=Broad Band: The Untold Story of the Women Who Made the Internet|last=Evans|first=Claire L.|publisher=Portfolio/Penguin|year=2018|isbn=9780735211759|location=New York|pages=|ref=harv}}
* {{cite journal |last1=Fuegi |first1=J. |last2=Francis |first2=J. |title=Lovelace &amp; Babbage and the creation of the 1843 'notes' |journal=IEEE Annals of the History of Computing |volume=25 |issue=4 |pages=16 |year=2003 |doi=10.1109/MAHC.2003.1253887|url=https://semanticscholar.org/paper/81bbf32d2642a7a8c6b0a867379a4e9e99d872bc }}
* {{note label|kempf1961|Kempf 1961|a}} {{cite journal | author = Kempf, Karl | title = Historical Monograph: Electronic Computers Within the Ordnance Corps | publisher = [[Aberdeen Proving Ground]] ([[United States Army]]) | url = http://ed-thelen.org/comp-hist/U-S-Ord-61.html | year = 1961 }}
* {{note label|phillips2000|Phillips 2000|a}} {{cite web | last = Phillips | first = Tony | publisher = American Mathematical Society | year = 2000 | title = The Antikythera Mechanism I | url = http://www.math.sunysb.edu/~tony/whatsnew/column/antikytheraI-0400/kyth1.html | accessdate =5 April 2006 }}
* {{note label|shannon1940|Shannon 1940|a}} {{cite thesis | author = Shannon, Claude Elwood | title = A symbolic analysis of relay and switching circuits | publisher = Massachusetts Institute of Technology | hdl = 1721.1/11173 | year = 1940 | type = Thesis }}
* {{Cite book | ref = {{harvid|Digital Equipment Corporation|1972}} | author = Digital Equipment Corporation | publisher = Digital Equipment Corporation | location = [[Maynard, Massachusetts|Maynard, MA]] | title = PDP-11/40 Processor Handbook | url = https://www.minttwist.com/wp-content/uploads/2016/06/D-09-30-PDP11-40-Processor-Handbook.pdf | year = 1972 | author-link = Digital Equipment Corporation }}
* {{Cite journal | ref = {{harvid|Verma &amp; Mielke|1988}} |author1=Verma, G. |author2=Mielke, N. | title = Reliability performance of ETOX based flash memories | publisher = IEEE International Reliability Physics Symposium | year = 1988 }}
* {{Cite journal | ref = SWADE | first = Doron D. | last = Swade | title = Redeeming Charles Babbage's Mechanical Computer | journal = Scientific American |date=February 1993 | volume = 268 |issue = 2 | pages = 86–91 | jstor = 24941379 | bibcode = 1993SciAm.268b..86S | doi = 10.1038/scientificamerican0293-86 }}
* {{cite web | ref = {{harvid|TOP500|2006}} | url = http://www.top500.org/lists/2006/11/overtime/Architectures | title = Architectures Share Over Time | accessdate=27 November 2006 | last = Meuer | first = Hans | authorlink = Hans Meuer |author2=Strohmaier, Erich |author3=Simon, Horst | author4-link = Jack Dongarra |author4=Dongarra, Jack | date = 13 November 2006 | publisher = [[TOP500]] |archiveurl=https://web.archive.org/web/20070220095222/http://www.top500.org/lists/2006/11/overtime/Architectures|archivedate=20 February 2007}}
* {{Cite book|last=Lavington |first=Simon |title=A History of Manchester Computers |year=1998 |edition=2 |publisher=The British Computer Society |location=Swindon |isbn=978-0-902505-01-8 |ref=harv}}
* {{Cite journal|last=Light|first=Jennifer S.|date=1999|title=When Computers Were Women|jstor=25147356|journal=Technology and Culture|volume=40|issue=3|pages=455–483|ref=harv}}
* {{Cite book | last = Stokes | first = Jon | title = Inside the Machine: An Illustrated Introduction to Microprocessors and Computer Architecture | year = 2007 | publisher = No Starch Press | location = San Francisco | isbn = 978-1-59327-104-6 }}
* {{Cite book | ref= ZUSE| last = Zuse| first = Konrad | title = The Computer – My life | year = 1993 | publisher = Pringler-Verlag | location = Berlin | isbn = 978-0-387-56453-1 }}
* {{cite book | ref=FELT | last=Felt | first=Dorr E. | title=Mechanical arithmetic, or The history of the counting machine | publisher=Washington Institute | location=Chicago | year=1916 | url=https://archive.org/details/mechanicalarithm00feltrich }}
* {{cite book | ref = IFRAH | last = Ifrah | first = Georges | year = 2001 | title = The Universal History of Computing: From the Abacus to the Quantum Computer | location = New York | publisher = John Wiley &amp; Sons | isbn = 978-0-471-39671-0 | url = https://archive.org/details/unset0000unse_w3q2 }}
* {{cite book | ref = BERK | last = Berkeley | first = Edmund | year = 1949 | title = Giant Brains, or Machines That Think | url = https://archive.org/details/in.ernet.dli.2015.285568 | publisher=John Wiley &amp; Sons }}
* {{cite book | ref = AIKEN| last = Cohen| first = Bernard| year = 2000| title = Howard Aiken, Portrait of a computer pioneer  | journal = Physics Today| volume = 53| issue = 3| pages = 74–75| publisher=The MIT Press | location = Cambridge, Massachusetts|isbn= 978-0-262-53179-5 | bibcode = 2000PhT....53c..74C| doi = 10.1063/1.883007}}
* {{cite book | ref = LIGO| last = Ligonnière| first = Robert| year = 1987| title = Préhistoire et Histoire des ordinateurs | publisher=Robert Laffont | location=Paris| isbn = 978-2-221-05261-7 }}
* {{cite book | ref = COUFFIGNAL| last = Couffignal| first = Louis| year = 1933| title = Les machines à calculer ; leurs principes, leur évolution | publisher=Gauthier-Villars | location=Paris }}
* {{cite book | ref = JACWEB | last = Essinger | first = James | year = 2004 | title = Jacquard's Web, How a hand loom led to the birth of the information age | publisher = Oxford University Press | isbn = 978-0-19-280577-5 | url-access = registration | url = https://archive.org/details/jacquardswebhowh0000essi }}
* {{cite book | ref=HYMAN | last=Hyman | first=Anthony | title=Charles Babbage: Pioneer of the Computer | publisher=Princeton University Press | year= 1985 | isbn=978-0-691-02377-9 }}
* {{cite book | first=B. V. | last=Bowden | title=Faster than thought | year=1953 | publisher=Pitman publishing corporation | location=New York, Toronto, London | ref=BOWDEN }}
* {{cite book | first=Maboth | last=Moseley | title=Irascible Genius, Charles Babbage, inventor | year=1964 | publisher=Hutchinson | location=London | ref=GENIUS }}
* {{cite book|ref=COLLIER|last=Collier|first=Bruce|title=The little engine that could've: The calculating machines of Charles Babbage|year=1970|publisher=Garland Publishing Inc|isbn=978-0-8240-0043-1|url=http://robroy.dyndns.info/collier/index.html}}
* {{cite web|ref=LTB |url=http://www.cs.ncl.ac.uk/publications/articles/papers/398.pdf |title=From Analytical Engine to Electronic Digital Computer: The Contributions of Ludgate, Torres, and Bush |last1=Randell |first1=Brian |author-link1=Brian Randell |year=1982 |accessdate=29 October 2013 |url-status=dead |archiveurl=https://web.archive.org/web/20130921055055/http://www.cs.ncl.ac.uk/publications/articles/papers/398.pdf |archivedate=21 September 2013 |df= }}
* {{Cite journal|last=Smith|first=Erika E.|date=2013|title=Recognizing a Collective Inheritance through the History of Women in Computing|journal=CLCWeb: Comparative Literature and Culture |volume=15|issue=1|pages=1–9|ref=harv|doi=10.7771/1481-4374.1972|doi-access=free}}
{{Refend}}

== External links ==
* {{commonscatinline|Computers}}
* {{sister-inline
|project=v
|links=[[v:How things work college course/Computer quiz|Wikiversity has a quiz on this article]]
|short=yes}}
* [http://www.computerhistory.org/atchm/warhol-the-computer/ Warhol &amp; The Computer]

&lt;!--========================{{No more links}}============================
    | PLEASE BE CAUTIOUS IN ADDING MORE LINKS TO THIS ARTICLE. Wikipedia  |
    | is not a collection of links nor should it be used for advertising. |
    |                                                                     |
    |           Excessive or inappropriate links WILL BE DELETED.         |
    | See [[Wikipedia:External links]] &amp; [[Wikipedia:Spam]] for details.  |
    |                                                                     |
    | If there are already plentiful links, please propose additions or   |
    | replacements on this article's discussion page, or submit your link |
    | to the relevant category at the Open Directory Project (dmoz.org)   |
    | and link back to that category using the {{dmoz}} template.         |
   ======================={{No more links}}=====================--&gt;
{{Use dmy dates|date=July 2017}}

{{Authority control}}
{{Basic computer components}}
{{digital systems}}
{{Electronic systems}}

[[Category:Computers| ]]
[[Category:Consumer electronics]]
[[Category:Articles containing video clips]]
[[Category:Articles with example code]]
[[Category:Electronics industry]]</text>
      <sha1>t9ycxf1lvmrp4opusb48skfs37ni44t</sha1>
    </revision>
  </page>
  <page>
    <title>Software</title>
    <ns>0</ns>
    <id>5309</id>
    <revision>
      <id>954141645</id>
      <parentid>953187877</parentid>
      <timestamp>2020-04-30T22:07:06Z</timestamp>
      <contributor>
        <username>Nihiltres</username>
        <id>236191</id>
      </contributor>
      <minor/>
      <comment>Standardized hatnote</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="33906" xml:space="preserve">{{other uses|Software (disambiguation)}}{{distinguish|Softwear}}
{{pp-protected|small=yes}}
{{short description|Non-tangible executable component of a computer}}
{{redirect|Networked|the 2012 book|Networked: The New Social Operating System}}
[[File:Operating system placement (software).svg|thumb|upright|A diagram showing how the [[User (computing)|user]] interacts with [[application software]] on a typical [[desktop computer]]. The application software layer interfaces with the [[operating system]], which in turn communicates with the [[Personal computer hardware|hardware]]. The arrows indicate information flow.]]

'''Computer software''', or simply '''software''', is a collection of [[data (computing)|data]] or [[computer]] instructions that tell the computer how to work. This is in contrast to [[Computer hardware|physical hardware]], from which the system is built and actually performs the work. In [[computer science]] and [[software engineering]], computer software is all [[information]] processed by [[computer system]]s, [[Computer program|program]]s and [[data]]. Computer software includes [[computer program]]s, [[Library (computing)|libraries]] and related non-executable [[Data (computing)|data]], such as [[Software documentation|online documentation]] or [[digital media]]. Computer hardware and software require each other and neither can be realistically used on its own.

At the lowest programming level,{{Clarify|reason=What 'level' means can be unclear to non-technical readers|date=August 2018}} [[executable code]] consists of [[Machine code|machine language]] instructions supported by an individual [[Microprocessor|processor]]—typically a [[central processing unit]] (CPU) or a [[graphics processing unit]] (GPU). A machine language consists of groups of [[Binary number|binary values]] signifying [[Instruction set architecture|processor instructions]] that change the state of the computer from its preceding state. For example, an instruction may change the value stored in a particular storage location in the computer—an effect that is not directly observable to the user. An instruction [[System call|may also invoke]] one of many [[Input/output|input or output operations]], for example displaying some text on a computer screen; causing state changes which should be visible to the [[User (computing)|user]]. The processor [[Instruction cycle|executes]] the instructions in the order they are provided, unless it is instructed to [[branch instruction|"jump" to a different instruction]], or is [[interrupt]]ed by the operating system. {{As of|2015}}, most [[personal computer]]s, [[smartphone]] devices and [[Server (computing)|servers]] have [[Multi-core processor|processors with multiple execution units]] or [[Multiprocessing|multiple processors performing computation]] together, and computing has become a much more [[Concurrent computing|concurrent]] activity than in the past.

The majority of software is written in [[high-level programming language]]s. They are easier and more efficient for programmers because they are closer to [[natural language]]s than machine languages.&lt;ref&gt;{{cite web|title=Compiler construction|url=http://www.cs.uu.nl/education/vak.php?vak=INFOMCCO|url-status=live|archiveurl=https://web.archive.org/web/20131102143144/http://www.cs.uu.nl/education/vak.php?vak=INFOMCCO|archivedate=2 November 2013|df=dmy-all}}&lt;/ref&gt; High-level languages are translated into machine language using a [[compiler]] or an [[Interpreter (computing)|interpreter]] or a combination of the two. Software may also be written in a low-level [[assembly language]], which has strong correspondence to the computer's machine language instructions and is translated into machine language using an [[Assembly language|assembler]].

==History==
{{Main|History of software}}
An outline ([[algorithm]]) for what would have been the first piece of software was written by [[Ada Lovelace]] in the 19th century, for the planned [[Analytical Engine]].{{Sfn|Evans|2018|p=21}} She created [[Mathematical proof|proofs]] to show how the engine would calculate [[Bernoulli number|Bernoulli Numbers]].{{Sfn|Evans|2018|p=21}} Because of the proofs and the algorithm, she is considered the first computer programmer.&lt;ref name="Annals of the History of Computing"&gt;{{cite journal|last=Fuegi|first=J.|last2=Francis|first2=J.|date=2003|title=Lovelace &amp; Babbage and the creation of the 1843 'notes'|journal=Annals of the History of Computing|volume=25|issue=4|pages=16–26|doi=10.1109/MAHC.2003.1253887}}&lt;/ref&gt;&lt;ref name="Lovelace Google"&gt;{{Cite news|url=https://www.theguardian.com/technology/2012/dec/10/ada-lovelace-honoured-google-doodle|title=Ada Lovelace honoured by Google doodle|last=|first=|date=December 10, 2012|newspaper=The Guardian|accessdate=25 November 2018}}&lt;/ref&gt;

The first theory about software—prior to the creation of computers as we know them today—was proposed by [[Alan Turing]] in his 1935 essay ''On Computable Numbers, with an Application to the Entscheidungsproblem'' (decision problem).

This eventually led to the creation of the academic fields of [[computer science]] and [[software engineering]]; Both fields study software and its creation. Computer science is the theoretical study of computer and software (Turing's essay is an example of computer science), whereas software engineering is the application of engineering and development of software.

However, prior to 1946, software was not yet the programs stored in the memory of stored-program digital computers, as we now understand it. The first electronic computing devices were instead rewired in order to "reprogram" them.

In 2000, Fred Shapiro, a librarian at the Yale Law School, published a letter revealing that [[John Wilder Tukey]]'s 1958 paper "The Teaching of Concrete Mathematics"&lt;ref name="Tukey_1958"/&gt;&lt;ref name="Beebe_2017"/&gt; contained the earliest known usage of the term "software" found in a search of [[JSTOR]]'s electronic archives, predating the [[OED]]'s citation by two years.&lt;ref name="Shapiro_2000"/&gt; This led many to credit Tukey with coining the term, particularly in obituaries published that same year,&lt;ref name="Leonhardt_2000"/&gt; although Tukey never claimed credit for any such coinage. In 1995, Paul Niquette claimed he had originally coined the term in October 1953, although he could not find any documents supporting his claim.&lt;ref name="Niquette_2006"/&gt; The earliest known publication of the term "software" in an engineering context was in August 1953 by Richard R. Carhart, in a [[Rand Corporation]] Research Memorandum.&lt;ref name="Carhart_1953"/&gt;

==Types==
{{See also|Software categories}}
[[File:BgeCarSc.jpg|thumb|250px|[[Blender Game Engine]], a [[free software]].]]

On virtually all computer platforms, software can be grouped into a few broad categories.

===Purpose, or domain of use===
{{Ecommerce}}
Based on the goal, computer software can be divided into:

* '''[[Application software]]''' &lt;br /&gt; which is software that uses the computer system to perform special functions or provide [[video game|entertainment functions]] beyond the basic operation of the computer itself. There are many different types of application software, because the range of tasks that can be performed with a modern computer is so large—see [[list of software]].
* '''[[System software]]''' &lt;br /&gt; which is software for managing '''[[computer hardware]]''' behaviour, as to provide basic functionalities that are required by users, or for other software to run properly, if at all. System software is also designed for providing a platform for running application software,&lt;ref&gt;{{cite web|url=http://home.olemiss.edu/~misbook/sfsysfm.htm|title=System Software|publisher=The University of Mississippi|archive-url=https://web.archive.org/web/20010530092843/http://home.olemiss.edu/~misbook/sfsysfm.htm|archive-date=30 May 2001|url-status=dead|df=dmy-all}}&lt;/ref&gt; and it includes the following:
**'''[[Operating system]]s''' &lt;br /&gt; which are essential collections of software that manage resources and provide common services for other software that runs "on top" of them. [[Supervisory program]]s, [[boot loader]]s, [[shell (computing)|shells]] and [[window system]]s are core parts of operating systems. In practice, an operating system comes bundled with additional software (including application software) so that a user can potentially do some work with a computer that only has one operating system.
** '''[[Device driver]]s''' &lt;br /&gt; which operate or control a particular type of device that is attached to a computer. Each device needs at least one corresponding device driver; because a computer typically has at minimum at least one input device and at least one output device, a computer typically needs more than one device driver.
** '''[[Software utility|Utilities]]''' &lt;br /&gt; which are computer [[Control Panel (Windows)|programs]] designed to assist users in the maintenance and care of their computers.
* '''[[Malicious software]]''' or '''malware''' &lt;br /&gt; which is software that is developed to harm and disrupt computers. As such, malware is undesirable. Malware is closely associated with computer-related crimes, though some malicious programs may have been designed as [[practical joke]]s.

===Nature or domain of execution===
* [[Desktop applications]] such as [[web browser]]s and [[Microsoft Office]], as well as [[smartphone]] and [[Tablet computer|tablet]] applications (called "[[mobile app|apps]]"). (There is a push in some parts of the software industry to merge desktop applications with mobile apps, to some extent. [[Windows 8]], and later [[Ubuntu Touch]], tried to allow the same style of application user interface to be used on desktops, laptops and mobiles.)
* [[JavaScript]] scripts are pieces of software traditionally embedded in [[web page]]s that are run directly inside the [[web browser]] when a web page is loaded without the need for a web browser plugin. Software written in other programming languages can also be run within the web browser if the software is either translated into JavaScript, or if a web browser plugin that supports that language is installed; the most common example of the latter is [[ActionScript]] scripts, which are supported by the [[Adobe Flash]] plugin.
* [[Server software]], including:
** [[Web application]]s, which usually run on the [[web server]] and output dynamically generated web pages to web browsers, using e.g. [[PHP]], [[Java (programming language)|Java]], [[ASP.NET]], or even [[Node.js|JavaScript that runs on the server]]. In modern times these commonly include some JavaScript to be run in the web browser as well, in which case they typically run partly on the server, partly in the web browser.
* [[Plug-in (computing)|Plugins]] and extensions are software that extends or modifies the functionality of another piece of software, and require that software be used in order to function;
* [[Embedded software]] resides as [[firmware]] within [[embedded system]]s, devices dedicated to a single use or a few uses such as [[car]]s and [[television]]s (although some embedded devices such as wireless chipsets can ''themselves'' be part of an ordinary, non-embedded computer system such as a PC or smartphone).&lt;ref&gt;{{cite web|title=Embedded Software—Technologies and Trends|url=http://www.computer.org/csdl/mags/so/2009/03/mso2009030014.html|publisher=IEEE Computer Society|date=May–June 2009|accessdate=6 November 2013|url-status=live|archiveurl=https://web.archive.org/web/20131028045823/http://www.computer.org/csdl/mags/so/2009/03/mso2009030014.html|archivedate=28 October 2013|df=dmy-all}}&lt;/ref&gt; In the embedded system context there is sometimes no clear distinction between the system software and the application software. However, some embedded systems run [[embedded operating system]]s, and these systems do retain the distinction between system software and application software (although typically there will only be one, fixed application which is always run).
* [[Microcode]] is a special, relatively obscure type of embedded software which tells the processor ''itself'' how to execute machine code, so it is actually a lower level than machine code. It is typically proprietary to the processor manufacturer, and any necessary correctional microcode software updates are supplied by them to users (which is much cheaper than shipping replacement processor hardware). Thus an ordinary programmer would not expect to ever have to deal with it.

===Programming tools===
{{Main|Programming tool}}
Programming tools are also software in the form of programs or applications that [[software developer]]s (also known as
''programmers, coders, hackers'' or ''software engineers'') use to create, [[Debugging|debug]], [[Software maintenance|maintain]] (i.e. improve or fix), or otherwise [[Technical support|support]] software.

Software is written in one or more programming languages; there are many programming languages in existence, and each has at least one implementation, each of which consists of its own set of programming tools. These tools may be relatively self-contained programs such as [[compiler]]s, [[debugger]]s, [[interpreter (computing)|interpreters]], [[linker (computing)|linkers]], and [[text editor]]s, that can be combined together to accomplish a task; or they may form an [[integrated development environment]] (IDE), which combines much or all of the functionality of such self-contained tools. IDEs may do this by either invoking the relevant individual tools or by re-implementing their functionality in a new way. An IDE can make it easier to do specific tasks, such as searching in files in a particular project. Many programming language implementations provide the option of using both individual tools or an IDE.

==Topics==
===Architecture===
{{See also|Software architecture}}
Users often see things differently from programmers. People who use modern general purpose computers (as opposed to [[embedded system]]s, [[analog computer]]s and [[supercomputer]]s) usually see three layers of software performing a variety of tasks: platform, application, and user software.

* '''Platform software''' &lt;br /&gt; The [[Platform (computing)|Platform]] includes the [[firmware]], [[device driver]]s, an [[operating system]], and typically a [[graphical user interface]] which, in total, allow a user to interact with the computer and its [[peripheral]]s (associated equipment). Platform software often comes bundled with the computer. On a [[Personal computer|PC]] one will usually have the ability to change the platform software.
* '''Application software''' &lt;br /&gt; [[Application software]] or Applications are what most people think of when they think of software. Typical examples include office suites and video games. [[Application software]] is often purchased separately from computer hardware. Sometimes applications are bundled with the computer, but that does not change the fact that they run as independent applications. Applications are usually independent programs from the operating system, though they are often tailored for specific platforms. Most users think of compilers, databases, and other "system software" as applications.
* '''User-written software''' &lt;br /&gt; [[End-user development]] tailors systems to meet users' specific needs. User software includes spreadsheet templates and [[word processor]] templates. Even email filters are a kind of user software. Users create this software themselves and often overlook how important it is. Depending on how competently the user-written software has been integrated into default application packages, many users may not be aware of the distinction between the original packages, and what has been added by co-workers.

===Execution===
{{Main|Execution (computing)}}
Computer software has to be "loaded" into the [[computer storage|computer's storage]] (such as the [[hard drive]] or [[Computer memory|memory]]). Once the software has loaded, the computer is able to ''execute'' the software. This involves passing [[instruction set architecture|instructions]] from the [[application software]], through the system software, to the hardware which ultimately receives the instruction as [[machine code]]. Each instruction causes the computer to carry out an operation—moving [[data (computing)|data]], carrying out a [[computation]], or altering the [[control flow]] of instructions.

Data movement is typically from one place in memory to another. Sometimes it involves moving data between memory and registers which enable high-speed data access in the CPU. Moving data, especially large amounts of it, can be costly. So, this is sometimes avoided by using "pointers" to data instead. Computations include simple operations such as incrementing the value of a variable data element. More complex computations may involve many operations and data elements together.&lt;!-- This section is simply too long for this article and needs to be compressed into the intro above, or moved to the article itself.

Instructions may be performed sequentially, conditionally, or iteratively. Sequential instructions are those operations that are performed one after another. Conditional instructions are performed such that different sets of instructions execute depending on the value(s) of some data. In some languages this is known as an "if" statement. Iterative instructions are performed repetitively and may depend on some data value. This is sometimes called a "loop." Often, one instruction may "call" another set of instructions that are defined in some other program or [[modular programming|module]]. When more than one computer processor is used, instructions may be executed simultaneously.

A simple example of the way software operates is what happens when a user selects an entry such as "Copy" from a menu. In this case, a conditional instruction is executed to copy text from data in a 'document' area residing in memory, perhaps to an intermediate storage area known as a 'clipboard' data area. If a different menu entry such as "Paste" is chosen, the software may execute the instructions to copy the text from the clipboard data area to a specific location in the same or another document in memory.

Depending on the application, even the example above could become complicated. The field of software engineering endeavors to manage the complexity of how software operates. This is especially true for software that operates in the context of a large or powerful [[computer system]].

Currently, almost the only limitations on the use of computer software in applications is the ingenuity of the designer/programmer. Consequently, large areas of activities (such as playing grand master-level chess) formerly assumed to be incapable of software simulation are now routinely programmed. The only area that has so far proved reasonably secure from software simulation is the realm of human art— especially, pleasing music and literature.{{Citation needed|date=June 2007}}

Kinds of software by operation: [[computer program]] as [[executable]], [[source code]] or [[scripting language|script]], [[computer configuration|configuration]].--&gt;

===Quality and reliability===
{{Main|Software quality|Software testing}}
Software quality is very important, especially for [[commercial software|commercial]] and system software like [[Microsoft Office]], [[Microsoft Windows]] and [[Linux]]. If software is faulty (buggy), it can delete a person's work, crash the computer and do other unexpected things. Faults and errors are called "[[Software bug|bugs]]" which are often discovered during alpha and beta testing. Software is often also a victim to what is known as [[software aging]], the progressive performance degradation resulting from a combination of unseen bugs.

Many bugs are discovered and eliminated (debugged) through [[software testing]]. However, software testing rarely—if ever—eliminates every bug; some programmers say that "every program has at least one more bug" (Lubarsky's Law).&lt;ref name="github"&gt;{{cite web | url=https://github.com/mark-watson/scripting-intelligence-book-examples/blob/master/part1/wikipedia_text/software.txt | title=scripting intelligence book examples | url-status=live | archiveurl=https://web.archive.org/web/20151106154317/https://github.com/mark-watson/scripting-intelligence-book-examples/blob/master/part1/wikipedia_text/software.txt | archivedate=6 November 2015 | df=dmy-all | date=2018-05-09 }}&lt;/ref&gt; In the [[Waterfall model|waterfall]] method of software development, separate testing teams are typically employed, but in newer approaches, collectively termed [[agile software development]], developers often do all their own testing, and demonstrate the software to users/clients regularly to obtain feedback. Software can be tested through [[unit testing]], [[regression testing]] and other methods, which are done manually, or most commonly, automatically, since the amount of code to be tested can be quite large. For instance, [[NASA]] has extremely rigorous software testing procedures for many operating systems and communication functions. Many NASA-based operations interact and identify each other through command programs. This enables many people who work at NASA to check and evaluate functional systems overall. Programs containing command software enable hardware engineering and system operations to function much easier together.

===License===
{{Main|Software license}}
The software's license gives the user the right to use the software in the licensed environment, and in the case of [[free software license]]s, also grants other rights such as the right to make copies.

[[Proprietary software]] can be divided into two types:

* [[freeware]], which includes the category of "free trial" software or "[[freemium]]" software (in the past, the term [[shareware]] was often used for free trial/freemium software). As the name suggests, freeware can be used for free, although in the case of free trials or freemium software, this is sometimes only true for a limited period of time or with limited functionality.
* software available for a fee, often inaccurately termed "[[commercial software]]", which can only be legally used on purchase of a license.

[[Open-source software]], on the other hand, comes with a [[free software license]], granting the recipient the rights to modify and redistribute the software.

===Patents===
{{Main|Software patent|Software patent debate}}
Software patents, like other types of patents, are theoretically supposed to give an inventor an exclusive, time-limited license for a ''detailed idea (e.g. an algorithm) on how to implement'' a piece of software, or a component of a piece of software. Ideas for useful things that software could ''do'', and user ''requirements'', are not supposed to be patentable, and concrete implementations (i.e. the actual software packages implementing the patent) are not supposed to be patentable either—the latter are already covered by copyright, generally automatically. So software patents are supposed to cover the middle area, between requirements and concrete implementation. In some countries, a requirement for the claimed invention to have an effect on the physical world may also be part of the requirements for a software patent to be held valid—although since ''all'' useful software has effects on the physical world, this requirement may be open to debate. Meanwhile, American copyright law was applied to various aspects of the writing of the software code.&lt;ref&gt;Gerardo Con Díaz, "The Text in the Machine: American Copyright Law and the Many Natures of Software, 1974–1978,” ''Technology and Culture'' 57 (October 2016), 753–79.&lt;/ref&gt;

Software patents are controversial in the software industry with many people holding different views about them. One of the sources of controversy is that the aforementioned split between initial ideas and patent does not seem to be honored in practice by patent lawyers—for example the patent for [[Aspect-Oriented Programming]] (AOP), which purported to claim rights over ''any'' programming tool implementing the idea of AOP, howsoever implemented. Another source of controversy is the effect on innovation, with many distinguished experts and companies arguing that software is such a fast-moving field that software patents merely create vast additional litigation costs and risks, and actually retard innovation. In the case of debates about software patents outside the United States, the argument has been made that large American corporations and patent lawyers are likely to be the primary beneficiaries of allowing or continue to allow software patents.

==Design and implementation==
{{Main|Software development|Computer programming|Software engineering}}
Design and implementation of software varies depending on the complexity of the software. For instance, the design and creation of [[Microsoft Word]] took much more time than designing and developing [[Microsoft Notepad]] because the latter has much more basic functionality.

Software is usually designed and created (aka coded/written/programmed) in [[integrated development environment]]s (IDE) like [[Eclipse (software)|Eclipse]], [[IntelliJ IDEA|IntelliJ]] and [[Microsoft Visual Studio]] that can simplify the process and [[compiler|compile]] the software (if applicable). As noted in a different section, software is usually created on top of existing software and the [[application programming interface]] (API) that the underlying software provides like [[GTK+]], JavaBeans or [[Swing (Java)|Swing]]. Libraries (APIs) can be categorized by their purpose. For instance, the [[Spring Framework]] is used for implementing [[enterprise application]]s, the [[Windows Forms]] library is used for designing graphical user interface (GUI) applications like [[Microsoft Word]], and [[Windows Communication Foundation]] is used for designing [[web service]]s. When a program is designed, it relies upon the API. For instance, a Microsoft Windows desktop application might call API functions in the [[.NET Framework|.NET]] Windows Forms library like ''Form1.Close()'' and ''Form1.Show()''&lt;ref&gt;{{cite web |url=http://msdn.microsoft.com/en-us/library/default.aspx |title=MSDN Library |accessdate=2010-06-14 |url-status=live |archiveurl=https://web.archive.org/web/20100611204810/http://msdn.microsoft.com/en-us/library/default.aspx |archivedate=11 June 2010 |df=dmy-all }}&lt;/ref&gt; to close or open the application. Without these APIs, the programmer needs to write these functionalities entirely themselves. Companies like [[Oracle Corporation|Oracle]] and [[Microsoft]] provide their own APIs so that many applications are written using their [[Library (computing)|software libraries]] that usually have numerous APIs in them.

[[Data structure]]s such as [[hash table]]s, [[array data type|arrays]], and [[binary tree]]s, and [[algorithm]]s such as [[quicksort]], can be useful for creating software.

Computer software has special economic characteristics that make its design, creation, and distribution different from most other economic goods.{{Specify|Which characteristics?|date=May 2012}}&lt;ref&gt;{{cite journal |author=v. Engelhardt, Sebastian |year=2008 |url=https://ideas.repec.org/p/jrp/jrpwrp/2008-045.html |title=The Economic Properties of Software |journal=Jena Economic Research Papers |volume=2 |issue=2008–045 |url-status=live |archiveurl=https://web.archive.org/web/20160105145954/https://ideas.repec.org/p/jrp/jrpwrp/2008-045.html |archivedate=5 January 2016 |df=dmy-all }}&lt;/ref&gt;&lt;ref&gt;{{cite web |url=http://dankaminsky.com/1999/03/02/69/ |title=Why Open Source Is The Optimum Economic Paradigm for Software |first=Dan |last=Kaminsky |year=1999 |url-status=live |archiveurl=https://web.archive.org/web/20120522001231/http://dankaminsky.com/1999/03/02/69/ |archivedate=22 May 2012 |df=dmy-all }}&lt;/ref&gt;

A person who creates software is called a [[programmer]], [[software engineer]] or software developer, terms that all have a similar meaning. More informal terms for programmer also exist such as "coder" and "'''hacker'''"{{Spaced ndash}}although use of the latter word may cause confusion, because it is more often used to mean [[Security hacker|someone who illegally breaks into computer systems]].

==Industry and organizations==
{{Main|Software industry}}
A great variety of software companies and programmers in the world comprise a software industry. Software can be quite a profitable industry: [[Bill Gates]], the co-founder of [[Microsoft]] was the richest person in the world in 2009, largely due to his ownership of a significant number of shares in Microsoft, the company responsible for [[Microsoft Windows]] and [[Microsoft Office]] software products - both market leaders in their respective product categories.

Non-profit software organizations include the [[Free Software Foundation]], [[GNU Project]] and the [[Mozilla Foundation]]. Software standard organizations like the [[W3C]], [[IETF]] develop recommended software standards such as [[XML]], [[HTTP]] and [[HTML]], so that software can interoperate through these standards.

Other well-known large software companies include [[Google]], [[IBM]], [[Tata Consultancy Services|TCS]], [[Infosys]], [[Wipro]], [[HCL Technologies]], [[Oracle Corporation|Oracle]], [[Novell]], [[SAP AG|SAP]], [[NortonLifeLock|Symantec]], [[Adobe Systems]], [[Sidetrade]] and [[Corel]], while small companies often provide innovation.

==See also==
* [[Software release life cycle]]
* [[Independent software vendor]]
* [[Outline of software]]
* [[Software asset management]]
* [[Open-source software]]
{{Portal bar|Free and open-source software}}

==References==
{{reflist|refs=
&lt;ref name="Carhart_1953"&gt;{{cite book |author-last=Carhart |author-first=Richard |title=A survey of the current status of the electronic reliability problem |date=1953 |publisher=[[Rand Corporation]] |location=Santa Monica, CA |page=69 |url=https://www.rand.org/content/dam/rand/pubs/research_memoranda/2013/RM1131.pdf#79 |access-date= |quote=[…] It will be recalled from Sec. 1.6 that the term ''personnel'' was defined to include people who come into direct contact with the hardware, from production to field use, i.e., people who assemble, inspect, pack, ship, handle, install, operate, and maintain electronic equipment. In any of these phases personnel failures may result in unoperational gear. As with the hardware factors, there is almost no quantitative data concerning these software or human factors in reliability: How many faults are caused by personnel, why they occur, and what can be done to remove the errors. […]}}&lt;/ref&gt;
&lt;ref name="Tukey_1958"&gt;{{cite journal |author-first=John Wilder |author-last=Tukey |author-link=John Wilder Tukey |title=The Teaching of Concrete Mathematics |journal=[[American Mathematical Monthly]] |publisher=[[Taylor &amp; Francis, Ltd.]] / [[Mathematical Association of America]] |volume=65 |issue=1 |pages=1–9, 2 |date=January 1958 |id={{CODEN|AMMYAE}} |issn=0002-9890 |doi=10.2307/2310294 |quote=[…] Today the "software" comprising the carefully planned interpretive routines, compilers, and other aspects of automative programming are at least as important to the modern electronic calculator as its "hardware" of tubes, transistors, wires, tapes, and the like. […]|jstor=2310294 }}&lt;/ref&gt;
&lt;ref name="Niquette_2006"&gt;{{citation |author-last=Niquette |author-first=R. Paul |date=2006 |title=Softword: Provenance for the Word 'Software |isbn=1-58922-233-4 |url=http://www.niquette.com/books/softword/tocsoft.html |access-date=2019-08-18 |url-status=live |archive-url=https://web.archive.org/web/20190808124650/http://www.niquette.com/books/softword/tocsoft.html |archive-date=2019-08-08}}&lt;/ref&gt;
&lt;ref name="Shapiro_2000"&gt;{{cite journal |author-last=Shapiro |author-first=Fred |date=2000 |title=Origin of the Term Software: Evidence from the JSTOR Electronic Journal Archive |journal=[[IEEE Annals of the History of Computing]] |volume=22 |issue=2 |pages=69–71 |doi=10.1109/mahc.2000.887997 |url=http://computer.org/annals/an2000/pdf/a2069.pdf |access-date=2013-06-25 |url-status=dead |archive-url=https://web.archive.org/web/20030605004419/http://computer.org/annals/an2000/pdf/a2069.pdf |archive-date=2003-06-05}}&lt;/ref&gt;
&lt;ref name="Leonhardt_2000"&gt;{{cite news |title=John Tukey, 85, Statistician; Coined the Word 'Software' |author-last=Leonhardt |author-first=David |newspaper=[[The New York Times]] |date=2000-07-28 |url=https://www.nytimes.com/2000/07/28/us/john-tukey-85-statistician-coined-the-word-software.html |access-date=2012-09-24}}&lt;/ref&gt;
&lt;ref name="Beebe_2017"&gt;{{cite book |author-first=Nelson H. F. |author-last=Beebe |title=The Mathematical-Function Computation Handbook - Programming Using the MathCW Portable Software Library |chapter=Chapter I - Integer arithmetic |date=2017-08-22 |location=Salt Lake City, UT, USA |publisher=[[Springer International Publishing AG]] |edition=1 |lccn=2017947446 |isbn=978-3-319-64109-6 |doi=10.1007/978-3-319-64110-2 |pages=969, 1035}}&lt;/ref&gt;
}}

===Sources===
*{{Cite book|url=https://books.google.com/books?id=C8ouDwAAQBAJ&amp;lpg=PP1&amp;dq=9780735211759&amp;pg=PP1#v=onepage&amp;q=9780735211759&amp;f=false|title=Broad Band: The Untold Story of the Women Who Made the Internet|last=Evans|first=Claire L.|publisher=Portfolio/Penguin|year=2018|isbn=9780735211759|location=New York|pages=|ref=harv}}

==External links==
{{Sister project links | wikt=software | commons=Special:Search/Software | b= | n= | s= | v=Computer Software | voy= |q=no}}
* {{curlie|Computers/Software}}&lt;!--ref name="github"/--&gt;

{{Software digital distribution platforms|state=collapsed}}
{{Authority control}}
{{Use dmy dates|date=May 2017}}

[[Category:Computer science]]
[[Category:Software| ]]
[[Category:Mathematical and quantitative methods (economics)]]</text>
      <sha1>hjhpsf2aknenrhk7029lykkcybhjyl9</sha1>
    </revision>
  </page>
  <page>
    <title>Hacking</title>
    <ns>0</ns>
    <id>13192</id>
    <revision>
      <id>935002468</id>
      <parentid>934973271</parentid>
      <timestamp>2020-01-09T21:07:57Z</timestamp>
      <contributor>
        <username>Bkonrad</username>
        <id>44062</id>
      </contributor>
      <comment>no terminal punctuation for sentence fragments</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1258" xml:space="preserve">{{pp-semi|small=yes}}
{{wiktionary|hacking}}
'''Hacking''' may refer to:
{{TOC right}}
==Places==
* [[Hacking (Vienna)]], an area within [[Hietzing]], Vienna, Austria
==People==
* [[Ian Hacking]] (born 1936), Canadian philosopher of science

==Sports==
* [[Hacking (falconry)]], the practice of raising falcons in captivity then later releasing into the wild
* [[Hacking (rugby)]], tripping an opposing player
* [[Pleasure riding]], horseback riding for purely recreational purposes, also called hacking
* [[Shin-kicking]], an English martial art also called hacking

==Technology==
* [[Hacker]], a computer expert with advanced technical knowledge
** [[Hacker culture]],  activity within the computer programmer subculture
* [[Security hacker]], someone who breaches defenses in a computer system 
** [[Cybercrime]], which involves security hacking
* [[Phone hacking]], gaining unauthorized access to phones
* [[ROM hacking]], the process of modifying a video game's program image

==Other uses==
* [[Roof and tunnel hacking]], unauthorized exploration of roof and utility tunnel spaces

==See also==
* [[Hack (disambiguation)]]
* [[Hacker (disambiguation)]]
* [[Hacks (disambiguation)]]
* [[List of hacker groups]]
* {{Intitle}}

{{disambiguation|surname}}</text>
      <sha1>53fpkjta1ww3o4ef2tjxiiimhc1k2qk</sha1>
    </revision>
  </page>
  <page>
    <title>Covid-19</title>
    <ns>0</ns>
    <id>63084615</id>
    <redirect title="Coronavirus disease 2019" />
    <revision>
      <id>951479641</id>
      <parentid>948446812</parentid>
      <timestamp>2020-04-17T11:00:37Z</timestamp>
      <contributor>
        <username>1234qwer1234qwer4</username>
        <id>20836525</id>
      </contributor>
      <comment>rcats</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="165" xml:space="preserve">#REDIRECT [[Coronavirus disease 2019]]

{{Redirect category shell|
{{R from acronym}}
{{R avoided double redirect|COVID-19}}
{{R from alternative capitalisation}}
}}</text>
      <sha1>2pltcnyw6m96a47enl0ig226y4v7q8g</sha1>
    </revision>
  </page>
  <page>
    <title>Template:"'</title>
    <ns>10</ns>
    <id>19022529</id>
    <redirect title="Template:Double+single" />
    <revision>
      <id>850485763</id>
      <parentid>810440727</parentid>
      <timestamp>2018-07-16T04:55:43Z</timestamp>
      <contributor>
        <username>EmausBot</username>
        <id>11292982</id>
      </contributor>
      <minor/>
      <comment>Bot: Fixing double redirect to [[Template:Double+single]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="81" xml:space="preserve">#REDIRECT [[Template:Double+single]]

{{Rcat shell|{{R from template shortcut}}}}</text>
      <sha1>3j9mg9nksdetc4kkal0y1j9e644x2lo</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Abbr</title>
    <ns>10</ns>
    <id>2557713</id>
    <revision>
      <id>729977787</id>
      <parentid>717635601</parentid>
      <timestamp>2016-07-15T21:52:51Z</timestamp>
      <contributor>
        <username>Matt Fitzpatrick</username>
        <id>291848</id>
      </contributor>
      <comment>escaping " as &amp;amp;quot; in title attribute per talk page request</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="304" xml:space="preserve">&lt;abbr {{#if:{{{class|}}}|class="{{{class}}}"}} {{#if:{{{id|}}}|id="{{{id}}}"}} {{#if:{{{style|}}}|style="{{{style}}}"}} title="{{#tag:nowiki|{{#invoke:String|replace|{{{2|}}}|"|&amp;quot;}}}}"&gt;{{#switch: {{{3|}}}
  | i | IPA = {{IPA|{{{1|}}}}}
  | {{{1|}}} }}&lt;/abbr&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>lsg55nurv2zqn8xx8h6dxaaqq3y08tu</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ambox</title>
    <ns>10</ns>
    <id>13179742</id>
    <revision>
      <id>948474634</id>
      <parentid>948472450</parentid>
      <timestamp>2020-04-01T06:36:53Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <comment>Undid revision 948472448 by [[Special:Contributions/w&gt;MarcoAurelio|w&gt;MarcoAurelio]] ([[User talk:w&gt;MarcoAurelio|talk]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="220" xml:space="preserve">{{#invoke:Message box|ambox}}{{#ifeq:{{{small}}}|left|[[Category:Articles using small message boxes]]}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>j0j11qao0sl45x6kzzme1ycda7wiz9f</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Anchor</title>
    <ns>10</ns>
    <id>2236346</id>
    <revision>
      <id>629642299</id>
      <parentid>586910254</parentid>
      <timestamp>2014-10-14T23:35:24Z</timestamp>
      <contributor>
        <username>Frietjes</username>
        <id>13791031</id>
      </contributor>
      <comment>add {{{|safesubst:}}} per talk</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="157" xml:space="preserve">{{{{{|safesubst:}}}#invoke:anchor|main}}&lt;noinclude&gt;
{{Documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>cjfgfxc6tpjgpyvzhnbfkngu6u3spzc</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Authority control</title>
    <ns>10</ns>
    <id>23327809</id>
    <revision>
      <id>939135673</id>
      <parentid>917353006</parentid>
      <timestamp>2020-02-04T16:00:19Z</timestamp>
      <contributor>
        <username>Uzume</username>
        <id>51070</id>
      </contributor>
      <comment>Undid revision 917353006 by [[Special:Contributions/Tom.Reding|Tom.Reding]] ([[User talk:Tom.Reding|talk]]); rv when adding support for [[d:Property:P7859]] as per request</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="998" xml:space="preserve">{{#invoke:Authority control|authorityControl}}&lt;noinclude&gt;{{Documentation}}&lt;/noinclude&gt;&lt;includeonly&gt;&lt;!-- tracking categories to compare with Wikidata 
--&gt;{{#switch:{{NAMESPACE}}||{{ns:14}}=&lt;!-- Only articles and categories. 
--&gt;{{#invoke:Check for unknown parameters|check|unknown=[[Category:Pages using authority control with parameters]]|preview=Page using [[Template:Authority control]] with "_VALUE_", please move this to Wikidata if possible}}&lt;!--
--&gt;{{#ifeq:{{{VIAF|}}}|
    |&lt;!-- empty or no VIAF in template --&gt;
    |&lt;!-- VIAF in template 
  --&gt;{{#ifeq:{{#property:P214}}|
      |&lt;!-- no property P214 at Wikidata --&gt; [[Category:VIAF not on Wikidata]] &lt;!-- These we still need to import --&gt;
      |&lt;!-- property P214 at Wikidata    --&gt; 
       {{#ifeq:{{{VIAF|}}}|{{#property:P214}}
        |&lt;!-- same ID: We want to end up here --&gt;
        |[[Category:VIAF different on Wikidata]] &lt;!-- Figure out the best link, FIXME: multiple values on Wikidata --&gt;
       }}
     }}
  }}
}}&lt;/includeonly&gt;</text>
      <sha1>hpf5q0aod8ov7l14auaw059lm34vl92</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Basic computer components</title>
    <ns>10</ns>
    <id>24991697</id>
    <revision>
      <id>925276233</id>
      <parentid>919934853</parentid>
      <timestamp>2019-11-09T00:42:46Z</timestamp>
      <contributor>
        <username>Maestro2016</username>
        <id>27684861</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2145" xml:space="preserve">{{Navbox
|name      = Basic computer components
|title     = Basic [[computer]] [[Computer hardware|components]]
|listclass = hlist
|state     = {{{state|autocollapse}}}

|group1 = [[Input device]]s
|list1  =
*[[Computer keyboard|Keyboard]]
*[[Image scanner]]
*[[Microphone]]
*[[Pointing device]]
**[[Graphics tablet]]
**[[Game controller]]
**[[Light pen]]
**[[Computer mouse|Mouse]]
***[[Optical mouse|Optical]]
**[[Pointing stick]]
**[[Touchpad]]
**[[Touchscreen]]
**[[Trackball]]
*[[Refreshable braille display]]
*[[Sound card]]
**[[Sound chip]]
*[[Webcam]]
**[[Softcam]]
*[[Video card]]
**[[Graphics processing unit|GPU]]

|group2 = [[Output device]]s
|list2  = 
*[[Computer monitor|Monitor]]
**[[Electronic visual display|Screen]]
*[[Refreshable braille display]]
*[[Printer (computing)|Printer]]
**[[Plotter]]
*[[Computer speakers|Speakers]]
*[[Sound card]]
*[[Video card]]

|group3 = [[Removable media|Removable &lt;br/&gt; data storage]]
|list3  = 
*[[Disk pack]]
*[[Floppy disk]]
*[[Optical disc]]
**[[Compact disc|CD]]
**[[DVD]]
**[[Blu-ray]]
*[[Flash memory]]
**[[Memory card]]
**[[USB flash drive]]

|group4 = [[Computer case]]
|list4  = 
*[[Central processing unit]]
**[[Microprocessor]]
*[[Motherboard]]
*[[Computer memory|Memory]]
**[[Random-access memory|RAM]]
**[[Nonvolatile BIOS memory|BIOS]]
*[[Computer data storage|Data storage]]
**[[Hard disk drive|HDD]]
**[[Solid-state drive|SSD]]
**[[Solid-state hybrid drive|SSHD]]
*[[Power supply unit (computer)|Power supply]]
**[[Switched-mode power supply|SMPS]]
*[[MOSFET]]
**[[Power MOSFET]]
**[[Voltage regulator module|VRM]]
*[[Network interface controller]]
*[[Fax modem]]
*[[Expansion card]]

|group5 = [[Computer port (hardware)|Ports]]
|list5  = 
*[[Ethernet]]
*[[IEEE 1394|FireWire]] (IEEE 1394)
*[[Parallel port]]
*[[Serial port]]
*[[PS/2 port]]
*[[USB]]
*[[Thunderbolt_(interface)|Thunderbolt]]
*[[DisplayPort]] / [[HDMI]] / [[Digital_Visual_Interface|DVI]] / [[VGA_connector|VGA]]
*[[Serial_ATA#eSATA|eSATA]]
*[[Phone connector (audio)|Audio jack]]
}}&lt;noinclude&gt;{{Documentation |content={{Collapsible option}}}}

[[Category:Computer hardware navigational boxes]]
&lt;/noinclude&gt;</text>
      <sha1>1ypmbfndq5moicuk0f7bqdtohzveoa9</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Category handler</title>
    <ns>10</ns>
    <id>25084818</id>
    <revision>
      <id>874046584</id>
      <parentid>577959188</parentid>
      <timestamp>2018-12-16T20:13:00Z</timestamp>
      <contributor>
        <username>Amorymeltzer</username>
        <id>141948</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Category handler]]": [[WP:High-risk templates|Highly visible template]] ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="148" xml:space="preserve">{{#invoke:Category handler|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories to the /doc subpage, and interwikis to Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>og6fhyj2ssd4fmzpqzuodk12q3cms0z</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Circa</title>
    <ns>10</ns>
    <id>14421092</id>
    <revision>
      <id>925245088</id>
      <parentid>888920960</parentid>
      <timestamp>2019-11-08T20:11:50Z</timestamp>
      <contributor>
        <username>Neveselbert</username>
        <id>25820411</id>
      </contributor>
      <minor/>
      <comment>Span title</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="739" xml:space="preserve">{{#if:{{{sortable|}}}
 |&lt;span style="display:none; speak:none;"&gt;{{padleft:{{{1|}}}|4|0}}&amp;nbsp;&lt;/span&gt;
}}{{#if:{{{i|}}}
 |&lt;nowiki/&gt;''
}}{{#switch:{{{lk|}}}
 |no|off   = &lt;span title="circa"&gt;c.&lt;/span&gt;
 |yes|on   = [[Circa|c.]]
 |abbr
 |#default = {{Abbr|c.|circa}}
}}{{#if:{{{i|}}}
 |''&lt;nowiki/&gt;
}}{{#if:{{{1|}}}
 |&lt;span style="white-space:nowrap;"&gt;&amp;thinsp;{{{1}}}&lt;/span&gt;
}}{{#if:{{{2|}}}
 |&amp;nbsp;– c.&lt;span style="white-space:nowrap;"&gt;&amp;thinsp;{{{2}}}&lt;/span&gt;
}}&lt;noinclude&gt;&lt;!--
--------------------------------------------
HISTORY:
25Nov2007 Created to format/link "c." years.
10Sep2009 Add new parameter "sortable=yes".
07Apr2016 Pad sortkey+"0" for years &lt;1000.
07Apr2016 Set sortable=y span "speak:none".
--&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>mk898c8cxueg0acbzojn7xk3zf0qxlc</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Citation</title>
    <ns>10</ns>
    <id>3164016</id>
    <revision>
      <id>895815361</id>
      <parentid>895803258</parentid>
      <timestamp>2019-05-06T17:38:52Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>per [[Wikipedia:Templates for discussion/Log/2019 April 18#separate patent cites from Template:Citation‎|TfD]];</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="127" xml:space="preserve">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=citation
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>c5vwsrpqyl5vzwjnrpazsisamya1wve</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Citation/make link</title>
    <ns>10</ns>
    <id>29897504</id>
    <revision>
      <id>690395470</id>
      <parentid>579832459</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Citation/make link: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrator...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="535" xml:space="preserve">{{#if:{{{1|}}}
 |[{{{1}}} {{{2}}}]
 |{{{2}}}
}}&lt;noinclude&gt;&lt;!--
  Code notes (here so that people /read/ it)
  1. Parameter #2 is always nonempty when called from {{Citation/core}}.
  2. It's up to {{Citation/core}} to stop italicized "'foo' &amp; 'bar'" from becoming
     "'''foo' &amp; 'bar'''". Citation/core does this by having a &lt;nowiki&gt;&lt;/nowiki&gt;
     at both beginning and end of the call to this template. Since this is only
     needed once, it's more efficient to do it in {{Citation/core}} than here.
--&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>kpq1iofpfn0fdo5bshpu1vjve3ehx2d</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Citation needed</title>
    <ns>10</ns>
    <id>2048472</id>
    <revision>
      <id>896877408</id>
      <parentid>896877270</parentid>
      <timestamp>2019-05-13T12:18:57Z</timestamp>
      <contributor>
        <username>MSGJ</username>
        <id>42630</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Citation needed]]": my mistake, meant to be on [[Template:Citation required]] ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="515" xml:space="preserve">{{ {{{|safesubst:}}}#invoke:Unsubst||date=__DATE__ |$B=
{{Fix
|name={{{name|Citation needed}}}
|link=Wikipedia:Citation needed
|text=citation needed
|class=Template-Fact
|title={{{reason|This claim needs references to reliable sources.}}}
|date={{{date|}}}
|cat=[[Category:All articles with unsourced statements]]
|cat-date=Category:Articles with unsourced statements
}}{{#if:{{{1|}}}|[[Category:Pages containing citation needed template with deprecated parameters]]}}
}}&lt;noinclude&gt;

{{Documentation}}

&lt;/noinclude&gt;</text>
      <sha1>gacd4ag6cry31kvoa6np8uzxo7bq89z</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite book</title>
    <ns>10</ns>
    <id>4086375</id>
    <revision>
      <id>810449908</id>
      <parentid>810433573</parentid>
      <timestamp>2017-11-15T09:11:45Z</timestamp>
      <contributor>
        <username>Salix alba</username>
        <id>212526</id>
      </contributor>
      <comment>put TD in a collapse top / bottom section</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="200" xml:space="preserve">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=book
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
{{collapse top|TemplateData}}
{{Cite book/TemplateData}}
{{collapse bottom}}
&lt;/noinclude&gt;</text>
      <sha1>my4yy07itdv4e2t5sc1x4l3pzgpmzo7</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite journal</title>
    <ns>10</ns>
    <id>4740319</id>
    <revision>
      <id>690395473</id>
      <parentid>579832342</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite journal: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrators] (in...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="126" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Citation/CS1|citation
|CitationClass=journal
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>9fcytsszanq7xbwi3p28zsneear9938</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite news</title>
    <ns>10</ns>
    <id>4321630</id>
    <revision>
      <id>828626614</id>
      <parentid>828404709</parentid>
      <timestamp>2018-03-03T19:19:37Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <comment>Per edit request on [[Help talk:Citation Style 1]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="123" xml:space="preserve">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=news
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>pbjnspfej5gxihr9izxrzkow3f1uf3i</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite patent</title>
    <ns>10</ns>
    <id>10073712</id>
    <revision>
      <id>895814320</id>
      <parentid>827250615</parentid>
      <timestamp>2019-05-06T17:31:53Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>per [[Wikipedia:Templates for discussion/Log/2019 April 18#separate patent cites from Template:Citation‎|TfD]];</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2100" xml:space="preserve">&lt;includeonly&gt;{{cite patent/core
 |Surname1 = {{#if:{{{inventor|}}}|{{{inventor}}}|{{{inventor-surname|{{{inventor1-surname|{{{inventor-last|{{{inventor1-last|{{{inventor-last1|{{{invent-1|{{{invent1|}}}}}}}}}}}}}}}}}}}}} }}
 |Surname2={{{inventor2-surname|{{{inventor2-last|{{{inventor-last2|{{{inventor2|{{{invent2|}}}}}}}}}}}}}}}
 |Surname3={{{inventor3-surname|{{{inventor3-last|{{{inventor-last3|{{{inventor3|{{{invent3|}}}}}}}}}}}}}}}
 |Surname4={{{inventor4-surname|{{{inventor4-last|{{{inventor-last4|{{{inventor4|{{{invent4|}}}}}}}}}}}}}}}
 |Given1 = {{{inventor-given|{{{inventor1-given|{{{inventor-first|{{{inventor1-first|{{{inventor-first1|}}}}}}}}}}}}}}}
 |Given2={{{inventor2-given|{{{inventor2-first|{{{inventor-first2|}}}}}}}}}
 |Given3={{{inventor3-given|{{{inventor3-first|{{{inventor-first3|}}}}}}}}}
 |Given4={{{inventor4-given|{{{inventor4-first|{{{inventor-first4|}}}}}}}}}
 |Inventorlink1={{{inventor1-link|{{{inventor-link1|{{{inventorlink1|{{{inventor-link|{{{inventorlink|}}}}}}}}}}}}}}}
 |Inventorlink2={{{inventor2-link|{{{inventor-link2|{{{inventorlink2|}}}}}}}}}
 |Inventorlink3={{{inventor3-link|{{{inventor-link3|{{{inventorlink3|}}}}}}}}}
 |Inventorlink4={{{inventor4-link|{{{inventor-link4|{{{inventorlink4|}}}}}}}}}
 |Title={{{title|}}}
 |CountryCode={{{country-code|{{{country|{{{1|}}}}}}}}}
 |PublicationNumber={{{publication-number|{{{patent-number|{{{number|{{{2|}}}}}}}}}}}}
 |Description={{{description|{{{status|{{{3|}}}}}}}}}
 |PublicationDate={{{publication-date|{{{pubdate|}}}}}}
 |IssueDate={{{issue-date|{{{gdate|}}}}}}
 |Year={{{year}}} 
 |FilingDate={{{fdate|}}}
 |PriorityDate={{{pridate|}}}
 |Assignee1={{{assign1|{{{assignee|{{{assign|}}}}}}}}}
 |Assignee2={{{assign2|}}}
  |Ref={{{ref|harv}}}
  |Sep = {{#ifeq:{{{separator|{{{seperator}}}}}}|;|&amp;#059;|{{{separator|{{{seperator|,}}}}}}}}
  |PS = {{#if:{{{quote|}}}||{{{postscript|}}}|.}}
  |AuthorSep = {{#ifeq:{{{author-separator|}}}|;|&amp;#059;|{{{author-separator|&amp;#059;}}}}}&amp;#32;
 |URL{{#if:{{{URL|{{{url|}}}}}}||NULL}}={{{URL|{{{url|}}}}}}
}}&lt;/includeonly&gt;&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>rd9ss7znksuqzjn3qvwh0gd9y642ljg</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite patent/core</title>
    <ns>10</ns>
    <id>9231947</id>
    <revision>
      <id>895973115</id>
      <parentid>895814674</parentid>
      <timestamp>2019-05-07T16:50:44Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <minor/>
      <comment>documentation;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2477" xml:space="preserve">&lt;span class="citation patent" {{#ifeq: {{{Ref|}}}|harv|{{#if:{{{Surname1|}}}{{{EditorSurname1|}}}
|id="CITEREF{{anchorencode:{{#if:{{{Surname1|}}}
|{{{Surname1}}}{{{Surname2|}}}{{{Surname3|}}}{{{Surname4|}}}
|{{{EditorSurname1|}}}{{{EditorSurname2|}}}{{{EditorSurname3|}}}{{{EditorSurname4|}}}
}}{{#time:Y|{{{IssueDate|{{{PublicationDate|}}}}}}}}}}"
}}
|{{#if:{{{Ref|}}}|id="{{anchorencode:{{{Ref|}}}}}"}}
}}&gt;{{citation/make_link
  | 1={{{URL|{{{url|https://worldwide.espacenet.com/textdoc?DB=EPODOC&amp;IDX={{{CountryCode}}}{{{PublicationNumber}}}}}}}}}
  | 2={{{CountryCode}}}{{
        #if: {{{Description|}}}
        |&amp;#32;{{{Description}}}
      }} {{{PublicationNumber}}}
}}{{#if:{{{Surname1|}}}|{{{Sep|,}}}&amp;#32;{{cite patent/authors
  | Surname1 = {{{Surname1}}}
  | Given1 = {{{Given1|}}}
  | Authorlink1 = {{{Inventorlink1|}}}
  | Surname2 = {{{Surname2|}}}
  | Given2 = {{{Given2|}}}
  | Authorlink2 = {{{Inventorlink2|}}}
  | Surname3 = {{{Surname3|}}}
  | Given3 = {{{Given3|}}}
  | Authorlink3 = {{{Inventorlink3|}}}
  | Surname4 = {{{Surname4|}}}
  | Given4 = {{{Given4|}}}
  | Authorlink4 = {{{Inventorlink4|}}}
}}}}{{
 #if: {{{Title|}}}
 |{{{Sep|,}}}&amp;#32;"{{{Title}}}"
}}{{
  #if: {{{PublicationDate|}}}
  |{{{Sep|,}}}&amp;#32;published {{{PublicationDate}}}
}}{{
  #if: {{{IssueDate|}}}
  |{{{Sep|,}}}&amp;#32;issued {{{IssueDate}}}
}}{{
  #if: {{{Assignee1|}}}
  |{{{Sep|,}}}&amp;#32; assigned to {{{Assignee1}}}
}}{{
  #if: {{{Assignee2|}}}
  | &amp;#32;and {{{Assignee2}}}
}}{{{PS|}}}&lt;/span&gt;&lt;!--

=== This is a COinS tag (http://ocoins.info), which allows automated tools to parse the citation information: ===

--&gt;&lt;span class="Z3988" title="ctx_ver=Z39.88-2004&lt;!--
--&gt;&amp;rft_val_fmt={{urlencode:info:ofi/fmt:kev:mtx:patent}}&lt;!--
--&gt;{{#ifeq: {{{Description|}}}|application
|&amp;rft.applnumber={{{PublicationNumber}}}&lt;!--
--&gt; |&amp;rft.number={{{PublicationNumber}}}}}&lt;!--
--&gt;&amp;rft.cc={{{CountryCode}}}&lt;!--
--&gt;&amp;rft.title={{urlencode:{{{Title}}}}}&lt;!--
--&gt;{{#if: {{{Surname1|}}} | &amp;rft.inventor={{urlencode:{{{Surname1}}}}} }}&lt;!--
--&gt;{{#if: {{{Assignee1|}}} | &amp;rft.assignee={{urlencode:{{{Assignee1}}}}} }}&lt;!--
--&gt;{{#if: {{{IssueDate|}}} | &amp;rft.date={{{IssueDate}}} }}&lt;!--
--&gt;{{#if: {{{FilingDate|}}} | &amp;rft.appldate={{{FilingDate}}} }}&lt;!--
--&gt;{{#if: {{{PublicationDate|}}} | &amp;rft.pubdate={{{PublicationDate}}} }}&lt;!--
--&gt;{{#if: {{{PriorityDate|}}} | &amp;rft.prioritydate={{{PriorityDate}}} }}&lt;!--
--&gt;"&gt;&lt;span style="display: none;"&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>nwqa3nctcwozeyki1jrx80w6ix5qp3w</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite thesis</title>
    <ns>10</ns>
    <id>24979476</id>
    <revision>
      <id>827245141</id>
      <parentid>580884246</parentid>
      <timestamp>2018-02-23T16:29:42Z</timestamp>
      <contributor>
        <username>Primefac</username>
        <id>11508456</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Cite thesis]]": [[WP:HIGHRISK|high-risk]] template with 4000+ transclusions ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="125" xml:space="preserve">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=thesis
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>56y1ni1s4cj23abrdeq1wiazsceexao</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite web</title>
    <ns>10</ns>
    <id>1252907</id>
    <revision>
      <id>753103437</id>
      <parentid>753063659</parentid>
      <timestamp>2016-12-05T05:36:52Z</timestamp>
      <contributor>
        <username>Anthony Appleyard</username>
        <id>119438</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Cite web]]": restore old protection ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="122" xml:space="preserve">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=web
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>rcgmbcxu7hvs583g1f3rzz4c4dkizda</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Clear</title>
    <ns>10</ns>
    <id>1239772</id>
    <revision>
      <id>684162145</id>
      <parentid>683948339</parentid>
      <timestamp>2015-10-04T23:53:36Z</timestamp>
      <contributor>
        <username>Nyttend</username>
        <id>1960810</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Clear: Enable access by template editors; NeilN is okay with this move ([Edit=Allow only template editors and admins] (indefinite) [Move=Allow only template editors and admins] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="81" xml:space="preserve">&lt;div style="clear:{{{1|both}}};"&gt;&lt;/div&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>6mk3e4afot6hzu6tzbljxxk83e14xv6</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Column-width</title>
    <ns>10</ns>
    <id>29216399</id>
    <revision>
      <id>638540885</id>
      <parentid>579832996</parentid>
      <timestamp>2014-12-17T20:09:33Z</timestamp>
      <contributor>
        <username>Edokter</username>
        <id>1624037</id>
      </contributor>
      <minor/>
      <comment>redundant</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="165" xml:space="preserve">&lt;includeonly&gt;-moz-column-width: {{{1|30em}}}; -webkit-column-width: {{{1|30em}}}; column-width: {{{1|30em}}};&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>sum88q311kc02222mb4cgzbikcx7fqy</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Commons category-inline</title>
    <ns>10</ns>
    <id>8221998</id>
    <revision>
      <id>951137354</id>
      <parentid>950302988</parentid>
      <timestamp>2020-04-15T17:51:15Z</timestamp>
      <contributor>
        <username>Mike Peel</username>
        <id>214232</id>
      </contributor>
      <comment>tweak tracking category logic</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2461" xml:space="preserve">{{sister-inline
| short={{{short|}}}
| project=commonscat
| list={{{list|}}}
| extratext={{{extratext|}}}
| links=[[commons:&lt;!--
 Check for a locally-specified category
 --&gt;{{#if:{{{1|}}} | Category:{{{1|}}} &lt;!--
  ... or use Wikidata
  --&gt;|{{if then show|{{#invoke:WikidataIB |getCommonsLink|qid={{{qid|}}}|onlycat=True}}&lt;!--
  ... or fall back to the page name
  --&gt; |Category:{{PAGENAME}}}}}}&lt;!--
   Now define the display title
  --&gt;|&lt;span style="{{#ifeq:{{{nowrap|no}}}|yes|white-space:nowrap;}} {{#ifeq:{{{italic|no}}}|yes|font-style: italic; }}"&gt;{{#ifeq:{{{lcf|{{{lcfirst|no}}}}}}|yes|{{lcfirst:{{{2|{{#if:{{{1|}}} | {{{1|}}} &lt;!--
  --&gt;|{{if then show|{{#invoke:String|replace|{{#invoke:WikidataIB |getCommonsLink|qid={{{qid|}}}|onlycat=True}}|Category:|}}&lt;!--
  --&gt; |{{PAGENAME}} }} }} }}} }}&lt;!--
  --&gt;|{{{2|{{#if:{{{1|}}} | {{{1|}}} &lt;!--
  --&gt;|{{if then show|{{#invoke:String|replace|{{#invoke:WikidataIB |getCommonsLink|qid={{{qid|}}}|onlycat=True}}|Category:|}}&lt;!--
  --&gt; |{{PAGENAME}} }} }} }}}
}}&lt;/span&gt;]]
}}&lt;!--

 End of the template code, now add relevant tracking categories

--&gt;&lt;includeonly&gt;{{#switch:{{NAMESPACE}}||{{ns:14}}=&lt;!--
 Only add tracking categories to articles and categories.
 --&gt;{{#if:{{{1|}}}|{{#ifeq:Category:{{replace|{{{1|}}}|_|&amp;#32;}}|{{#invoke:WikidataIB |getCommonsLink|qid={{{qid|}}}|onlycat=True|fallback=False}}|&lt;!--
   --&gt;[[Category:Commons category link is on Wikidata]]&lt;!--

   --&gt;|{{#ifeq:{{replace|{{{1|}}}|_|&amp;#32;}}|{{PAGENAME}}|&lt;!--
   ... the local parameter is the same as the local pagename, but not the same as on Wikidata
   --&gt;[[Category:Commons category link is defined as the pagename]]&lt;!--

   ... the local parameter does not match either of these
   --&gt;|[[Category:Commons category link is locally defined]]}} }}&lt;!--

  We don't have a locally-defined link 
  --&gt;|{{#if:{{#invoke:WikidataIB |getCommonsLink|qid={{{qid|}}}|onlycat=True|fallback=False}}|&lt;!--

   ... so we're using Wikidata
   --&gt;[[Category:Commons category link from Wikidata]]&lt;!--

    &lt;!-- ... or we're using P373
    --&gt;|{{#ifeq:{{#invoke:WikidataIB |getCommonsLink |qid={{{qid|}}}|onlycat=True|fallback=True}}|{{#invoke:WikidataIB |getCommonsLink |qid={{{qid|}}}|onlycat=True|fallback=False}}|[[Category:Commons category link is the pagename]]|[[Category:Commons category link is on Wikidata using P373]]}}
  }}
  }}
  }}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;!-- Add categories to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>1zxbnv2fckzz0ota09s1vl6o3br6x38</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Commonscatinline</title>
    <ns>10</ns>
    <id>26612821</id>
    <redirect title="Template:Commons category-inline" />
    <revision>
      <id>827250634</id>
      <parentid>804533711</parentid>
      <timestamp>2018-02-23T17:02:12Z</timestamp>
      <contributor>
        <username>Primefac</username>
        <id>11508456</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Commonscatinline]]": [[WP:HIGHRISK|high-risk]] template with 2000+ transclusions ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="46" xml:space="preserve">#REDIRECT [[Template:Commons category-inline]]</text>
      <sha1>m30d5qm0jlu9c6t6rvxw9n6os6b0rzr</sha1>
    </revision>
  </page>
  <page>
    <title>Template:DMCA</title>
    <ns>10</ns>
    <id>23226218</id>
    <revision>
      <id>774491639</id>
      <parentid>296800547</parentid>
      <timestamp>2017-04-08T20:40:50Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:DMCA]]": [[WP:High-risk templates|Highly visible template]]: Allowing template editors ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="197" xml:space="preserve">{{Dated maintenance category
 |onlyarticles=yes
 |1={{{1|}}}
 |2={{{2|}}}
 |3={{{3|}}}
 |4={{{4|}}}
 |5={{{5|}}}
}}&lt;noinclude&gt;
{{documentation|Template:Dated maintenance category/doc}}
&lt;/noinclude&gt;</text>
      <sha1>cl1tba6o83bu6hpmnvwvbcse6qwofoo</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Dated maintenance category</title>
    <ns>10</ns>
    <id>22598546</id>
    <revision>
      <id>589732290</id>
      <parentid>584337311</parentid>
      <timestamp>2014-01-08T08:14:55Z</timestamp>
      <contributor>
        <username>John of Reading</username>
        <id>11308236</id>
      </contributor>
      <comment>Second attempt. Those spaces upset inline templates such as {{As of}}. Instead, try an unconditional &lt;nowiki/&gt;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="660" xml:space="preserve">&lt;nowiki/&gt;&lt;!--This nowiki helps to prevent whitespace at the top of articles--&gt;{{#ifeq:{{FULLROOTPAGENAME}}|Wikipedia:Template messages|&lt;!--Do not categorize--&gt;|&lt;!--
--&gt;{{#ifexpr:{{#if:{{NAMESPACE}}|0|1}}+{{#ifeq:{{{onlyarticles|no}}}|yes|0|1}}
 |{{#if:{{{3|}}}
  |[[Category:{{{1}}} {{{2}}} {{{3}}}]]&lt;!--
--&gt;{{#ifexist:Category:{{{1}}} {{{2}}} {{{3}}}
    |&lt;!--
 --&gt;|[[Category:Articles with invalid date parameter in template]]&lt;!--
--&gt;}}
  |[[Category:{{#if:{{{5|}}}
               |{{{5}}}&lt;!--
            --&gt;|{{{1}}}&lt;!--
           --&gt;}}]]&lt;!--
--&gt;}}{{#if:{{{4|}}}
      |[[Category:{{{4}}}]]}}&lt;!--
  --&gt;}}&lt;!--
--&gt;}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>7p59j4cq4i8wg65odpv5287yu50sczo</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Delink</title>
    <ns>10</ns>
    <id>28069338</id>
    <revision>
      <id>696877808</id>
      <parentid>695173639</parentid>
      <timestamp>2015-12-26T16:26:10Z</timestamp>
      <contributor>
        <username>Frietjes</username>
        <id>13791031</id>
      </contributor>
      <comment>{{documentation}} does this</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="179" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:delink|delink}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>nxxwkb2lon9wgne4irg9ctbsle6zwiy</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Digital electronics</title>
    <ns>10</ns>
    <id>8253419</id>
    <revision>
      <id>934600039</id>
      <parentid>928144560</parentid>
      <timestamp>2020-01-07T12:43:17Z</timestamp>
      <contributor>
        <username>DexDor</username>
        <id>11025703</id>
      </contributor>
      <comment>Undid revision 928144560 by [[Special:Contributions/Chongkian|Chongkian]] ([[User talk:Chongkian|talk]]) [[WP:CAT#T]] etc</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1738" xml:space="preserve">{{Navbox
 | name = Digital electronics
 | title = [[Digital electronics]]
 | state = {{{state|}}}
 | listclass = hlist
 | groupstyle = text-align:center;

 | group1 = [[Electronic component|Components]]
 | list1 =
* [[Combinational logic]]
* [[Sequential logic]]
* [[Integrated circuit]] (IC)
* [[Logic gate]]

 | group2 = Theory
 | list2 =
* [[Digital signal]]
* [[Boolean algebra]]
* [[Logic synthesis]]
* [[Logic in computer science]]
* [[Computer architecture]]
* [[Digital signal (signal processing)|Digital signal]]
** [[Digital signal processing]]
* [[Circuit minimization for Boolean functions|Circuit minimization]]
* [[Switching circuit theory]]

 | group3 = [[Electronics design|Design]]
 | list3 =
* [[Logic synthesis]]
* [[Place and route]]
** [[Placement (electronic design automation)|Placement]]
** [[Routing (electronic design automation)|Routing]]
* [[Register-transfer level]]
** [[Hardware description language]]
** [[High-level synthesis]]
* [[Formal equivalence checking]]
* [[Synchronous circuit|Synchronous logic]]
* [[Asynchronous circuit|Asynchronous logic]]
* [[Finite-state machine]]
** [[Hierarchical state machine]]

 | group4 = Applications
 | list4 =
* [[Computer hardware]]
** [[Hardware acceleration]]
* [[Digital audio]]
** [[Digital radio|radio]]
* [[Digital photography]]
* [[Telephony#Digital_telephony|Digital telephone]]
* [[Digital video]]
** [[Digital cinema|cinema]]
** [[Digital television|television]]
* [[Electronic literature]]

 | group5 = Design issues
 | list5 =
* [[Metastability (electronics)|Metastability]]
* [[Runt pulse]]

}}&lt;noinclude&gt;
{{documentation|content=
{{collapsible option}}

===See also===
*{{tl|Electronic components}}

[[Category:Electronics templates]]
}}
&lt;/noinclude&gt;</text>
      <sha1>sujxzx8p7el1hkv9rcaeorgoh7zrf50</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Digital systems</title>
    <ns>10</ns>
    <id>47886918</id>
    <redirect title="Template:Digital electronics" />
    <revision>
      <id>682043193</id>
      <timestamp>2015-09-21T04:55:02Z</timestamp>
      <contributor>
        <username>Kvng</username>
        <id>910180</id>
      </contributor>
      <comment>Kvng moved page [[Template:Digital systems]] to [[Template:Digital electronics]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="58" xml:space="preserve">#REDIRECT [[Template:Digital electronics]]
{{R from move}}</text>
      <sha1>d3pc6ujbjilv52eeuvas7jdp4fgzhtm</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Div col</title>
    <ns>10</ns>
    <id>12679552</id>
    <revision>
      <id>898405122</id>
      <parentid>851876773</parentid>
      <timestamp>2019-05-23T10:37:27Z</timestamp>
      <contributor>
        <username>Jonesey95</username>
        <id>9755426</id>
      </contributor>
      <comment>Move closing div to separate line to prevent strange list formatting. See https://en.wikipedia.org/w/index.php?title=Template_talk:Navbox&amp;curid=12839040&amp;diff=898399557&amp;oldid=898394285</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="961" xml:space="preserve">&lt;includeonly&gt;&lt;div class="div-col columns column-width" style="{{column-width|{{{colwidth|30em}}}}} &lt;!--
 --&gt;{{#if: {{{gap|}}}
    | {{column-gap|{{{gap}}}}} }}&lt;!--
 --&gt;{{#switch: {{{rules|}}}
    | = &lt;!--empty--&gt;
    | yes = {{column-rule}}
    | {{Column-rule|{{{rules}}}}} }} &lt;!--
 --&gt;{{#ifeq: {{{small|}}}|yes
    | font-size:90%; }} &lt;!--
 --&gt;{{#if: {{{style|}}}
    | {{{style}}} }}"&gt;&lt;!--
 --&gt;{{#if: {{{content|}}}
    |{{{content}}}
&lt;/div&gt;}}&lt;!-- Inventory how many pages use small=yes 
 --&gt;{{#ifeq: {{{small|}}}|yes
    |[[Category:Pages using div col with small parameter]]}}&lt;/includeonly&gt;{{#invoke:Check for unknown parameters|check|unknown={{main other|[[Category:Pages using div col with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Div col]] with unknown parameter "_VALUE_"; use colwidth= to specify column size |ignoreblank=y | colwidth | content | gap | rules | small | style }}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>9i3dvd2ka83rtdcvu2c26h28yeutjov</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Div col end</title>
    <ns>10</ns>
    <id>12679680</id>
    <revision>
      <id>683947856</id>
      <parentid>627002509</parentid>
      <timestamp>2015-10-03T15:58:07Z</timestamp>
      <contributor>
        <username>NeilN</username>
        <id>409043</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Div col end: per request at [[WP:RFPP]] ([Edit=Allow only template editors and admins] (indefinite) [Move=Allow only template editors and admins] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="96" xml:space="preserve">&lt;includeonly&gt;&lt;/div&gt;&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation|Template:Div col/doc}}
&lt;/noinclude&gt;</text>
      <sha1>e0rj08wj8gm7na2mxp8t9b3l4y8kspb</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Double+single</title>
    <ns>10</ns>
    <id>19021917</id>
    <revision>
      <id>872298762</id>
      <parentid>872211276</parentid>
      <timestamp>2018-12-06T13:53:32Z</timestamp>
      <contributor>
        <username>Courcelles</username>
        <id>1004750</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Double+single]]": [[WP:High-risk templates|Highly visible template]] ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="145" xml:space="preserve">&lt;span style="padding-right:.15em;"&gt;"&lt;/span&gt;'&lt;noinclude&gt;

{{Documentation}}
&lt;!--Add interwikis and categories to the /doc subpage.--&gt;
&lt;/noinclude&gt;</text>
      <sha1>aid5um3m25qayatcap1inrnh9hspejx</sha1>
    </revision>
  </page>
  <page>
    <title>Template:EditAtWikidata</title>
    <ns>10</ns>
    <id>51464314</id>
    <revision>
      <id>915182280</id>
      <parentid>907415032</parentid>
      <timestamp>2019-09-11T18:15:13Z</timestamp>
      <contributor>
        <username>WOSlinker</username>
        <id>3138265</id>
      </contributor>
      <comment>add nbsp param</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="142" xml:space="preserve">{{#invoke:EditAtWikidata |showMessage |qid={{{qid|}}} |pid={{{pid|}}} |nbsp={{{nbsp|}}} |{{{1|}}} }}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>k3dnbwgfi8ka45sgpcor4r8i5d2lmjb</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Electronic systems</title>
    <ns>10</ns>
    <id>38684594</id>
    <revision>
      <id>946784310</id>
      <parentid>887792317</parentid>
      <timestamp>2020-03-22T11:37:20Z</timestamp>
      <contributor>
        <username>Certes</username>
        <id>5984052</id>
      </contributor>
      <minor/>
      <comment>Disambiguated: [[Water heater]] → [[Tankless water heater]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1931" xml:space="preserve">{{Navbox
|name       = Electronic systems
|title      = [[Electronics]]
|listclass = hlist

|group1     = Branches
|list1      =
* [[Analog electronics]]
* [[Digital electronics]]
* [[Electronic instrumentation]]
* [[Electronics engineering]] 
* [[Microelectronics]]
* [[Optoelectronics]]
* [[Power electronics]]
* [[Printed electronics]]
* [[Semiconductor]] 
* [[Schematic capture]]
* [[Thermal management of electronic devices and systems|Thermal management]]

|group2     = Advanced topics
|list2      =
* [[Atomtronics]]
* [[Bioelectronics]]
* [[Failure modes of electronics]]
* [[Flexible electronics]]
* [[Low-power electronics]]
* [[Molecular electronics]]
* [[Nanoelectronics]]
* [[Organic electronics]]
* [[Photonics]]
* [[Piezotronics]]
* [[Quantum electronics]]
* [[Spintronics]]

|group3     = Electronic equipment
|list3      =
* [[Air conditioner]]
* [[Central heating]]
* [[Clothes dryer]]
* [[Computer]]/[[Notebook]]
* [[Dishwasher]]
* [[Freezer]]
* [[Home robot]]
* [[Home cinema]]
* [[Home theater PC]]
* [[Information technologies]]
* [[Kitchen stove|Cooker]]
* [[Microwave oven]]
* [[Refrigerator]]
* [[Robotic vacuum cleaner]]
* [[Tablet computer|Tablet]]
* [[Telephone]]
* [[Television]]
* [[Tankless water heater|Water heater]]
* [[Washing machine]]

|group4     = Applications
|list4      =
* [[Audio electronics]]
* [[Automotive electronics]]
* [[Avionics]]
* [[Control Systems]]
* [[Consumer electronics]]
* [[Data acquisition]]
* [[E-health]]
* [[Electronic book]]
* [[Electronics industry]]
* [[Electronic warfare]]
* [[Embedded systems]]
* [[Home automation]]
* [[Integrated circuit]]
* [[Marine electronics]]
* [[Microwave]] technology
* [[Military]] electronics
* [[Multimedia]]
* [[Nuclear electronics]]
* [[Open hardware]]
* [[Radar]] and [[Radionavigation]]
* [[Radio electronics]]
* [[Terahertz radiation|Terahertz technology]]
* [[Video hardware]]
* [[Wire]]d and [[Wireless]] Communications

}}</text>
      <sha1>k3kmgt0iu1xz8kgaxug5880miynulae</sha1>
    </revision>
  </page>
  <page>
    <title>Template:FULLROOTPAGENAME</title>
    <ns>10</ns>
    <id>34701984</id>
    <revision>
      <id>774489771</id>
      <parentid>476439833</parentid>
      <timestamp>2017-04-08T20:24:42Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:FULLROOTPAGENAME]]": [[WP:High-risk templates|Highly visible template]]: Allowing template editors ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="420" xml:space="preserve">{{ {{{|safesubst:}}}#if: {{ {{{|safesubst:}}}Ns has subpages | {{ {{{|safesubst:}}}#if:{{{1|}}}|{{ {{{|safesubst:}}}NAMESPACE:{{{1}}}}}|{{ {{{|safesubst:}}}NAMESPACE}}}} }} 
  | {{ {{{|safesubst:}}}#titleparts:{{ {{{|safesubst:}}}#if:{{{1|}}}|{{{1}}}|{{ {{{|safesubst:}}}FULLPAGENAME}}}}|1}}
  | {{ {{{|safesubst:}}}#if:{{{1|}}}|{{{1}}}|{{ {{{|safesubst:}}}FULLPAGENAME}}}}
}}&lt;noinclude&gt;

{{documentation}}

&lt;/noinclude&gt;</text>
      <sha1>t4jn967jlk6ph7qu71w2b8f5083yjrl</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Find sources mainspace</title>
    <ns>10</ns>
    <id>43983930</id>
    <revision>
      <id>781356043</id>
      <parentid>781355927</parentid>
      <timestamp>2017-05-20T18:49:40Z</timestamp>
      <contributor>
        <username>Plastikspork</username>
        <id>5075409</id>
      </contributor>
      <comment>Fix</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="127" xml:space="preserve">{{#invoke:Find sources|Find sources mainspace}}&lt;noinclude&gt;
{{#invoke:Find sources/autodoc|Find sources mainspace}}
&lt;/noinclude&gt;</text>
      <sha1>8dqgswr68gd5uthbnrpvyiemcqiw1rm</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Fix</title>
    <ns>10</ns>
    <id>5632010</id>
    <revision>
      <id>814292698</id>
      <parentid>713657347</parentid>
      <timestamp>2017-12-07T23:00:24Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>replaced self-closed &lt;nowiki/&gt; and space with numeric space entity;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1113" xml:space="preserve">{{#switch:{{{subst|¬}}}
 |¬={{category handler
  |template=[[Category:Templates needing substitution checking]]
  |nocat={{{nocat|&lt;noinclude&gt;true&lt;/noinclude&gt;}}}
 }}
 |SUBST=[[Category:Pages with incorrectly substituted templates]]
}}{{Category handler
 |main={{Fix/category
  |cat-date={{{cat-date|}}} 
  |cat={{{cat|}}} 
  |cat-date2={{{cat-date2|}}} 
  |cat2={{{cat2|}}} 
  |cat-date3={{{cat-date3|}}} 
  |cat3={{{cat3|}}} 
  |date={{{date|}}}
 }}
 |template={{#if:{{{name|}}}|{{#ifeq:{{{name}}}|{{ROOTPAGENAME}}||{{#if:{{{date|}}}||[[Category:Templates including undated clean-up tags]]}}}}}} 
 |subpage=no
}}{{#if:{{{text|}}}
 |&lt;sup class="noprint Inline-Template {{{class|}}}" style="white-space:nowrap;"&gt;&amp;#91;&lt;i&gt;{{#if:{{{pre-text|}}}
  |{{{pre-text}}}&amp;#32;
 }}[[{{{link|Wikipedia:Cleanup}}}|&lt;span title="{{delink|1={{{title|{{{link|Wikipedia:Cleanup}}}}}}{{#if:{{{date|}}}|&amp;#32;({{{date}}})}}}}"&gt;{{{text|}}}&lt;/span&gt;]]{{#if:{{{post-text|}}}
  |&amp;#32;{{{post-text}}}
 }}&lt;/i&gt;&amp;#93;&lt;/sup&gt;|{{{special|}}}
}}&lt;noinclude&gt;
{{Documentation}}
&lt;!-- Add cats and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>owg7pdp6e9nqycfh3g7fuee1rm3t159</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Fix/category</title>
    <ns>10</ns>
    <id>34017846</id>
    <revision>
      <id>774489703</id>
      <parentid>471928517</parentid>
      <timestamp>2017-04-08T20:24:09Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Fix/category]]": [[WP:High-risk templates|Highly visible template]]: Allowing template editors ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="858" xml:space="preserve">&lt;noinclude&gt;{{pp-template|small=yes}}&lt;/noinclude&gt;{{{cat|[[Category:All pages needing cleanup]]}}}{{#if:{{{cat-date|}}}
  |[[{{{cat-date}}} {{#if:{{{date|}}}
   |from {{{date}}}
  }}]]{{#if:{{{date|}}}
   |{{#ifexist:{{{cat-date}}} from {{{date}}}|
    |[[Category:Articles with invalid date parameter in template]]
   }}
  }}
 }}{{#if:{{{cat2|}}}|{{{cat2}}}}}{{#if:{{{cat-date2|}}}
  |[[{{{cat-date2}}} {{#if:{{{date|}}}
   |from {{{date}}}
  }}]]{{#if:{{{date|}}}
   |{{#ifexist:{{{cat-date2}}} from {{{date}}}|
    |[[Category:Articles with invalid date parameter in template]]
   }}
  }}
 }}{{#if:{{{cat3|}}}|{{{cat3}}}}}{{#if:{{{cat-date3|}}}
  |[[{{{cat-date3}}} {{#if:{{{date|}}}
   |from {{{date}}}
  }}]]{{#if:{{{date|}}}
   |{{#ifexist:{{{cat-date3}}} from {{{date}}}|
    |[[Category:Articles with invalid date parameter in template]]
   }}
  }}
 }}</text>
      <sha1>gpikm5p2yggfosi6w5maxtx5my3u9im</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Further</title>
    <ns>10</ns>
    <id>1721317</id>
    <revision>
      <id>852258832</id>
      <parentid>827708293</parentid>
      <timestamp>2018-07-27T17:29:22Z</timestamp>
      <contributor>
        <username>Galobtter</username>
        <id>19502780</id>
      </contributor>
      <comment>fix so that don't need [[Module:Further]] anymore</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="251" xml:space="preserve">&lt;includeonly&gt;{{#invoke:labelled list hatnote|labelledList|Further information{{#if:{{{topic|}}}|&amp;#32;on {{{topic|}}}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>pu1ae8is2dmdurv2yovsfwxjajnhn2s</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Harv</title>
    <ns>10</ns>
    <id>3083829</id>
    <redirect title="Template:Harvard citation" />
    <restrictions>edit=sysop:move=sysop</restrictions>
    <revision>
      <id>95236892</id>
      <parentid>27653786</parentid>
      <timestamp>2006-12-19T03:27:09Z</timestamp>
      <contributor>
        <username>Renesis</username>
        <id>475878</id>
      </contributor>
      <minor/>
      <comment>Protected Template:Harv: Redirect to hprotected template [edit=sysop:move=sysop]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="39" xml:space="preserve">#REDIRECT [[Template:Harvard citation]]</text>
      <sha1>dn9qlg927pkdnmfh95oeycbtkzo47bk</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Harvard citation</title>
    <ns>10</ns>
    <id>3103864</id>
    <revision>
      <id>884947524</id>
      <parentid>884945617</parentid>
      <timestamp>2019-02-25T00:54:20Z</timestamp>
      <contributor>
        <username>Pppery</username>
        <id>28032115</id>
      </contributor>
      <comment>Undid revision 884945617 by [[Special:Contributions/Swarm|Swarm]] ([[User talk:Swarm|talk]]) Unnecessary: [[Template:Doc]] auto-detects protection level</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="144" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Footnotes|harvard_citation
|bracket_left= (
|bracket_right = )
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>58koru55lo3uw6ag6lpwgtdrjcterl8</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Harvard citation no brackets</title>
    <ns>10</ns>
    <id>5326834</id>
    <revision>
      <id>947689928</id>
      <parentid>854447453</parentid>
      <timestamp>2020-03-27T22:02:35Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="123" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Footnotes|harvard_citation|template=harvnb}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>1tgpzxb5legvtms3dpi7j9bwgfygmuv</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Harvid</title>
    <ns>10</ns>
    <id>25416230</id>
    <redirect title="Template:SfnRef" />
    <revision>
      <id>911344118</id>
      <parentid>804521304</parentid>
      <timestamp>2019-08-18T08:58:52Z</timestamp>
      <contributor>
        <username>Redrose64</username>
        <id>9612106</id>
      </contributor>
      <comment>wrong prot template</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="71" xml:space="preserve">#REDIRECT [[Template:SfnRef]]
{{R from merge}}
{{R template-protected}}</text>
      <sha1>6zmhna2etmyxuy6yr28w55zpb0xn2wx</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Harvnb</title>
    <ns>10</ns>
    <id>5326925</id>
    <redirect title="Template:Harvard citation no brackets" />
    <revision>
      <id>774336434</id>
      <parentid>103261552</parentid>
      <timestamp>2017-04-07T19:22:02Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Harvnb]]": Matching redirect target ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="50" xml:space="preserve">#REDIRECT[[Template:Harvard citation no brackets]]</text>
      <sha1>3shv1t0unnkqbpog36jda0nnq7r7rca</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Infobox</title>
    <ns>10</ns>
    <id>891845</id>
    <revision>
      <id>855069164</id>
      <parentid>855063393</parentid>
      <timestamp>2018-08-15T18:33:36Z</timestamp>
      <contributor>
        <username>Primefac</username>
        <id>11508456</id>
      </contributor>
      <comment>Undid revision 855063393 by [[Special:Contributions/Jdlrobson|Jdlrobson]] ([[User talk:Jdlrobson|talk]]) rather problematic change mentioned [[Template_talk:Infobox#Using_template_styles_to_reduce_technical_debt_inside_mobile_skin|on talk page]], reverting until it can be sorted</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="340" xml:space="preserve">{{#invoke:Infobox|infobox}}&lt;includeonly&gt;{{template other|{{#ifeq:{{PAGENAME}}|Infobox||{{#ifeq:{{str left|{{SUBPAGENAME}}|7}}|Infobox|[[Category:Infobox templates|{{remove first word|{{SUBPAGENAME}}}}]]}}}}|}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go in the /doc subpage, and interwikis go in Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>f4hgwrnr11ahhwyo266vcd10dpi92pe</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Link note</title>
    <ns>10</ns>
    <id>35168072</id>
    <revision>
      <id>825510446</id>
      <parentid>756212913</parentid>
      <timestamp>2018-02-13T20:29:11Z</timestamp>
      <contributor>
        <username>WOSlinker</username>
        <id>3138265</id>
      </contributor>
      <comment>separate pp-template not needed</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="200" xml:space="preserve">&lt;span style="font-size:0.95em; font-size:90%; color:#555"&gt;({{{note|}}})&lt;/span&gt;&lt;includeonly&gt;{{#if:{{{cat|}}}|{{DMCA|{{{cat|}}}|from|{{{date|}}}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>bwyu2tjw5755ttqsibbg470pjnd65x7</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Main</title>
    <ns>10</ns>
    <id>1208356</id>
    <revision>
      <id>856268932</id>
      <parentid>849583277</parentid>
      <timestamp>2018-08-24T01:27:01Z</timestamp>
      <contributor>
        <username>Pppery</username>
        <id>28032115</id>
      </contributor>
      <comment>You forgot to remove this notice</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="138" xml:space="preserve">{{#invoke:main|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>jkpvpyms818jhpg2lkzsq5qur195qbr</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Main other</title>
    <ns>10</ns>
    <id>17220251</id>
    <revision>
      <id>388689011</id>
      <parentid>334818505</parentid>
      <timestamp>2010-10-04T14:46:48Z</timestamp>
      <contributor>
        <username>WOSlinker</username>
        <id>3138265</id>
      </contributor>
      <comment>remove {{pp-template}}</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="409" xml:space="preserve">{{#switch:
  &lt;!--If no or empty "demospace" parameter then detect namespace--&gt;
  {{#if:{{{demospace|}}} 
  | {{lc: {{{demospace}}} }}    &lt;!--Use lower case "demospace"--&gt;
  | {{#ifeq:{{NAMESPACE}}|{{ns:0}}
    | main
    | other
    }} 
  }}
| main     = {{{1|}}}
| other
| #default = {{{2|}}}
}}&lt;noinclude&gt;

{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>ngt28vb1n5t4bh1su57btnqyofkd1d5</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Navbox</title>
    <ns>10</ns>
    <id>995954</id>
    <revision>
      <id>948472467</id>
      <parentid>630098073</parentid>
      <timestamp>2020-04-01T06:12:36Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="94" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Navbox|navbox}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>tqodcaa2vvhehqaod229udlla0wimek</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Note label</title>
    <ns>10</ns>
    <id>2196511</id>
    <revision>
      <id>827245524</id>
      <parentid>384676363</parentid>
      <timestamp>2018-02-23T16:30:14Z</timestamp>
      <contributor>
        <username>Primefac</username>
        <id>11508456</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Note label]]": [[WP:HIGHRISK|high-risk]] template with 4000+ transclusions ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="377" xml:space="preserve">&lt;span class="citation wikicite" id="{{anchorencode:endnote_{{{1}}}{{{3|}}}}}"&gt;{{#if:{{{3|}}}
  |[[#ref_{{{1}}}{{{3}}}|'''&lt;sup&gt;{{#ifeq:none|{{{3|none}}}
    |^
    |{{{3|}}}
  }}&lt;/sup&gt;''']]
  |&lt;sup&gt;{{{2|}}}&lt;/sup&gt;
}}{{#if:{{{4|}}}| {{{4|}}}}}&lt;/span&gt; &lt;noinclude&gt;
{{Documentation|Template:Ref/doc}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>8wnxcjme3mbgs65ulzgfb84utd71flt</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ns has subpages</title>
    <ns>10</ns>
    <id>22589696</id>
    <revision>
      <id>637438114</id>
      <parentid>637437596</parentid>
      <timestamp>2014-12-10T06:37:09Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>convert this to use [[Module:Ns has subpages]] - this gets the subpage status directly from MediaWiki, avoiding the need to update the template when namespaces change</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="185" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:Ns has subpages|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>0pg457y46td6p53rdt8tyc76jeg9pa8</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Other uses</title>
    <ns>10</ns>
    <id>693634</id>
    <revision>
      <id>850158103</id>
      <parentid>848893060</parentid>
      <timestamp>2018-07-14T01:05:26Z</timestamp>
      <contributor>
        <username>Primefac</username>
        <id>11508456</id>
      </contributor>
      <comment>TFD closed as no consensus ([[WP:XFDC|XFDcloser]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="75" xml:space="preserve">{{#invoke:other uses|otheruses}}&lt;noinclude&gt;
{{documentation}} 
&lt;/noinclude&gt;</text>
      <sha1>nxkbcfjkg9b2zpfkap2k5ykmwk5x0z6</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Pagetype</title>
    <ns>10</ns>
    <id>23143954</id>
    <revision>
      <id>616197024</id>
      <parentid>580855388</parentid>
      <timestamp>2014-07-09T08:29:38Z</timestamp>
      <contributor>
        <username>Callanecc</username>
        <id>10440891</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Pagetype: [[WP:High-risk templates|Highly visible template]]: With more than 5.5 million transclusions and cascade protections this should be full protected as well ([Edit=Allow only administrators] (indefinite) [Move=</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="179" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:pagetype|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>lljnsh3xa96oyrio8us1qbonct9sq7b</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Pp-move-indef</title>
    <ns>10</ns>
    <id>20814756</id>
    <revision>
      <id>626025152</id>
      <parentid>626025082</parentid>
      <timestamp>2014-09-18T01:43:57Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Pp-move-indef: [[WP:High-risk templates|Highly visible template]]: allow template editors ([Edit=Allow only template editors and admins] (indefinite) [Move=Allow only template editors and admins] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="174" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Pp-move-indef|main}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>ige1ruktwt70sig3zmubaou2g290avd</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Pp-semi-indef</title>
    <ns>10</ns>
    <id>7896691</id>
    <revision>
      <id>772120871</id>
      <parentid>619983103</parentid>
      <timestamp>2017-03-25T12:38:46Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Pp-semi-indef]]": Allowing template editors on some templates with full protection dating back to pre-[[WP:TPROT|TPROT]] times which aren't too often or too sensitively used. ([Edit=Require template editor acces...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="178" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Protection banner|main}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>5t6lal9n9hcpwsso2obr7pcyjbg26xc</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ref patent</title>
    <ns>10</ns>
    <id>27381972</id>
    <redirect title="Template:Cite patent" />
    <revision>
      <id>362599412</id>
      <timestamp>2010-05-17T11:55:41Z</timestamp>
      <contributor>
        <username>MSGJ</username>
        <id>42630</id>
      </contributor>
      <comment>moved [[Template:Ref patent]] to [[Template:Cite patent]]: combining two templates, per proposal on talk page</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="34" xml:space="preserve">#REDIRECT [[Template:Cite patent]]</text>
      <sha1>fz3vckkl5gs5wryll43zuktrwydt2r1</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Refbegin</title>
    <ns>10</ns>
    <id>9391283</id>
    <revision>
      <id>924781542</id>
      <parentid>880577697</parentid>
      <timestamp>2019-11-05T22:22:22Z</timestamp>
      <contributor>
        <username>Wugapodes</username>
        <id>24484530</id>
      </contributor>
      <comment>add .reflist class which is defined in [[MediaWiki:common.css]], see [[Wikipedia:Interface administrators' noticeboard#.refbegin and .reflist]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="870" xml:space="preserve">&lt;includeonly&gt;&lt;templatestyles src="Refbegin/styles.css" /&gt;&lt;!--
--&gt;&lt;div class="refbegin reflist &lt;!--
--&gt;{{#if: {{{indent|}}}
    | refbegin-hanging-indents }} &lt;!--
 --&gt;{{#if: {{{normalfont|}}}
    | refbegin-100 }} &lt;!--
 --&gt;{{#if: {{{1|}}}
    | columns {{#iferror: {{#ifexpr: {{{1|1}}} &gt; 1 }}
      | references-column-width 
      | references-column-count references-column-count-{{#if:1|{{{1}}}}} }}
    | {{#if: {{{colwidth|}}}
      | references-column-width }} }}" style="&lt;!--
 --&gt;{{#if: {{{1|}}}
    | {{#iferror: {{#ifexpr: {{{1|1}}} &gt; 1 }}
      | {{column-width|{{#if:1|{{{1}}}}}}}
      | {{column-count|{{#if:1|{{{1}}}}}}} }}
    | {{#if: {{{colwidth|}}}
      | {{column-width|{{{colwidth}}}}} }} }}"&gt;&lt;!--
 --&gt;{{#if: {{{normalfont|}}}
    | [[Category:Pages using refbegin with normalfont parameter]]}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>chruxt1gox0h5hs68nu289ucxb0vjjj</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Refbegin/styles.css</title>
    <ns>10</ns>
    <id>58037900</id>
    <revision>
      <id>886047268</id>
      <parentid>853264625</parentid>
      <timestamp>2019-03-03T23:41:41Z</timestamp>
      <contributor>
        <username>Pppery</username>
        <id>28032115</id>
      </contributor>
      <comment>Adding protection template</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="520" xml:space="preserve">/* {{pp-template}} */
.refbegin {
	font-size: 90%;            /* Default font-size */
	margin-bottom: 0.5em;
}
/* Hanging indentation for Template:Refbegin */
.refbegin-hanging-indents &gt; ul {
	list-style-type: none;
	margin-left: 0;
}
/* Definition list version is deprecated */
.refbegin-hanging-indents &gt; ul &gt; li,
.refbegin-hanging-indents &gt; dl &gt; dd {
	margin-left: 0;
	padding-left: 3.2em;
	text-indent: -3.2em;
	list-style: none;
}
/* Option for normal fontsize in {{refbegin}} */
.refbegin-100 {
	font-size: 100%;
}</text>
      <sha1>td80povo597100rvxukfatnollga2xs</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Refend</title>
    <ns>10</ns>
    <id>10023179</id>
    <revision>
      <id>792167400</id>
      <parentid>772120878</parentid>
      <timestamp>2017-07-24T21:40:56Z</timestamp>
      <contributor>
        <username>WOSlinker</username>
        <id>3138265</id>
      </contributor>
      <comment>remove &lt;/dl&gt; since no &lt;dl&gt; in Template:Refbegin</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="246" xml:space="preserve">&lt;includeonly&gt;&lt;/div&gt;&lt;/includeonly&gt;&lt;noinclude&gt;
{{template doc|Template:refbegin/doc}}
{{TemplateDataHeader}}
&lt;templatedata&gt;
{
    "description": "Ends a reference lists started by {{refbegin}}.",
    "params": {
    }
}
&lt;/templatedata&gt;
&lt;/noinclude&gt;</text>
      <sha1>kcrxzrf6v4rvbl0yhnfcb5labufpnsp</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Reflist</title>
    <ns>10</ns>
    <id>7585648</id>
    <revision>
      <id>794499661</id>
      <parentid>794499298</parentid>
      <timestamp>2017-08-08T12:05:27Z</timestamp>
      <contributor>
        <username>Anomie</username>
        <id>301903</id>
      </contributor>
      <comment>Please stop, you apparently don't know what you're doing here and shouldn't fool around with heavily-used live templates. I'll post an explanation to the talk page momentarily.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1008" xml:space="preserve">&lt;div class="reflist &lt;!--
 --&gt;{{#if: {{{1|}}} {{{colwidth|}}}
    | columns references-column-width
	}}" style="&lt;!--
 --&gt;{{#if: {{{1|}}}
    | {{#iferror: {{#ifexpr: {{{1|1}}} &gt; 1 }}
      | {{column-width|1={{{1}}}}}
      | {{#switch:{{{1|}}}|1=|2={{column-width|1=30em}}|#default={{column-width|1=25em}}}} }}
    | {{#if: {{{colwidth|}}}
      | {{column-width|1={{{colwidth}}}}} }} }} list-style-type: &lt;!--
 --&gt;{{{liststyle|{{#switch: {{{group|}}}
    | upper-alpha
    | upper-roman
    | lower-alpha
    | lower-greek
    | lower-roman = {{{group}}}
    | #default = decimal}}}}};"&gt;
{{#tag:references|{{{refs|}}}|group={{{group|}}}|responsive={{#if:{{{1|}}}{{{colwidth|}}}|0|1}}}}&lt;/div&gt;{{#invoke:Check for unknown parameters|check|unknown={{main other|[[Category:Pages using reflist with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Reflist]] with unknown parameter "_VALUE_"|ignoreblank=y| 1 | colwidth | group | liststyle | refs }}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>2k096ppl7lxbcjqmfluu9x2sc91rmzl</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Replace</title>
    <ns>10</ns>
    <id>38650247</id>
    <revision>
      <id>882861180</id>
      <parentid>882860584</parentid>
      <timestamp>2019-02-11T20:00:50Z</timestamp>
      <contributor>
        <username>Pppery</username>
        <id>28032115</id>
      </contributor>
      <comment>OOPS</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="135" xml:space="preserve">{{{{{|safesubst:}}}#invoke:String|replace|source={{{1}}}|{{{2}}}|{{{3}}}|count={{{count|}}}}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>gb7k311qbdoyqn193n5d717fd6jg9kv</sha1>
    </revision>
  </page>
  <page>
    <title>Template:See</title>
    <ns>10</ns>
    <id>35060800</id>
    <redirect title="Template:Further" />
    <revision>
      <id>814506466</id>
      <parentid>725635703</parentid>
      <timestamp>2017-12-09T06:09:36Z</timestamp>
      <contributor>
        <username>Alex 21</username>
        <id>22194871</id>
      </contributor>
      <comment>Changed redirect target from [[Template:Further information]] to [[Template:Further]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="30" xml:space="preserve">#REDIRECT [[Template:Further]]</text>
      <sha1>av4m7u5e2k4xmrwdrm0zo3bi5s6lwhj</sha1>
    </revision>
  </page>
  <page>
    <title>Template:See also</title>
    <ns>10</ns>
    <id>1721254</id>
    <revision>
      <id>763260609</id>
      <parentid>725632232</parentid>
      <timestamp>2017-02-02T05:40:25Z</timestamp>
      <contributor>
        <username>Nihiltres</username>
        <id>236191</id>
      </contributor>
      <comment>Updated from sandbox to use [[Module:Labelled list hatnote]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="199" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Labelled list hatnote|labelledList|See also}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>dn9i3dv2bt8lqifr6vkbycoya78rnav</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sfn</title>
    <ns>10</ns>
    <id>23092408</id>
    <revision>
      <id>947792252</id>
      <parentid>947792080</parentid>
      <timestamp>2020-03-28T14:24:24Z</timestamp>
      <contributor>
        <username>Black Kite</username>
        <id>3002016</id>
      </contributor>
      <comment>it didn't</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="107" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Footnotes|sfn|template=sfn}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>e1hupjkiy5qym74x2tdq3s29vk3e8gv</sha1>
    </revision>
  </page>
  <page>
    <title>Template:SfnRef</title>
    <ns>10</ns>
    <id>25072600</id>
    <revision>
      <id>744219786</id>
      <parentid>533867813</parentid>
      <timestamp>2016-10-13T21:21:21Z</timestamp>
      <contributor>
        <username>Geni</username>
        <id>55582</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:SfnRef: locking down everything used on the Hillary page ([Edit=Require template editor access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="224" xml:space="preserve">CITEREF{{#if:||{{anchorencode:{{{1|}}}}}}}{{#if:||{{anchorencode:{{{2|}}}}}}}{{#if:||{{anchorencode:{{{3|}}}}}}}{{#if:||{{anchorencode:{{{4|}}}}}}}{{#if:||{{anchorencode:{{{5|}}}}}}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>ig1kziqy8yoiyqxckskh3r7zw2vyx80</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Short description</title>
    <ns>10</ns>
    <id>55686718</id>
    <revision>
      <id>940143496</id>
      <parentid>940143453</parentid>
      <timestamp>2020-02-10T19:56:26Z</timestamp>
      <contributor>
        <username>DannyS712</username>
        <id>34581532</id>
      </contributor>
      <minor/>
      <comment>Reverted edits by [[Special:Contribs/DannyS712|DannyS712]] ([[User talk:DannyS712|talk]]) to last version by Trialpears</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="976" xml:space="preserve">{{#ifeq:{{{1|}}}|none||&lt;div class="shortdescription nomobile noexcerpt noprint searchaux" style="display:none"&gt;{{{1|}}}{{SHORTDESC:{{{1|}}}|{{{2|}}}}}&lt;/div&gt;}}&lt;includeonly&gt;[[Category:{{{pagetype|{{pagetype|defaultns = extended}}}}}s with short description]]&lt;/includeonly&gt;&lt;!-- Start tracking
--&gt;{{#invoke:Check for unknown parameters|check|unknown={{Main other|[[Category:Pages using short description with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Short description]] with unknown parameter "_VALUE_"|ignoreblank=y| 1 | 2 | pagetype | bot }}&lt;!--
--&gt;{{#if: {{{bot|}}} | [[Category:{{{pagetype|{{pagetype|defaultns = extended}}}}}s with short description added by {{{bot|}}}]]}}{{#ifexpr:{{#invoke:String|len|{{{1|}}}}}&gt;100|[[Category:{{{pagetype|{{pagetype|defaultns = extended}}}}}s with long short description]]}}&lt;noinclude&gt;
&lt;!-- to implement this, set the class to display:none and remove the inline style here --&gt;
{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>fbp2dlu8tg1ku8lt5h42f7pdv937cll</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sister-inline</title>
    <ns>10</ns>
    <id>33288175</id>
    <revision>
      <id>787697454</id>
      <parentid>733961531</parentid>
      <timestamp>2017-06-27T00:14:40Z</timestamp>
      <contributor>
        <username>Train2104</username>
        <id>10341578</id>
      </contributor>
      <minor/>
      <comment>wkt logo renamed</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3222" xml:space="preserve">[[File:{{#switch:{{lc:{{{project|}}}}}
    | commons|commonscat     = Commons-logo.svg
    | meta|metawiki|m        = Wikimedia Community Logo.svg
    | wikibooks|wbk|wb|b     = Wikibooks-logo-en-noslogan.svg
    | wikidata|data          = Wikidata-logo.svg
    | cookbook               = Wikibooks-logo-en-noslogan.svg
    | wikiquote|quote|wqt|q  = Wikiquote-logo.svg
    | wikipedia|wp|w         = Wikipedia-logo-v2.svg
    | wikisource|wikisource2|source|source2|ws|ws2|s|s2 = Wikisource-logo.svg
    | wiktionary|wkt|wdy|d   = Wiktionary-logo-en-v2.svg
    | wikinews|news|wnw|n    = Wikinews-logo.svg
    | wikispecies|species    = Wikispecies-logo.svg
    | wikiversity|wvy|v      = Wikiversity-logo.svg
    | wikivoyage|voyage|voy  = Wikivoyage-Logo-v3-icon.svg
    | mediawiki|mw           = Mediawiki.png
    | outreachwiki|outreach  = Wikimedia Outreach.png
    | incubator              = Incubator-notext.svg
    | #default               = Wikimedia-logo.svg
}}|16x16px|class=noviewer|alt=]] {{#if:{{{short|}}}|{{{links|}}}|{{#if:{{{list|}}}|{{#switch:{{lc:{{{project|}}}}}
    | commons                = Related media at Wikimedia Commons
    | commonscat             = Related categories at Wikimedia Commons
    | meta|metawiki|m        = 
    | wikibooks|wbk|wb|b     = Texts at Wikibooks
    | wikidata|data          = 
    | cookbook               = Cookbooks at Wikibooks
    | wikiquote|quote|wqt|q  = Quotations on Wikiquote
    | wikipedia|wp|w         = 
    | wikisource|wikisource2|source|source2|ws|ws2|s|s2 = Texts on Wikisource
    | wiktionary|wkt|wdy|d   = Definitions and translations at Wiktionary
    | wikinews|news|wnw|n    = 
    | wikispecies|species    = Data related to Wikispecies
    | wikiversity|wvy|v      = Learning materials from Wikiversity
    | wikivoyage|voyage|voy  = Travel information on Wikivoyage
    | mediawiki|mw           = 
    | outreachwiki|outreach  = 
    | incubator              = 
    | #default               = }}:
{{{list}}}|{{#switch:{{lc:{{{project|}}}}}
    | commons                = Media related to {{{links|}}} at Wikimedia Commons
    | commonscat             = Media related to {{{links|}}} at Wikimedia Commons
    | meta|metawiki|m        = 
    | wikibooks|wbk|wb|b     = {{{links|}}} at Wikibooks{{{extratext|}}}
    | wikidata|data          = 
    | cookbook               = {{{links|}}} at Wikibook Cookbooks{{{extratext|}}}
    | wikiquote|quote|wqt|q  = Quotations related to {{{links|}}} at Wikiquote
    | wikipedia|wp|w         = 
    | wikisource|source|ws|s = Works related to {{{links|}}} at Wikisource
    | wikisource2|source2|ws2|s2 = The full text of {{{links|}}} at Wikisource
    | wiktionary|wkt|wdy|d   = The dictionary definition of {{{links|}}} at Wiktionary
    | wikinews|news|wnw|n    = 
    | wikispecies|species    = Data related to {{{links|}}} at Wikispecies
    | wikiversity|wvy|v      = Learning materials related to {{{links|}}} at Wikiversity
    | wikivoyage|voyage|voy  = {{{links|}}} travel guide from Wikivoyage
    | mediawiki|mw           = 
    | outreachwiki|outreach  = 
    | incubator              = 
    | #default               = }}{{{extratext|}}}}}
}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>d8uas2jvgpv2i8lihddgfyrlu1bdxhp</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Subscription required</title>
    <ns>10</ns>
    <id>19379091</id>
    <revision>
      <id>827245669</id>
      <parentid>557964233</parentid>
      <timestamp>2018-02-23T16:30:25Z</timestamp>
      <contributor>
        <username>Primefac</username>
        <id>11508456</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Subscription required]]": [[WP:HIGHRISK|high-risk]] template with 4000+ transclusions ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="471" xml:space="preserve">{{#if:{{{via|}}}|&amp;nbsp;–&amp;nbsp;via&amp;nbsp;{{{via}}} {{link note|note={{#switch: {{{1|not-sentence}}}
 | s
 | sentence = Subscription required.
 | subscription required
}}}} [[Category:Subscription required using via]]|{{link note|note={{#switch: {{{1|not-sentence}}}
 | s
 | sentence = Subscription required.
 | subscription required
}}}}
}}&lt;includeonly&gt;[[Category:Pages containing links to subscription-only content]]&lt;/includeonly&gt;&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>ovlbbshxtrywzhvxvfo97bgqa527wsg</sha1>
    </revision>
  </page>
  <page>
    <title>Template:TOC limit</title>
    <ns>10</ns>
    <id>10794362</id>
    <revision>
      <id>872451201</id>
      <parentid>645375001</parentid>
      <timestamp>2018-12-07T07:36:09Z</timestamp>
      <contributor>
        <username>TheDJ</username>
        <id>244887</id>
      </contributor>
      <comment>Use template styles</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="153" xml:space="preserve">&lt;templatestyles src="Template:TOC limit/styles.css" /&gt;&lt;div class="toclimit-{{{1|{{{limit|3}}}}}}"&gt;__TOC__&lt;/div&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>dwdn99dxyfhkqqw4i3lmafbzsxd31mr</sha1>
    </revision>
  </page>
  <page>
    <title>Template:TOC limit/styles.css</title>
    <ns>10</ns>
    <id>59293976</id>
    <revision>
      <id>886046785</id>
      <parentid>872693506</parentid>
      <timestamp>2019-03-03T23:36:55Z</timestamp>
      <contributor>
        <username>Pppery</username>
        <id>28032115</id>
      </contributor>
      <comment>Adding protection template</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="488" xml:space="preserve">/* {{pp-template}} 
   Allow limiting of which header levels are shown in a TOC;
   &lt;div class="toclimit-3"&gt;, for instance, will limit to
   showing ==headings== and ===headings=== but no further
   (as long as there are no =headings= on the page, which
   there shouldn't be according to the MoS). */
.toclimit-2 .toclevel-1 ul,
.toclimit-3 .toclevel-2 ul,
.toclimit-4 .toclevel-3 ul,
.toclimit-5 .toclevel-4 ul,
.toclimit-6 .toclevel-5 ul,
.toclimit-7 .toclevel-6 ul {
	display: none;
}</text>
      <sha1>clkz25e6xu067l6ec31e9unokrhkflm</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Template other</title>
    <ns>10</ns>
    <id>21418395</id>
    <revision>
      <id>874062289</id>
      <parentid>774731050</parentid>
      <timestamp>2018-12-16T22:06:25Z</timestamp>
      <contributor>
        <username>Amorymeltzer</username>
        <id>141948</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Template other]]": [[WP:High-risk templates|Highly visible template]]: Transclusion count has increased dramatically ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="435" xml:space="preserve">{{#switch:
  &lt;!--If no or empty "demospace" parameter then detect namespace--&gt;
  {{#if:{{{demospace|}}}
  | {{lc: {{{demospace}}} }}    &lt;!--Use lower case "demospace"--&gt;
  | {{#ifeq:{{NAMESPACE}}|{{ns:Template}}
    | template
    | other
    }}
  }}
| template = {{{1|}}}
| other
| #default = {{{2|}}}
}}&lt;!--End switch--&gt;&lt;noinclude&gt;

{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>0tcssjmltwl7y5v3f5wj2kqciaabqly</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Unreferenced</title>
    <ns>10</ns>
    <id>1440745</id>
    <revision>
      <id>925435476</id>
      <parentid>899807237</parentid>
      <timestamp>2019-11-10T03:02:27Z</timestamp>
      <contributor>
        <username>JJMC89</username>
        <id>24812038</id>
      </contributor>
      <comment>+{{find sources mainspace}} per request by JalenFolf</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1092" xml:space="preserve">{{ {{{|safesubst:}}}#invoke:Unsubst||date=__DATE__ |$B=
{{Ambox
| name  = {{{name|Unreferenced}}}
| subst = &lt;includeonly&gt;{{subst:substcheck}}&lt;/includeonly&gt;
| type  = content
| class = ambox-Unreferenced
| small = {{{small|}}}
| image = [[File:Question book-new.svg|50x40px|alt=]]
| issue = This {{{1|article}}} '''does not [[Wikipedia:Citing sources|cite]] any [[Wikipedia:Verifiability|sources]]'''.
| fix   = Please help [{{fullurl:{{FULLPAGENAME}}|action=edit}} improve this {{{1|article}}}] by [[Help:Introduction to referencing with Wiki Markup/1|adding citations to reliable sources]]. Unsourced material may be challenged and [[Wikipedia:Verifiability#Burden of evidence|removed]].&lt;br /&gt;&lt;small&gt;{{find sources mainspace}}&lt;/small&gt;
| removalnotice = yes
| date  = {{{date|}}}
| cat   = Articles {{#ifeq:{{{1}}}|section|needing additional references|lacking sources}}
| all   = All articles {{#ifeq:{{{1}}}|section|needing additional references|lacking sources}}
| all2  = {{#ifeq:{{{status}}}|hasaref|All articles possibly lacking sources}}
}}
}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>0xb0fn46pmdojimorgrt09z2qskljvd</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Unreferenced section</title>
    <ns>10</ns>
    <id>1357439</id>
    <revision>
      <id>784070871</id>
      <parentid>760876869</parentid>
      <timestamp>2017-06-06T09:03:31Z</timestamp>
      <contributor>
        <username>UsuallyNonviolentBot</username>
        <id>31197275</id>
      </contributor>
      <minor/>
      <comment>/* top */Remove deprecated parameter $N from [[Module:Unsubst]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="257" xml:space="preserve">{{ {{{|safesubst:}}}#invoke:Unsubst||date=__DATE__ |$B=
{{Unreferenced|section|name=Unreferenced section|small={{#if:{{{small|}}}|left}}
|subst=&lt;includeonly&gt;{{subst:substcheck}}&lt;/includeonly&gt;
|date={{{date|}}}
}}
}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>gjkxmfh7v7n0f4ose2ow6odr42i5zlz</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Use dmy dates</title>
    <ns>10</ns>
    <id>21044097</id>
    <revision>
      <id>930735233</id>
      <parentid>927361621</parentid>
      <timestamp>2019-12-14T15:38:30Z</timestamp>
      <contributor>
        <username>Jonesey95</username>
        <id>9755426</id>
      </contributor>
      <comment>Wrap invoke within substable code. See talk page.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="411" xml:space="preserve">{{ {{{|safesubst:}}}#invoke:Unsubst||date=__DATE__ |$B=
{{DMCA|Use dmy dates|from|{{{date|}}}}}{{#invoke:Check for unknown parameters|check|unknown={{main other|[[Category:Pages using Use dmy dates template with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Use dmy dates]] with unknown parameter "_VALUE_"|ignoreblank=y| cs1-dates  | date }}}}&lt;noinclude&gt;{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>cla2dfrmmjhd6zxii2qxqbjfiuqe2ip</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Webarchive</title>
    <ns>10</ns>
    <id>22577742</id>
    <revision>
      <id>769654926</id>
      <parentid>750709028</parentid>
      <timestamp>2017-03-10T21:29:55Z</timestamp>
      <contributor>
        <username>Rich Farmbrough</username>
        <id>82835</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="176" xml:space="preserve">&lt;includeonly&gt;{{#invoke:webarchive|webarchive}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- PLEASE ADD CATEGORIES AND INTERWIKIS TO THE /doc SUBPAGE, THANKS --&gt;
&lt;/noinclude&gt;</text>
      <sha1>af0jh9wqwfjf3uyx3ywwvb039disnpm</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Anchor</title>
    <ns>828</ns>
    <id>41372338</id>
    <revision>
      <id>586910342</id>
      <parentid>586194472</parentid>
      <timestamp>2013-12-20T06:14:24Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <minor/>
      <comment>Protected Module:Anchor: [[Wikipedia:Lua/Modules|High-risk Lua module]]: 20,000 transclusions ([Edit=Allow only template editors and admins] (indefinite) [Move=Allow only template editors and admins] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="632" xml:space="preserve">-- This module implements {{anchor}}.

local getArgs = require('Module:Arguments').getArgs
local tableTools = require('Module:TableTools')

local p = {}

function p.main(frame)
	-- Get the positional arguments from #invoke, remove any nil values,
	-- and pass them to p._main.
	local args = getArgs(frame)
	local argArray = tableTools.compressSparseArray(args)
	return p._main(unpack(argArray))
end

function p._main(...)
	-- Generate the list of anchors.
	local anchors = {...}
	local ret = {}
	for _, anchor in ipairs(anchors) do
		ret[#ret + 1] = '&lt;span id="' .. anchor .. '"&gt;&lt;/span&gt;'
	end
	return table.concat(ret)
end

return p</text>
      <sha1>na5loe2ne1o9yhs2k5p73tr355hey7t</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Arguments</title>
    <ns>828</ns>
    <id>41298065</id>
    <revision>
      <id>948472485</id>
      <parentid>948472482</parentid>
      <timestamp>2020-04-01T06:12:40Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="10054" xml:space="preserve">-- This module provides easy processing of arguments passed to Scribunto from
-- #invoke. It is intended for use by other Lua modules, and should not be
-- called from #invoke directly.

local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType

local arguments = {}

-- Generate four different tidyVal functions, so that we don't have to check the
-- options every time we call it.

local function tidyValDefault(key, val)
	if type(val) == 'string' then
		val = val:match('^%s*(.-)%s*$')
		if val == '' then
			return nil
		else
			return val
		end
	else
		return val
	end
end

local function tidyValTrimOnly(key, val)
	if type(val) == 'string' then
		return val:match('^%s*(.-)%s*$')
	else
		return val
	end
end

local function tidyValRemoveBlanksOnly(key, val)
	if type(val) == 'string' then
		if val:find('%S') then
			return val
		else
			return nil
		end
	else
		return val
	end
end

local function tidyValNoChange(key, val)
	return val
end

local function matchesTitle(given, title)
	local tp = type( given )
	return (tp == 'string' or tp == 'number') and mw.title.new( given ).prefixedText == title
end

local translate_mt = { __index = function(t, k) return k end }

function arguments.getArgs(frame, options)
	checkType('getArgs', 1, frame, 'table', true)
	checkType('getArgs', 2, options, 'table', true)
	frame = frame or {}
	options = options or {}

	--[[
	-- Set up argument translation.
	--]]
	options.translate = options.translate or {}
	if getmetatable(options.translate) == nil then
		setmetatable(options.translate, translate_mt)
	end
	if options.backtranslate == nil then
		options.backtranslate = {}
		for k,v in pairs(options.translate) do
			options.backtranslate[v] = k
		end
	end
	if options.backtranslate and getmetatable(options.backtranslate) == nil then
		setmetatable(options.backtranslate, {
			__index = function(t, k)
				if options.translate[k] ~= k then
					return nil
				else
					return k
				end
			end
		})
	end

	--[[
	-- Get the argument tables. If we were passed a valid frame object, get the
	-- frame arguments (fargs) and the parent frame arguments (pargs), depending
	-- on the options set and on the parent frame's availability. If we weren't
	-- passed a valid frame object, we are being called from another Lua module
	-- or from the debug console, so assume that we were passed a table of args
	-- directly, and assign it to a new variable (luaArgs).
	--]]
	local fargs, pargs, luaArgs
	if type(frame.args) == 'table' and type(frame.getParent) == 'function' then
		if options.wrappers then
			--[[
			-- The wrappers option makes Module:Arguments look up arguments in
			-- either the frame argument table or the parent argument table, but
			-- not both. This means that users can use either the #invoke syntax
			-- or a wrapper template without the loss of performance associated
			-- with looking arguments up in both the frame and the parent frame.
			-- Module:Arguments will look up arguments in the parent frame
			-- if it finds the parent frame's title in options.wrapper;
			-- otherwise it will look up arguments in the frame object passed
			-- to getArgs.
			--]]
			local parent = frame:getParent()
			if not parent then
				fargs = frame.args
			else
				local title = parent:getTitle():gsub('/sandbox$', '')
				local found = false
				if matchesTitle(options.wrappers, title) then
					found = true
				elseif type(options.wrappers) == 'table' then
					for _,v in pairs(options.wrappers) do
						if matchesTitle(v, title) then
							found = true
							break
						end
					end
				end

				-- We test for false specifically here so that nil (the default) acts like true.
				if found or options.frameOnly == false then
					pargs = parent.args
				end
				if not found or options.parentOnly == false then
					fargs = frame.args
				end
			end
		else
			-- options.wrapper isn't set, so check the other options.
			if not options.parentOnly then
				fargs = frame.args
			end
			if not options.frameOnly then
				local parent = frame:getParent()
				pargs = parent and parent.args or nil
			end
		end
		if options.parentFirst then
			fargs, pargs = pargs, fargs
		end
	else
		luaArgs = frame
	end

	-- Set the order of precedence of the argument tables. If the variables are
	-- nil, nothing will be added to the table, which is how we avoid clashes
	-- between the frame/parent args and the Lua args.
	local argTables = {fargs}
	argTables[#argTables + 1] = pargs
	argTables[#argTables + 1] = luaArgs

	--[[
	-- Generate the tidyVal function. If it has been specified by the user, we
	-- use that; if not, we choose one of four functions depending on the
	-- options chosen. This is so that we don't have to call the options table
	-- every time the function is called.
	--]]
	local tidyVal = options.valueFunc
	if tidyVal then
		if type(tidyVal) ~= 'function' then
			error(
				"bad value assigned to option 'valueFunc'"
					.. '(function expected, got '
					.. type(tidyVal)
					.. ')',
				2
			)
		end
	elseif options.trim ~= false then
		if options.removeBlanks ~= false then
			tidyVal = tidyValDefault
		else
			tidyVal = tidyValTrimOnly
		end
	else
		if options.removeBlanks ~= false then
			tidyVal = tidyValRemoveBlanksOnly
		else
			tidyVal = tidyValNoChange
		end
	end

	--[[
	-- Set up the args, metaArgs and nilArgs tables. args will be the one
	-- accessed from functions, and metaArgs will hold the actual arguments. Nil
	-- arguments are memoized in nilArgs, and the metatable connects all of them
	-- together.
	--]]
	local args, metaArgs, nilArgs, metatable = {}, {}, {}, {}
	setmetatable(args, metatable)

	local function mergeArgs(tables)
		--[[
		-- Accepts multiple tables as input and merges their keys and values
		-- into one table. If a value is already present it is not overwritten;
		-- tables listed earlier have precedence. We are also memoizing nil
		-- values, which can be overwritten if they are 's' (soft).
		--]]
		for _, t in ipairs(tables) do
			for key, val in pairs(t) do
				if metaArgs[key] == nil and nilArgs[key] ~= 'h' then
					local tidiedVal = tidyVal(key, val)
					if tidiedVal == nil then
						nilArgs[key] = 's'
					else
						metaArgs[key] = tidiedVal
					end
				end
			end
		end
	end

	--[[
	-- Define metatable behaviour. Arguments are memoized in the metaArgs table,
	-- and are only fetched from the argument tables once. Fetching arguments
	-- from the argument tables is the most resource-intensive step in this
	-- module, so we try and avoid it where possible. For this reason, nil
	-- arguments are also memoized, in the nilArgs table. Also, we keep a record
	-- in the metatable of when pairs and ipairs have been called, so we do not
	-- run pairs and ipairs on the argument tables more than once. We also do
	-- not run ipairs on fargs and pargs if pairs has already been run, as all
	-- the arguments will already have been copied over.
	--]]

	metatable.__index = function (t, key)
		--[[
		-- Fetches an argument when the args table is indexed. First we check
		-- to see if the value is memoized, and if not we try and fetch it from
		-- the argument tables. When we check memoization, we need to check
		-- metaArgs before nilArgs, as both can be non-nil at the same time.
		-- If the argument is not present in metaArgs, we also check whether
		-- pairs has been run yet. If pairs has already been run, we return nil.
		-- This is because all the arguments will have already been copied into
		-- metaArgs by the mergeArgs function, meaning that any other arguments
		-- must be nil.
		--]]
		if type(key) == 'string' then
			key = options.translate[key]
		end
		local val = metaArgs[key]
		if val ~= nil then
			return val
		elseif metatable.donePairs or nilArgs[key] then
			return nil
		end
		for _, argTable in ipairs(argTables) do
			local argTableVal = tidyVal(key, argTable[key])
			if argTableVal ~= nil then
				metaArgs[key] = argTableVal
				return argTableVal
			end
		end
		nilArgs[key] = 'h'
		return nil
	end

	metatable.__newindex = function (t, key, val)
		-- This function is called when a module tries to add a new value to the
		-- args table, or tries to change an existing value.
		if type(key) == 'string' then
			key = options.translate[key]
		end
		if options.readOnly then
			error(
				'could not write to argument table key "'
					.. tostring(key)
					.. '"; the table is read-only',
				2
			)
		elseif options.noOverwrite and args[key] ~= nil then
			error(
				'could not write to argument table key "'
					.. tostring(key)
					.. '"; overwriting existing arguments is not permitted',
				2
			)
		elseif val == nil then
			--[[
			-- If the argument is to be overwritten with nil, we need to erase
			-- the value in metaArgs, so that __index, __pairs and __ipairs do
			-- not use a previous existing value, if present; and we also need
			-- to memoize the nil in nilArgs, so that the value isn't looked
			-- up in the argument tables if it is accessed again.
			--]]
			metaArgs[key] = nil
			nilArgs[key] = 'h'
		else
			metaArgs[key] = val
		end
	end

	local function translatenext(invariant)
		local k, v = next(invariant.t, invariant.k)
		invariant.k = k
		if k == nil then
			return nil
		elseif type(k) ~= 'string' or not options.backtranslate then
			return k, v
		else
			local backtranslate = options.backtranslate[k]
			if backtranslate == nil then
				-- Skip this one. This is a tail call, so this won't cause stack overflow
				return translatenext(invariant)
			else
				return backtranslate, v
			end
		end
	end

	metatable.__pairs = function ()
		-- Called when pairs is run on the args table.
		if not metatable.donePairs then
			mergeArgs(argTables)
			metatable.donePairs = true
		end
		return translatenext, { t = metaArgs }
	end

	local function inext(t, i)
		-- This uses our __index metamethod
		local v = t[i + 1]
		if v ~= nil then
			return i + 1, v
		end
	end

	metatable.__ipairs = function (t)
		-- Called when ipairs is run on the args table.
		return inext, t, 0
	end

	return args
end

return arguments</text>
      <sha1>5qx9tzlul9ser30uxj9nbasjt92cevn</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Authority control</title>
    <ns>828</ns>
    <id>39028170</id>
    <revision>
      <id>954338951</id>
      <parentid>954273736</parentid>
      <timestamp>2020-05-01T22:32:34Z</timestamp>
      <contributor>
        <username>Matthiaspaul</username>
        <id>13467261</id>
      </contributor>
      <comment>switched another link to use (identifier) redirect</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="43593" xml:space="preserve">require('Module:No globals')

local p = {}
local title = mw.title.getCurrentTitle()
local namespace = title.namespace
local testcases = (string.sub(title.subpageText,1,9) == 'testcases')

--[[==========================================================================]]
--[[                            Category functions                            ]]
--[[==========================================================================]]

function p.getCatForId( id )
	local catName = ''
	if namespace == 0 then
		catName = 'Wikipedia articles with '..id..' identifiers'
	elseif namespace == 2 and not title.isSubpage then
		catName = 'User pages with '..id..' identifiers'
	else
		catName = 'Miscellaneous pages with '..id..' identifiers'
	end
	return '[[Category:'..catName..']]'..p.redCatLink(catName)
end

function p.redCatLink( catName ) --catName == 'Blah', not 'Category:Blah', not '[[Category:Blah]]'
	if catName and catName ~= '' and
	   testcases == false and
	   mw.title.new(catName, 14).exists == false
	then
		return '[[Category:Pages with red-linked authority control categories]]'
	end
	return ''
end

--[[==========================================================================]]
--[[                      Property formatting functions                       ]]
--[[==========================================================================]]

function p.aagLink( id )
	--P3372's format regex: \d+ (e.g. 1)
	if not id:match( '^%d+$' ) then
		return false
	end
	return '[https://www.aucklandartgallery.com/explore-art-and-ideas/artist/'..id..'/ '..id..']'..p.getCatForId( 'AAG' )
end

function p.acmLink( id )
	--P864's format regex: \d{11} (e.g. 12345678901)
	if not id:match( '^%d%d%d%d%d%d%d%d%d%d%d$' ) then
		return false
	end
	return '[https://dl.acm.org/profile/'..id..' '..id..']'..p.getCatForId( 'ACM-DL' )
end

function p.adbLink( id )
	--P1907's format regex: [a-z][-a-z]+-([1-2]\d|[1-9])\d{0,3} (e.g. barton-sir-edmund-toby-71)
	if not id:match( '^[a-z][-a-z]+-[1-2]%d%d?%d?%d?$' ) and
	   not id:match( '^[a-z][-a-z]+-[1-9]%d?%d?%d?$' ) then
		return false
	end
	return '[http://adb.anu.edu.au/biography/'..id..' '..id..']'..p.getCatForId( 'ADB' )
end

function p.agsaLink( id )
	--P6804's format regex: [1-9]\d* (e.g. 3625)
	if not id:match( '^[1-9]%d*$' ) then
		return false
	end
	return '[https://www.agsa.sa.gov.au/collection-publications/collection/creators/_/'..id..'/ '..id..']'..p.getCatForId( 'AGSA' )
end

function p.autoresuyLink( id )
	--P2558's format regex: [1-9]\d{0,4} (e.g. 12345)
	if not id:match( '^[1-9]%d?%d?%d?%d?$' ) then
		return false
	end
	return '[https://autores.uy/autor/'..id..' '..id..']'..p.getCatForId( 'autores.uy' )
end

function p.awrLink( id )
	--P4186's format regex: (([A-Z]{3}\d{4})|([A-Z]{2}\d{5}))[a-z] (e.g. PR00768b)
	if not id:match( '^[A-Z][A-Z][A-Z]%d%d%d%d[a-z]$' ) and
	   not id:match( '^[A-Z][A-Z]%d%d%d%d%d[a-z]$' ) then
		return false
	end
	return '[http://www.womenaustralia.info/biogs/'..id..'.htm '..id..']'..p.getCatForId( 'AWR' )
end

function p.balatLink( id )
	--P3293's format regex: \d+ (e.g. 1)
	if not id:match( '^%d+$' ) then
		return false
	end
	return '[http://balat.kikirpa.be/object/104257'..id..' '..id..']'..p.getCatForId( 'BALaT' ) --no https as of 9/2019
end

function p.bibsysLink( id )
	--P1015's format regex: [1-9]\d* or [1-9](\d{0,8}|\d{12}) (e.g. 1234567890123)
	--TODO: follow up @ [[d:Property talk:P1015#Discrepancy between the 2 regex constraints]] or escalate/investigate
	if not id:match( '^[1-9]%d?%d?%d?%d?%d?%d?%d?%d?$' ) and
	   not id:match( '^[1-9]%d%d%d%d%d%d%d%d%d%d%d%d$' ) then
		return false
	end
	return '[https://authority.bibsys.no/authority/rest/authorities/html/'..id..' '..id..']'..p.getCatForId( 'BIBSYS' )
end

function p.bildLink( id )
	--P2092's format regex: \d+ (e.g. 1)
	if not id:match( '^%d+$' ) then
		return false
	end
	return '[https://www.bildindex.de/document/obj'..id..' '..id..']'..p.getCatForId( 'Bildindex' )
end

function p.bncLink( id )
	--P1890's format regex: \d{9} (e.g. 123456789)
	if not id:match( '^%d%d%d%d%d%d%d%d%d$' ) then
		return false
	end
	return '[http://www.bncatalogo.cl/F?func=direct&amp;local_base=red10&amp;doc_number='..id..' '..id..']'..p.getCatForId( 'BNC' )
end

function p.bneLink( id )
	--P950's format regex: (XX|FF|a)\d{4,7}|(bima|bimo|bica|bis[eo]|bivi|Mise|Mimo|Mima)\d{10} (e.g. XX1234567)
	if not id:match( '^[XF][XF]%d%d%d%d%d?%d?%d?$' ) and
	   not id:match( '^a%d%d%d%d%d?%d?%d?$' ) and
	   not id:match( '^bi[mcsv][aoei]%d%d%d%d%d%d%d%d%d%d$' ) and
	   not id:match( '^Mi[sm][eoa]%d%d%d%d%d%d%d%d%d%d$' ) then
		return false
	end
	return '[http://catalogo.bne.es/uhtbin/authoritybrowse.cgi?action=display&amp;authority_id='..id..' '..id..']'..p.getCatForId( 'BNE' ) --no https as of 9/2019
end

function p.bnfLink( id )
	--P268's format regex: \d{8}[0-9bcdfghjkmnpqrstvwxz] (e.g. 123456789)
	if not id:match( '^c?b?%d%d%d%d%d%d%d%d[0-9bcdfghjkmnpqrstvwxz]$' ) then
		return false
	end
	--Add cb prefix if it has been removed
	if not id:match( '^cb.+$' ) then
		id = 'cb'..id
	end
	return '[https://catalogue.bnf.fr/ark:/12148/'..id..' '..id..'] [https://data.bnf.fr/ark:/12148/'..id..' (data)]'..p.getCatForId( 'BNF' )
end

function p.botanistLink( id )
	--P428's format regex: ('t )?(d')?(de )?(la )?(van (der )?)?(Ma?c)?(De)?(Di)?\p{Lu}?C?['\p{Ll}]*([-'. ]*(van )?(y )?(d[ae][nr]?[- ])?(Ma?c)?[\p{Lu}bht]?C?['\p{Ll}]*)*\.? ?f?\.? (e.g. L.)
	--not easily/meaningfully implementable in Lua's regex since "(this)?" is not allowed...
	if not mw.ustring.match( id, "^[%u%l%d%. '-]+$" ) then --better than nothing
		return false
	end
	local id2 = id:gsub(' +', '%%20')
	return '[https://www.ipni.org/ipni/advAuthorSearch.do?find_abbreviation='..id2..' '..id..']'..p.getCatForId( 'Botanist' )
end

function p.bpnLink( id )
	--P651's format regex: \d{6,8} (e.g. 00123456)
	if not id:match( '^%d%d%d%d%d%d%d%d$' ) and --original format regex, changed 8/2019 to
	   not id:match( '^0?%d%d%d%d%d%d%d$' ) and --allow 1-2 leading 0s, allowed by the website
	   not id:match( '^0?0?%d%d%d%d%d%d$' ) then
		return false
	end
	return '[http://www.biografischportaal.nl/en/persoon/'..id..' '..id..']'..p.getCatForId( 'BPN' ) --no https as of 9/2019
end

function p.canticLink( id )
	--P1273's format regex: a\d{7}[0-9x] (e.g. a10640745)
	if not id:match( '^a%d%d%d%d%d%d%d[%dx]$' ) then
		return false
	end
	return '[http://cantic.bnc.cat/registres/CUCId/'..id..' '..id..']'..p.getCatForId( 'CANTIC' ) --no https as of 10/2019
end

function p.ciniiLink( id )
	--P271's format regex: DA\d{7}[\dX] (e.g. DA12345678)
	if not id:match( '^DA%d%d%d%d%d%d%d[%dX]$' ) then
		return false
	end
	return '[https://ci.nii.ac.jp/author/'..id..'?l=en '..id..']'..p.getCatForId( 'CINII' )
end

function p.daaoLink( id )
	--P1707's format regex: [a-z\-]+\d* (e.g. rolf-harris)
	if not id:match( '^[a-z%-]+%d*$' ) then
		return false
	end
	return '[https://www.daao.org.au/bio/'..id..' '..id..']'..p.getCatForId( 'DAAO' )
end

function p.dblpLink( id )
	--P2456's format regex: \d{2,3} /\d+(-\d+)?|[a-z] /[a-zA-Z][0-9A-Za-z]*(-\d+)? (e.g. 123/123)
	if not id:match( '^%d%d%d?/%d+$' ) and
	   not id:match( '^%d%d%d?/%d+%-%d+$' ) and
	   not id:match( '^[a-z]/[a-zA-Z][0-9A-Za-z]*$' ) and
	   not id:match( '^[a-z]/[a-zA-Z][0-9A-Za-z]*%-%d+$' ) then
		return false
	end
	return '[https://dblp.org/pid/'..id..' '..id..']'..p.getCatForId( 'DBLP' )
end

function p.dsiLink( id )
	--P2349's format regex: [1-9]\d* (e.g. 1538)
	if not id:match( '^[1-9]%d*$' ) then
		return false
	end
	return '[http://www.uni-stuttgart.de/hi/gnt/dsi2/index.php?table_name=dsi&amp;function=details&amp;where_field=id&amp;where_value='..id..' '..id..']'..p.getCatForId( 'DSI' )
end

function p.fnzaLink( id )
	--P6792's format regex: [1-9]\d* (e.g. 9785)
	if not id:match( '^[1-9]%d*$' ) then
		return false
	end
	return '[https://findnzartists.org.nz/artist/'..id..'/ '..id..']'..p.getCatForId( 'FNZA' )
end

function p.gndLink( id )
	--P227's format regex: 1[012]?\d{7}[0-9X]|[47]\d{6}-\d|[1-9]\d{0,7}-[0-9X]|3\d{7}[0-9X] (e.g. 4079154-3)
	if not id:match( '^1[012]?%d%d%d%d%d%d%d[0-9X]$' ) and
	   not id:match( '^[47]%d%d%d%d%d%d%-%d$' ) and
	   not id:match( '^[1-9]%d?%d?%d?%d?%d?%d?%d?%-[0-9X]$' ) and
	   not id:match( '^3%d%d%d%d%d%d%d[0-9X]$' ) then
		return false
	end
	return '[https://d-nb.info/gnd/'..id..' '..id..']'..p.getCatForId( 'GND' )
end

function p.hdsLink( id )
	--P902's format regex: \d{6} (e.g. 050123)
	if not id:match( '^%d%d%d%d%d%d$' ) then
		return false
	end
	return '[https://hls-dhs-dss.ch/fr/articles/'..id..' '..id..']'..p.getCatForId( 'HDS' )
end

function p.iaafLink( id )
	--P1146's format regex: [0-9][0-9]* (e.g. 012)
	if not id:match( '^%d+$' ) then
		return false
	end
	return '[https://www.iaaf.org/athletes/_/'..id..' '..id..']'..p.getCatForId( 'IAAF' )
end

function p.iciaLink( id )
	--P1736's format regex: \d+ (e.g. 1)
	if not id:match( '^%d+$' ) then
		return false
	end
	return '[https://www.imj.org.il/artcenter/newsite/en/?artist='..id..' '..id..']'..p.getCatForId( 'ICIA' )
end

function p.isniLink( id )
	id = p.validateIsni( id ) --e.g. 0000-0000-6653-4145
	if not id then
		return false
	end
	return '[http://isni.org/isni/'..id..' '..id:sub( 1, 4 )..' '..id:sub( 5, 8 )..' '..id:sub( 9, 12 )..' '..id:sub( 13, 16 )..']'..p.getCatForId( 'ISNI' ) --no https as of 9/2019
end

function p.jocondeLink( id )
	--P347's format regex: [\-0-9A-Za-z]{11} (e.g. 12345678901)
	local regex = '^'..string.rep('[%-0-9A-Za-z]', 11)..'$'
	if not id:match( regex ) then
		return false
	end
	return '[https://www.pop.culture.gouv.fr/notice/joconde/'..id..' '..id..']'..p.getCatForId( 'Joconde' )
end

function p.kulturnavLink( id )
	--P1248's format regex: [0-9a-f]{8}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{12} (e.g. 12345678-1234-1234-1234-1234567890AB)
	if not id:match( '^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$' ) then
		return false
	end
	return '[http://kulturnav.org/'..id..' '..id..']'..p.getCatForId( 'KULTURNAV' ) --no https as of 9/2019
end

function p.lccnLink( id )
	local parts = p.splitLccn( id ) --e.g. n78039510
	if not parts then
		return false
	end
	local lccnType = parts[1] ~= 'sh' and 'names' or 'subjects'
	id = parts[1] .. parts[2] .. p.append( parts[3], '0', 6 )
	return '[https://id.loc.gov/authorities/'..lccnType..'/'..id..' '..id..']'..p.getCatForId( 'LCCN' )
end

function p.lirLink( id )
	--P886's format regex: \d+ (e.g. 1)
	if not id:match( '^%d+$' ) then
		return false
	end
	return '[http://www.e-lir.ch/e-LIR___Lexicon.'..id..'.450.0.html '..id..']'..p.getCatForId( 'LIR' ) --no https as of 9/2019
end

function p.lnbLink( id )
	--P1368's format regex: \d{9} (e.g. 123456789)
	if not id:match( '^%d%d%d%d%d%d%d%d%d$' ) then
		return false
	end
	return '[https://kopkatalogs.lv/F?func=direct&amp;local_base=lnc10&amp;doc_number='..id..'&amp;P_CON_LNG=ENG '..id..']'..p.getCatForId( 'LNB' )
end

function p.leonoreLink( id )
	--P640's format regex: LH/\d{1,4}/\d{1,3}|19800035/\d{1,4}/\d{1,5}(Bis)?|C/0/\d{1,2} (e.g. LH/2064/18)
	if not id:match( '^LH/%d%d?%d?%d?/%d%d?%d?$' ) and             --IDs from       LH/1/1 to         LH/2794/54 (legionaries)
	   not id:match( '^19800035/%d%d?%d?%d?/%d%d?%d?%d?%d?$' ) and --IDs from 19800035/1/1 to 19800035/385/51670 (legionnaires who died 1954-1977 &amp; some who died &lt; 1954)
	   not id:match( '^C/0/%d%d?$' ) then                          --IDs from        C/0/1 to             C/0/84 (84 famous legionaries)
		return false
	end
	return '[http://www.culture.gouv.fr/public/mistral/leonore_fr?ACTION=CHERCHER&amp;FIELD_1=COTE&amp;VALUE_1='..id..' '..id..']'..p.getCatForId( 'Léonore' ) --no https as of 9/2019
end

function p.mbaLink( id )
	--P434's format regex: [0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12} (e.g. 12345678-1234-1234-1234-1234567890AB)
	if not id:match( '^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$' ) then
		return false
	end
	return '[https://musicbrainz.org/artist/'..id..' '..id..']'..p.getCatForId( 'MusicBrainz' ) --special category name
end

function p.mbareaLink( id )
	--P982's format regex: [0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12} (e.g. 12345678-1234-1234-1234-1234567890AB)
	if not id:match( '^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$' ) then
		return false
	end
	return '[https://musicbrainz.org/area/'..id..' '..id..']'..p.getCatForId( 'MusicBrainz area' ) --special category name
end

function p.mbiLink( id )
	--P1330's format regex: [0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12} (e.g. 12345678-1234-1234-1234-1234567890AB)
	if not id:match( '^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$' ) then
		return false
	end
	return '[https://musicbrainz.org/instrument/'..id..' '..id..']'..p.getCatForId( 'MusicBrainz instrument' ) --special category name
end

function p.mblLink( id )
	--P966's format regex: [0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12} (e.g. 12345678-1234-1234-1234-1234567890AB)
	if not id:match( '^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$' ) then
		return false
	end
	return '[https://musicbrainz.org/label/'..id..' '..id..']'..p.getCatForId( 'MusicBrainz label' ) --special category name
end

function p.mbpLink( id )
	--P1004's format regex: [0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12} (e.g. 12345678-1234-1234-1234-1234567890AB)
	if not id:match( '^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$' ) then
		return false
	end
	return '[https://musicbrainz.org/place/'..id..' '..id..']'..p.getCatForId( 'MusicBrainz place' ) --special category name
end

function p.mbrgLink( id )
	--P436's format regex: [0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12} (e.g. 12345678-1234-1234-1234-1234567890AB)
	if not id:match( '^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$' ) then
		return false
	end
	return '[https://musicbrainz.org/release-group/'..id..' '..id..']'..p.getCatForId( 'MusicBrainz release group' ) --special category name
end

function p.mbsLink( id )
	--P1407's format regex: [0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12} (e.g. 12345678-1234-1234-1234-1234567890AB)
	if not id:match( '^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$' ) then
		return false
	end
	return '[https://musicbrainz.org/series/'..id..' '..id..']'..p.getCatForId( 'MusicBrainz series' ) --special category name
end

function p.mbwLink( id )
	--P435's format regex: [0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12} (e.g. 12345678-1234-1234-1234-1234567890AB)
	if not id:match( '^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$' ) then
		return false
	end
	return '[https://musicbrainz.org/work/'..id..' '..id..']'..p.getCatForId( 'MusicBrainz work' ) --special category name
end

function p.mgpLink( id )
	--P549's format regex: \d{1,6} (e.g. 123456)
	if not id:match( '^%d%d?%d?%d?%d?%d?$' ) then
		return false
	end
	return '[https://genealogy.math.ndsu.nodak.edu/id.php?id='..id..' '..id..']'..p.getCatForId( 'MGP' )
end

function p.naraLink( id )
	--P1225's format regex: ^([1-9]\d{0,8})$ (e.g. 123456789)
	if not id:match( '^[1-9]%d?%d?%d?%d?%d?%d?%d?%d?$' ) then
		return false
	end
	return '[https://catalog.archives.gov/id/'..id..' '..id..']'..p.getCatForId( 'NARA' )
end

function p.nclLink( id )
	--P1048's format regex: \d+ (e.g. 1081436)
	if not id:match( '^%d+$' ) then
		return false
	end
	return '[http://aleweb.ncl.edu.tw/F/?func=accref&amp;acc_sequence='..id..'&amp;CON_LNG=ENG '..id..']'..p.getCatForId( 'NCL' ) --no https as of 9/2019
end

function p.ndlLink( id )
	--P349's format regex: 0?\d{8} (e.g. 012345678)
	if not id:match( '^0?%d%d%d%d%d%d%d%d$' ) then
		return false
	end
	return '[https://id.ndl.go.jp/auth/ndlna/'..id..' '..id..']'..p.getCatForId( 'NDL' )
end

function p.ngvLink( id )
	--P2041's format regex: \d+ (e.g. 12354)
	if not id:match( '^%d+$' ) then
		return false
	end
	return '[https://www.ngv.vic.gov.au/explore/collection/artist/'..id..'/ '..id..']'..p.getCatForId( 'NGV' )
end

function p.nkcLink( id )
	--P691's format regex: [a-z]{2,4}[0-9]{2,14} (e.g. abcd12345678901234)
	if not id:match( '^[a-z][a-z][a-z]?[a-z]?%d%d%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?$' ) then
		return false
	end
	return '[https://aleph.nkp.cz/F/?func=find-c&amp;local_base=aut&amp;ccl_term=ica='..id..'&amp;CON_LNG=ENG '..id..']'..p.getCatForId( 'NKC' )
end

function p.nlaLink( id )
	--P409's format regex: [1-9][0-9]{0,11} (e.g. 123456789012)
	if not id:match( '^[1-9]%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?$' ) then
		return false
	end
	return '[https://nla.gov.au/anbd.aut-an'..id..' '..id..']'..p.getCatForId( 'NLA' )
end

function p.nlgLink( id )
	--P3348's format regex: [1-9]\d* (e.g. 1)
	if not id:match( '^[1-9]%d*$' ) then
		return false
	end
	return '[https://data.nlg.gr/resource/authority/record'..id..' '..id..']'..p.getCatForId( 'NLG' )
end

function p.nliLink( id )
	--P949's format regex: \d{9} (e.g. 123456789)
	if not id:match( '^%d%d%d%d%d%d%d%d%d$' ) then
		return false
	end
	return '[http://uli.nli.org.il/F/?func=direct&amp;doc_number='..id..'&amp;local_base=nlx10'..' '..id..']'..p.getCatForId( 'NLI' )
end

function p.nlkLink( id )
	--P5034's format regex: KA.(19|20).{7} (e.g. KAC201501465)
	if not id:match( '^KA.19.......$' ) and
	   not id:match( '^KA.20.......$' ) then
		return false
	end
	return '[https://nl.go.kr/authorities/resource/'..id..' '..id..']'..p.getCatForId( 'NLK' )
end

function p.nlpLink( id )
	--P1695's format regex: 9810[0-9]\d* or A[0-9]{7}[0-9X] (e.g. 9810123456789012345 or A10414836)
	if not id:match( '^9810%d+$' ) and
	   not id:match( '^A%d%d%d%d%d%d%d[%dX]$' ) then
		return false
	end
	return '[https://tools.wmflabs.org/wikidata-externalid-url?p=1695&amp;id='..id..' '..id..']'..p.getCatForId( 'NLP' )
end

function p.nlrLink( id )
	--P1003's format regex: \d{9} (e.g. 123456789)
	if not id:match( '^%d%d%d%d%d%d%d%d%d$' ) then
		return false
	end
	return '[http://alephnew.bibnat.ro:8991/F?func=find-b&amp;request='..id..'&amp;find_code=SYS&amp;adjacent=Y&amp;local_base=NLR10 '..id..']'..p.getCatForId( 'NLR' )
end

function p.nskLink( id )
	--P1375's format regex: \d{9} (e.g. 123456789)
	if not id:match( '^%d%d%d%d%d%d%d%d%d$' ) then
		return false
	end
	return '[http://katalog.nsk.hr/F/?func=direct&amp;doc_number='..id..'&amp;local_base=nsk10 '..id..']'..p.getCatForId( 'NSK' ) --no https as of 9/2019
end

function p.ntaLink( id )
	--P1006's format regex: \d{8}[\dX] (e.g. 12345678X)
	if not id:match( '^%d%d%d%d%d%d%d%d[%dX]$' ) then
		return false
	end
	return '[http://data.bibliotheken.nl/id/thes/p'..id..' '..id..']'..p.getCatForId( 'NTA' )
end

function p.orcidLink( id )
	id = p.validateIsni( id ) --e.g. 0000-0002-7398-5483
	if not id then
		return false
	end
	id = id:sub( 1, 4 )..'-'..id:sub( 5, 8 )..'-'..id:sub( 9, 12 )..'-'..id:sub( 13, 16 )
	return '[https://orcid.org/'..id..' '..id..']'..p.getCatForId( 'ORCID' )
end

function p.picLink( id )
	--P2750's format regex: [1-9]\d* (e.g. 1)
	if not id:match( '^[1-9]%d*$' ) then
		return false
	end
	return '[https://pic.nypl.org/constituents/'..id..' '..id..']'..p.getCatForId( 'PIC' )
end

function p.ridLink( id )
	--P1053's format regex: [A-Z]-\d{4}-(19|20)\d\d (e.g. A-1234-1934)
	if not id:match( '^[A-Z]%-%d%d%d%d%-19%d%d$' ) and
	   not id:match( '^[A-Z]%-%d%d%d%d%-20%d%d$' ) then
		return false
	end
	return '[https://www.researcherid.com/rid/'..id..' '..id..']'..p.getCatForId( 'RID' )
end

function p.reroLink( id )
	--P3065's format regex: 0[1-2]-[A-Z0-9]{1,10} (e.g. 02-A012345678)
	if not id:match( '^0[1-2]%-[A-Z%d][A-Z%d]?[A-Z%d]?[A-Z%d]?[A-Z%d]?[A-Z%d]?[A-Z%d]?[A-Z%d]?[A-Z%d]?[A-Z%d]?$' ) then
		return false
	end
	return '[http://data.rero.ch/'..id..' '..id..']'..p.getCatForId( 'RERO' )
end

function p.rkdartistsLink( id )
	--P650's format regex: [1-9]\d{0,5} (e.g. 123456)
	if not id:match( '^[1-9]%d?%d?%d?%d?%d?$' ) then
		return false
	end
	return '[https://rkd.nl/en/explore/artists/'..id..' '..id..']'..p.getCatForId( 'RKDartists' )
end

function p.rkdidLink( id )
	--P350's format regex: [1-9]\d{0,5} (e.g. 123456)
	if not id:match( '^[1-9]%d?%d?%d?%d?%d?$' ) then
		return false
	end
	return '[https://rkd.nl/nl/explore/images/'..id..' '..id..']'..p.getCatForId( 'RKDID' )
end

function p.rslLink( id )
	--P947's format regex: \d{1,9} (e.g. 123456789)
	if not id:match( '^%d%d?%d?%d?%d?%d?%d?%d?%d?$' ) then
		return false
	end
	return '[http://aleph.rsl.ru/F?func=find-b&amp;find_code=SYS&amp;adjacent=Y&amp;local_base=RSL11&amp;request='..id..'&amp;CON_LNG=ENG '..id..']'..p.getCatForId( 'RSL' ) --no https as of 9/2019
end

function p.sbnLink( id )
	--P396's format regex: IT\\ICCU\\(\d{10}|\D\D[\D\d]\D\\\d{6}) (e.g. IT\ICCU\CFIV\000163)
	if not id:match( '^IT\\ICCU\\%d%d%d%d%d%d%d%d%d%d$' ) and
	   not id:match( '^IT\\ICCU\\%u%u[%u%d]%u\\%d%d%d%d%d%d$' ) then --legacy: %u used here instead of %D (but the faulty ID cat is empty, out of ~12k uses)
		return false
	end
	return '[https://opac.sbn.it/opacsbn/opac/iccu/scheda_authority.jsp?bid='..id..' '..id..']'..p.getCatForId( 'SBN' )
end

function p.selibrLink( id )
	--P906's format regex: [1-9]\d{4,5} (e.g. 123456)
	if not id:match( '^[1-9]%d%d%d%d%d?$' ) then
		return false
	end
	return '[https://libris.kb.se/auth/'..id..' '..id..']'..p.getCatForId( 'SELIBR' )
end

function p.sikartLink( id )
	--P781's format regex: \d{7,9} (e.g. 123456789)
	if not id:match( '^%d%d%d%d%d%d%d%d?%d?$' ) then
		return false
	end
	return '[http://www.sikart.ch/KuenstlerInnen.aspx?id='..id..'&amp;lng=en '..id..']'..p.getCatForId( 'SIKART' ) --no https as of 9/2019
end

function p.snacLink( id )
	--P3430's format regex: \d*[A-Za-z][0-9A-Za-z]* (e.g. A)
	if not id:match( '^%d*[A-Za-z][0-9A-Za-z]*$' ) then
		return false
	end
	return '[https://snaccooperative.org/ark:/99166/'..id..' '..id..']'..p.getCatForId( 'SNAC-ID' )
end

function p.sudocLink( id )
	--P269's format regex: (\d{8}[\dX]|) (e.g. 026927608)
	if not id:match( '^%d%d%d%d%d%d%d%d[%dxX]$' ) then --legacy: allow lowercase 'x'
		return false
	end
	return '[https://www.idref.fr/'..id..' '..id..']'..p.getCatForId( 'SUDOC' )
end

function p.s2authoridLink( id )
	--P4012's format regex: [1-9]\d* (e.g. 1796130)
	if not id:match( '^[1-9]%d*$' ) then
		return false
	end
	return '[https://www.semanticscholar.org/author/'..id..' '..id..']'..p.getCatForId( 'Semantic Scholar author' ) --special category name
end

function p.ta98Link( id )
	--P1323's format regex: A\d{2}\.\d\.\d{2}\.\d{3}[FM]? (e.g. A12.3.45.678)
	if not id:match( '^A%d%d%.%d%.%d%d%.%d%d%d[FM]?$' ) then
		return false
	end
	return '[http://tools.wmflabs.org/wikidata-externalid-url/?p=1323&amp;url_prefix=https:%2F%2Fwww.unifr.ch%2Fifaa%2FPublic%2FEntryPage%2FTA98%20Tree%2FEntity%20TA98%20EN%2F&amp;url_suffix=%20Entity%20TA98%20EN.htm&amp;id='..id..' '..id..']'..p.getCatForId( 'TA98' )
end

function p.tdviaLink( id )
	--P7314's format regex: [a-z/-]+] (e.g. barkan-omer-lutfi)
	if not id:match( '^[a-z/-]+$' ) then
		return false
	end
	return '[https://islamansiklopedisi.org.tr/'..id..' '..id..']'..p.getCatForId( 'TDVİA' )
end

function p.teLink( id )
	--P1693's format regex: E[1-8]\.\d{1,2}\.\d{1,2}\.\d{1,2}\.\d{1}\.\d{1}\.\d{1,3} (e.g. E1.23.45.67.8.9.0)
	local e1, e2 = id:match( '^E([1-8])%.(%d%d?)%.%d%d?%.%d%d?%.%d%.%d%.%d%d?%d?$' )
	if not e1 then
		return false
	end
	local TEnum = 'TEe0'..e1 --no formatter URL in WD, probably due to this complexity
	if e1 == '5' or e1 == '7' then
		if #e2 == 1 then e2 = '0'..e2 end
		TEnum = TEnum..e2
	end
	return '[http://www.unifr.ch/ifaa/Public/EntryPage/ViewTE/'..TEnum..'.html '..id..']'..p.getCatForId( 'TE' )
end

function p.tepapaLink( id )
	--P3544's format regex: \d+ (e.g. 1)
	if not id:match( '^%d+$' ) then
		return false
	end
	return '[https://collections.tepapa.govt.nz/agent/'..id..' '..id..']'..p.getCatForId( 'TePapa' )
end

function p.thLink( id )
	--P1694's format regex: H\d\.\d{2}\.\d{2}\.\d\.\d{5} (e.g. H1.23.45.6.78901)
	local h1, h2 = id:match( '^H(%d)%.(%d%d)%.%d%d%.%d%.%d%d%d%d%d$' )
	if not h1 then
		return false
	end
	local THnum = 'THh'..h1..h2 --no formatter URL in WD, probably due to this complexity
	return '[http://www.unifr.ch/ifaa/Public/EntryPage/ViewTH/'..THnum..'.html '..id..']'..p.getCatForId( 'TH' )
end

function p.tlsLink( id )
	local id2 = id:gsub(' +', '_')
	--P1362's format regex: \p{Lu}[\p{L}\d_',\.\-\(\)\*/–]{3,59} (e.g. Abcd)
	local class = "[%a%d_',%.%-%(%)%*/–]"
	local regex = "^%u"..string.rep(class, 3)..string.rep(class.."?", 56).."$"
	if not mw.ustring.match( id2, regex ) then
		return false
	end
	return '[http://tls.theaterwissenschaft.ch/wiki/'..id2..' '..id..']'..p.getCatForId( 'TLS' ) --no https as of 9/2019
end

function p.troveLink( id )
	--P1315's format regex: [1-9]\d{5,7} (e.g. 12345678)
	if not id:match( '^[1-9]%d%d%d%d%d%d?%d?$' ) then
		return false
	end
	return '[https://trove.nla.gov.au/people/'..id..' '..id..']'..p.getCatForId( 'Trove' )
end

function p.ulanLink( id )
	--P245's format regex: 500\d{6} (e.g. 500123456)
	if not id:match( '^500%d%d%d%d%d%d$' ) then
		return false
	end
	return '[https://www.getty.edu/vow/ULANFullDisplay?find=&amp;role=&amp;nation=&amp;subjectid='..id..' '..id..']'..p.getCatForId( 'ULAN' )
end

function p.uscongressLink( id )
	--P1157's format regex: [A-Z]00[01]\d{3} (e.g. A000123)
	if not id:match( '^[A-Z]00[01]%d%d%d$' ) then
		return false
	end
	return '[http://bioguide.congress.gov/scripts/biodisplay.pl?index='..id..' '..id..']'..p.getCatForId( 'USCongress' ) --no https as of 9/2019
end

function p.viafLink( id )
	--P214's format regex: [1-9]\d(\d{0,7}|\d{17,20}) (e.g. 123456789, 1234567890123456789012)
	if not id:match( '^[1-9]%d%d?%d?%d?%d?%d?%d?%d?$' ) and
	   not id:match( '^[1-9]%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d?%d?%d?$' ) then
		return false
	end
	return '[https://viaf.org/viaf/'..id..' '..id..']'..p.getCatForId( 'VIAF' )
end

--[[=========================== Helper functions =============================]]

function p.append(str, c, length)
	while str:len() &lt; length do
		str = c .. str
	end
	return str
end

--Returns the ISNI check digit isni must be a string where the 15 first elements are digits, e.g. 0000000066534145
function p.getIsniCheckDigit( isni )
	local total = 0
	for i = 1, 15 do
		local digit = isni:byte( i ) - 48 --Get integer value
		total = (total + digit) * 2
	end
	local remainder = total % 11
	local result = (12 - remainder) % 11
	if result == 10 then
		return "X"
	end
	return tostring( result )
end

--Validate ISNI (and ORCID) and retuns it as a 16 characters string or returns false if it's invalid
--See http://support.orcid.org/knowledgebase/articles/116780-structure-of-the-orcid-identifier
function p.validateIsni( id )
	--P213 (ISNI) format regex: [0-9]{4} [0-9]{4} [0-9]{4} [0-9]{3}[0-9X] (e.g. 0000-0000-6653-4145)
	--P496 (ORCID) format regex: 0000-000(1-[5-9]|2-[0-9]|3-[0-4])\d{3}-\d{3}[\dX] (e.g. 0000-0002-7398-5483)
	id = id:gsub( '[ %-]', '' ):upper()
	if not id:match( '^%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d[%dX]$' ) then
		return false
	end
	if p.getIsniCheckDigit( id ) ~= string.char( id:byte( 16 ) ) then
		return false
	end
	return id
end

function p.splitLccn( id )
	--P244's format regex: (n|nb|nr|no|ns|sh)([4-9][0-9]|00|20[0-1][0-9])[0-9]{6} (e.g. n78039510)
	if id:match( '^%l%l?%l?%d%d%d%d%d%d%d%d%d?%d?$' ) then
		id = id:gsub( '^(%l+)(%d+)(%d%d%d%d%d%d)$', '%1/%2/%3' )
	end
	if id:match( '^%l%l?%l?/%d%d%d?%d?/%d+$' ) then
		return mw.text.split( id, '/' )
	end
	return false
end

--[[==========================================================================]]
--[[          Wikidata, navigation bar, and documentation functions           ]]
--[[==========================================================================]]

function p.getIdsFromWikidata( itemId, property )
	local ids = {}
	local statements = mw.wikibase.getBestStatements( itemId, property )
	if statements then
		for _, statement in ipairs( statements ) do
			if statement.mainsnak.datavalue then
				table.insert( ids, statement.mainsnak.datavalue.value )
			end
		end
	end
	return ids
end

function p.matchesWikidataRequirements( itemId, reqs )
	for _, group in ipairs( reqs ) do
		local property = 'P'..group[1]
		local qid = group[2]
		local statements = mw.wikibase.getBestStatements( itemId, property )
		if statements then
			for _, statement in ipairs( statements ) do
				if statement.mainsnak.datavalue then
					if statement.mainsnak.datavalue.value['numeric-id'] == qid then
						return true
	end	end	end	end	end
	return false
end

function p.createRow( id, label, rawValue, link, withUid, specialCat )
	if link then
		if withUid then
			return '*&lt;span class="nowrap"&gt;'..label..' &lt;span class="uid"&gt;'..link..'&lt;/span&gt;&lt;/span&gt;\n'
		end
		return '*&lt;span class="nowrap"&gt;'..label..' '..link..'&lt;/span&gt;\n'
	end

	local catName = 'Wikipedia articles with faulty '..(specialCat or id)..' identifiers'
	return '* &lt;span class="error"&gt;The '..id..' id '..rawValue..' is not valid.&lt;/span&gt;[[Category:'..catName..']]'..p.redCatLink(catName)..'\n'
end

-- Creates a human-readable standalone wikitable version of p.conf, and tracking categories with page counts, for use in the documentation
function p.docConfTable( frame )
	local wikiTable = '{| class="wikitable sortable"\n'..
					  '! rowspan=2 | Parameter\n'..
					  '! rowspan=2 | Label\n'..
					  '! rowspan=2; data-sort-type=number | Wikidata property\n'..
					  '! colspan=4 | Tracking categories and page counts\n'..
					  '|-\n'..
					  '! [[:Category:Wikipedia articles with authority control information|'..       'Articles]]\n'..
					  '! [[:Category:User pages with authority control information|'..               'User pages]]\n'..
					  '! [[:Category:Miscellaneous pages with authority control information|'..      'Misc. pages]]\n'..
					  '! [[:Category:Wikipedia articles with faulty authority control information|'..'Faulty IDs]]\n'..
					  '|-\n'
	
	local lang = mw.getContentLanguage()
	for _, conf in pairs( p.conf ) do
		local param, link, pid = conf[1], conf[2], conf[3]
		local category = conf.category or param
		local args = { id = 'f', pid }
		local wpl = frame:expandTemplate{ title = 'Wikidata property link', args = args }
		--cats
		local articleCat = 'Wikipedia articles with '..category..' identifiers'
		local userCat =    'User pages with '..category..' identifiers'
		local miscCat =    'Miscellaneous pages with '..category..' identifiers'
		local faultyCat =  'Wikipedia articles with faulty '..category..' identifiers'
		--counts
		local articleCount = lang:formatNum( mw.site.stats.pagesInCategory(articleCat, 'pages') )
		local userCount =    lang:formatNum( mw.site.stats.pagesInCategory(userCat, 'pages') )
		local miscCount =    lang:formatNum( mw.site.stats.pagesInCategory(miscCat, 'pages') )
		local faultyCount =  lang:formatNum( mw.site.stats.pagesInCategory(faultyCat, 'pages') )
		--concat
		wikiTable = wikiTable..'\n'..
					'|-\n'..
					'||'..param..
					'||'..link..
					'||data-sort-value='..pid..'|'..wpl..
					'||style="text-align: right;"|[[:Category:'..articleCat..'|'..articleCount..']]'..
					'||style="text-align: right;"|[[:Category:'..   userCat..'|'..   userCount..']]'..
					'||style="text-align: right;"|[[:Category:'..   miscCat..'|'..   miscCount..']]'..
					'||style="text-align: right;"|[[:Category:'.. faultyCat..'|'.. faultyCount..']]'
	end
	return wikiTable..'\n|}'
end

--[[==========================================================================]]
--[[                              Configuration                               ]]
--[[==========================================================================]]

-- If a specific "(identifier) redirect" exists for an identifier, please route through this particular redirect rather than linking directly to the target page. This reduces clutter in "What links here" and improves reverse lookup of articles where a manifestation of this particular identifier is used.

-- Check that the Wikidata item has this property--&gt;value before adding it
local reqs = {}

-- Parameter format: { 'parameter name', 'label', propertyId # in Wikidata, formatting/validation function }
p.conf = {
	{ 'AAG', '[[Auckland Art Gallery Toi o Tāmaki|AAG]]', 3372, p.aagLink },
	{ 'ACM-DL', '[[ACM Digital Library|ACM DL]]', 864, p.acmLink },
	{ 'ADB', '[[Australian Dictionary of Biography|ADB]]', 1907, p.adbLink },
	{ 'AGSA', '[[Art Gallery of South Australia|AGSA]]', 6804, p.agsaLink },
	{ 'autores.uy', '[[autores.uy]]', 2558, p.autoresuyLink },
	{ 'AWR', '[[Australian Women\'s Register|AWR]]', 4186, p.awrLink },
	{ 'BALaT', '[[Royal Institute for Cultural Heritage#Online artworks pages|BALaT]]', 3293, p.balatLink },
	{ 'BIBSYS', '[[Bibsys|BIBSYS]]', 1015, p.bibsysLink },
	{ 'Bildindex', '[[Marburg Picture Index|Bildindex]]', 2092, p.bildLink },
	{ 'BNC', '[[Biblioteca Nacional de Chile|BNC]]', 1890, p.bncLink },
	{ 'BNE', '[[Biblioteca Nacional de España|BNE]]', 950, p.bneLink },
	{ 'BNF', '[[BNF (identifier)|BNF]]', 268, p.bnfLink },
	{ 'Botanist', '[[Author citation (botany)|Botanist]]', 428, p.botanistLink },
	{ 'BPN', '[[Biografisch Portaal|BPN]]', 651, p.bpnLink },
	{ 'CANTIC', '[[Name and Title Authority File of Catalonia|CANTIC]]', 1273, p.canticLink },
	{ 'CINII', '[[CiNii (identifier)|CiNii]]', 271, p.ciniiLink },
	{ 'DAAO', '[[Dictionary of Australian Artists|DAAO]]', 1707, p.daaoLink },
	{ 'DBLP', '[[DBLP]]', 2456, p.dblpLink },
	{ 'DSI', '[[Stuttgart Database of Scientific Illustrators 1450–1950|DSI]]', 2349, p.dsiLink },
	{ 'FNZA', '[[:d:Property:P6792|FNZA]]', 6792, p.fnzaLink },
	{ 'GND', '[[GND (identifier)|GND]]', 227, p.gndLink },
	{ 'HDS', '[[Historical Dictionary of Switzerland|HDS]]', 902, p.hdsLink },
	{ 'IAAF', '[[World Athletics]]', 1146, p.iaafLink },
	{ 'ICIA', '[[Information Center for Israeli Art|ICIA]]', 1736, p.iciaLink },
	{ 'ISNI', '[[ISNI (identifier)|ISNI]]', 213, p.isniLink },
	{ 'Joconde', '[[Joconde]]' , 347, p.jocondeLink },
	{ 'KULTURNAV', '[[KulturNav]]', 1248, p.kulturnavLink },
	{ 'LCCN', '[[LCCN (identifier)|LCCN]]', 244, p.lccnLink },
	{ 'LIR', '[[Historical Dictionary of Switzerland#Lexicon_Istoric_Retic|LIR]]', 886, p.lirLink },
	{ 'LNB', '[[National Library of Latvia|LNB]]', 1368, p.lnbLink },
	{ 'Léonore', '[[Base Léonore|Léonore]]', 640, p.leonoreLink },
	{ 'MBA', '[[MusicBrainz]]', 434, p.mbaLink, category = 'MusicBrainz' }, --special category name
	{ 'MBAREA', '[[MusicBrainz]]', 982, p.mbareaLink, category = 'MusicBrainz area' }, --special category name
	{ 'MBI', '[[MusicBrainz]]', 1330, p.mbiLink, category = 'MusicBrainz instrument' }, --special category name
	{ 'MBL', '[[MusicBrainz]]', 966, p.mblLink, category = 'MusicBrainz label' }, --special category name
	{ 'MBP', '[[MusicBrainz]]', 1004, p.mbpLink, category = 'MusicBrainz place' }, --special category name
	{ 'MBRG', '[[MusicBrainz]] release group', 436, p.mbrgLink, category = 'MusicBrainz release group' }, --special category name
	{ 'MBS', '[[MusicBrainz]]', 1407, p.mbsLink, category = 'MusicBrainz series' }, --special category name
	{ 'MBW', '[[MusicBrainz]] work', 435, p.mbwLink, category = 'MusicBrainz work' }, --special category name
	{ 'MGP', '[[Mathematics Genealogy Project|MGP]]', 549, p.mgpLink },
	{ 'NARA', '[[National Archives and Records Administration|NARA]]', 1225, p.naraLink },
	{ 'NCL', '[[National Central Library|NCL]]', 1048, p.nclLink },
	{ 'NDL', '[[National Diet Library|NDL]]', 349, p.ndlLink },
	{ 'NGV', '[[National Gallery of Victoria|NGV]]', 2041, p.ngvLink },
	{ 'NKC', '[[National Library of the Czech Republic|NKC]]', 691, p.nkcLink },
	{ 'NLA', '[[National Library of Australia|NLA]]', 409, p.nlaLink },
	{ 'NLG', '[[National Library of Greece|NLG]]', 3348, p.nlgLink },
	{ 'NLI', '[[National Library of Israel|NLI]]', 949, p.nliLink },
	{ 'NLK', '[[National Library of Korea|NLK]]', 5034, p.nlkLink },
	{ 'NLP', '[[National Library of Poland|NLP]]', 1695, p.nlpLink },
	{ 'NLR', '[[National Library of Romania|NLR]]', 1003, p.nlrLink },
	{ 'NSK', '[[National and University Library in Zagreb|NSK]]', 1375, p.nskLink },
	{ 'NTA', '[[Royal Library of the Netherlands|NTA]]', 1006, p.ntaLink },
	{ 'ORCID', '[[ORCID (identifier)|ORCID]]', 496, p.orcidLink },
	{ 'PIC', '[[:d:Q23892012|PIC]]', 2750, p.picLink },
	{ 'RID', '[[ResearcherID]]', 1053, p.ridLink },
	{ 'RERO', '[[RERO (Library Network of Western Switzerland)|RERO]]', 3065, p.reroLink },
	{ 'RKDartists', '[[Netherlands Institute for Art History#Online artist pages|RKD]]', 650, p.rkdartistsLink },
	{ 'RKDID', '[[:d:Q17299580|RKDimages ID]]', 350, p.rkdidLink },
	{ 'RSL', '[[Russian State Library|RSL]]', 947, p.rslLink },
	{ 'SBN', '[[ICCU (identifier)|ICCU]]', 396, p.sbnLink },
	{ 'SELIBR', '[[SELIBR (identifier)|SELIBR]]', 906, p.selibrLink },
	{ 'SIKART', '[[SIKART]]', 781, p.sikartLink },
	{ 'SNAC-ID', '[[SNAC]]', 3430, p.snacLink },
	{ 'SUDOC', '[[SUDOC (identifier)|SUDOC]]', 269, p.sudocLink },
	{ 'S2AuthorId', '[[Semantic Scholar|S2AuthorId]]', 4012, p.s2authoridLink, category = 'Semantic Scholar author' }, --special category name
	{ 'TA98', '[[Terminologia Anatomica|TA98]]', 1323, p.ta98Link },
	{ 'TDVİA', '[[:d:Q21527102|TDVİA]]', 7314, p.tdviaLink },
	{ 'TE', '[[Terminologia Embryologica|TE]]', 1693, p.teLink },
	{ 'TePapa', '[[Museum of New Zealand Te Papa Tongarewa|TePapa]]', 3544, p.tepapaLink },
	{ 'TH', '[[Terminologia Histologica|TH]]', 1694, p.thLink },
	{ 'TLS', '[[Theaterlexikon der Schweiz|TLS]]', 1362, p.tlsLink },
	{ 'Trove', '[[Trove]]', 1315, p.troveLink }, --formerly NLA-person
	{ 'ULAN', '[[Union List of Artist Names|ULAN]]', 245, p.ulanLink },
	{ 'USCongress', '[[Biographical Directory of the United States Congress|US Congress]]', 1157, p.uscongressLink },
	{ 'VIAF', '[[VIAF (identifier)|VIAF]]', 214, p.viafLink },
	{ 'WORLDCATID', '[[WorldCat Identities]]', 7859, nil },
}

-- Legitimate aliases to p.conf, for convenience
-- Format: { 'alias', 'parameter name in p.conf' }
p.aliases = {
	{ 'RLS', 'RSL' },
	{ 'MusicBrainz', 'MBA' },
	{ 'MusicBrainz artist', 'MBA' },
	{ 'MusicBrainz label', 'MBL' },
	{ 'MusicBrainz release group', 'MBRG' },
	{ 'MusicBrainz work', 'MBW' },
	{ 'Leonore', 'Léonore' },
	{ 'TDVIA', 'TDVİA' },
}

-- Deprecated aliases to p.conf; tracked in [[Category:Wikipedia articles with deprecated authority control identifiers]]
-- Format: { 'deprecated parameter name', 'replacement parameter name in p.conf' }
p.deprecated = {
	{ 'GKD', 'GND' },
	{ 'PND', 'GND' },
	{ 'SWD', 'GND' },
	{ 'NARA-organization', 'NARA' },
	{ 'NARA-person', 'NARA' },
}

--[[==========================================================================]]
--[[                                   Main                                   ]]
--[[==========================================================================]]

function p.authorityControl( frame )
	local resolveEntity = require( "Module:ResolveEntityId" )
	local parentArgs = frame:getParent().args
	local elements = {} --create/insert rows later
	local worldcatCat = ''
	local suppressedIdCat = ''
	local deprecatedIdCat = ''
	
	--Redirect aliases to proper parameter names
	for _, a in pairs( p.aliases ) do
		local alias, param = a[1], a[2]
		if (parentArgs[param] == nil or parentArgs[param] == '') and parentArgs[alias] then
			parentArgs[param] = parentArgs[alias]
		end
	end
	
	--Redirect deprecated parameters to proper parameter names, and assign tracking cat
	for _, d in pairs( p.deprecated ) do
		local dep, param = d[1], d[2]
		if (parentArgs[param] == nil or parentArgs[param] == '') and parentArgs[dep] then
			parentArgs[param] = parentArgs[dep]
			if namespace == 0 then
				deprecatedIdCat = '[[Category:Wikipedia articles with deprecated authority control identifiers|'..dep..']]'
			end
		end
	end
	
	--Use QID= parameter for testing/example purposes only
	local itemId = nil
	if namespace ~= 0 then
		local qid = parentArgs['qid'] or parentArgs['QID']
		if qid then
			itemId = 'Q'..mw.ustring.gsub(qid, '^[Qq]', '')
			itemId = resolveEntity._id(itemId) --nil if unresolvable
		end
	else
		itemId = mw.wikibase.getEntityIdForCurrentPage()
	end
	
	--Wikidata fallback if requested
	if itemId then
		for _, params in ipairs( p.conf ) do
			if params[3] &gt; 0 then
				local val = parentArgs[params[1]]
				if val == nil or val == '' then
					local canUseWikidata = nil
					if reqs[params[1]] then
						canUseWikidata = p.matchesWikidataRequirements( itemId, reqs[params[1]] )
					else
						canUseWikidata = true
					end
					if canUseWikidata then
						local wikidataIds = p.getIdsFromWikidata( itemId, 'P'..params[3] )
						if wikidataIds[1] then
							if val == '' and (namespace == 0 or testcases) then
								suppressedIdCat = '[[Category:Wikipedia articles with suppressed authority control identifiers|'..params[1]..']]'
							else
								parentArgs[params[1]] = wikidataIds[1]
	end	end	end	end	end	end	end
	
	--Configured rows
	local rct = 0
	for _, params in ipairs( p.conf ) do
		local val = parentArgs[params[1]]
		if val and val ~= '' and type(params[4]) == 'function' then
			table.insert( elements, p.createRow( params[1], params[2]..':', val, params[4]( val ), true, params.category ) )
			rct = rct + 1
		end
	end
	
	--WorldCat
	local worldcatId = parentArgs['WORLDCATID']
	if worldcatId and worldcatId ~= '' then --if present &amp; unsuppressed
		table.insert( elements, p.createRow( 'WORLDCATID', '', worldcatId, '[[WorldCat Identities]]: [https://www.worldcat.org/identities/'..mw.uri.encode(worldcatId, 'PATH')..' '..worldcatId..']', false ) ) --Validation?
		worldcatCat = '[[Category:Wikipedia articles with WorldCat identifiers]]'
	elseif worldcatId == nil then --if absent &amp; unsuppressed
		local viafId = parentArgs['VIAF']
		local lccnId = parentArgs['LCCN']
                if lccnId and lccnId ~= '' and p.lccnLink( lccnId ) then --LCCN must be present, unsuppressed, &amp; validated
			local lccnParts = p.splitLccn( lccnId )
			if lccnParts and lccnParts[1] ~= 'sh' then
				local lccnIdFmtd = lccnParts[1]..lccnParts[2]..'-'..lccnParts[3]
				table.insert( elements, p.createRow( 'LCCN', '', lccnId, '[[WorldCat Identities]] (via LCCN): [https://www.worldcat.org/identities/lccn-'..lccnIdFmtd..' '..lccnIdFmtd..']', false ) )
				if namespace == 0 then
					worldcatCat = '[[Category:Wikipedia articles with WorldCat-LCCN identifiers]]'
				end
			end
		end
	elseif worldcatId == '' then --if suppressed
		suppressedIdCat = '[[Category:Wikipedia articles with suppressed authority control identifiers|WORLDCATID]]'
	end
	
	local Navbox = require('Module:Navbox')
	local elementsCat = ''
	if rct &gt;= 25 then
		local eCat = 'AC with '..rct..' elements'
		elementsCat  = '[[Category:'..eCat..']]'..p.redCatLink(eCat)
	end
	
	local outString = ''
	if #elements &gt; 0 then
		local args = {}
		if testcases and itemId then args = { qid = itemId } end --expensive
		local pencil = frame:expandTemplate{ title = 'EditAtWikidata', args = args}
		outString = Navbox._navbox( {
			name  = 'Authority control',
			navboxclass = 'authority-control',
			bodyclass = 'hlist',
			group1 = '[[Help:Authority control|Authority control]]'..pencil,
			list1 = table.concat( elements )
			} )
		local auxCats = worldcatCat .. elementsCat .. suppressedIdCat .. deprecatedIdCat
		if testcases then
			auxCats = mw.ustring.gsub(auxCats, '(%[%[)(Category)', '%1:%2') --for easier checking
		end
		outString = outString .. auxCats
		if namespace ~= 0 then
			outString = mw.ustring.gsub(outString, '(%[%[)(Category:Wikipedia articles)', '%1:%2') --by definition
		end
	end
	
	return outString
end

return p</text>
      <sha1>9xmrut3ts9fi0ijsr2g2w8eq2jyyewc</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler</title>
    <ns>828</ns>
    <id>39772274</id>
    <revision>
      <id>948472489</id>
      <parentid>948472486</parentid>
      <timestamp>2020-04-01T06:12:40Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="7871" xml:space="preserve">--------------------------------------------------------------------------------
--                                                                            --
--                              CATEGORY HANDLER                              --
--                                                                            --
--      This module implements the {{category handler}} template in Lua,      --
--      with a few improvements: all namespaces and all namespace aliases     --
--      are supported, and namespace names are detected automatically for     --
--      the local wiki. This module requires [[Module:Namespace detect]]      --
--      and [[Module:Yesno]] to be available on the local wiki. It can be     --
--      configured for different wikis by altering the values in              --
--      [[Module:Category handler/config]], and pages can be blacklisted      --
--      from categorisation by using [[Module:Category handler/blacklist]].   --
--                                                                            --
--------------------------------------------------------------------------------

-- Load required modules
local yesno = require('Module:Yesno')

-- Lazily load things we don't always need
local mShared, mappings

local p = {}

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function trimWhitespace(s, removeBlanks)
	if type(s) ~= 'string' then
		return s
	end
	s = s:match('^%s*(.-)%s*$')
	if removeBlanks then
		if s ~= '' then
			return s
		else
			return nil
		end
	else
		return s
	end
end

--------------------------------------------------------------------------------
-- CategoryHandler class
--------------------------------------------------------------------------------

local CategoryHandler = {}
CategoryHandler.__index = CategoryHandler

function CategoryHandler.new(data, args)
	local obj = setmetatable({ _data = data, _args = args }, CategoryHandler)
	
	-- Set the title object
	do
		local pagename = obj:parameter('demopage')
		local success, titleObj
		if pagename then
			success, titleObj = pcall(mw.title.new, pagename)
		end
		if success and titleObj then
			obj.title = titleObj
			if titleObj == mw.title.getCurrentTitle() then
				obj._usesCurrentTitle = true
			end
		else
			obj.title = mw.title.getCurrentTitle()
			obj._usesCurrentTitle = true
		end
	end

	-- Set suppression parameter values
	for _, key in ipairs{'nocat', 'categories'} do
		local value = obj:parameter(key)
		value = trimWhitespace(value, true)
		obj['_' .. key] = yesno(value)
	end
	do
		local subpage = obj:parameter('subpage')
		local category2 = obj:parameter('category2')
		if type(subpage) == 'string' then
			subpage = mw.ustring.lower(subpage)
		end
		if type(category2) == 'string' then
			subpage = mw.ustring.lower(category2)
		end
		obj._subpage = trimWhitespace(subpage, true)
		obj._category2 = trimWhitespace(category2) -- don't remove blank values
	end
	return obj
end

function CategoryHandler:parameter(key)
	local parameterNames = self._data.parameters[key]
	local pntype = type(parameterNames)
	if pntype == 'string' or pntype == 'number' then
		return self._args[parameterNames]
	elseif pntype == 'table' then
		for _, name in ipairs(parameterNames) do
			local value = self._args[name]
			if value ~= nil then
				return value
			end
		end
		return nil
	else
		error(string.format(
			'invalid config key "%s"',
			tostring(key)
		), 2)
	end
end

function CategoryHandler:isSuppressedByArguments()
	return
		-- See if a category suppression argument has been set.
		self._nocat == true
		or self._categories == false
		or (
			self._category2
			and self._category2 ~= self._data.category2Yes
			and self._category2 ~= self._data.category2Negative
		)

		-- Check whether we are on a subpage, and see if categories are
		-- suppressed based on our subpage status.
		or self._subpage == self._data.subpageNo and self.title.isSubpage
		or self._subpage == self._data.subpageOnly and not self.title.isSubpage
end

function CategoryHandler:shouldSkipBlacklistCheck()
	-- Check whether the category suppression arguments indicate we
	-- should skip the blacklist check.
	return self._nocat == false
		or self._categories == true
		or self._category2 == self._data.category2Yes
end

function CategoryHandler:matchesBlacklist()
	if self._usesCurrentTitle then
		return self._data.currentTitleMatchesBlacklist
	else
		mShared = mShared or require('Module:Category handler/shared')
		return mShared.matchesBlacklist(
			self.title.prefixedText,
			mw.loadData('Module:Category handler/blacklist')
		)
	end
end

function CategoryHandler:isSuppressed()
	-- Find if categories are suppressed by either the arguments or by
	-- matching the blacklist.
	return self:isSuppressedByArguments()
		or not self:shouldSkipBlacklistCheck() and self:matchesBlacklist()
end

function CategoryHandler:getNamespaceParameters()
	if self._usesCurrentTitle then
		return self._data.currentTitleNamespaceParameters
	else
		if not mappings then
			mShared = mShared or require('Module:Category handler/shared')
			mappings = mShared.getParamMappings(true) -- gets mappings with mw.loadData
		end
		return mShared.getNamespaceParameters(
			self.title,
			mappings
		)
	end
end

function CategoryHandler:namespaceParametersExist()
	-- Find whether any namespace parameters have been specified.
	-- We use the order "all" --&gt; namespace params --&gt; "other" as this is what
	-- the old template did.
	if self:parameter('all') then
		return true
	end
	if not mappings then
		mShared = mShared or require('Module:Category handler/shared')
		mappings = mShared.getParamMappings(true) -- gets mappings with mw.loadData
	end
	for ns, params in pairs(mappings) do
		for i, param in ipairs(params) do
			if self._args[param] then
				return true
			end
		end
	end
	if self:parameter('other') then
		return true
	end
	return false
end

function CategoryHandler:getCategories()
	local params = self:getNamespaceParameters()
	local nsCategory
	for i, param in ipairs(params) do
		local value = self._args[param]
		if value ~= nil then
			nsCategory = value
			break
		end
	end
	if nsCategory ~= nil or self:namespaceParametersExist() then
		-- Namespace parameters exist - advanced usage.
		if nsCategory == nil then
			nsCategory = self:parameter('other')
		end
		local ret = {self:parameter('all')}
		local numParam = tonumber(nsCategory)
		if numParam and numParam &gt;= 1 and math.floor(numParam) == numParam then
			-- nsCategory is an integer
			ret[#ret + 1] = self._args[numParam]
		else
			ret[#ret + 1] = nsCategory
		end
		if #ret &lt; 1 then
			return nil
		else
			return table.concat(ret)
		end
	elseif self._data.defaultNamespaces[self.title.namespace] then
		-- Namespace parameters don't exist, simple usage.
		return self._args[1]
	end
	return nil
end

--------------------------------------------------------------------------------
-- Exports
--------------------------------------------------------------------------------

local p = {}

function p._exportClasses()
	-- Used for testing purposes.
	return {
		CategoryHandler = CategoryHandler
	}
end

function p._main(args, data)
	data = data or mw.loadData('Module:Category handler/data')
	local handler = CategoryHandler.new(data, args)
	if handler:isSuppressed() then
		return nil
	end
	return handler:getCategories()
end

function p.main(frame, data)
	data = data or mw.loadData('Module:Category handler/data')
	local args = require('Module:Arguments').getArgs(frame, {
		wrappers = data.wrappers,
		valueFunc = function (k, v)
			v = trimWhitespace(v)
			if type(k) == 'number' then
				if v ~= '' then
					return v
				else
					return nil
				end
			else
				return v
			end
		end
	})
	return p._main(args, data)
end

return p</text>
      <sha1>letwavu3yvlayfzew66uuwixmwebq5b</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler/blacklist</title>
    <ns>828</ns>
    <id>43232926</id>
    <revision>
      <id>951673917</id>
      <parentid>948472491</parentid>
      <timestamp>2020-04-18T08:48:05Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <comment>Per category talk page</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="761" xml:space="preserve">-- This module contains the blacklist used by [[Module:Category handler]].
-- Pages that match Lua patterns in this list will not be categorised unless
-- categorisation is explicitly requested.

return {
	'^Main Page$', -- don't categorise the main page.

	-- Don't categorise the following pages or their subpages.
	-- "%f[/\0]" matches if the next character is "/" or the end of the string.
	'^Wikipedia:Cascade%-protected items%f[/\0]',
	'^User:UBX%f[/\0]', -- The userbox "template" space.
	'^User talk:UBX%f[/\0]',

	-- Don't categorise subpages of these pages, but allow
	-- categorisation of the base page.
	'^Wikipedia:Template index/.*$',

	-- Don't categorise archives.
	'/[aA]rchive',
	"^Wikipedia:Administrators' noticeboard/IncidentArchive%d+$",
}</text>
      <sha1>fsv1drcay6t25e91hzhqxtyp7pckbpx</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler/config</title>
    <ns>828</ns>
    <id>42291997</id>
    <revision>
      <id>948472494</id>
      <parentid>894414603</parentid>
      <timestamp>2020-04-01T06:12:40Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5755" xml:space="preserve">--------------------------------------------------------------------------------
--            [[Module:Category handler]] configuration data                  --
--       Language-specific parameter names and values can be set here.        --
--       For blacklist config, see [[Module:Category handler/blacklist]].     --
--------------------------------------------------------------------------------

local cfg = {} -- Don't edit this line.

--------------------------------------------------------------------------------
--                       Start configuration data                             --
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--                              Parameter names                               --
-- These configuration items specify custom parameter names.                  --
-- To add one extra name, you can use this format:                            --
--                                                                            --
-- foo = 'parameter name',                                                    --
--                                                                            --
-- To add multiple names, you can use this format:                            --
--                                                                            --
-- foo = {'parameter name 1', 'parameter name 2', 'parameter name 3'},        --
--------------------------------------------------------------------------------

cfg.parameters = {
	
	-- The nocat and categories parameter suppress
	-- categorisation. They are used with Module:Yesno, and work as follows:
	--
	-- cfg.nocat:
	-- Result of yesno()                        Effect
	-- true                                     Categorisation is suppressed
	-- false                                    Categorisation is allowed, and
	--                                          the blacklist check is skipped
	-- nil                                      Categorisation is allowed
	--
	-- cfg.categories:
	-- Result of yesno()                        Effect
	-- true                                     Categorisation is allowed, and
	--                                          the blacklist check is skipped
	-- false                                    Categorisation is suppressed
	-- nil                                      Categorisation is allowed
	nocat = 'nocat',
	categories = 'categories',
	
	-- The parameter name for the legacy "category2" parameter. This skips the
	-- blacklist if set to the cfg.category2Yes value, and suppresses
	-- categorisation if present but equal to anything other than
	-- cfg.category2Yes or cfg.category2Negative.
	category2 = 'category2',
	
	-- cfg.subpage is the parameter name to specify how to behave on subpages.
	subpage = 'subpage',
	
	-- The parameter for data to return in all namespaces.
	all = 'all',
	
	-- The parameter name for data to return if no data is specified for the
	-- namespace that is detected.
	other = 'other',
	
	-- The parameter name used to specify a page other than the current page;
	-- used for testing and demonstration.
	demopage = 'page',
}

--------------------------------------------------------------------------------
--                              Parameter values                              --
-- These are set values that can be used with certain parameters. Only one    --
-- value can be specified, like this:                                         --
--                                                                            --
-- cfg.foo = 'value name'                                                     --                                               --
--------------------------------------------------------------------------------

-- The following settings are used with the cfg.category2 parameter. Setting
-- cfg.category2 to cfg.category2Yes skips the blacklist, and if cfg.category2
-- is present but equal to anything other than cfg.category2Yes or
-- cfg.category2Negative then it supresses cateogrisation.
cfg.category2Yes = 'yes'
cfg.category2Negative = '¬'

-- The following settings are used with the cfg.subpage parameter.
-- cfg.subpageNo is the value to specify to not categorise on subpages;
-- cfg.subpageOnly is the value to specify to only categorise on subpages.
cfg.subpageNo = 'no'
cfg.subpageOnly = 'only'

--------------------------------------------------------------------------------
--                           Default namespaces                               --
-- This is a table of namespaces to categorise by default. The keys are the   --
-- namespace numbers.                                                         --
--------------------------------------------------------------------------------

cfg.defaultNamespaces = {
	[  0] = true, -- main
	[  6] = true, -- file
	[ 12] = true, -- help
	[ 14] = true, -- category
	[100] = true, -- portal
	[108] = true, -- book
}

--------------------------------------------------------------------------------
--                                Wrappers                                    --
-- This is a wrapper template or a list of wrapper templates to be passed to  --
-- [[Module:Arguments]].                                                      --
--------------------------------------------------------------------------------

cfg.wrappers = 'Template:Category handler'

--------------------------------------------------------------------------------
--                           End configuration data                           --
--------------------------------------------------------------------------------

return cfg -- Don't edit this line.</text>
      <sha1>6ga9hbq2pdwalsvx68i53dmbr421rq5</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler/data</title>
    <ns>828</ns>
    <id>43233647</id>
    <revision>
      <id>948472496</id>
      <parentid>894414581</parentid>
      <timestamp>2020-04-01T06:12:41Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="631" xml:space="preserve">-- This module assembles data to be passed to [[Module:Category handler]] using
-- mw.loadData. This includes the configuration data and whether the current
-- page matches the title blacklist.

local data = require('Module:Category handler/config')
local mShared = require('Module:Category handler/shared')
local blacklist = require('Module:Category handler/blacklist')
local title = mw.title.getCurrentTitle()

data.currentTitleMatchesBlacklist = mShared.matchesBlacklist(
	title.prefixedText,
	blacklist
)

data.currentTitleNamespaceParameters = mShared.getNamespaceParameters(
	title,
	mShared.getParamMappings()
)

return data</text>
      <sha1>k26mwixuaeijisfddb0sxkg82iux8v4</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler/shared</title>
    <ns>828</ns>
    <id>43232937</id>
    <revision>
      <id>948472498</id>
      <parentid>894414384</parentid>
      <timestamp>2020-04-01T06:12:41Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="888" xml:space="preserve">-- This module contains shared functions used by [[Module:Category handler]]
-- and its submodules.

local p = {}

function p.matchesBlacklist(page, blacklist)
	for i, pattern in ipairs(blacklist) do
		local match = mw.ustring.match(page, pattern)
		if match then
			return true
		end
	end
	return false
end

function p.getParamMappings(useLoadData)
	local dataPage = 'Module:Namespace detect/data'
	if useLoadData then
		return mw.loadData(dataPage).mappings
	else
		return require(dataPage).mappings
	end
end

function p.getNamespaceParameters(titleObj, mappings)
	-- We don't use title.nsText for the namespace name because it adds
	-- underscores.
	local mappingsKey
	if titleObj.isTalkPage then
		mappingsKey = 'talk'
	else
		mappingsKey = mw.site.namespaces[titleObj.namespace].name
	end
	mappingsKey = mw.ustring.lower(mappingsKey)
	return mappings[mappingsKey] or {}
end

return p</text>
      <sha1>omlsnhudxz6juptvtxz7ns97jutbzc5</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Check for unknown parameters</title>
    <ns>828</ns>
    <id>42286729</id>
    <revision>
      <id>934641291</id>
      <parentid>881505995</parentid>
      <timestamp>2020-01-07T17:25:33Z</timestamp>
      <contributor>
        <username>Gonnym</username>
        <id>14984434</id>
      </contributor>
      <comment>Added entry point for modules per talk page discussion. Report any errors on talk page.</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3153" xml:space="preserve">-- This module may be used to compare the arguments passed to the parent
-- with a list of arguments, returning a specified result if an argument is
-- not on the list
local p = {}

local function trim(s)
	return s:match('^%s*(.-)%s*$')
end

local function isnotempty(s)
	return s and s:match('%S')
end

local function clean(text)
	-- Return text cleaned for display and truncated if too long.
	-- Strip markers are replaced with dummy text representing the original wikitext.
	local pos, truncated
	local function truncate(text)
		if truncated then
			return ''
		end
		if mw.ustring.len(text) &gt; 25 then
			truncated = true
			text = mw.ustring.sub(text, 1, 25) .. '...'
		end
		return mw.text.nowiki(text)
	end
	local parts = {}
	for before, tag, remainder in text:gmatch('([^\127]*)\127[^\127]*%-(%l+)%-[^\127]*\127()') do
		pos = remainder
		table.insert(parts, truncate(before) .. '&amp;lt;' .. tag .. '&amp;gt;...&amp;lt;/' .. tag .. '&amp;gt;')
	end
	table.insert(parts, truncate(text:sub(pos or 1)))
	return table.concat(parts)
end

function p._check(args, pargs)
	if type(args) ~= "table" or type(pargs) ~= "table" then
		-- TODO: error handling
		return
	end

	local ignoreblank = isnotempty(args['ignoreblank'])
	local showblankpos = isnotempty(args['showblankpositional'])
	local knownargs = {}
	local unknown = args['unknown'] or 'Found _VALUE_, '
	local preview = args['preview']

	local values = {}
	local res = {}
	local regexps = {}

	-- create the list of known args, regular expressions, and the return string
	for k, v in pairs(args) do
		if type(k) == 'number' then
			v = trim(v)
			knownargs[v] = 1
		elseif k:find('^regexp[1-9][0-9]*$') then
			table.insert(regexps, '^' .. v .. '$')
		end
	end
	if isnotempty(preview) then
		preview = '&lt;div class="hatnote" style="color:red"&gt;&lt;strong&gt;Warning:&lt;/strong&gt; ' .. preview .. ' (this message is shown only in preview).&lt;/div&gt;'
	elseif preview == nil then
		preview = unknown
	end

	-- loop over the parent args, and make sure they are on the list
	for k, v in pairs(pargs) do
		if type(k) == 'string' and knownargs[k] == nil then
			local knownflag = false
			for _, regexp in ipairs(regexps) do
				if mw.ustring.match(k, regexp) then
					knownflag = true
					break
				end
			end
			if not knownflag and ( not ignoreblank or isnotempty(v) )  then
				table.insert(values, clean(k))
			end
		elseif type(k) == 'number' and
			knownargs[tostring(k)] == nil and
			( showblankpos or isnotempty(v) )
		then
			table.insert(values, k .. ' = ' .. clean(v))
		end
	end

	-- add results to the output tables
	if #values &gt; 0 then
		if mw.getCurrentFrame():preprocess( "{{REVISIONID}}" ) == "" then
			unknown = preview
		end
		for _, v in pairs(values) do
			if v == '' then
				-- Fix odd bug for | = which gets stripped to the empty string and
				-- breaks category links
				v = ' '
			end
			-- avoid error with v = 'example%2' ("invalid capture index")
			local r =  unknown:gsub('_VALUE_', {_VALUE_ = v})
			table.insert(res, r)
		end
	end

	return table.concat(res)
end

function p.check(frame)
	local args = frame.args
	local pargs = frame:getParent().args
	return p._check(args, pargs)
end

return p</text>
      <sha1>fai6f8jbbmvoyopkl9xbkhi5th8yqh4</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1</title>
    <ns>828</ns>
    <id>38573037</id>
    <revision>
      <id>951705319</id>
      <parentid>935243648</parentid>
      <timestamp>2020-04-18T12:50:55Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>sync from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="186750" xml:space="preserve">
--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local dates, year_date_check, reformat_dates, date_hyphen_to_dash,				-- functions in Module:Citation/CS1/Date_validation
	date_name_xlate

local is_set, in_array, substitute, error_comment, set_error, select_one,		-- functions in Module:Citation/CS1/Utilities
	add_maint_cat, wrap_style, safe_for_italics, is_wikilink, make_wikilink,
	strip_apostrophe_markup;

local z ={};																	-- tables in Module:Citation/CS1/Utilities

local extract_ids, extract_id_access_levels, build_id_list, is_embargoed;		-- functions in Module:Citation/CS1/Identifiers

local make_coins_title, get_coins_pages, COinS;									-- functions in Module:Citation/CS1/COinS

local cfg = {};																	-- table of configuration tables that are defined in Module:Citation/CS1/Configuration
local whitelist = {};															-- table of tables listing valid template parameter names; defined in Module:Citation/CS1/Whitelist


--[[--------------------------&lt; P A G E   S C O P E   V A R I A B L E S &gt;--------------------------------------

delare variables here that have page-wide scope that are not brought in from other modules; thatare created here
and used here

]]

local added_deprecated_cat;														-- boolean flag so that the category is added only once
local added_prop_cats = {};														-- list of property categories that have been added to z.properties_cats
local added_vanc_errs;															-- boolean flag so we only emit one Vancouver error / category

local Frame;																	-- holds the module's frame table


--[[--------------------------&lt; F I R S T _ S E T &gt;------------------------------------------------------------

Locates and returns the first set value in a table of values where the order established in the table,
left-to-right (or top-to-bottom), is the order in which the values are evaluated.  Returns nil if none are set.

This version replaces the original 'for _, val in pairs do' and a similar version that used ipairs.  With the pairs
version the order of evaluation could not be guaranteed.  With the ipairs version, a nil value would terminate
the for-loop before it reached the actual end of the list.

]]

local function first_set (list, count)
	local i = 1;
	while i &lt;= count do															-- loop through all items in list
		if is_set( list[i] ) then
			return list[i];														-- return the first set list member
		end
		i = i + 1;																-- point to next
	end
end


--[[--------------------------&lt; A D D _ P R O P _ C A T &gt;--------------------------------------------------------

Adds a category to z.properties_cats using names from the configuration file with additional text if any.

foreign_lang_source and foreign_lang_source_2 keys have a language code appended to them so that multiple languages
may be categorized but multiples of the same language are not categorized.

added_prop_cats is a table declared in page scope variables above

]]

local function add_prop_cat (key, arguments)
	if not added_prop_cats [key] then
		added_prop_cats [key] = true;											-- note that we've added this category
		key = key:gsub ('(foreign_lang_source_?2?)%a%a%a?[%a%-]*', '%1');		-- strip lang code from keyname
		table.insert( z.properties_cats, substitute (cfg.prop_cats [key], arguments));	-- make name then add to table
	end
end


--[[--------------------------&lt; A D D _ V A N C _ E R R O R &gt;----------------------------------------------------

Adds a single Vancouver system error message to the template's output regardless of how many error actually exist.
To prevent duplication, added_vanc_errs is nil until an error message is emitted.

added_vanc_errs is a boolean declared in page scope variables above

]]

local function add_vanc_error (source)
	if not added_vanc_errs then
		added_vanc_errs = true;													-- note that we've added this category
		table.insert( z.message_tail, { set_error( 'vancouver', {source}, true ) } );
	end
end


--[[--------------------------&lt; I S _ S C H E M E &gt;------------------------------------------------------------

does this thing that purports to be a uri scheme seem to be a valid scheme?  The scheme is checked to see if it
is in agreement with http://tools.ietf.org/html/std66#section-3.1 which says:
	Scheme names consist of a sequence of characters beginning with a
   letter and followed by any combination of letters, digits, plus
   ("+"), period ("."), or hyphen ("-").

returns true if it does, else false

]]

local function is_scheme (scheme)
	return scheme and scheme:match ('^%a[%a%d%+%.%-]*:');						-- true if scheme is set and matches the pattern
end


--[=[-------------------------&lt; I S _ D O M A I N _ N A M E &gt;--------------------------------------------------

Does this thing that purports to be a domain name seem to be a valid domain name?

Syntax defined here: http://tools.ietf.org/html/rfc1034#section-3.5
BNF defined here: https://tools.ietf.org/html/rfc4234
Single character names are generally reserved; see https://tools.ietf.org/html/draft-ietf-dnsind-iana-dns-01#page-15;
	see also [[Single-letter second-level domain]]
list of tlds: https://www.iana.org/domains/root/db

rfc952 (modified by rfc 1123) requires the first and last character of a hostname to be a letter or a digit.  Between
the first and last characters the name may use letters, digits, and the hyphen.

Also allowed are IPv4 addresses. IPv6 not supported

domain is expected to be stripped of any path so that the last character in the last character of the tld.  tld
is two or more alpha characters.  Any preceding '//' (from splitting a url with a scheme) will be stripped
here.  Perhaps not necessary but retained incase it is necessary for IPv4 dot decimal.

There are several tests:
	the first character of the whole domain name including subdomains must be a letter or a digit
	internationalized domain name (ascii characters with .xn-- ASCII Compatible Encoding (ACE) prefix xn-- in the tld) see https://tools.ietf.org/html/rfc3490
	single-letter/digit second-level domains in the .org, .cash, and .today TLDs
	q, x, and z SL domains in the .com TLD
	i and q SL domains in the .net TLD
	single-letter SL domains in the ccTLDs (where the ccTLD is two letters)
	two-character SL domains in gTLDs (where the gTLD is two or more letters)
	three-plus-character SL domains in gTLDs (where the gTLD is two or more letters)
	IPv4 dot-decimal address format; TLD not allowed

returns true if domain appears to be a proper name and tld or IPv4 address, else false

]=]

local function is_domain_name (domain)
	if not domain then
		return false;															-- if not set, abandon
	end
	
	domain = domain:gsub ('^//', '');											-- strip '//' from domain name if present; done here so we only have to do it once
	
	if not domain:match ('^[%w]') then											-- first character must be letter or digit
		return false;
	end

	if domain:match ('^%a+:') then												-- hack to detect things that look like s:Page:Title where Page: is namespace at wikisource
		return false;
	end

	local patterns = {															-- patterns that look like urls
		'%f[%w][%w][%w%-]+[%w]%.%a%a+$',										-- three or more character hostname.hostname or hostname.tld
		'%f[%w][%w][%w%-]+[%w]%.xn%-%-[%w]+$',									-- internationalized domain name with ACE prefix
		'%f[%a][qxz]%.com$',													-- assigned one character .com hostname (x.com times out 2015-12-10)
		'%f[%a][iq]%.net$',														-- assigned one character .net hostname (q.net registered but not active 2015-12-10)
		'%f[%w][%w]%.%a%a$',													-- one character hostname and cctld (2 chars)
		'%f[%w][%w][%w]%.%a%a+$',												-- two character hostname and tld
		'^%d%d?%d?%.%d%d?%d?%.%d%d?%d?%.%d%d?%d?',								-- IPv4 address
		}

	for _, pattern in ipairs (patterns) do										-- loop through the patterns list
		if domain:match (pattern) then
			return true;														-- if a match then we think that this thing that purports to be a url is a url
		end
	end

	for _, d in ipairs ({'cash', 'company', 'today', 'org'}) do					-- look for single letter second level domain names for these top level domains
		if domain:match ('%f[%w][%w]%.' .. d) then
			return true
		end
	end
	return false;																-- no matches, we don't know what this thing is
end


--[[--------------------------&lt; I S _ U R L &gt;------------------------------------------------------------------

returns true if the scheme and domain parts of a url appear to be a valid url; else false.

This function is the last step in the validation process.  This function is separate because there are cases that
are not covered by split_url(), for example is_parameter_ext_wikilink() which is looking for bracketted external
wikilinks.

]]

local function is_url (scheme, domain)
	if is_set (scheme) then														-- if scheme is set check it and domain
		return is_scheme (scheme) and is_domain_name (domain);
	else
		return is_domain_name (domain);											-- scheme not set when url is protocol relative
	end
end


--[[--------------------------&lt; S P L I T _ U R L &gt;------------------------------------------------------------

Split a url into a scheme, authority indicator, and domain.

First remove Fully Qualified Domain Name terminator (a dot following tld) (if any) and any path(/), query(?) or fragment(#).

If protocol relative url, return nil scheme and domain else return nil for both scheme and domain.

When not protocol relative, get scheme, authority indicator, and domain.  If there is an authority indicator (one
or more '/' characters immediately following the scheme's colon), make sure that there are only 2.

Strip off any port and path;

]]

local function split_url (url_str)
	local scheme, authority, domain;
	
	url_str = url_str:gsub ('([%a%d])%.?[/%?#].*$', '%1');						-- strip FQDN terminator and path(/), query(?), fragment (#) (the capture prevents false replacement of '//')

	if url_str:match ('^//%S*') then											-- if there is what appears to be a protocol relative url
		domain = url_str:match ('^//(%S*)')
	elseif url_str:match ('%S-:/*%S+') then										-- if there is what appears to be a scheme, optional authority indicator, and domain name
		scheme, authority, domain = url_str:match ('(%S-:)(/*)(%S+)');			-- extract the scheme, authority indicator, and domain portions
		authority = authority:gsub ('//', '', 1);								-- replace place 1 pair of '/' with nothing;
		if is_set(authority) then												-- if anything left (1 or 3+ '/' where authority should be) then
			return scheme;														-- return scheme only making domain nil which will cause an error message
		end
		domain = domain:gsub ('(%a):%d+', '%1');								-- strip port number if present
	end
	
	return scheme, domain;
end


--[[--------------------------&lt; L I N K _ P A R A M _ O K &gt;---------------------------------------------------

checks the content of |title-link=, |series-link=, |author-link= etc for properly formatted content: no wikilinks, no urls

Link parameters are to hold the title of a wikipedia article so none of the WP:TITLESPECIALCHARACTERS are allowed:
	# &lt; &gt; [ ] | { } _
except the underscore which is used as a space in wiki urls and # which is used for section links

returns false when the value contains any of these characters.

When there are no illegal characters, this function returns TRUE if value DOES NOT appear to be a valid url (the
|&lt;param&gt;-link= parameter is ok); else false when value appears to be a valid url (the |&lt;param&gt;-link= parameter is NOT ok).

]]

local function link_param_ok (value)
	local scheme, domain;
	if value:find ('[&lt;&gt;%[%]|{}]') then											-- if any prohibited characters
		return false;
	end

	scheme, domain = split_url (value);											-- get scheme or nil and domain or nil from url; 
	return not is_url (scheme, domain);											-- return true if value DOES NOT appear to be a valid url
end


--[[--------------------------&lt; L I N K _ T I T L E _ O K &gt;---------------------------------------------------

Use link_param_ok() to validate |&lt;param&gt;-link= value and its matching |&lt;title&gt;= value.

|&lt;title&gt;= may be wikilinked but not when |&lt;param&gt;-link= has a value.  This function emits an error message when
that condition exists

]]

local function link_title_ok (link, lorig, title, torig)
local orig;

	if is_set (link) then 														-- don't bother if &lt;param&gt;-link doesn't have a value
		if not link_param_ok (link) then										-- check |&lt;param&gt;-link= markup
			orig = lorig;														-- identify the failing link parameter
		elseif title:find ('%[%[') then											-- check |title= for wikilink markup
			orig = torig;														-- identify the failing |title= parameter
		end
	end

	if is_set (orig) then
		table.insert( z.message_tail, { set_error( 'bad_paramlink', orig)});	-- url or wikilink in |title= with |title-link=;
	end
end


--[[--------------------------&lt; C H E C K _ U R L &gt;------------------------------------------------------------

Determines whether a URL string appears to be valid.

First we test for space characters.  If any are found, return false.  Then split the url into scheme and domain
portions, or for protocol relative (//example.com) urls, just the domain.  Use is_url() to validate the two
portions of the url.  If both are valid, or for protocol relative if domain is valid, return true, else false.

Because it is different from a standard url, and because this module used external_link() to make external links
that work for standard and news: links, we validate newsgroup names here.  The specification for a newsgroup name
is at https://tools.ietf.org/html/rfc5536#section-3.1.4

]]

local function check_url( url_str )
	if nil == url_str:match ("^%S+$") then										-- if there are any spaces in |url=value it can't be a proper url
		return false;
	end
	local scheme, domain;

	scheme, domain = split_url (url_str);										-- get scheme or nil and domain or nil from url;
	
	if 'news:' == scheme then													-- special case for newsgroups
		return domain:match('^[%a%d%+%-_]+%.[%a%d%+%-_%.]*[%a%d%+%-_]$');
	end
	
	return is_url (scheme, domain);												-- return true if value appears to be a valid url
end


--[=[-------------------------&lt; I S _ P A R A M E T E R _ E X T _ W I K I L I N K &gt;----------------------------

Return true if a parameter value has a string that begins and ends with square brackets [ and ] and the first
non-space characters following the opening bracket appear to be a url.  The test will also find external wikilinks
that use protocol relative urls. Also finds bare urls.

The frontier pattern prevents a match on interwiki links which are similar to scheme:path urls.  The tests that
find bracketed urls are required because the parameters that call this test (currently |title=, |chapter=, |work=,
and |publisher=) may have wikilinks and there are articles or redirects like '//Hus' so, while uncommon, |title=[[//Hus]]
is possible as might be [[en://Hus]].

]=]

local function is_parameter_ext_wikilink (value)
local scheme, domain;

	if value:match ('%f[%[]%[%a%S*:%S+.*%]') then								-- if ext wikilink with scheme and domain: [xxxx://yyyyy.zzz]
		scheme, domain = split_url (value:match ('%f[%[]%[(%a%S*:%S+).*%]'));
	elseif value:match ('%f[%[]%[//%S+.*%]') then								-- if protocol relative ext wikilink: [//yyyyy.zzz]
		scheme, domain = split_url (value:match ('%f[%[]%[(//%S+).*%]'));
	elseif value:match ('%a%S*:%S+') then										-- if bare url with scheme; may have leading or trailing plain text
		scheme, domain = split_url (value:match ('(%a%S*:%S+)'));
	elseif value:match ('//%S+') then											-- if protocol relative bare url: //yyyyy.zzz; may have leading or trailing plain text
		scheme, domain = split_url (value:match ('(//%S+)'));					-- what is left should be the domain
	else
		return false;															-- didn't find anything that is obviously a url
	end

	return is_url (scheme, domain);												-- return true if value appears to be a valid url
end


--[[-------------------------&lt; C H E C K _ F O R _ U R L &gt;-----------------------------------------------------

loop through a list of parameters and their values.  Look at the value and if it has an external link, emit an error message.

]]

local function check_for_url (parameter_list)
local error_message = '';
	for k, v in pairs (parameter_list) do										-- for each parameter in the list
		if is_parameter_ext_wikilink (v) then									-- look at the value; if there is a url add an error message
			if is_set(error_message) then										-- once we've added the first portion of the error message ...
				error_message=error_message .. ", ";							-- ... add a comma space separator
			end
			error_message=error_message .. "&amp;#124;" .. k .. "=";				-- add the failed parameter
		end
	end
	if is_set (error_message) then												-- done looping, if there is an error message, display it
		table.insert( z.message_tail, { set_error( 'param_has_ext_link', {error_message}, true ) } );
	end
end


--[[--------------------------&lt; S A F E _ F O R _ U R L &gt;------------------------------------------------------

Escape sequences for content that will be used for URL descriptions

]]

local function safe_for_url( str )
	if str:match( "%[%[.-%]%]" ) ~= nil then 
		table.insert( z.message_tail, { set_error( 'wikilink_in_url', {}, true ) } );
	end
	
	return str:gsub( '[%[%]\n]', {	
		['['] = '&amp;#91;',
		[']'] = '&amp;#93;',
		['\n'] = ' ' } );
end


--[[--------------------------&lt; E X T E R N A L _ L I N K &gt;----------------------------------------------------

Format an external link with error checking

]]

local function external_link( URL, label, source, access)
	local error_str = "";
	local domain;
	local path;
	local base_url;

	if not is_set( label ) then
		label = URL;
		if is_set( source ) then
			error_str = set_error( 'bare_url_missing_title', { wrap_style ('parameter', source) }, false, " " );
		else
			error( cfg.messages["bare_url_no_origin"] );
		end			
	end
	if not check_url( URL ) then
		error_str = set_error( 'bad_url', {wrap_style ('parameter', source)}, false, " " ) .. error_str;
	end
	
	domain, path = URL:match ('^([/%.%-%+:%a%d]+)([/%?#].*)$');					-- split the url into scheme plus domain and path
	if path then																-- if there is a path portion
		path = path:gsub ('[%[%]]', {['[']='%5b',[']']='%5d'});					-- replace '[' and ']' with their percent encoded values
		URL = table.concat ({domain, path});									-- and reassemble
	end

	base_url = table.concat({ "[", URL, " ", safe_for_url (label), "]" });		-- assemble a wikimarkup url

	if is_set (access) then														-- access level (subscription, registration, limited)
		base_url = substitute (cfg.presentation['ext-link-access-signal'], {cfg.presentation[access].class, cfg.presentation[access].title, base_url});	-- add the appropriate icon
	end
	
	return table.concat ({base_url, error_str});
end


--[[--------------------------&lt; D E P R E C A T E D _ P A R A M E T E R &gt;--------------------------------------

Categorize and emit an error message when the citation contains one or more deprecated parameters.  The function includes the
offending parameter name to the error message.  Only one error message is emitted regardless of the number of deprecated
parameters in the citation.

added_deprecated_cat is a boolean declared in page scope variables above

]]

local function deprecated_parameter(name)
	if not added_deprecated_cat then
		added_deprecated_cat = true;											-- note that we've added this category
		table.insert( z.message_tail, { set_error( 'deprecated_params', {name}, true ) } );	-- add error message
	end
end


--[=[-------------------------&lt; K E R N _ Q U O T E S &gt;--------------------------------------------------------

Apply kerning to open the space between the quote mark provided by the Module and a leading or trailing quote
mark contained in a |title= or |chapter= parameter's value.

This function will positive kern either single or double quotes:
	"'Unkerned title with leading and trailing single quote marks'"
	" 'Kerned title with leading and trailing single quote marks' " (in real life the kerning isn't as wide as this example)
Double single quotes (italic or bold wikimarkup) are not kerned.

Replaces unicode quotemarks in plain text or in the label portion of a [[L|D]] style wikilink with typewriter
quote marks regardless of the need for kerning.  Unicode quote marks are not replaced in simple [[D]] wikilinks.

Call this function for chapter titles, for website titles, etc; not for book titles.

]=]

local function kern_quotes (str)
	local cap='';
	local cap2='';
	local wl_type, label, link;

	wl_type, label, link = is_wikilink (str);									-- wl_type is: 0, no wl (text in label variable); 1, [[D]]; 2, [[L|D]]
	
	if 1 == wl_type then														-- [[D]] simple wikilink with or without quote marks
		if mw.ustring.match (str, '%[%[[\"“”\'‘’].+[\"“”\'‘’]%]%]') then		-- leading and trailing quote marks
			str = substitute (cfg.presentation['kern-wl-both'], str);
		elseif mw.ustring.match (str, '%[%[[\"“”\'‘’].+%]%]')	then			-- leading quote marks
			str = substitute (cfg.presentation['kern-wl-left'], str);
		elseif mw.ustring.match (str, '%[%[.+[\"“”\'‘’]%]%]') then				-- trailing quote marks
			str = substitute (cfg.presentation['kern-wl-right'], str);
		end

	else																		-- plain text or [[L|D]]; text in label variable
		label= mw.ustring.gsub (label, '[“”]', '\"');							-- replace “” (U+201C &amp; U+201D) with " (typewriter double quote mark)
		label= mw.ustring.gsub (label, '[‘’]', '\'');							-- replace ‘’ (U+2018 &amp; U+2019) with ' (typewriter single quote mark)

		cap, cap2 = mw.ustring.match (label, "^([\"\'])([^\'].+)");				-- match leading double or single quote but not doubled single quotes (italic markup)
		if is_set (cap) then
			label = substitute (cfg.presentation['kern-left'], {cap, cap2});
		end
	
		cap, cap2 = mw.ustring.match (label, "^(.+[^\'])([\"\'])$")				-- match trailing double or single quote but not doubled single quotes (italic markup)
		if is_set (cap) then
			label = substitute (cfg.presentation['kern-right'], {cap, cap2});
		end
		
		if 2 == wl_type then
			str = make_wikilink (link, label);									-- reassemble the wikilink
		else
			str = label;
		end
	end
	return str;
end


--[[--------------------------&lt; F O R M A T _ S C R I P T _ V A L U E &gt;----------------------------------------

|script-title= holds title parameters that are not written in Latin based scripts: Chinese, Japanese, Arabic, Hebrew, etc. These scripts should
not be italicized and may be written right-to-left.  The value supplied by |script-title= is concatenated onto Title after Title has been wrapped
in italic markup.

Regardless of language, all values provided by |script-title= are wrapped in &lt;bdi&gt;...&lt;/bdi&gt; tags to isolate rtl languages from the English left to right.

|script-title= provides a unique feature.  The value in |script-title= may be prefixed with a two-character ISO639-1 language code and a colon:
	|script-title=ja:*** *** (where * represents a Japanese character)
Spaces between the two-character code and the colon and the colon and the first script character are allowed:
	|script-title=ja : *** ***
	|script-title=ja: *** ***
	|script-title=ja :*** ***
Spaces preceding the prefix are allowed: |script-title = ja:*** ***

The prefix is checked for validity.  If it is a valid ISO639-1 language code, the lang attribute (lang="ja") is added to the &lt;bdi&gt; tag so that browsers can
know the language the tag contains.  This may help the browser render the script more correctly.  If the prefix is invalid, the lang attribute
is not added.  At this time there is no error message for this condition.

Supports |script-title=, |script-chapter=, |script-&lt;periodical&gt;=

]]

local function format_script_value (script_value, script_param)
	local lang='';																-- initialize to empty string
	local name;
	if script_value:match('^%l%l%l?%s*:') then									-- if first 3 or 4 non-space characters are script language prefix
		lang = script_value:match('^(%l%l%l?)%s*:%s*%S.*');						-- get the language prefix or nil if there is no script
		if not is_set (lang) then
			table.insert( z.message_tail, { set_error( 'script_parameter', {script_param, 'missing title part'}, true ) } );		-- prefix without 'title'; add error message
			return '';															-- script_value was just the prefix so return empty string
		end
																				-- if we get this far we have prefix and script
		name = cfg.lang_code_remap[lang] or mw.language.fetchLanguageName( lang, cfg.this_wiki_code );	-- get language name so that we can use it to categorize
		if is_set (name) then													-- is prefix a proper ISO 639-1 language code?
			script_value = script_value:gsub ('^%l+%s*:%s*', '');				-- strip prefix from script
																				-- is prefix one of these language codes?
			if in_array (lang, cfg.script_lang_codes) then
				add_prop_cat ('script_with_name', {name, lang})
			else
				table.insert( z.message_tail, { set_error( 'script_parameter', {script_param, 'unknown language code'}, true ) } );	-- unknown script-language; add error message
			end
			lang = ' lang="' .. lang .. '" ';									-- convert prefix into a lang attribute
		else
			table.insert( z.message_tail, { set_error( 'script_parameter', {script_param, 'invalid language code'}, true ) } );		-- invalid language code; add error message
			lang = '';															-- invalid so set lang to empty string
		end
	else
		table.insert( z.message_tail, { set_error( 'script_parameter', {script_param, 'missing prefix'}, true ) } );				-- no language code prefix; add error message
	end
	script_value = substitute (cfg.presentation['bdi'], {lang, script_value});	-- isolate in case script is rtl

	return script_value;
end


--[[--------------------------&lt; S C R I P T _ C O N C A T E N A T E &gt;------------------------------------------

Initially for |title= and |script-title=, this function concatenates those two parameter values after the script value has been 
wrapped in &lt;bdi&gt; tags.
]]

local function script_concatenate (title, script, script_param)
	if is_set (script) then
		script = format_script_value (script, script_param);					-- &lt;bdi&gt; tags, lang atribute, categorization, etc; returns empty string on error
		if is_set (script) then
			title = title .. ' ' .. script;										-- concatenate title and script title
		end
	end
	return title;
end


--[[--------------------------&lt; W R A P _ M S G &gt;--------------------------------------------------------------

Applies additional message text to various parameter values. Supplied string is wrapped using a message_list
configuration taking one argument.  Supports lower case text for {{citation}} templates.  Additional text taken
from citation_config.messages - the reason this function is similar to but separate from wrap_style().

]]

local function wrap_msg (key, str, lower)
	if not is_set( str ) then
		return "";
	end
	if true == lower then
		local msg;
		msg = cfg.messages[key]:lower();										-- set the message to lower case before 
		return substitute( msg, str );											-- including template text
	else
		return substitute( cfg.messages[key], str );
	end		
end


--[[--------------------------&lt; W I K I S O U R C E _ U R L _ M A K E &gt;----------------------------------------

makes a wikisource url from wikisource interwiki link.  returns the url and appropriate label; nil else.

str is the value assigned to |chapter= (or aliases) or |title= or |title-link=

]]

local function wikisource_url_make (str)
	local wl_type, D, L;
	local ws_url, ws_label;
	local wikisource_prefix = table.concat ({'https://', cfg.this_wiki_code, '.wikisource.org/wiki/'});

	wl_type, D, L = is_wikilink (str);											-- wl_type is 0 (not a wikilink), 1 (simple wikilink), 2 (complex wikilink)

	if 0 == wl_type then														-- not a wikilink; might be from |title-link=
		str = D:match ('^[Ww]ikisource:(.+)') or D:match ('^[Ss]:(.+)');		-- article title from interwiki link with long-form or short-form namespace
		if is_set (str) then
			ws_url = table.concat ({											-- build a wikisource url
				wikisource_prefix,												-- prefix
				str,															-- article title
				});
			ws_label = str;														-- label for the url
		end
	elseif 1 == wl_type then													-- simple wikilink: [[Wikisource:ws article]]
		str = D:match ('^[Ww]ikisource:(.+)') or D:match ('^[Ss]:(.+)');		-- article title from interwiki link with long-form or short-form namespace
		if is_set (str) then
			ws_url = table.concat ({											-- build a wikisource url
				wikisource_prefix,												-- prefix
				str,															-- article title
				});
			ws_label = str;														-- label for the url
		end
	elseif 2 == wl_type then													-- non-so-simple wikilink: [[Wikisource:ws article|displayed text]] ([[L|D]])
		str = L:match ('^[Ww]ikisource:(.+)') or L:match ('^[Ss]:(.+)');		-- article title from interwiki link with long-form or short-form namespace
		if is_set (str) then
			ws_label = D;														-- get ws article name from display portion of interwiki link
			ws_url = table.concat ({											-- build a wikisource url
				wikisource_prefix,												-- prefix
				str,															-- article title without namespace from link portion of wikilink
				});
		end
	end
	
	if ws_url then
		ws_url = mw.uri.encode (ws_url, 'WIKI');								-- make a usable url
		ws_url = ws_url:gsub ('%%23', '#');										-- undo percent encoding of fragment marker
	end

	return ws_url, ws_label, L or D;											-- return proper url or nil and a label or nil
end


--[[--------------------------&lt; F O R M A T _ P E R I O D I C A L &gt;--------------------------------------------

Format the three periodical parameters: |script-&lt;periodical&gt;=, |&lt;periodical&gt;=, and |trans-&lt;periodical&gt;= into a single Periodical meta-
parameter.

]]

local function format_periodical (script_periodical, script_periodical_source, periodical, trans_periodical)
	local periodical_error = '';

	if not is_set (periodical) then
		periodical = '';														-- to be safe for concatenation
	else
		periodical = wrap_style ('italic-title', periodical);					-- style 
	end

	periodical = script_concatenate (periodical, script_periodical, script_periodical_source);	-- &lt;bdi&gt; tags, lang atribute, categorization, etc; must be done after title is wrapped

	if is_set (trans_periodical) then
		trans_periodical = wrap_style ('trans-italic-title', trans_periodical);
		if is_set (periodical) then
			periodical = periodical ..  ' ' .. trans_periodical;
		else																	-- here when trans-periodical without periodical or script-periodical
			periodical = trans_periodical;
			periodical_error = ' ' .. set_error ('trans_missing_title', {'periodical'});
		end
	end

	return periodical .. periodical_error;
end


--[[--------------------------&lt; F O R M A T _ C H A P T E R _ T I T L E &gt;--------------------------------------

Format the four chapter parameters: |script-chapter=, |chapter=, |trans-chapter=, and |chapter-url= into a single Chapter meta-
parameter (chapter_url_source used for error messages).

]]

local function format_chapter_title (scriptchapter, script_chapter_source, chapter, transchapter, chapterurl, chapter_url_source, no_quotes, access)
	local chapter_error = '';

	local ws_url, ws_label, L = wikisource_url_make (chapter);					-- make a wikisource url and label from a wikisource interwiki link
	if ws_url then
		ws_label = ws_label:gsub ('_', '');										-- replace underscore separaters with space characters
		chapter = ws_label;
	end

	if not is_set (chapter) then
		chapter = '';															-- to be safe for concatenation
	else
		if false == no_quotes then
			chapter = kern_quotes (chapter);									-- if necessary, separate chapter title's leading and trailing quote marks from Module provided quote marks
			chapter = wrap_style ('quoted-title', chapter);
		end
	end

	chapter = script_concatenate (chapter, scriptchapter, script_chapter_source);	-- &lt;bdi&gt; tags, lang atribute, categorization, etc; must be done after title is wrapped

	if is_set (chapterurl) then
		chapter = external_link (chapterurl, chapter, chapter_url_source, access);	-- adds bare_url_missing_title error if appropriate
	elseif ws_url then
		chapter = external_link (ws_url, chapter .. '&amp;nbsp;', 'ws link in chapter');	-- adds bare_url_missing_title error if appropriate; space char to move icon away from chap text; TODO: better way to do this?
		chapter = substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, chapter});				
	end

	if is_set (transchapter) then
		transchapter = wrap_style ('trans-quoted-title', transchapter);
		if is_set (chapter) then
			chapter = chapter ..  ' ' .. transchapter;
		else																	-- here when transchapter without chapter or script-chapter
			chapter = transchapter;
			chapter_error = ' ' .. set_error ('trans_missing_title', {'chapter'});
		end
	end

	return chapter .. chapter_error;
end


--[[--------------------------&lt; H A S _ I N V I S I B L E _ C H A R S &gt;----------------------------------------

This function searches a parameter's value for nonprintable or invisible characters.  The search stops at the
first match.

This function will detect the visible replacement character when it is part of the wikisource.

Detects but ignores nowiki and math stripmarkers.  Also detects other named stripmarkers (gallery, math, pre, ref)
and identifies them with a slightly different error message.  See also coins_cleanup().

Output of this function is an error message that identifies the character or the Unicode group, or the stripmarker
that was detected along with its position (or, for multi-byte characters, the position of its first byte) in the
parameter value.

]]

local function has_invisible_chars (param, v)
	local position = '';														-- position of invisible char or starting position of stripmarker
	local dummy;																-- end of matching string; not used but required to hold end position when a capture is returned
	local capture;																-- used by stripmarker detection to hold name of the stripmarker
	local i=1;
	local stripmarker, apostrophe;
	
	capture = string.match (v, '[%w%p ]*');										-- Test for values that are simple ASCII text and bypass other tests if true
	if capture == v then														-- if same there are no unicode characters
		return;
	end

	while cfg.invisible_chars[i] do
		local char=cfg.invisible_chars[i][1]									-- the character or group name
		local pattern=cfg.invisible_chars[i][2]									-- the pattern used to find it
		position, dummy, capture = mw.ustring.find (v, pattern)					-- see if the parameter value contains characters that match the pattern
		
		if position and (char == 'zero width joiner') then						-- if we found a zero width joiner character
			if mw.ustring.find (v, cfg.indic_script) then						-- its ok if one of the indic scripts
				position = nil;													-- unset position
			end
		end
		
		if position then
			if 'nowiki' == capture or 'math' == capture or						-- nowiki and math stripmarkers (not an error condition)
				('templatestyles' == capture and in_array (param, {'id', 'quote'})) then	-- templatestyles stripmarker allowed in these parameters
					stripmarker = true;											-- set a flag
			elseif true == stripmarker and 'delete' == char then				-- because stripmakers begin and end with the delete char, assume that we've found one end of a stripmarker
				position = nil;													-- unset
			else
				local err_msg;
				if capture then
					err_msg = capture .. ' ' .. char;
				else
					err_msg = char .. ' ' .. 'character';
				end

				table.insert( z.message_tail, { set_error( 'invisible_char', {err_msg, wrap_style ('parameter', param), position}, true ) } );	-- add error message
				return;															-- and done with this parameter
			end
		end
		i=i+1;																	-- bump our index
	end
end


--[[--------------------------&lt; A R G U M E N T _ W R A P P E R &gt;----------------------------------------------

Argument wrapper.  This function provides support for argument mapping defined in the configuration file so that
multiple names can be transparently aliased to single internal variable.

]]

local function argument_wrapper( args )
	local origin = {};
	
	return setmetatable({
		ORIGIN = function( self, k )
			local dummy = self[k]; --force the variable to be loaded.
			return origin[k];
		end
	},
	{
		__index = function ( tbl, k )
			if origin[k] ~= nil then
				return nil;
			end
			
			local args, list, v = args, cfg.aliases[k];
			
			if type( list ) == 'table' then
				v, origin[k] = select_one( args, list, 'redundant_parameters' );
				if origin[k] == nil then
					origin[k] = ''; -- Empty string, not nil
				end
			elseif list ~= nil then
				v, origin[k] = args[list], list;
			else
				-- maybe let through instead of raising an error?
				-- v, origin[k] = args[k], k;
				error( cfg.messages['unknown_argument_map'] .. ': ' .. k);
			end
			
			-- Empty strings, not nil;
			if v == nil then
--				v = cfg.defaults[k] or '';
				v = '';
				origin[k] = '';
			end
			
			tbl = rawset( tbl, k, v );
			return v;
		end,
	});
end


--[[--------------------------&lt; N O W R A P _ D A T E &gt;--------------------------------------------------------

When date is YYYY-MM-DD format wrap in nowrap span: &lt;span ...&gt;YYYY-MM-DD&lt;/span&gt;.  When date is DD MMMM YYYY or is
MMMM DD, YYYY then wrap in nowrap span: &lt;span ...&gt;DD MMMM&lt;/span&gt; YYYY or &lt;span ...&gt;MMMM DD,&lt;/span&gt; YYYY

DOES NOT yet support MMMM YYYY or any of the date ranges.

]]

local function nowrap_date (date)
	local cap='';
	local cap2='';

	if date:match("^%d%d%d%d%-%d%d%-%d%d$") then
		date = substitute (cfg.presentation['nowrap1'], date);
	
	elseif date:match("^%a+%s*%d%d?,%s+%d%d%d%d$") or date:match ("^%d%d?%s*%a+%s+%d%d%d%d$") then
		cap, cap2 = string.match (date, "^(.*)%s+(%d%d%d%d)$");
		date = substitute (cfg.presentation['nowrap2'], {cap, cap2});
	end
	
	return date;
end


--[[--------------------------&lt; S E T _ T I T L E T Y P E &gt;----------------------------------------------------

This function sets default title types (equivalent to the citation including |type=&lt;default value&gt;) for those templates that have defaults.
Also handles the special case where it is desirable to omit the title type from the rendered citation (|type=none).

]]

local function set_titletype (cite_class, title_type)
	if is_set(title_type) then

	if cfg.keywords_xlate[title_type] == 'none' then
			title_type = "";													-- if |type=none then type parameter not displayed
		end
		return title_type;														-- if |type= has been set to any other value use that value
	end

	return cfg.title_types [cite_class] or '';									-- set template's default title type; else empty string for concatenation
end


--[[--------------------------&lt; H Y P H E N _ T O _ D A S H &gt;--------------------------------------------------

Converts a hyphen to a dash under certain conditions.  The hyphen must separate like items; unlike items are
returned unmodified.  These forms are modified:
	letter - letter (A - B)
	digit - digit (4-5)
	digit separator digit - digit separator digit (4.1-4.5 or 4-1-4-5)
	letterdigit - letterdigit (A1-A5) (an optional separator between letter and digit is supported – a.1-a.5 or a-1-a-5)
	digitletter - digitletter (5a - 5d) (an optional separator between letter and digit is supported – 5.a-5.d or 5-a-5-d)

any other forms are returned unmodified.

str may be a comma- or semicolon-separated list

]]

local function hyphen_to_dash( str )
	if not is_set (str) then
		return str;
	end
	
	str, count = str:gsub ('^%(%((.+)%)%)$', '%1');								-- remove accept-this-as-written markup when it wraps all of str
	if 0 ~= count then															-- non-zero when markup removed; zero else
		return str;																-- nothing to do, we're done
	end
	
	str = str:gsub ('&amp;[nm]dash;', {['&amp;ndash;'] = '–', ['&amp;mdash;'] = '—'});		-- replace &amp;mdash; and &amp;ndash; entities  with their characters; semicolon mucks up the text.split
	str = str:gsub ('&amp;#45;', '-');												-- replace html numeric entity with hyphen character
	str = str:gsub ('&amp;nbsp;', ' ');												-- replace &amp;nbsp; entity with generic keyboard space character
	
	local out = {};
	local list = mw.text.split (str, '%s*[,;]%s*');								-- split str at comma or semicolon separators if there are any

	for _, item in ipairs (list) do												-- for each item in the list
		if mw.ustring.match (item, '^%w*[%.%-]?%w+%s*[%-–—]%s*%w*[%.%-]?%w+$') then	-- if a hyphenated range or has endash or emdash separators
			if item:match ('^%a+[%.%-]?%d+%s*%-%s*%a+[%.%-]?%d+$') or			-- letterdigit hyphen letterdigit (optional separator between letter and digit)
				item:match ('^%d+[%.%-]?%a+%s*%-%s*%d+[%.%-]?%a+$') or			-- digitletter hyphen digitletter (optional separator between digit and letter)
				item:match ('^%d+[%.%-]%d+%s*%-%s*%d+[%.%-]%d+$') or			-- digit separator digit hyphen digit separator digit
				item:match ('^%d+%s*%-%s*%d+$') or								-- digit hyphen digit
				item:match ('^%a+%s*%-%s*%a+$') then							-- letter hyphen letter
					item = item:gsub ('(%w*[%.%-]?%w+)%s*%-%s*(%w*[%.%-]?%w+)', '%1–%2');	-- replace hyphen, remove extraneous space characters
			else
				item = mw.ustring.gsub (item, '%s*[–—]%s*', '–');				-- for endash or emdash separated ranges, replace em with en, remove extraneous white space
			end
		end
		item = item:gsub ('^%(%((.+)%)%)$', '%1');								-- remove the accept-this-as-written markup
		table.insert (out, item);												-- add the (possibly modified) item to the output table
	end

	return table.concat (out, ', ');											-- concatenate the output table into a comma separated string
end


--[[--------------------------&lt; S A F E _ J O I N &gt;------------------------------------------------------------

Joins a sequence of strings together while checking for duplicate separation characters.

]]

local function safe_join( tbl, duplicate_char )
	local f = {};																-- create a function table appropriate to type of 'dupicate character'
		if 1 == #duplicate_char then											-- for single byte ascii characters use the string library functions
			f.gsub=string.gsub
			f.match=string.match
			f.sub=string.sub
		else																	-- for multi-byte characters use the ustring library functions
			f.gsub=mw.ustring.gsub
			f.match=mw.ustring.match
			f.sub=mw.ustring.sub
		end

	local str = '';																-- the output string
	local comp = '';															-- what does 'comp' mean?
	local end_chr = '';
	local trim;
	for _, value in ipairs( tbl ) do
		if value == nil then value = ''; end
		
		if str == '' then														-- if output string is empty
			str = value;														-- assign value to it (first time through the loop)
		elseif value ~= '' then
			if value:sub(1,1) == '&lt;' then										-- Special case of values enclosed in spans and other markup.
				comp = value:gsub( "%b&lt;&gt;", "" );								-- remove html markup (&lt;span&gt;string&lt;/span&gt; -&gt; string)
			else
				comp = value;
			end
																				-- typically duplicate_char is sepc
			if f.sub(comp, 1,1) == duplicate_char then							-- is first character same as duplicate_char? why test first character?
																				--   Because individual string segments often (always?) begin with terminal punct for the
																				--   preceding segment: 'First element' .. 'sepc next element' .. etc?
				trim = false;
				end_chr = f.sub(str, -1,-1);									-- get the last character of the output string
				-- str = str .. "&lt;HERE(enchr=" .. end_chr.. ")"					-- debug stuff?
				if end_chr == duplicate_char then								-- if same as separator
					str = f.sub(str, 1,-2);										-- remove it
				elseif end_chr == "'" then										-- if it might be wikimarkup
					if f.sub(str, -3,-1) == duplicate_char .. "''" then			-- if last three chars of str are sepc'' 
						str = f.sub(str, 1, -4) .. "''";						-- remove them and add back ''
					elseif  f.sub(str, -5,-1) == duplicate_char .. "]]''" then	-- if last five chars of str are sepc]]'' 
						trim = true;											-- why? why do this and next differently from previous?
					elseif f.sub(str, -4,-1) == duplicate_char .. "]''" then	-- if last four chars of str are sepc]'' 
						trim = true;											-- same question
					end
				elseif end_chr == "]" then										-- if it might be wikimarkup
					if f.sub(str, -3,-1) == duplicate_char .. "]]" then			-- if last three chars of str are sepc]] wikilink 
						trim = true;
					elseif f.sub(str, -3,-1) == duplicate_char .. '"]' then		-- if last three chars of str are sepc"] quoted external link 
						trim = true;
					elseif  f.sub(str, -2,-1) == duplicate_char .. "]" then		-- if last two chars of str are sepc] external link
						trim = true;
					elseif f.sub(str, -4,-1) == duplicate_char .. "'']" then	-- normal case when |url=something &amp; |title=Title.
						trim = true;
					end
				elseif end_chr == " " then										-- if last char of output string is a space
					if f.sub(str, -2,-1) == duplicate_char .. " " then			-- if last two chars of str are &lt;sepc&gt;&lt;space&gt;
						str = f.sub(str, 1,-3);									-- remove them both
					end
				end

				if trim then
					if value ~= comp then 										-- value does not equal comp when value contains html markup
						local dup2 = duplicate_char;
						if f.match(dup2, "%A" ) then dup2 = "%" .. dup2; end	-- if duplicate_char not a letter then escape it
						
						value = f.gsub(value, "(%b&lt;&gt;)" .. dup2, "%1", 1 )		-- remove duplicate_char if it follows html markup
					else
						value = f.sub(value, 2, -1 );							-- remove duplicate_char when it is first character
					end
				end
			end
			str = str .. value;													--add it to the output string
		end
	end
	return str;
end


--[[--------------------------&lt; I S _ S U F F I X &gt;------------------------------------------------------------

returns true is suffix is properly formed Jr, Sr, or ordinal in the range 2–9.  Puncutation not allowed.

]]

local function is_suffix (suffix)
	if in_array (suffix, {'Jr', 'Sr', '2nd', '3rd'}) or suffix:match ('^%dth$') then
		return true;
	end
	return false;
end


--[[--------------------------&lt; I S _ G O O D _ V A N C _ N A M E &gt;--------------------------------------------

For Vancouver Style, author/editor names are supposed to be rendered in Latin (read ASCII) characters.  When a name
uses characters that contain diacritical marks, those characters are to converted to the corresponding Latin character.
When a name is written using a non-Latin alphabet or logogram, that name is to be transliterated into Latin characters.
These things are not currently possible in this module so are left to the editor to do.

This test allows |first= and |last= names to contain any of the letters defined in the four Unicode Latin character sets
	[http://www.unicode.org/charts/PDF/U0000.pdf C0 Controls and Basic Latin] 0041–005A, 0061–007A
	[http://www.unicode.org/charts/PDF/U0080.pdf C1 Controls and Latin-1 Supplement] 00C0–00D6, 00D8–00F6, 00F8–00FF
	[http://www.unicode.org/charts/PDF/U0100.pdf Latin Extended-A] 0100–017F
	[http://www.unicode.org/charts/PDF/U0180.pdf Latin Extended-B] 0180–01BF, 01C4–024F

|lastn= also allowed to contain hyphens, spaces, and apostrophes. (http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35029/)
|firstn= also allowed to contain hyphens, spaces, apostrophes, and periods

This original test:
	if nil == mw.ustring.find (last, "^[A-Za-zÀ-ÖØ-öø-ƿǄ-ɏ%-%s%']*$") or nil == mw.ustring.find (first, "^[A-Za-zÀ-ÖØ-öø-ƿǄ-ɏ%-%s%'%.]+[2-6%a]*$") then
was written ouside of the code editor and pasted here because the code editor gets confused between character insertion point and cursor position.
The test has been rewritten to use decimal character escape sequence for the individual bytes of the unicode characters so that it is not necessary
to use an external editor to maintain this code.

	\195\128-\195\150 – À-Ö (U+00C0–U+00D6 – C0 controls)
	\195\152-\195\182 – Ø-ö (U+00D8-U+00F6 – C0 controls)
	\195\184-\198\191 – ø-ƿ (U+00F8-U+01BF – C0 controls, Latin extended A &amp; B)
	\199\132-\201\143 – Ǆ-ɏ (U+01C4-U+024F – Latin extended B)

]]

local function is_good_vanc_name (last, first)
	local first, suffix = first:match ('(.-),?%s*([%dJS][%drndth]+)%.?$') or first;	-- if first has something that looks like a generational suffix, get it

	if is_set (suffix) then
		if not is_suffix (suffix) then
			add_vanc_error (cfg.err_msg_supl.suffix);
			return false;														-- not a name with an appropriate suffix
		end
	end
	if nil == mw.ustring.find (last, "^[A-Za-z\195\128-\195\150\195\152-\195\182\195\184-\198\191\199\132-\201\143%-%s%']*$") or
		nil == mw.ustring.find (first, "^[A-Za-z\195\128-\195\150\195\152-\195\182\195\184-\198\191\199\132-\201\143%-%s%'%.]*$") then
			add_vanc_error (cfg.err_msg_supl['non-Latin character']);
			return false;														-- not a string of latin characters; Vancouver requires Romanization
	end;
	return true;
end


--[[--------------------------&lt; R E D U C E _ T O _ I N I T I A L S &gt;------------------------------------------

Attempts to convert names to initials in support of |name-list-format=vanc.  

Names in |firstn= may be separated by spaces or hyphens, or for initials, a period. See http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35062/.

Vancouver style requires family rank designations (Jr, II, III, etc) to be rendered as Jr, 2nd, 3rd, etc.  See http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35085/.
This code only accepts and understands generational suffix in the Vancouver format because Roman numerals look like, and can be mistaken for, initials.

This function uses ustring functions because firstname initials may be any of the unicode Latin characters accepted by is_good_vanc_name ().

]]

local function reduce_to_initials(first)
	local name, suffix = mw.ustring.match(first, "^(%u+) ([%dJS][%drndth]+)$");

	if not name then															-- if not initials and a suffix
		name = mw.ustring.match(first, "^(%u+)$");								-- is it just intials?
	end

	if name then																-- if first is initials with or without suffix
		if 3 &gt; mw.ustring.len (name) then										-- if one or two initials
			if suffix then														-- if there is a suffix
				if is_suffix (suffix) then										-- is it legitimate?
					return first;												-- one or two initials and a valid suffix so nothing to do
				else
					add_vanc_error (cfg.err_msg_supl.suffix);									-- one or two initials with invalid suffix so error message
					return first;												-- and return first unmolested
				end
			else
				return first;													-- one or two initials without suffix; nothing to do
			end
		end
	end																			-- if here then name has 3 or more uppercase letters so treat them as a word

	local initials, names = {}, {};												-- tables to hold name parts and initials
	local i = 1;																-- counter for number of initials

	names = mw.text.split (first, '[%s,]+');									-- split into a table of names and possible suffix

	while names[i] do															-- loop through the table
		if 1 &lt; i and names[i]:match ('[%dJS][%drndth]+%.?$') then				-- if not the first name, and looks like a suffix (may have trailing dot)
			names[i] = names[i]:gsub ('%.', '');								-- remove terminal dot if present
			if is_suffix (names[i]) then										-- if a legitimate suffix
				table.insert (initials, ' ' .. names[i]);						-- add a separator space, insert at end of initials table
				break;															-- and done because suffix must fall at the end of a name
			end																	-- no error message if not a suffix; possibly because of Romanization
		end
		if 3 &gt; i then
			table.insert (initials, mw.ustring.sub(names[i],1,1));				-- insert the intial at end of initials table
		end
		i = i+1;																-- bump the counter
	end
			
	return table.concat(initials)												-- Vancouver format does not include spaces.
end


--[[--------------------------&lt; L I S T  _ P E O P L E &gt;-------------------------------------------------------

Formats a list of people (e.g. authors / editors) 

]]

local function list_people(control, people, etal)
	local sep;
	local namesep;
	local format = control.format
	local maximum = control.maximum
	local lastauthoramp = control.lastauthoramp;
	local text = {}

	if 'vanc' == format then													-- Vancouver-like author/editor name styling?
		sep = cfg.presentation['sep_nl_vanc'];									-- name-list separator between authors is a comma
		namesep = cfg.presentation['sep_name_vanc'];							-- last/first separator is a space
		lastauthoramp = nil;													-- unset because isn't used by Vancouver style
	else
		sep = cfg.presentation['sep_nl'];										-- name-list separator between authors is a semicolon
		namesep = cfg.presentation['sep_name'];									-- last/first separator is &lt;comma&gt;&lt;space&gt;
	end
	
	if sep:sub(-1,-1) ~= " " then sep = sep .. " " end
	if is_set (maximum) and maximum &lt; 1 then return "", 0; end					-- returned 0 is for EditorCount; not used for authors
	
	for i,person in ipairs(people) do
		if is_set(person.last) then
			local mask = person.mask
			local one
			local sep_one = sep;
			if is_set (maximum) and i &gt; maximum then
				etal = true;
				break;
			elseif (mask ~= nil) then
				local n = tonumber(mask)
				if (n ~= nil) then
					one = string.rep("&amp;mdash;",n)
				else
					one = mask;
					sep_one = " ";
				end
			else
				one = person.last
				local first = person.first
				if is_set(first) then
					if ( "vanc" == format ) then								-- if vancouver format
						one = one:gsub ('%.', '');								-- remove periods from surnames (http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35029/)
						if not person.corporate and is_good_vanc_name (one, first) then		-- and name is all Latin characters; corporate authors not tested
							first = reduce_to_initials(first)					-- attempt to convert first name(s) to initials
						end
					end
					one = one .. namesep .. first;
				end
			end
			if is_set (person.link) then
				one = make_wikilink (person.link, one);							-- link author/editor
			end
			table.insert (text, one)
			table.insert (text, sep_one)
		end
	end

	local count = #text / 2;													-- (number of names + number of separators) divided by 2
	if count &gt; 0 then 
		if count &gt; 1 and is_set(lastauthoramp) and not etal then
			text[#text-2] = " &amp; ";												-- replace last separator with ampersand text
		end
		text[#text] = nil;														-- erase the last separator
	end
	
	local result = table.concat(text)											-- construct list
	if etal and is_set (result) then											-- etal may be set by |display-authors=etal but we might not have a last-first list
		result = result .. sep .. ' ' .. cfg.messages['et al'];					-- we've go a last-first list and etal so add et al.
	end
	
	return result, count
end


--[[--------------------------&lt; A N C H O R _ I D &gt;------------------------------------------------------------

Generates a CITEREF anchor ID if we have at least one name or a date.  Otherwise returns an empty string.

namelist is one of the contributor-, author-, or editor-name lists chosen in that order.  year is Year or anchor_year.

]]

local function anchor_id (namelist, year)
	local names={};																-- a table for the one to four names and year
	for i,v in ipairs (namelist) do												-- loop through the list and take up to the first four last names
		names[i] = v.last 
		if i == 4 then break end												-- if four then done
	end
	table.insert (names, year);													-- add the year at the end
	local id = table.concat(names);												-- concatenate names and year for CITEREF id
	if is_set (id) then															-- if concatenation is not an empty string
		return "CITEREF" .. id;													-- add the CITEREF portion
	else
		return '';																-- return an empty string; no reason to include CITEREF id in this citation
	end
end


--[[--------------------------&lt; N A M E _ H A S _ E T A L &gt;----------------------------------------------------

Evaluates the content of name parameters (author, editor, etc) for variations on the theme of et al.  If found,
the et al. is removed, a flag is set to true and the function returns the modified name and the flag.

This function never sets the flag to false but returns it's previous state because it may have been set by
previous passes through this function or by the associated |display-&lt;names&gt;=etal parameter

]]

local function name_has_etal (name, etal, nocat, param)

	if is_set (name) then														-- name can be nil in which case just return
		local patterns = cfg.et_al_patterns;									--get patterns from configuration
		
		for _, pattern in ipairs (patterns) do									-- loop through all of the patterns
			if name:match (pattern) then										-- if this 'et al' pattern is found in name
				name = name:gsub (pattern, '');									-- remove the offending text
				etal = true;													-- set flag (may have been set previously here or by |display-&lt;names&gt;=etal)
				if not nocat then												-- no categorization for |vauthors=
					table.insert( z.message_tail, {set_error ('etal', {param})});	-- and set an error if not added
				end
			end
		end
	end

	return name, etal;															-- 
end


--[[--------------------------&lt; N A M E _ I S _ N U M E R I C &gt;------------------------------------------------

Add maint cat when name parameter value does not contain letters.  Does not catch mixed alphanumeric names so
|last=A. Green (1922-1987) does not get caught in the current version of this test but |first=(1888) is caught.

returns nothing

]]

local function name_is_numeric (name, list_name)
	if is_set (name) then
		if mw.ustring.match (name, '^[%A]+$') then								-- when name does not contain any letters
			add_maint_cat ('numeric_names', cfg.special_case_translation [list_name]);	-- add a maint cat for this template
		end
	end
end


--[[--------------------------&lt; N A M E _ H A S _ E D _ M A R K U P &gt;------------------------------------------

Evaluates the content of author and editor parameters for extranious editor annotations: ed, ed., eds, (Ed.), etc.
These annotation do not belong in author parameters and are redundant in editor parameters.  If found, the function
adds the editor markup maintenance category.

returns nothing

]]

local function name_has_ed_markup (name, list_name)
	local patterns = cfg.editor_markup_patterns;								-- get patterns from configuration

	if is_set (name) then
		for _, pattern in ipairs (patterns) do									-- spin through patterns table and
			if name:match (pattern) then
				add_maint_cat ('extra_text_names', cfg.special_case_translation [list_name]);	-- add a maint cat for this template
				break;
			end
		end
	end
end


--[[--------------------------&lt; N A M E _ H A S _ M U L T _ N A M E S &gt;----------------------------------------

Evaluates the content of author and editor (surnames only) parameters for multiple names.  Multiple names are
indicated if there is more than one comma and or semicolon.  If found, the function adds the multiple name
(author or editor) maintenance category.

returns nothing

]]

local function name_has_mult_names (name, list_name)
	local _, count;
	if is_set (name) then
		_, count = name:gsub ('[;,]', '');										-- count the number of separator-like characters
		
		if 1 &lt; count then														-- param could be |author= or |editor= so one separator character is acceptable
			add_maint_cat ('mult_names', cfg.special_case_translation [list_name]);	-- more than one separator indicates multiple names so add a maint cat for this template
		end
	end
end


--[[--------------------------&lt; N A M E _ C H E C K S &gt;--------------------------------------------------------

This function calls various name checking functions used to validate the content of the various name-holding
parameters.

]]

local function name_checks (last, first, list_name)
	if is_set (last) then
		if last:match ('^%(%(.*%)%)$') then										-- if wrapped in doubled parentheses, accept as written 
			last = last:match ('^%(%((.*)%)%)$');								-- strip parens
		else
			name_has_mult_names (last, list_name);								-- check for multiple names in the parameter (last only)
			name_has_ed_markup (last, list_name);								-- check for extraneous 'editor' annotation
			name_is_numeric (last, list_name);									-- check for names that are compsed of digits and punctuation
		end
	end
	if is_set (first) then
		if first:match ('^%(%(.*%)%)$') then									-- if wrapped in doubled parentheses, accept as written 
			first = first:match ('^%(%((.*)%)%)$');								-- strip parens
		else
			name_has_ed_markup (first, list_name);								-- check for extraneous 'editor' annotation
			name_is_numeric (first, list_name);									-- check for names that are compsed of digits and punctuation
		end
	end
	return last, first;															-- done
	end


--[[--------------------------&lt; E X T R A C T _ N A M E S &gt;----------------------------------------------------
Gets name list from the input arguments

Searches through args in sequential order to find |lastn= and |firstn= parameters (or their aliases), and their matching link and mask parameters.
Stops searching when both |lastn= and |firstn= are not found in args after two sequential attempts: found |last1=, |last2=, and |last3= but doesn't
find |last4= and |last5= then the search is done.

This function emits an error message when there is a |firstn= without a matching |lastn=.  When there are 'holes' in the list of last names, |last1= and |last3=
are present but |last2= is missing, an error message is emitted. |lastn= is not required to have a matching |firstn=.

When an author or editor parameter contains some form of 'et al.', the 'et al.' is stripped from the parameter and a flag (etal) returned
that will cause list_people() to add the static 'et al.' text from Module:Citation/CS1/Configuration.  This keeps 'et al.' out of the 
template's metadata.  When this occurs, the page is added to a maintenance category.

]]

local function extract_names(args, list_name)
	local names = {};			-- table of names
	local last;					-- individual name components
	local first;
	local link;
	local mask;
	local i = 1;				-- loop counter/indexer
	local n = 1;				-- output table indexer
	local count = 0;			-- used to count the number of times we haven't found a |last= (or alias for authors, |editor-last or alias for editors)
	local etal=false;			-- return value set to true when we find some form of et al. in an author parameter

	local last_alias, first_alias, link_alias;									-- selected parameter aliases used in error messaging
	while true do
		last, last_alias = select_one( args, cfg.aliases[list_name .. '-Last'], 'redundant_parameters', i );		-- search through args for name components beginning at 1
		first, first_alias = select_one( args, cfg.aliases[list_name .. '-First'], 'redundant_parameters', i );
		link, link_alias = select_one( args, cfg.aliases[list_name .. '-Link'], 'redundant_parameters', i );
		mask = select_one( args, cfg.aliases[list_name .. '-Mask'], 'redundant_parameters', i );

		last, etal = name_has_etal (last, etal, false, last_alias);				-- find and remove variations on et al.
		first, etal = name_has_etal (first, etal, false, first_alias);			-- find and remove variations on et al.
		last, first= name_checks (last, first, list_name);						-- multiple names, extraneous annotation, etc checks
		
		if first and not last then												-- if there is a firstn without a matching lastn
			table.insert( z.message_tail, { set_error( 'first_missing_last', {first_alias, first_alias:gsub('first', 'last')}, true ) } );	-- add this error message
		elseif not first and not last then										-- if both firstn and lastn aren't found, are we done?
			count = count + 1;													-- number of times we haven't found last and first
			if 2 &lt;= count then													-- two missing names and we give up
				break;															-- normal exit or there is a two-name hole in the list; can't tell which
			end
		else																	-- we have last with or without a first
			link_title_ok (link, link_alias, last, last_alias);					-- check for improper wikimarkup
			if first then
				link_title_ok (link, link_alias, first, first_alias);			-- check for improper wikimarkup
			end

			names[n] = {last = last, first = first, link = link, mask = mask, corporate=false};	-- add this name to our names list (corporate for |vauthors= only)
			n = n + 1;															-- point to next location in the names table
			if 1 == count then													-- if the previous name was missing
				table.insert( z.message_tail, { set_error( 'missing_name', {list_name:match ("(%w+)List"):lower(), i-1}, true ) } );	-- add this error message
			end
			count = 0;															-- reset the counter, we're looking for two consecutive missing names
		end
		i = i + 1;																-- point to next args location
	end
	
	return names, etal;															-- all done, return our list of names
end


--[[--------------------------&lt; G E T _ I S O 6 3 9 _ C O D E &gt;------------------------------------------------

Validates language names provided in |language= parameter if not an ISO639-1 or 639-2 code.

Returns the language name and associated two- or three-character code.  Because case of the source may be incorrect
or different from the case that WikiMedia uses, the name comparisons are done in lower case and when a match is
found, the Wikimedia version (assumed to be correct) is returned along with the code.  When there is no match, we
return the original language name string.

mw.language.fetchLanguageNames(&lt;local wiki language&gt;, 'all') returns a list of languages that in some cases may include
extensions. For example, code 'cbk-zam' and its associated name 'Chavacano de Zamboanga' (MediaWiki does not support
code 'cbk' or name 'Chavacano'.  Most (all?) of these languages are not used a 'language' codes per se, rather they
are used as sub-domain names: cbk-zam.wikipedia.org.  A list of language names and codes supported by fetchLanguageNames()
can be found at Template:Citation Style documentation/language/doc

Names that are included in the list will be found if that name is provided in the |language= parameter.  For example,
if |language=Chavacano de Zamboanga, that name will be found with the associated code 'cbk-zam'.  When names are found
and the associated code is not two or three characters, this function returns only the WikiMedia language name.

Some language names have multiple entries under different codes:
	Aromanian has code rup and code roa-rup
When this occurs, this function returns the language name and the 2- or 3-character code

Adapted from code taken from Module:Check ISO 639-1.

]]

local function get_iso639_code (lang, this_wiki_code)
	if cfg.lang_name_remap[lang:lower()] then									-- if there is a remapped name (because MediaWiki uses something that we don't think is correct)
		return cfg.lang_name_remap[lang:lower()][1], cfg.lang_name_remap[lang:lower()][2];	-- for this language 'name', return a possibly new name and appropriate code
	end

	local ietf_code;															-- because some languages have both ietf-like codes and iso 639-like codes
	local ietf_name;
	
	local languages = mw.language.fetchLanguageNames(this_wiki_code, 'all')		-- get a list of language names known to Wikimedia
																				-- ('all' is required for North Ndebele, South Ndebele, and Ojibwa)
	local langlc = mw.ustring.lower(lang);										-- lower case version for comparisons

	for code, name in pairs(languages) do										-- scan the list to see if we can find our language
		if langlc == mw.ustring.lower(name) then
			if 2 == code:len() or 3 == code:len() then							-- two- or three-character codes only; extensions not supported
				return name, code;												-- so return the name and the code
			end
			ietf_code = code;													-- remember that we found an ietf-like code and save its name
			ietf_name = name;													-- but keep looking for a 2- or 3-char code
		end
	end
																				-- didn't find name with 2- or 3-char code; if ietf-like code found return
	return ietf_code and ietf_name or lang;										-- associated name; return original language text else
end


--[[--------------------------&lt; L A N G U A G E _ P A R A M E T E R &gt;------------------------------------------

Gets language name from a provided two- or three-character ISO 639 code.  If a code is recognized by MediaWiki,
use the returned name; if not, then use the value that was provided with the language parameter.

When |language= contains a recognized language (either code or name), the page is assigned to the category for
that code: Category:Norwegian-language sources (no).  For valid three-character code languages, the page is assigned
to the single category for '639-2' codes: Category:CS1 ISO 639-2 language sources.

Languages that are the same as the local wiki are not categorized.  MediaWiki does not recognize three-character
equivalents of two-character codes: code 'ar' is recognized but code 'ara' is not.

This function supports multiple languages in the form |language=nb, French, th where the language names or codes are
separated from each other by commas with optional space characters.

]]

local function language_parameter (lang)
	local code;																	-- the two- or three-character language code
	local name;																	-- the language name
	local language_list = {};													-- table of language names to be rendered
	local names_table = {};														-- table made from the value assigned to |language=

	local this_wiki_name = mw.language.fetchLanguageName(cfg.this_wiki_code, cfg.this_wiki_code);	-- get this wiki's language name

	names_table = mw.text.split (lang, '%s*,%s*');								-- names should be a comma separated list

	for _, lang in ipairs (names_table) do										-- reuse lang
		name = cfg.lang_code_remap[lang:lower()];								-- first see if this is a code that is not supported by MediaWiki but is in remap

		if name then															-- there was a remapped code so
			if not lang:match ('^%a%a%a?%-x%-%a+$') then						-- if not a private ietf tag
				lang = lang:gsub ('^(%a%a%a?)%-.*', '%1');						-- strip ietf tags from code
			end
		else
			lang = lang:gsub ('^(%a%a%a?)%-.*', '%1');							-- strip any ietf-like tags from code
			if 2 == lang:len() or 3 == lang:len() then							-- if two-or three-character code
				name = mw.language.fetchLanguageName (lang:lower(), cfg.this_wiki_code);	-- get language name if |language= is a proper code
			end
		end

		if is_set (name) then													-- if |language= specified a valid code
			code = lang:lower();												-- save it
		else
			name, code = get_iso639_code (lang, cfg.this_wiki_code);				-- attempt to get code from name (assign name here so that we are sure of proper capitalization)
		end
	
		if is_set (code) then													-- only 2- or 3-character codes
			name = cfg.lang_code_remap[code] or name;							-- override wikimedia when they misuse language codes/names

			if cfg.this_wiki_code ~= code then									-- when the language is not the same as this wiki's language
				if 2 == code:len() then											-- and is a two-character code
					add_prop_cat ('foreign_lang_source' .. code, {name, code});	-- categorize it; code appended to allow for multiple language categorization
				else															-- or is a recognized language (but has a three-character code)
					add_prop_cat ('foreign_lang_source_2' .. code, {code});		-- categorize it differently TODO: support mutliple three-character code categories per cs1|2 template
				end
			elseif cfg.local_lang_cat_enable then								-- when the language and this wiki's language are the same and categorization is enabled
				add_prop_cat ('local_lang_source', {name, code});				-- categorize it
			end
		else
			add_maint_cat ('unknown_lang');										-- add maint category if not already added
		end
		
		table.insert (language_list, name);
		name = '';																-- so we can reuse it
	end
	
	code = #language_list														-- reuse code as number of languages in the list
	if 2 &gt;= code then
		name = table.concat (language_list, cfg.messages['parameter-pair-separator'])		-- insert '&lt;space&gt;and&lt;space&gt;' between two language names
	elseif 2 &lt; code then
		name = table.concat (language_list, cfg.messages['parameter-separator'], 1, code-1);			-- concatenate all but last
		name = table.concat ({name, language_list[code]}, cfg.messages['parameter-final-separator']);	-- concatenate last with final separator
	end
	if this_wiki_name == name then
		return '';																-- if one language and that language is this wiki's return an empty string (no annotation)
	end
	return (" " .. wrap_msg ('language', name));								-- otherwise wrap with '(in ...)'
	--[[ TODO: should only return blank or name rather than full list
	so we can clean up the bunched parenthetical elements Language, Type, Format
	]]
end


--[[--------------------------&lt; S E T _ C S 1 _ S T Y L E &gt;----------------------------------------------------

Set style settings for CS1 citation templates. Returns separator and postscript settings
At en.wiki, for cs1:
	ps gets:	'.'
	sep gets:	'.'

]]

local function set_cs1_style (ps)
	if not is_set (ps) then														-- unless explicitly set to something
		ps = cfg.presentation['ps_cs1'];										-- terminate the rendered citation
	end
	return cfg.presentation['sep_cs1'], ps;										-- element separator
end


--[[--------------------------&lt; S E T _ C S 2 _ S T Y L E &gt;----------------------------------------------------

Set style settings for CS2 citation templates. Returns separator, postscript, ref settings
At en.wiki, for cs2:
	ps gets:	'' (empty string - no terminal punctuation)
	sep gets:	','

]]

local function set_cs2_style (ps, ref)
	if not is_set (ps) then														-- if |postscript= has not been set, set cs2 default
		ps = cfg.presentation['ps_cs2'];										-- terminate the rendered citation
	end
	if not is_set (ref) then													-- if |ref= is not set
		ref = "harv";															-- set default |ref=harv
	end
	return cfg.presentation['sep_cs2'], ps, ref;								-- element separator
end


--[[--------------------------&lt; G E T _ S E T T I N G S _ F R O M _ C I T E _ C L A S S &gt;----------------------

When |mode= is not set or when its value is invalid, use config.CitationClass and parameter values to establish
rendered style.

]]

local function get_settings_from_cite_class (ps, ref, cite_class)
	local sep;
	if (cite_class == "citation") then											-- for citation templates (CS2)
		sep, ps, ref = set_cs2_style (ps, ref);
	else																		-- not a citation template so CS1
		sep, ps = set_cs1_style (ps);
	end

	return sep, ps, ref															-- return them all
end


--[[--------------------------&lt; S E T _ S T Y L E &gt;------------------------------------------------------------

Establish basic style settings to be used when rendering the citation.  Uses |mode= if set and valid or uses
config.CitationClass from the template's #invoke: to establish style.

]]

local function set_style (mode, ps, ref, cite_class)
	local sep;
	if 'cs2' == mode then														-- if this template is to be rendered in CS2 (citation) style
		sep, ps, ref = set_cs2_style (ps, ref);
	elseif 'cs1' == mode then													-- if this template is to be rendered in CS1 (cite xxx) style
		sep, ps = set_cs1_style (ps);
	else																		-- anything but cs1 or cs2
		sep, ps, ref = get_settings_from_cite_class (ps, ref, cite_class);		-- get settings based on the template's CitationClass
	end

	if cfg.keywords_xlate[ps:lower()] == 'none' then							-- if assigned value is 'none' then
		ps = '';																-- set to empty string
	end
	
	return sep, ps, ref
end


--[=[-------------------------&lt; I S _ P D F &gt;------------------------------------------------------------------

Determines if a url has the file extension that is one of the pdf file extensions used by [[MediaWiki:Common.css]] when
applying the pdf icon to external links.

returns true if file extension is one of the recognized extensions, else false

]=]

local function is_pdf (url)
	return url:match ('%.pdf$') or url:match ('%.PDF$') or
		url:match ('%.pdf[%?#]') or url:match ('%.PDF[%?#]') or
		url:match ('%.PDF&amp;#035') or url:match ('%.pdf&amp;#035');
end


--[[--------------------------&lt; S T Y L E _ F O R M A T &gt;------------------------------------------------------

Applies css style to |format=, |chapter-format=, etc.  Also emits an error message if the format parameter does
not have a matching url parameter.  If the format parameter is not set and the url contains a file extension that
is recognized as a pdf document by MediaWiki's commons.css, this code will set the format parameter to (PDF) with
the appropriate styling.

]]

local function style_format (format, url, fmt_param, url_param)
	if is_set (format) then
		format = wrap_style ('format', format);									-- add leading space, parentheses, resize
		if not is_set (url) then
			format = format .. set_error( 'format_missing_url', {fmt_param, url_param} );	-- add an error message
		end
	elseif is_pdf (url) then													-- format is not set so if url is a pdf file then
		format = wrap_style ('format', 'PDF');									-- set format to pdf
	else
		format = '';															-- empty string for concatenation
	end
	return format;
end


--[[--------------------------&lt; G E T _ D I S P L A Y _ N A M E S &gt;--------------------------------------------

Returns a number that defines the number of names displayed for author and editor name lists and a boolean flag
to indicate when et al. should be appended to the name list.

When the value assigned to |display-xxxxors= is a number greater than or equal to zero, return the number and
the previous state of the 'etal' flag (false by default but may have been set to true if the name list contains
some variant of the text 'et al.').

When the value assigned to |display-xxxxors= is the keyword 'etal', return a number that is one greater than the
number of authors in the list and set the 'etal' flag true.  This will cause the list_people() to display all of
the names in the name list followed by 'et al.'

In all other cases, returns nil and the previous state of the 'etal' flag.

inputs:
	max: A['DisplayAuthors'] or A['DisplayEditors']; a number or some flavor of etal
	count: #a or #e
	list_name: 'authors' or 'editors'
	etal: author_etal or editor_etal

]]

local function get_display_names (max, count, list_name, etal)
	if is_set (max) then
		if 'etal' == max:lower():gsub("[ '%.]", '') then						-- the :gsub() portion makes 'etal' from a variety of 'et al.' spellings and stylings
			max = count + 1;													-- number of authors + 1 so display all author name plus et al.
			etal = true;														-- overrides value set by extract_names()
		elseif max:match ('^%d+$') then											-- if is a string of numbers
			max = tonumber (max);												-- make it a number
			if max &gt;= count then												-- if |display-xxxxors= value greater than or equal to number of authors/editors
				add_maint_cat ('disp_name', cfg.special_case_translation [list_name]);
			end
		else																	-- not a valid keyword or number
			table.insert( z.message_tail, { set_error( 'invalid_param_val', {'display-' .. list_name, max}, true ) } );		-- add error message
			max = nil;															-- unset; as if |display-xxxxors= had not been set
		end
	end
	
	return max, etal;
end


--[[--------------------------&lt; E X T R A _ T E X T _ I N _ P A G E _ C H E C K &gt;------------------------------

Adds page to Category:CS1 maint: extra text if |page= or |pages= has what appears to be some form of p. or pp. 
abbreviation in the first characters of the parameter content.

check Page and Pages for extraneous p, p., pp, and pp. at start of parameter value:
	good pattern: '^P[^%.P%l]' matches when |page(s)= begins PX or P# but not Px where x and X are letters and # is a dgiit
	bad pattern: '^[Pp][Pp]' matches matches when |page(s)= begins pp or pP or Pp or PP

]]

local function extra_text_in_page_check (page)
	local good_pattern = '^P[^%.Pp]';											-- ok to begin with uppercase P: P7 (pg 7 of section P) but not p123 (page 123) TODO: add Gg for PG or Pg?
	local bad_pattern = '^[Pp]?[Pp]%.?[ %d]';

	if not page:match (good_pattern) and (page:match (bad_pattern) or  page:match ('^[Pp]ages?')) then
		add_maint_cat ('extra_text');
	end
end


--[=[-------------------------&lt; G E T _ V _ N A M E _ T A B L E &gt;----------------------------------------------

split apart a |vauthors= or |veditors= parameter.  This function allows for corporate names, wrapped in doubled
parentheses to also have commas; in the old version of the code, the doubled parnetheses were included in the
rendered citation and in the metadata.  Individual author names may be wikilinked

	|vauthors=Jones AB, [[E. B. White|White EB]], ((Black, Brown, and Co.))

]=]

local function get_v_name_table (vparam, output_table, output_link_table)
	local name_table = mw.text.split(vparam, "%s*,%s*");						-- names are separated by commas
	local wl_type, label, link;													-- wl_type not used here; just a place holder
	
	local i = 1;
	
	while name_table[i] do
		if name_table[i]:match ('^%(%(.*[^%)][^%)]$') then						-- first segment of corporate with one or more commas; this segment has the opening doubled parens
			local name = name_table[i];
			i=i+1;																-- bump indexer to next segment
			while name_table[i] do
				name = name .. ', ' .. name_table[i];							-- concatenate with previous segments
				if name_table[i]:match ('^.*%)%)$') then						-- if this table member has the closing doubled parens
					break;														-- and done reassembling so
				end
				i=i+1;															-- bump indexer
			end
			table.insert (output_table, name);									-- and add corporate name to the output table
			table.insert (output_link_table, '');								-- no wikilink
		else
			wl_type, label, link = is_wikilink (name_table[i]);					-- wl_type is: 0, no wl (text in label variable); 1, [[D]]; 2, [[L|D]]
			table.insert (output_table, label);									-- add this name
			if 1 == wl_type then
				table.insert (output_link_table, label);						-- simple wikilink [[D]]
			else
				table.insert (output_link_table, link);							-- no wikilink or [[L|D]]; add this link if there is one, else empty string
			end
		end
		i = i+1;
	end	
	return output_table;
end


--[[--------------------------&lt; P A R S E _ V A U T H O R S _ V E D I T O R S &gt;--------------------------------

This function extracts author / editor names from |vauthors= or |veditors= and finds matching |xxxxor-maskn= and
|xxxxor-linkn= in args.  It then returns a table of assembled names just as extract_names() does.

Author / editor names in |vauthors= or |veditors= must be in Vancouver system style. Corporate or institutional names
may sometimes be required and because such names will often fail the is_good_vanc_name() and other format compliance
tests, are wrapped in doubled paranethese ((corporate name)) to suppress the format tests.

Supports generational suffixes Jr, 2nd, 3rd, 4th–6th.

This function sets the vancouver error when a reqired comma is missing and when there is a space between an author's initials.

]]

local function parse_vauthors_veditors (args, vparam, list_name)
	local names = {};															-- table of names assembled from |vauthors=, |author-maskn=, |author-linkn=
	local v_name_table = {};
	local v_link_table = {};													-- when name is wikilinked, targets go in this table
	local etal = false;															-- return value set to true when we find some form of et al. vauthors parameter
	local last, first, link, mask, suffix;
	local corporate = false;

	vparam, etal = name_has_etal (vparam, etal, true);							-- find and remove variations on et al. do not categorize (do it here because et al. might have a period)
	v_name_table = get_v_name_table (vparam, v_name_table, v_link_table);		-- names are separated by commas

	for i, v_name in ipairs(v_name_table) do
		if v_name:match ('^%(%(.+%)%)$') then									-- corporate authors are wrapped in doubled parentheses to supress vanc formatting and error detection
			first = '';															-- set to empty string for concatenation and because it may have been set for previous author/editor
			last = v_name:match ('^%(%((.+)%)%)$')								-- remove doubled parntheses
			corporate = true;													-- flag used in list_people()
		elseif string.find(v_name, "%s") then
			if v_name:find('[;%.]') then										-- look for commonly occurring punctuation characters; 
				add_vanc_error (cfg.err_msg_supl.punctuation);
			end
			local lastfirstTable = {}
			lastfirstTable = mw.text.split(v_name, "%s")
			first = table.remove(lastfirstTable);								-- removes and returns value of last element in table which should be author intials
			if is_suffix (first) then											-- if a valid suffix
				suffix = first													-- save it as a suffix and
				first = table.remove(lastfirstTable);							-- get what should be the initials from the table
			end																	-- no suffix error message here because letter combination may be result of Romanization; check for digits?
			last = table.concat(lastfirstTable, " ")							-- returns a string that is the concatenation of all other names that are not initials
			if mw.ustring.match (last, '%a+%s+%u+%s+%a+') then
				add_vanc_error (cfg.err_msg_supl['missing comma']);								-- matches last II last; the case when a comma is missing
			end
			if mw.ustring.match (v_name, ' %u %u$') then						-- this test is in the wrong place TODO: move or replace with a more appropriate test
				add_vanc_error (cfg.err_msg_supl.name);										-- matches a space between two intiials
			end
		else
			first = '';															-- set to empty string for concatenation and because it may have been set for previous author/editor
			last = v_name;														-- last name or single corporate name?  Doesn't support multiword corporate names? do we need this?
		end
																
		if is_set (first) then
			if not mw.ustring.match (first, "^%u?%u$") then						-- first shall contain one or two upper-case letters, nothing else
				add_vanc_error (cfg.err_msg_supl.initials);									-- too many initials; mixed case initials (which may be ok Romanization); hyphenated initials
			end
			is_good_vanc_name (last, first);									-- check first and last before restoring the suffix which may have a non-Latin digit
			if is_set (suffix) then
				first = first .. ' ' .. suffix;									-- if there was a suffix concatenate with the initials
				suffix = '';													-- unset so we don't add this suffix to all subsequent names
			end
		else
			if not corporate then
				is_good_vanc_name (last, '');
			end
		end

		link = select_one( args, cfg.aliases[list_name .. '-Link'], 'redundant_parameters', i ) or v_link_table[i];
		mask = select_one( args, cfg.aliases[list_name .. '-Mask'], 'redundant_parameters', i );
		names[i] = {last = last, first = first, link = link, mask = mask, corporate=corporate};		-- add this assembled name to our names list
	end
	return names, etal;															-- all done, return our list of names
end


--[[--------------------------&lt; S E L E C T _ A U T H O R _ E D I T O R _ S O U R C E &gt;------------------------

Select one of |authors=, |authorn= / |lastn / firstn=, or |vauthors= as the source of the author name list or
select one of |editors=, |editorn= / editor-lastn= / |editor-firstn= or |veditors= as the source of the editor name list.

Only one of these appropriate three will be used.  The hierarchy is: |authorn= (and aliases) highest and |authors= lowest and
similarly, |editorn= (and aliases) highest and |editors= lowest

When looking for |authorn= / |editorn= parameters, test |xxxxor1= and |xxxxor2= (and all of their aliases); stops after the second
test which mimicks the test used in extract_names() when looking for a hole in the author name list.  There may be a better
way to do this, I just haven't discovered what that way is.

Emits an error message when more than one xxxxor name source is provided.

In this function, vxxxxors = vauthors or veditors; xxxxors = authors or editors as appropriate.

]]

local function select_author_editor_source (vxxxxors, xxxxors, args, list_name)
	local lastfirst = false;
	if select_one( args, cfg.aliases[list_name .. '-Last'], 'none', 1 ) or		-- do this twice incase we have a |first1= without a |last1=; this ...
		select_one( args, cfg.aliases[list_name .. '-First'], 'none', 1 ) or	-- ... also catches the case where |first= is used with |vauthors=
		select_one( args, cfg.aliases[list_name .. '-Last'], 'none', 2 ) or
		select_one( args, cfg.aliases[list_name .. '-First'], 'none', 2 ) then
			lastfirst=true;
	end

	if (is_set (vxxxxors) and true == lastfirst) or								-- these are the three error conditions
		(is_set (vxxxxors) and is_set (xxxxors)) or
		(true == lastfirst and is_set (xxxxors)) then
			local err_name;
			if 'AuthorList' == list_name then									-- figure out which name should be used in error message
				err_name = 'author';
			else
				err_name = 'editor';
			end
			table.insert( z.message_tail, { set_error( 'redundant_parameters',
				{err_name .. '-name-list parameters'}, true ) } );				-- add error message
	end

	if true == lastfirst then return 1 end;										-- return a number indicating which author name source to use
	if is_set (vxxxxors) then return 2 end;
	if is_set (xxxxors) then return 3 end;
	return 1;																	-- no authors so return 1; this allows missing author name test to run in case there is a first without last 
end


--[[--------------------------&lt; I S _ V A L I D _ P A R A M E T E R _ V A L U E &gt;------------------------------

This function is used to validate a parameter's assigned value for those parameters that have only a limited number
of allowable values (yes, y, true, live, dead, etc).  When the parameter value has not been assigned a value (missing
or empty in the source template) the function returns the value specified by ret_val.  If the parameter value is one
of the list of allowed values returns the translated value; else, emits an error message and returns the value
specified by ret_val.

]]

local function is_valid_parameter_value (value, name, possible, ret_val)
	if not is_set (value) then
		return ret_val;															-- an empty parameter is ok
	elseif in_array (value, possible) then
		return cfg.keywords_xlate[value];										-- return translation of parameter keyword
	else
		table.insert( z.message_tail, { set_error( 'invalid_param_val', {name, value}, true ) } );	-- not an allowed value so add error message
		return ret_val;
	end
end


--[[--------------------------&lt; T E R M I N A T E _ N A M E _ L I S T &gt;----------------------------------------

This function terminates a name list (author, contributor, editor) with a separator character (sepc) and a space
when the last character is not a sepc character or when the last three characters are not sepc followed by two
closing square brackets (close of a wikilink).  When either of these is true, the name_list is terminated with a
single space character.

]]

local function terminate_name_list (name_list, sepc)
	if (string.sub (name_list,-3,-1) == sepc .. '. ') then						-- if already properly terminated
		return name_list;														-- just return the name list
	elseif (string.sub (name_list,-1,-1) == sepc) or (string.sub (name_list,-3,-1) == sepc .. ']]') then	-- if last name in list ends with sepc char
		return name_list .. " ";												-- don't add another
	else
		return name_list .. sepc .. ' ';										-- otherwise terninate the name list
	end
end


--[[-------------------------&lt; F O R M A T _ V O L U M E _ I S S U E &gt;----------------------------------------

returns the concatenation of the formatted volume and issue parameters as a single string; or formatted volume
or formatted issue, or an empty string if neither are set.

]]
	
local function format_volume_issue (volume, issue, cite_class, origin, sepc, lower)
	if not is_set (volume) and not is_set (issue) then
		return '';
	end
	
	if 'magazine' == cite_class or (in_array (cite_class, {'citation', 'map'}) and 'magazine' == origin) then
		if is_set (volume) and is_set (issue) then
			return wrap_msg ('vol-no', {sepc, volume, issue}, lower);
		elseif is_set (volume) then
			return wrap_msg ('vol', {sepc, volume}, lower);
		else
			return wrap_msg ('issue', {sepc, issue}, lower);
		end
	end

	if 'podcast' == cite_class and is_set (issue) then
		return wrap_msg ('issue', {sepc, issue}, lower);
	end

	local vol = '';																-- here for all cites except magazine
		
	if is_set (volume) then
		if volume:match ('^[MDCLXVI]+$') or volume:match ('^%d+$')then			-- volume value is all digits or all uppercase roman numerals
			vol = substitute (cfg.presentation['vol-bold'], {sepc, hyphen_to_dash(volume)});	-- render in bold face
		elseif (4 &lt; mw.ustring.len(volume)) then								-- not all digits or roman numerals and longer than 4 characters
			vol = substitute (cfg.messages['j-vol'], {sepc, volume});			-- not bold
			add_prop_cat ('long_vol');
		else																	-- four or less characters
			vol = substitute (cfg.presentation['vol-bold'], {sepc, hyphen_to_dash(volume)});	-- bold
		end
	end
	if is_set (issue) then
		return vol .. substitute (cfg.messages['j-issue'], issue);
	end
	return vol;
end


--[[-------------------------&lt; F O R M A T _ P A G E S _ S H E E T S &gt;-----------------------------------------

adds static text to one of |page(s)= or |sheet(s)= values and returns it with all of the others set to empty strings.
The return order is:
	page, pages, sheet, sheets

Singular has priority over plural when both are provided.

]]

local function format_pages_sheets (page, pages, sheet, sheets, cite_class, origin, sepc, nopp, lower)
	if 'map' == cite_class then													-- only cite map supports sheet(s) as in-source locators
		if is_set (sheet) then
			if 'journal' == origin then
				return '', '', wrap_msg ('j-sheet', sheet, lower), '';
			else
				return '', '', wrap_msg ('sheet', {sepc, sheet}, lower), '';
			end
		elseif is_set (sheets) then
			if 'journal' == origin then
				return '', '', '', wrap_msg ('j-sheets', sheets, lower);
			else
				return '', '', '', wrap_msg ('sheets', {sepc, sheets}, lower);
			end
		end
	end

	local is_journal = 'journal' == cite_class or (in_array (cite_class, {'citation', 'map', 'interview'}) and 'journal' == origin);
	
	if is_set (page) then
		if is_journal then
			return substitute (cfg.messages['j-page(s)'], page), '', '', '';
		elseif not nopp then
			return substitute (cfg.messages['p-prefix'], {sepc, page}), '', '', '';
		else
			return substitute (cfg.messages['nopp'], {sepc, page}), '', '', '';
		end
	elseif is_set(pages) then
		if is_journal then
			return substitute (cfg.messages['j-page(s)'], pages), '', '', '';
		elseif tonumber(pages) ~= nil and not nopp then							-- if pages is only digits, assume a single page number
			return '', substitute (cfg.messages['p-prefix'], {sepc, pages}), '', '';
		elseif not nopp then
			return '', substitute (cfg.messages['pp-prefix'], {sepc, pages}), '', '';
		else
			return '', substitute (cfg.messages['nopp'], {sepc, pages}), '', '';
		end
	end
	
	return '', '', '', '';														-- return empty strings
end


--[[--------------------------&lt; I N S O U R C E _ L O C _ G E T &gt;----------------------------------------------

returns one of the in-source locators: page, pages, or at. 

If any of these are interwiki links to wikisource, returns the label portion of the interwikilink as plain text
for use in COinS.  This COinS thing is done because here we convert an interwiki link to and external link and
add an icon span around that; get_coins_pages() doesn't know about the span.  TODO: should it?  

TODO: add support for sheet and sheets?; streamline;

TODO: make it so that this function returns only one of the three as the single in-source (the return value assigned
to a new name)?

]]

local function insource_loc_get (page, pages, at)
	local ws_url, ws_label, coins_pages, L;										-- for wikisource interwikilinks; TODO: this corrupts page metadata (span remains in place after cleanup; fix there?)

	if is_set (page) then
		if is_set (pages) or is_set(at) then
			pages = '';															-- unset the others
			at = '';
		end
		extra_text_in_page_check (page);										-- add this page to maint cat if |page= value begins with what looks like p. or pp.

		ws_url, ws_label, L = wikisource_url_make (page);						-- make ws url from |page= interwiki link; link portion L becomes tool tip label
		if ws_url then
			page = external_link (ws_url, ws_label .. '&amp;nbsp;', 'ws link in page');	-- space char after label to move icon away from in-source text; TODO: a better way to do this?
			page = substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, page});
			coins_pages = ws_label;
		end
	elseif is_set (pages) then
		if is_set (at) then
			at = '';															-- unset
		end
		extra_text_in_page_check (pages);										-- add this page to maint cat if |pages= value begins with what looks like p. or pp.

		ws_url, ws_label, L = wikisource_url_make (pages);						-- make ws url from |pages= interwiki link; link portion L becomes tool tip label
		if ws_url then
			pages = external_link (ws_url, ws_label .. '&amp;nbsp;', 'ws link in pages');	-- space char after label to move icon away from in-source text; TODO: a better way to do this?
			pages = substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, pages});
			coins_pages = ws_label;
		end
	elseif is_set (at) then
		ws_url, ws_label, L = wikisource_url_make (at);							-- make ws url from |at= interwiki link; link portion L becomes tool tip label
		if ws_url then
			at = external_link (ws_url, ws_label .. '&amp;nbsp;', 'ws link in at');	-- space char after label to move icon away from in-source text; TODO: a better way to do this?
			at = substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, at});
			coins_pages = ws_label;
		end
	end
	
	return page, pages, at, coins_pages;
end


--[=[-------------------------&lt; A R C H I V E _ U R L _ C H E C K &gt;--------------------------------------------

Check archive.org urls to make sure they at least look like they are pointing at valid archives and not to the 
save snapshot url or to calendar pages.  When the archive url is 'https://web.archive.org/save/' (or http://...)
archive.org saves a snapshot of the target page in the url.  That is something that Wikipedia should not allow
unwitting readers to do.

When the archive.org url does not have a complete timestamp, archive.org chooses a snapshot according to its own
algorithm or provides a calendar 'search' result.  [[WP:ELNO]] discourages links to search results.

This function looks at the value assigned to |archive-url= and returns empty strings for |archive-url= and
|archive-date= and an error message when:
	|archive-url= holds an archive.org save command url
	|archive-url= is an archive.org url that does not have a complete timestamp (YYYYMMDDhhmmss 14 digits) in the
		correct place
otherwise returns |archive-url= and |archive-date=

There are two mostly compatible archive.org urls:
	//web.archive.org/&lt;timestamp&gt;...		-- the old form
	//web.archive.org/web/&lt;timestamp&gt;...	-- the new form

The old form does not support or map to the new form when it contains a display flag.  There are four identified flags
('id_', 'js_', 'cs_', 'im_') but since archive.org ignores others following the same form (two letters and an underscore)
we don't check for these specific flags but we do check the form.

This function supports a preview mode.  When the article is rendered in preview mode, this funct may return a modified
archive url:
	for save command errors, return undated wildcard (/*/)
	for timestamp errors when the timestamp has a wildcard, return the url unmodified
	for timestamp errors when the timestamp does not have a wildcard, return with timestamp limited to six digits plus wildcard (/yyyymm*/)

]=]

local function archive_url_check (url, date)
	local err_msg = '';															-- start with the error message empty
	local path, timestamp, flag;												-- portions of the archive.or url
	
	if (not url:match('//web%.archive%.org/')) and (not url:match('//liveweb%.archive%.org/')) then		-- also deprecated liveweb Wayback machine url
		return url, date;														-- not an archive.org archive, return ArchiveURL and ArchiveDate
	end

	if url:match('//web%.archive%.org/save/') then								-- if a save command url, we don't want to allow saving of the target page 
		err_msg = cfg.err_msg_supl.save;
		url = url:gsub ('(//web%.archive%.org)/save/', '%1/*/', 1);				-- for preview mode: modify ArchiveURL
	elseif url:match('//liveweb%.archive%.org/') then
		err_msg = cfg.err_msg_supl.liveweb;
	else
		path, timestamp, flag = url:match('//web%.archive%.org/([^%d]*)(%d+)([^/]*)/');	-- split out some of the url parts for evaluation
		
		if not is_set(timestamp) or 14 ~= timestamp:len() then					-- path and flag optional, must have 14-digit timestamp here
			err_msg = cfg.err_msg_supl.timestamp;
			if '*' ~= flag then
				url=url:gsub ('(//web%.archive%.org/[^%d]*%d?%d?%d?%d?%d?%d?)[^/]*', '%1*', 1)	-- for preview, modify ts to be yearmo* max (0-6 digits plus splat)
			end
		elseif is_set(path) and 'web/' ~= path then								-- older archive urls do not have the extra 'web/' path element
			err_msg = cfg.err_msg_supl.path;
		elseif is_set (flag) and not is_set (path) then							-- flag not allowed with the old form url (without the 'web/' path element)
			err_msg = cfg.err_msg_supl.flag;
		elseif is_set (flag) and not flag:match ('%a%a_') then					-- flag if present must be two alpha characters and underscore (requires 'web/' path element)
			err_msg = cfg.err_msg_supl.flag;
		else
			return url, date;													-- return ArchiveURL and ArchiveDate
		end
	end
																				-- if here, something not right so
	table.insert( z.message_tail, { set_error( 'archive_url', {err_msg}, true ) } );	-- add error message and
	if is_set (Frame:preprocess('{{REVISIONID}}')) then
		return '', '';															-- return empty strings for ArchiveURL and ArchiveDate
	else
		return url, date;														-- preview mode so return ArchiveURL and ArchiveDate
	end
end


--[[--------------------------&lt; P L A C E _ C H E C K &gt;--------------------------------------------------------

check |place=, |publication-place=, |location= to see if these params include digits.  This function added because
many editors mis-use location to specify the in-source location (|page(s)= and |at= are supposed to do that)

returns the original parameter value without modification; added maint cat when parameter value contains digits

]]

local function place_check (param_val)
	if not is_set (param_val) then												-- parameter empty or omitted
		return param_val;														-- return that empty state
	end
	
	if mw.ustring.find (param_val, '%d') then									-- not empty, are there digits in the parameter value
		add_maint_cat ('location');												-- yep, add maint cat
	end
	
	return param_val;															-- and done
end


--[[--------------------------&lt; C I T A T I O N 0 &gt;------------------------------------------------------------

This is the main function doing the majority of the citation formatting.

]]

local function citation0( config, args)
	--[[ 
	Load Input Parameters
	The argument_wrapper facilitates the mapping of multiple aliases to single internal variable.
	]]
	local A = argument_wrapper( args );
	local i 

	-- Pick out the relevant fields from the arguments.  Different citation templates
	-- define different field names for the same underlying things.	

	local Mode = is_valid_parameter_value (A['Mode'], A:ORIGIN('Mode'), cfg.keywords_lists['mode'], '');

	local author_etal;
	local a	= {};																-- authors list from |lastn= / |firstn= pairs or |vauthors=
	local Authors;

	local NameListFormat = is_valid_parameter_value (A['NameListFormat'], A:ORIGIN('NameListFormat'), cfg.keywords_lists['name-list-format'], '');
	local Collaboration = A['Collaboration'];

	do																			-- to limit scope of selected
		local selected = select_author_editor_source (A['Vauthors'], A['Authors'], args, 'AuthorList');
		if 1 == selected then
			a, author_etal = extract_names (args, 'AuthorList');				-- fetch author list from |authorn= / |lastn= / |firstn=, |author-linkn=, and |author-maskn=
		elseif 2 == selected then
			NameListFormat = 'vanc';											-- override whatever |name-list-format= might be
			a, author_etal = parse_vauthors_veditors (args, args.vauthors, 'AuthorList');	-- fetch author list from |vauthors=, |author-linkn=, and |author-maskn=
		elseif 3 == selected then
			Authors = A['Authors'];												-- use content of |authors=
			if 'authors' == A:ORIGIN('Authors') then							-- but add a maint cat if the parameter is |authors=
				add_maint_cat ('authors');										-- because use of this parameter is discouraged; what to do about the aliases is a TODO:
			end
		end
		if is_set (Collaboration) then
			author_etal = true;													-- so that |display-authors=etal not required
		end
	end

	local Others = A['Others'];

	local editor_etal;
	local e	= {};																-- editors list from |editor-lastn= / |editor-firstn= pairs or |veditors=
	local Editors;

	do																			-- to limit scope of selected
		local selected = select_author_editor_source (A['Veditors'], A['Editors'], args, 'EditorList');
		if 1 == selected then
			e, editor_etal = extract_names (args, 'EditorList');				-- fetch editor list from |editorn= / |editor-lastn= / |editor-firstn=, |editor-linkn=, and |editor-maskn=
		elseif 2 == selected then
			NameListFormat = 'vanc';											-- override whatever |name-list-format= might be
			e, editor_etal = parse_vauthors_veditors (args, args.veditors, 'EditorList');	-- fetch editor list from |veditors=, |editor-linkn=, and |editor-maskn=
		elseif 3 == selected then
			Editors = A['Editors'];												-- use content of |editors=
			add_maint_cat ('editors');											-- but add a maint cat because use of this parameter is discouraged
		end
	end

	local translator_etal;
	local t = {};																-- translators list from |translator-lastn= / translator-firstn= pairs
	local Translators;															-- assembled translators name list
	t = extract_names (args, 'TranslatorList');									-- fetch translator list from |translatorn= / |translator-lastn=, -firstn=, -linkn=, -maskn=

	local interviewer_etal;
	local interviewers_list = {};												
	local Interviewers;															-- used later
	interviewers_list = extract_names (args, 'InterviewerList');				-- process preferred interviewers parameters

	local contributor_etal;
	local c = {};																-- contributors list from |contributor-lastn= / contributor-firstn= pairs
	local Contributors;															-- assembled contributors name list
	local Contribution = A['Contribution'];										-- TODO: move to after chapter use if A:ORIGIN ('Chapter') ... to set Contribution; this to remove duplicate in aliases list
	if in_array(config.CitationClass, {"book","citation"}) and not is_set(A['Periodical']) then	-- |contributor= and |contribution= only supported in book cites
		c = extract_names (args, 'ContributorList');							-- fetch contributor list from |contributorn= / |contributor-lastn=, -firstn=, -linkn=, -maskn=
		
		if 0 &lt; #c then
			if not is_set (Contribution) then									-- |contributor= requires |contribution=
				table.insert( z.message_tail, { set_error( 'contributor_missing_required_param', 'contribution')});	-- add missing contribution error message
				c = {};															-- blank the contributors' table; it is used as a flag later
			end
			if 0 == #a then														-- |contributor= requires |author=
				table.insert( z.message_tail, { set_error( 'contributor_missing_required_param', 'author')});	-- add missing author error message
				c = {};															-- blank the contributors' table; it is used as a flag later
			end
		end
	else																		-- if not a book cite
		if select_one (args, cfg.aliases['ContributorList-Last'], 'redundant_parameters', 1 ) then	-- are there contributor name list parameters?
			table.insert( z.message_tail, { set_error( 'contributor_ignored')});	-- add contributor ignored error message
		end
		Contribution = nil;														-- unset
	end

	if is_set (Others) then
		if 0 == #a and 0 == #e then												-- add maint cat when |others= has value and used without |author=, |editor=
			add_maint_cat ('others');
		end
	end

	local Year = A['Year'];
	local PublicationDate = A['PublicationDate'];
	local OrigYear = A['OrigYear'];
	local Date = A['Date'];
	local LayDate = A['LayDate'];
	------------------------------------------------- Get title data
	local Title = A['Title'];
	local ScriptTitle = A['ScriptTitle'];
	local BookTitle = A['BookTitle'];
	local Conference = A['Conference'];
	local TransTitle = A['TransTitle'];
	local TitleNote = A['TitleNote'];
	local TitleLink = A['TitleLink'];
			link_title_ok (TitleLink, A:ORIGIN ('TitleLink'), Title, 'title');	-- check for wikimarkup in |title-link= or wikimarkup in |title= when |title-link= is set

	local Chapter = A['Chapter'];												-- TODO: insert test, assignment, and then unset Chapter when |section= in cite map; test is at c. line 3220
	local ScriptChapter = A['ScriptChapter'];
	local ScriptChapterOrigin = A:ORIGIN ('ScriptChapter');
	local ChapterLink	-- = A['ChapterLink'];									-- deprecated as a parameter but still used internally by cite episode
	local TransChapter = A['TransChapter'];
	local TitleType = A['TitleType'];
	local Degree = A['Degree'];
	local Docket = A['Docket'];
	local ArchiveFormat = A['ArchiveFormat'];

	local ArchiveDate;
	local ArchiveURL;

	ArchiveURL, ArchiveDate = archive_url_check (A['ArchiveURL'], A['ArchiveDate'])
	
	local UrlStatus = is_valid_parameter_value (A['UrlStatus'], A:ORIGIN('UrlStatus'), cfg.keywords_lists['url-status'], '');


	local URL = A['URL']
	local URLorigin = A:ORIGIN('URL');											-- get name of parameter that holds URL
	local ChapterURL = A['ChapterURL'];
	local ChapterURLorigin = A:ORIGIN('ChapterURL');							-- get name of parameter that holds ChapterURL
	local ConferenceFormat = A['ConferenceFormat'];
	local ConferenceURL = A['ConferenceURL'];
	local ConferenceURLorigin = A:ORIGIN('ConferenceURL');						-- get name of parameter that holds ConferenceURL

																				-- TODO: mailinglist should be removed from Periodical alias list; Periodical should be assigned value from |mailinglist= here wh
	local Periodical = A['Periodical'];											-- cite mailinglist or citation and |mailinglist=; error check for duplicate work params (Periodical already set)
	local Periodical_origin = '';
		if is_set (Periodical) then
			Periodical_origin = A:ORIGIN('Periodical');							-- get the name of the periodical parameter
			local i;
			Periodical, i = strip_apostrophe_markup (Periodical);				-- strip appostrophe markup so that metadata isn't contaminated 
			if i then															-- non-zero when markup was stripped so emit an error message
				table.insert( z.message_tail, {set_error ('apostrophe_markup', {Periodical_origin}, true)});
			end
		end
																				-- TODO: mailinglist assignment here? iff Periodical not set; err msg else; see TODO c. line 2607
	local ScriptPeriodical = A['ScriptPeriodical'];
	local ScriptPeriodical_origin = A:ORIGIN('ScriptPeriodical');
																				-- web and news not tested for now because of 
																				-- Wikipedia:Administrators%27_noticeboard#Is_there_a_semi-automated_tool_that_could_fix_these_annoying_"Cite_Web"_errors?
		if not (is_set (Periodical) or is_set (ScriptPeriodical)) then			-- 'periodical' templates require periodical parameter
	--		local p = {['journal'] = 'journal', ['magazine'] = 'magazine', ['news'] = 'newspaper', ['web'] = 'website'};	-- for error message
			local p = {['journal'] = 'journal', ['magazine'] = 'magazine'};		-- for error message
			if p[config.CitationClass]  then
				table.insert( z.message_tail, {set_error ('missing_periodical', {config.CitationClass, p[config.CitationClass]}, true)});
			end
		end

	local TransPeriodical =  A['TransPeriodical'];

	local Series = A['Series'];
	
	local Volume;
	local Issue;
	local Page;
	local Pages;
	local At;

	if 'citation' == config.CitationClass then
		if is_set (Periodical) then
			if not in_array (Periodical_origin, {'website', 'mailinglist'}) then	-- {{citation}} does not render volume for these 'periodicals'
				Volume = A['Volume'];											-- but does for all other 'periodicals'
			end
		elseif is_set (ScriptPeriodical) then
			if 'script-website' ~= ScriptPeriodical_origin then					-- {{citation}} does not render volume for |script-website=
				Volume = A['Volume'];											-- but does for all other 'periodicals'
			end
		else
			Volume = A['Volume'];												-- and does for non-'periodical' cites
		end
	elseif in_array (config.CitationClass, cfg.templates_using_volume) then		-- render |volume= for cs1 according to the configuration settings
		Volume = A['Volume'];
	end	

	if 'citation' == config.CitationClass then
		if is_set (Periodical) and in_array (Periodical_origin, {'journal', 'magazine', 'newspaper', 'periodical', 'work'}) or	-- {{citation}} renders issue for these 'periodicals'
			is_set (ScriptPeriodical) and in_array (ScriptPeriodical_origin, {'script-journal', 'script-magazine', 'script-newspaper', 'script-periodical', 'script-work'}) then -- and these 'script-periodicals'
				Issue = hyphen_to_dash (A['Issue']);
		end
	elseif in_array (config.CitationClass, cfg.templates_using_issue) then		-- conference &amp; map books do not support issue; {{citation}} listed here because included in settings table
		if not (in_array (config.CitationClass, {'conference', 'map', 'citation'}) and not (is_set (Periodical) or is_set (ScriptPeriodical))) then
			Issue = hyphen_to_dash (A['Issue']);
		end
	end

	local Position = '';
	if not in_array (config.CitationClass, cfg.templates_not_using_page) then
		Page = A['Page'];
		Pages = hyphen_to_dash (A['Pages']);	
		At = A['At'];
	end

	local Edition = A['Edition'];
	local PublicationPlace = place_check (A['PublicationPlace'], A:ORIGIN('PublicationPlace'));
	local Place = place_check (A['Place'], A:ORIGIN('Place'));
	
	local PublisherName = A['PublisherName'];
	local PublisherName_origin = A:ORIGIN('PublisherName');
		if is_set (PublisherName) then
			local i=0;
			PublisherName, i = strip_apostrophe_markup (PublisherName);			-- strip appostrophe markup so that metadata isn't contaminated; publisher is never italicized

			if i then															-- non-zero when markup was stripped so emit an error message
				table.insert( z.message_tail, {set_error ('apostrophe_markup', {PublisherName_origin}, true)});
			end
		end

	local Newsgroup = A['Newsgroup'];											-- TODO: strip apostrophe markup?
	local Newsgroup_origin = A:ORIGIN('Newsgroup');	

	if 'newsgroup' == config.CitationClass then
		if is_set (PublisherName) then											-- general use parmeter |publisher= not allowed in cite newsgroup
			local error_text = set_error ('parameter_ignored', {PublisherName_origin}, true);
			if is_set (error_text) then
				table.insert( z.message_tail, {error_text, error_state} );
			end				
		end

		PublisherName = nil;													-- ensure that this parameter is unset for the time being; will be used again after COinS
	end

	local UrlAccess = is_valid_parameter_value (A['UrlAccess'], A:ORIGIN('UrlAccess'), cfg.keywords_lists['url-access'], nil);
		if not is_set(URL) and is_set(UrlAccess) then
			UrlAccess = nil;
			table.insert( z.message_tail, { set_error( 'param_access_requires_param', {'url'}, true ) } );
		end
		
	local ChapterUrlAccess = is_valid_parameter_value (A['ChapterUrlAccess'], A:ORIGIN('ChapterUrlAccess'), cfg.keywords_lists['url-access'], nil);
		if not is_set(ChapterURL) and is_set(ChapterUrlAccess) then
			ChapterUrlAccess = nil;
			table.insert( z.message_tail, { set_error( 'param_access_requires_param', {A:ORIGIN('ChapterUrlAccess'):gsub ('%-access', '')}, true ) } );
		end

	local MapUrlAccess = is_valid_parameter_value (A['MapUrlAccess'], A:ORIGIN('MapUrlAccess'), cfg.keywords_lists['url-access'], nil);
		if not is_set(A['MapURL']) and is_set(MapUrlAccess) then
			MapUrlAccess = nil;
			table.insert( z.message_tail, { set_error( 'param_access_requires_param', {'map-url'}, true ) } );
		end

	local Via = A['Via'];
	local AccessDate = A['AccessDate'];
	local Agency = A['Agency'];

	local Language = A['Language'];
	local Format = A['Format'];
	local ChapterFormat = A['ChapterFormat'];
	local DoiBroken = A['DoiBroken'];
	local ID = A['ID'];
	local ASINTLD = A['ASINTLD'];
	local IgnoreISBN = is_valid_parameter_value (A['IgnoreISBN'], A:ORIGIN('IgnoreISBN'), cfg.keywords_lists['yes_true_y'], nil);
	local Embargo = A['Embargo'];
	local Class = A['Class'];													-- arxiv class identifier

	local ID_list = extract_ids( args );
		if is_set (DoiBroken) and not ID_list['DOI'] then
			table.insert( z.message_tail, { set_error( 'doibroken_missing_doi', A:ORIGIN('DoiBroken'))});
		end
	local ID_access_levels = extract_id_access_levels( args, ID_list );

	local Quote = A['Quote'];

	local LayFormat = A['LayFormat'];
	local LayURL = A['LayURL'];
	local LaySource = A['LaySource'];
	local Transcript = A['Transcript'];
	local TranscriptFormat = A['TranscriptFormat'];
	local TranscriptURL = A['TranscriptURL'] 
	local TranscriptURLorigin = A:ORIGIN('TranscriptURL');						-- get name of parameter that holds TranscriptURL

	local LastAuthorAmp = is_valid_parameter_value (A['LastAuthorAmp'], A:ORIGIN('LastAuthorAmp'), cfg.keywords_lists['yes_true_y'], nil);

	local no_tracking_cats = is_valid_parameter_value (A['NoTracking'], A:ORIGIN('NoTracking'), cfg.keywords_lists['yes_true_y'], nil);

	--local variables that are not cs1 parameters
	local use_lowercase;														-- controls capitalization of certain static text
	local this_page = mw.title.getCurrentTitle();								-- also used for COinS and for language
	local anchor_year;															-- used in the CITEREF identifier
	local COinS_date = {};														-- holds date info extracted from |date= for the COinS metadata by Module:Date verification

	local DF = is_valid_parameter_value (A['DF'], A:ORIGIN('DF'), cfg.keywords_lists['df'], '');
	if not is_set (DF) then
		DF = cfg.global_df;														-- local df if present overrides global df set by {{use xxx date}} template
	end

	local sepc;																	-- separator between citation elements for CS1 a period, for CS2, a comma
	local PostScript;
	local Ref = A['Ref'];
	if 'harv' == Ref then
		add_maint_cat ('ref_harv');												-- add maint cat to identify templates that have this now-extraneous param value
	elseif not is_set (Ref) then
		Ref = 'harv';															-- set as default when not set externally
	end
	
	sepc, PostScript, Ref = set_style (Mode:lower(), A['PostScript'], Ref, config.CitationClass);
	use_lowercase = ( sepc == ',' );											-- used to control capitalization for certain static text

	--check this page to see if it is in one of the namespaces that cs1 is not supposed to add to the error categories
	if not is_set (no_tracking_cats) then										-- ignore if we are already not going to categorize this page
		if in_array (this_page.nsText, cfg.uncategorized_namespaces) then
			no_tracking_cats = "true";											-- set no_tracking_cats
		end
		for _,v in ipairs (cfg.uncategorized_subpages) do						-- cycle through page name patterns
			if this_page.text:match (v) then									-- test page name against each pattern
				no_tracking_cats = "true";										-- set no_tracking_cats
				break;															-- bail out if one is found
			end
		end
	end
																				-- check for extra |page=, |pages= or |at= parameters. (also sheet and sheets while we're at it)
	select_one (args, {'page', 'p', 'pp', 'pages', 'at', 'sheet', 'sheets'}, 'redundant_parameters');	-- this is a dummy call simply to get the error message and category

	local coins_pages;
	
	Page, Pages, At, coins_pages = insource_loc_get (Page, Pages, At);

	local NoPP = is_valid_parameter_value (A['NoPP'], A:ORIGIN('NoPP'), cfg.keywords_lists['yes_true_y'], nil);

	if is_set (PublicationPlace) and is_set (Place) then						-- both |publication-place= and |place= (|location=) allowed if different
		add_prop_cat ('location test');											-- add property cat to evaluate how often PublicationPlace and Place are used together
		if PublicationPlace == Place then
			Place = '';															-- unset; don't need both if they are the same
		end
	elseif not is_set (PublicationPlace) and is_set (Place) then				-- when only |place= (|location=) is set ...
		PublicationPlace = Place;												-- promote |place= (|location=) to |publication-place
	end

	if PublicationPlace == Place then Place = ''; end							-- don't need both if they are the same
	
	--[[
	Parameter remapping for cite encyclopedia:
	When the citation has these parameters:
		|encyclopedia and |title then map |title to |article and |encyclopedia to |title
		|encyclopedia and |article then map |encyclopedia to |title

		|trans-title maps to |trans-chapter when |title is re-mapped
		|url maps to |chapterurl when |title is remapped
	
	All other combinations of |encyclopedia, |title, and |article are not modified
	
	]]

	local Encyclopedia = A['Encyclopedia'];

	if ( config.CitationClass == "encyclopaedia" ) or ( config.CitationClass == "citation" and is_set (Encyclopedia)) then	-- test code for citation
		if is_set (Periodical) then												-- Periodical is set when |encyclopedia is set
			if is_set(Title) or is_set (ScriptTitle) then
				if not is_set(Chapter) then
					Chapter = Title;											-- |encyclopedia and |title are set so map |title to |article and |encyclopedia to |title
					ScriptChapter = ScriptTitle;
					ScriptChapterOrigin = A:ORIGIN('ScriptTitle')
					TransChapter = TransTitle;
					ChapterURL = URL;
					ChapterURLorigin = A:ORIGIN('URL')

					ChapterUrlAccess = UrlAccess;

					if not is_set (ChapterURL) and is_set (TitleLink) then
						Chapter = make_wikilink (TitleLink, Chapter);
					end
					Title = Periodical;
					ChapterFormat = Format;
					Periodical = '';											-- redundant so unset
					TransTitle = '';
					URL = '';
					Format = '';
					TitleLink = '';
					ScriptTitle = '';
				end
			elseif is_set (Chapter) then										-- |title not set
				Title = Periodical;												-- |encyclopedia set and |article set so map |encyclopedia to |title
				Periodical = '';												-- redundant so unset
			end
		end
	end

	-- Special case for cite techreport.
	if (config.CitationClass == "techreport") then								-- special case for cite techreport
		if is_set(A['Number']) then												-- cite techreport uses 'number', which other citations alias to 'issue'
			if not is_set(ID) then												-- can we use ID for the "number"?
				ID = A['Number'];												-- yes, use it
			else																-- ID has a value so emit error message
				table.insert( z.message_tail, { set_error('redundant_parameters', {wrap_style ('parameter', 'id') .. ' and ' .. wrap_style ('parameter', 'number')}, true )});
			end
		end	
	end

	-- special case for cite mailing list
	if (config.CitationClass == "mailinglist") then								-- TODO: move this to Periodical assignment; see TODOs at c. line 2360
		Periodical = A ['MailingList'];
	elseif 'mailinglist' == Periodical_origin then
		Periodical = '';														-- unset because mailing list is only used for cite mailing list
	end

	-- Account for the oddity that is {{cite conference}}, before generation of COinS data.
	if 'conference' == config.CitationClass then
		if is_set(BookTitle) then
			Chapter = Title;
	--		ChapterLink = TitleLink;											-- |chapterlink= is deprecated
			ChapterURL = URL;
			ChapterUrlAccess = UrlAccess;
			ChapterURLorigin = URLorigin;
			URLorigin = '';
			ChapterFormat = Format;
			TransChapter = TransTitle;
			Title = BookTitle;
			Format = '';
	--		TitleLink = '';
			TransTitle = '';
			URL = '';
		end
	elseif 'speech' ~= config.CitationClass then
		Conference = '';														-- not cite conference or cite speech so make sure this is empty string
	end

	-- cite map oddities
	local Cartography = "";
	local Scale = "";
	local Sheet = A['Sheet'] or '';
	local Sheets = A['Sheets'] or '';
	if config.CitationClass == "map" then
		Chapter = A['Map'];
		ChapterURL = A['MapURL'];
		ChapterURLorigin = A:ORIGIN('MapURL');
		TransChapter = A['TransMap'];
		ScriptChapter = A['ScriptMap']
		ScriptChapterOrigin = A:ORIGIN('ScriptMap')

		ChapterUrlAccess = MapUrlAccess;
		ChapterFormat = A['MapFormat'];

		Cartography = A['Cartography'];
		if is_set( Cartography ) then
			Cartography = sepc .. " " .. wrap_msg ('cartography', Cartography, use_lowercase);
		end		
		Scale = A['Scale'];
		if is_set( Scale ) then
			Scale = sepc .. " " .. Scale;
		end
	end

	-- Account for the oddities that are {{cite episode}} and {{cite serial}}, before generation of COinS data.
	if 'episode' == config.CitationClass or 'serial' == config.CitationClass then
		local SeriesLink = A['SeriesLink'];

		link_title_ok (SeriesLink, A:ORIGIN ('SeriesLink'), Series, 'series');	-- check for wikimarkup in |series-link= or wikimarkup in |series= when |series-link= is set

		local Network = A['Network'];
		local Station = A['Station'];
		local s, n = {}, {};
																				-- do common parameters first
		if is_set(Network) then table.insert(n, Network); end
		if is_set(Station) then table.insert(n, Station); end
		ID = table.concat(n, sepc .. ' ');
		
		if 'episode' == config.CitationClass then								-- handle the oddities that are strictly {{cite episode}}
			local Season = A['Season'];
			local SeriesNumber = A['SeriesNumber'];

			if is_set (Season) and is_set (SeriesNumber) then					-- these are mutually exclusive so if both are set
				table.insert( z.message_tail, { set_error( 'redundant_parameters', {wrap_style ('parameter', 'season') .. ' and ' .. wrap_style ('parameter', 'seriesno')}, true ) } );		-- add error message
				SeriesNumber = '';												-- unset; prefer |season= over |seriesno=
			end
																				-- assemble a table of parts concatenated later into Series
			if is_set(Season) then table.insert(s, wrap_msg ('season', Season, use_lowercase)); end
			if is_set(SeriesNumber) then table.insert(s, wrap_msg ('seriesnum', SeriesNumber, use_lowercase)); end
			if is_set(Issue) then table.insert(s, wrap_msg ('episode', Issue, use_lowercase)); end
			Issue = '';															-- unset because this is not a unique parameter
	
			Chapter = Title;													-- promote title parameters to chapter
			ScriptChapter = ScriptTitle;
			ScriptChapterOrigin = A:ORIGIN('ScriptTitle');
			ChapterLink = TitleLink;											-- alias episodelink
			TransChapter = TransTitle;
			ChapterURL = URL;
			ChapterUrlAccess = UrlAccess;
			ChapterURLorigin = A:ORIGIN('URL');
			
			Title = Series;														-- promote series to title
			TitleLink = SeriesLink;
			Series = table.concat(s, sepc .. ' ');								-- this is concatenation of season, seriesno, episode number

			if is_set (ChapterLink) and not is_set (ChapterURL) then			-- link but not URL
				Chapter = make_wikilink (ChapterLink, Chapter);
			elseif is_set (ChapterLink) and is_set (ChapterURL) then			-- if both are set, URL links episode;
				Series = make_wikilink (ChapterLink, Series);
			end
			URL = '';															-- unset
			TransTitle = '';
			ScriptTitle = '';
			
		else																	-- now oddities that are cite serial
			Issue = '';															-- unset because this parameter no longer supported by the citation/core version of cite serial
			Chapter = A['Episode'];												-- TODO: make |episode= available to cite episode someday?
			if is_set (Series) and is_set (SeriesLink) then
				Series = make_wikilink (SeriesLink, Series);
			end
			Series = wrap_style ('italic-title', Series);						-- series is italicized
		end	
	end
	-- end of {{cite episode}} stuff

	-- Account for the oddities that are {{cite arxiv}}, {{cite biorxiv}}, {{cite citeseerx}}, {{cite ssrn}}, before generation of COinS data.
	do
		if in_array (config.CitationClass, whitelist.preprint_template_list) then
			if not is_set (ID_list[config.CitationClass:upper()]) then			-- |arxiv= or |eprint= required for cite arxiv; |biorxiv= &amp; |citeseerx= required for their templates
				table.insert( z.message_tail, { set_error( config.CitationClass .. '_missing', {}, true ) } );	-- add error message
			end

			Periodical = ({['arxiv'] = 'arXiv', ['biorxiv'] = 'bioRxiv', ['citeseerx'] = 'CiteSeerX', ['ssrn'] = 'Social Science Research Network'})[config.CitationClass];
		end
	end

	-- handle type parameter for those CS1 citations that have default values
	if in_array(config.CitationClass, {"AV-media-notes", "interview", "mailinglist", "map", "podcast", "pressrelease", "report", "techreport", "thesis"}) then
		TitleType = set_titletype (config.CitationClass, TitleType);
		if is_set(Degree) and "Thesis" == TitleType then						-- special case for cite thesis
			TitleType = Degree .. ' ' .. cfg.title_types ['thesis']:lower();
		end
	end

	if is_set(TitleType) then													-- if type parameter is specified
		TitleType = substitute( cfg.messages['type'], TitleType);				-- display it in parentheses
	-- TODO: Hack on TitleType to fix bunched parentheses problem
	end

	-- legacy: promote PublicationDate to Date if neither Date nor Year are set.
 	local Date_origin;															-- to hold the name of parameter promoted to Date; required for date error messaging

	if not is_set (Date) then
		Date = Year;															-- promote Year to Date
		Year = nil;																-- make nil so Year as empty string isn't used for CITEREF
		if not is_set (Date) and is_set(PublicationDate) then					-- use PublicationDate when |date= and |year= are not set
			Date = PublicationDate;												-- promote PublicationDate to Date
			PublicationDate = '';												-- unset, no longer needed
			Date_origin = A:ORIGIN('PublicationDate');							-- save the name of the promoted parameter
		else
			Date_origin = A:ORIGIN('Year');										-- save the name of the promoted parameter
		end
	else
		Date_origin = A:ORIGIN('Date');											-- not a promotion; name required for error messaging
	end

	if PublicationDate == Date then PublicationDate = ''; end					-- if PublicationDate is same as Date, don't display in rendered citation

	--[[
	Go test all of the date-holding parameters for valid MOS:DATE format and make sure that dates are real dates. This must be done before we do COinS because here is where
	we get the date used in the metadata.
	
	Date validation supporting code is in Module:Citation/CS1/Date_validation
	]]
	do	-- create defined block to contain local variables error_message, date_parameters_list, mismatch
		local error_message = '';
																				-- AirDate has been promoted to Date so not necessary to check it
		local date_parameters_list = {
			['access-date'] = {val=AccessDate, name=A:ORIGIN ('AccessDate')},
			['archive-date'] = {val=ArchiveDate, name=A:ORIGIN ('ArchiveDate')},
			['date'] = {val=Date, name=Date_origin},
			['doi-broken-date'] = {val=DoiBroken, name=A:ORIGIN ('DoiBroken')},
			['embargo'] = {val=Embargo, name=A:ORIGIN ('Embargo')},
			['lay-date'] = {val=LayDate, name=A:ORIGIN ('LayDate')},
			['publication-date'] ={val=PublicationDate, name=A:ORIGIN ('PublicationDate')},
			['year'] = {val=Year, name=A:ORIGIN ('Year')},
			};
		anchor_year, Embargo, error_message = dates(date_parameters_list, COinS_date);

-- start temporary Julian / Gregorian calendar uncertainty categorization
		if COinS_date.inter_cal_cat then
			add_prop_cat ('jul_greg_uncertainty');
		end
-- end temporary Julian / Gregorian calendar uncertainty categorization

		if is_set (Year) and is_set (Date) then									-- both |date= and |year= not normally needed; 
			local mismatch = year_date_check (Year, Date)
			if 0 == mismatch then												-- |year= does not match a year-value in |date=
				if is_set (error_message) then									-- if there is already an error message
					error_message = error_message .. ', ';						-- tack on this additional message
				end
				error_message = error_message .. '&amp;#124;year= / &amp;#124;date= mismatch';
			elseif 1 == mismatch then											-- |year= matches year-value in |date=
				add_maint_cat ('date_year');
			end
		end
		
		if not is_set(error_message) then										-- error free dates only
			local modified = false;												-- flag
			
			if is_set (DF) then													-- if we need to reformat dates
				modified = reformat_dates (date_parameters_list, DF, false);	-- reformat to DF format, use long month names if appropriate
			end

			if true == date_hyphen_to_dash (date_parameters_list) then			-- convert hyphens to dashes where appropriate
				modified = true;
				add_maint_cat ('date_format');									-- hyphens were converted so add maint category
			end
			
	-- for those wikis that can and want to have English date names translated to the local language,
	-- uncomment these three lines.  Not supported by en.wiki (for obvious reasons)
	-- set date_name_xlate() second argument to true to translate English digits to local digits (will translate ymd dates)
	--		if date_name_xlate (date_parameters_list, false) then
	--			modified = true;
	--		end

			if modified then													-- if the date_parameters_list values were modified
				AccessDate = date_parameters_list['access-date'].val;			-- overwrite date holding parameters with modified values
				ArchiveDate = date_parameters_list['archive-date'].val;
				Date = date_parameters_list['date'].val;
				DoiBroken = date_parameters_list['doi-broken-date'].val;
				LayDate = date_parameters_list['lay-date'].val;
				PublicationDate = date_parameters_list['publication-date'].val;
			end
		else
			table.insert( z.message_tail, { set_error( 'bad_date', {error_message}, true ) } );	-- add this error message
		end
	end	-- end of do

	-- Account for the oddity that is {{cite journal}} with |pmc= set and |url= not set.  Do this after date check but before COInS.
	-- Here we unset Embargo if PMC not embargoed (|embargo= not set in the citation) or if the embargo time has expired. Otherwise, holds embargo date
	Embargo = is_embargoed (Embargo);

	if config.CitationClass == "journal" and not is_set(URL) and is_set(ID_list['PMC']) then
		if not is_set (Embargo) then											-- if not embargoed or embargo has expired
			URL=cfg.id_handlers['PMC'].prefix .. ID_list['PMC'];				-- set url to be the same as the PMC external link if not embargoed
			URLorigin = cfg.id_handlers['PMC'].parameters[1];					-- set URLorigin to parameter name for use in error message if citation is missing a |title=
			if is_set(AccessDate) then											-- access date requires |url=; pmc created url is not |url=
				table.insert( z.message_tail, { set_error( 'accessdate_missing_url', {}, true ) } );
				AccessDate = '';												-- unset
			end

		end
	end

	-- At this point fields may be nil if they weren't specified in the template use.  We can use that fact.
	-- Test if citation has no title
	if	not is_set(Title) and
		not is_set(TransTitle) and
		not is_set(ScriptTitle) then
			if 'episode' == config.CitationClass then							-- special case for cite episode; TODO: is there a better way to do this?
				table.insert( z.message_tail, { set_error( 'citation_missing_title', {'series'}, true ) } );
			else
				table.insert( z.message_tail, { set_error( 'citation_missing_title', {'title'}, true ) } );
			end
	end

	if cfg.keywords_xlate[Title] == 'none' and
			in_array (config.CitationClass, {'journal', 'citation'}) and
			(is_set (Periodical) or is_set (ScriptPeriodical)) and
			('journal' == Periodical_origin or 'script-journal' == ScriptPeriodical_origin) then	-- special case for journal cites
				Title = '';														-- set title to empty string
				add_maint_cat ('untitled');
	end

	check_for_url ({															-- add error message when any of these parameters hold a URL
		['title']=Title,
		[A:ORIGIN('Chapter')]=Chapter,
		[Periodical_origin] = Periodical,
		[PublisherName_origin] = PublisherName
		});

	-- COinS metadata (see &lt;http://ocoins.info/&gt;) for automated parsing of citation information.
	-- handle the oddity that is cite encyclopedia and {{citation |encyclopedia=something}}. Here we presume that
	-- when Periodical, Title, and Chapter are all set, then Periodical is the book (encyclopedia) title, Title
	-- is the article title, and Chapter is a section within the article.  So, we remap 
	
	local coins_chapter = Chapter;												-- default assuming that remapping not required
	local coins_title = Title;													-- et tu
	if 'encyclopaedia' == config.CitationClass or ('citation' == config.CitationClass and is_set (Encyclopedia)) then
		if is_set (Chapter) and is_set (Title) and is_set (Periodical) then		-- if all are used then
			coins_chapter = Title;												-- remap
			coins_title = Periodical;
		end
	end
	local coins_author = a;														-- default for coins rft.au 
	if 0 &lt; #c then																-- but if contributor list
		coins_author = c;														-- use that instead
	end
	
	-- this is the function call to COinS()
	local OCinSoutput = COinS({
		['Periodical'] = strip_apostrophe_markup (Periodical),					-- no markup in the metadata
		['Encyclopedia'] = strip_apostrophe_markup (Encyclopedia),
		['Chapter'] = make_coins_title (coins_chapter, ScriptChapter),			-- Chapter and ScriptChapter stripped of bold / italic wikimarkup
		['Degree'] = Degree;													-- cite thesis only
		['Title'] = make_coins_title (coins_title, ScriptTitle),				-- Title and ScriptTitle stripped of bold / italic wikimarkup
		['PublicationPlace'] = PublicationPlace,
		['Date'] = COinS_date.rftdate,											-- COinS_date has correctly formatted date if Date is valid;
		['Season'] = COinS_date.rftssn,
		['Chron'] =  COinS_date.rftchron or (not COinS_date.rftdate and Date) or '',	-- chron but if not set and invalid date format use Date; keep this last bit?
		['Series'] = Series,
		['Volume'] = Volume,
		['Issue'] = Issue,
		['Pages'] = coins_pages or get_coins_pages (first_set ({Sheet, Sheets, Page, Pages, At}, 5)),	-- pages stripped of external links
		['Edition'] = Edition,
		['PublisherName'] = PublisherName or Newsgroup,							-- any apostrophe markup already removed from PublisherName
		['URL'] = first_set ({ChapterURL, URL}, 2),
		['Authors'] = coins_author,
		['ID_list'] = ID_list,
		['RawPage'] = this_page.prefixedText,
	}, config.CitationClass);

	-- Account for the oddities that are {{cite arxiv}}, {{cite biorxiv}}, {{cite citeseerx}}, and {{cite ssrn}} AFTER generation of COinS data.
	if in_array (config.CitationClass, whitelist.preprint_template_list) then	-- we have set rft.jtitle in COinS to arXiv, bioRxiv, CiteSeerX, or ssrn now unset so it isn't displayed
		Periodical = '';														-- periodical not allowed in these templates; if article has been published, use cite journal
	end

	-- special case for cite newsgroup.  Do this after COinS because we are modifying Publishername to include some static text
	if 'newsgroup' == config.CitationClass and is_set (Newsgroup) then
		PublisherName = substitute (cfg.messages['newsgroup'], external_link( 'news:' .. Newsgroup, Newsgroup, Newsgroup_origin, nil ));
	end

	-- Now perform various field substitutions.
	-- We also add leading spaces and surrounding markup and punctuation to the
	-- various parts of the citation, but only when they are non-nil.
	local EditorCount;															-- used only for choosing {ed.) or (eds.) annotation at end of editor name-list
	do
		local last_first_list;
		local control = { 
			format = NameListFormat,											-- empty string or 'vanc'
			maximum = nil,														-- as if display-authors or display-editors not set
			lastauthoramp = LastAuthorAmp,
			mode = Mode
		};

		do																		-- do editor name list first because the now unsupported coauthors used to modify control table
			control.maximum , editor_etal = get_display_names (A['DisplayEditors'], #e, 'editors', editor_etal);
			last_first_list, EditorCount = list_people(control, e, editor_etal);

			if is_set (Editors) then
				Editors, editor_etal = name_has_etal (Editors, editor_etal, false, 'editors');	-- find and remove variations on et al.
				if editor_etal then
					Editors = Editors .. ' ' .. cfg.messages['et al'];			-- add et al. to editors parameter beause |display-editors=etal
				end
				EditorCount = 2;												-- we don't know but assume |editors= is multiple names; spoof to display (eds.) annotation
			else
				Editors = last_first_list;										-- either an author name list or an empty string
			end

			if 1 == EditorCount and (true == editor_etal or 1 &lt; #e) then		-- only one editor displayed but includes etal then 
				EditorCount = 2;												-- spoof to display (eds.) annotation
			end
		end
		do																		-- now do interviewers
			control.maximum , interviewer_etal = get_display_names (A['DisplayInterviewers'], #interviewers_list, 'interviewers', interviewer_etal);
			Interviewers = list_people (control, interviewers_list, interviewer_etal);
		end
		do																		-- now do translators
			control.maximum , translator_etal = get_display_names (A['DisplayTranslators'], #t, 'translators', translator_etal);
			Translators = list_people (control, t, translator_etal);
		end
		do																		-- now do contributors
			control.maximum , contributor_etal = get_display_names (A['DisplayContributors'], #c, 'contributors', contributor_etal);
			Contributors = list_people (control, c, contributor_etal);
		end
		do																		-- now do authors
			control.maximum , author_etal = get_display_names (A['DisplayAuthors'], #a, 'authors', author_etal);

			last_first_list = list_people(control, a, author_etal);

			if is_set (Authors) then
				Authors, author_etal = name_has_etal (Authors, author_etal, false, 'authors');	-- find and remove variations on et al.
				if author_etal then
					Authors = Authors .. ' ' .. cfg.messages['et al'];			-- add et al. to authors parameter
				end
			else
				Authors = last_first_list;										-- either an author name list or an empty string
			end
		end																		-- end of do
	
		if is_set (Authors) and is_set (Collaboration) then
			Authors = Authors .. ' (' .. Collaboration .. ')';					-- add collaboration after et al.
		end

	end

	-- apply |[xx-]format= styling; at the end, these parameters hold correctly styled format annotation,
	-- an error message if the associated url is not set, or an empty string for concatenation
	ArchiveFormat = style_format (ArchiveFormat, ArchiveURL, 'archive-format', 'archive-url');
	ConferenceFormat = style_format (ConferenceFormat, ConferenceURL, 'conference-format', 'conference-url');
	Format = style_format (Format, URL, 'format', 'url');
	LayFormat = style_format (LayFormat, LayURL, 'lay-format', 'lay-url');
	TranscriptFormat = style_format (TranscriptFormat, TranscriptURL, 'transcript-format', 'transcripturl');

	-- special case for chapter format so no error message or cat when chapter not supported
	if not (in_array(config.CitationClass, {'web', 'news', 'journal', 'magazine', 'pressrelease', 'podcast', 'newsgroup', 'arxiv', 'biorxiv', 'citeseerx', 'ssrn'}) or
		('citation' == config.CitationClass and (is_set (Periodical) or is_set (ScriptPeriodical)) and not is_set (Encyclopedia))) then
			ChapterFormat = style_format (ChapterFormat, ChapterURL, 'chapter-format', 'chapter-url');
	end

	if not is_set(URL) then
		if in_array(config.CitationClass, {"web","podcast", "mailinglist"}) or		-- |url= required for cite web, cite podcast, and cite mailinglist
			('citation' == config.CitationClass and ('website' == Periodical_origin or 'script-website' == ScriptPeriodical_origin)) then	-- and required for {{citation}} with |website= or |script-website=
				table.insert( z.message_tail, { set_error( 'cite_web_url', {}, true ) } );
		end
		
		-- do we have |accessdate= without either |url= or |chapter-url=?
		if is_set(AccessDate) and not is_set(ChapterURL)then					-- ChapterURL may be set when URL is not set;
			table.insert( z.message_tail, { set_error( 'accessdate_missing_url', {}, true ) } );
			AccessDate = '';
		end
	end

	local OriginalURL, OriginalURLorigin, OriginalFormat, OriginalAccess;
	UrlStatus = UrlStatus:lower();												-- used later when assembling archived text
	if is_set( ArchiveURL ) then
		if is_set (ChapterURL) then 											-- if chapter-url is set apply archive url to it
			OriginalURL = ChapterURL;											-- save copy of source chapter's url for archive text
			OriginalURLorigin = ChapterURLorigin;								-- name of chapter-url parameter for error messages
			OriginalFormat = ChapterFormat;										-- and original |chapter-format=

			if 'live' ~= UrlStatus then
				ChapterURL = ArchiveURL											-- swap-in the archive's url
				ChapterURLorigin = A:ORIGIN('ArchiveURL')						-- name of archive-url parameter for error messages
				ChapterFormat = ArchiveFormat or '';							-- swap in archive's format
				ChapterUrlAccess = nil;											-- restricted access levels do not make sense for archived urls
			end
		elseif is_set (URL) then
			OriginalURL = URL;													-- save copy of original source URL
			OriginalURLorigin = URLorigin;										-- name of url parameter for error messages
			OriginalFormat = Format; 											-- and original |format=
			OriginalAccess = UrlAccess;

			if 'live' ~= UrlStatus then											-- if URL set then archive-url applies to it
				URL = ArchiveURL												-- swap-in the archive's url
				URLorigin = A:ORIGIN('ArchiveURL')								-- name of archive url parameter for error messages
				Format = ArchiveFormat or '';									-- swap in archive's format
				UrlAccess = nil;												-- restricted access levels do not make sense for archived urls
			end
 		end
	end

	if in_array(config.CitationClass, {'web','news','journal', 'magazine', 'pressrelease', 'podcast', 'newsgroup', 'arxiv', 'biorxiv', 'citeseerx', 'ssrn'}) or	-- if any of the 'periodical' cites except encyclopedia
		('citation' == config.CitationClass and (is_set (Periodical) or is_set (ScriptPeriodical)) and not is_set (Encyclopedia)) then
			local chap_param;
			if is_set (Chapter) then											-- get a parameter name from one of these chapter related meta-parameters
				chap_param = A:ORIGIN ('Chapter')
			elseif is_set (TransChapter) then
				chap_param = A:ORIGIN ('TransChapter')
			elseif is_set (ChapterURL) then
				chap_param = A:ORIGIN ('ChapterURL')
			elseif is_set (ScriptChapter) then
				chap_param = ScriptChapterOrigin;
			else is_set (ChapterFormat)
				chap_param = A:ORIGIN ('ChapterFormat')
			end

			if is_set (chap_param) then											-- if we found one
				table.insert( z.message_tail, { set_error( 'chapter_ignored', {chap_param}, true ) } );		-- add error message
				Chapter = '';													-- and set them to empty string to be safe with concatenation
				TransChapter = '';
				ChapterURL = '';
				ScriptChapter = '';
				ChapterFormat = '';
			end
	else																		-- otherwise, format chapter / article title
		local no_quotes = false;												-- default assume that we will be quoting the chapter parameter value
		if is_set (Contribution) and 0 &lt; #c then								-- if this is a contribution with contributor(s)
			if in_array (Contribution:lower(), cfg.keywords_lists.contribution) then	-- and a generic contribution title
				no_quotes = true;												-- then render it unquoted
			end
		end

		Chapter = format_chapter_title (ScriptChapter, ScriptChapterOrigin, Chapter, TransChapter, ChapterURL, ChapterURLorigin, no_quotes, ChapterUrlAccess);		-- Contribution is also in Chapter
		if is_set (Chapter) then
			Chapter = Chapter .. ChapterFormat ;
			if 'map' == config.CitationClass and is_set (TitleType) then
				Chapter = Chapter .. ' ' .. TitleType;							-- map annotation here; not after title
			end
			Chapter = Chapter.. sepc .. ' ';
		elseif is_set (ChapterFormat) then										-- |chapter= not set but |chapter-format= is so ...
			Chapter = ChapterFormat .. sepc .. ' ';								-- ... ChapterFormat has error message, we want to see it
		end
	end

	-- Format main title.	TODO: add support for non-English versions of 'Archived copy' when used on other-language wikis 
	if is_set (ArchiveURL) and 
		(mw.ustring.match (mw.ustring.lower(Title), cfg.special_case_translation.archived_copy.en) or	-- if title is 'Archived copy' (place holder added by bots that can't find proper title)
		mw.ustring.match (mw.ustring.lower(Title), cfg.special_case_translation.archived_copy['local'])) then	-- local-wiki's form
			add_maint_cat ('archived_copy');									-- add maintenance category before we modify the content of Title
	end

	if Title:match ('^%(%(.*%)%)$') then										-- if keep as written markup:
		Title= Title:gsub ('^%(%((.*)%)%)$', '%1')								-- remove the markup
	else
		if '...' == Title:sub (-3) then											-- if elipsis is the last three characters of |title=
			Title = Title:gsub ('(%.%.%.)%.+$', '%1');							-- limit the number of dots to three
		elseif not mw.ustring.find (Title, '%.%s*%a%.$') and					-- end of title is not a 'dot-(optional space-)letter-dot' initialism ...
			not mw.ustring.find (Title, '%s+%a%.$') then						-- ...and not a 'space-letter-dot' initial (''Allium canadense'' L.)
				Title = mw.ustring.gsub(Title, '%'..sepc..'$', '');				-- remove any trailing separator character; sepc and ms.ustring() here for languages that use multibyte separator characters
		end
	end

	if in_array(config.CitationClass, {'web', 'news', 'journal', 'magazine', 'pressrelease', 'podcast', 'newsgroup', 'mailinglist', 'interview', 'arxiv', 'biorxiv', 'citeseerx', 'ssrn'}) or
		('citation' == config.CitationClass and (is_set (Periodical) or is_set (ScriptPeriodical)) and not is_set (Encyclopedia)) or
		('map' == config.CitationClass and (is_set (Periodical) or is_set (ScriptPeriodical))) then		-- special case for cite map when the map is in a periodical treat as an article
			Title = kern_quotes (Title);										-- if necessary, separate title's leading and trailing quote marks from Module provided quote marks
			Title = wrap_style ('quoted-title', Title);
			Title = script_concatenate (Title, ScriptTitle, 'script-title');	-- &lt;bdi&gt; tags, lang atribute, categorization, etc; must be done after title is wrapped
			TransTitle= wrap_style ('trans-quoted-title', TransTitle );
	elseif 'report' == config.CitationClass then								-- no styling for cite report
		Title = script_concatenate (Title, ScriptTitle, 'script-title');		-- &lt;bdi&gt; tags, lang atribute, categorization, etc; must be done after title is wrapped
		TransTitle= wrap_style ('trans-quoted-title', TransTitle );				-- for cite report, use this form for trans-title
	else
		Title = wrap_style ('italic-title', Title);
		Title = script_concatenate (Title, ScriptTitle, 'script-title');		-- &lt;bdi&gt; tags, lang atribute, categorization, etc; must be done after title is wrapped
		TransTitle = wrap_style ('trans-italic-title', TransTitle);
	end

	local TransError = "";
	if is_set(TransTitle) then
		if is_set(Title) then
			TransTitle = " " .. TransTitle;
		else
			TransError = " " .. set_error( 'trans_missing_title', {'title'} );
		end
	end

	if is_set (Title) then														-- TODO: is this the right place to be making wikisource urls?
		if not is_set (TitleLink) and is_set (URL) then
			Title = external_link (URL, Title, URLorigin, UrlAccess) .. TransTitle .. TransError .. Format;
			URL = '';															-- unset these because no longer needed
			Format = "";
		elseif is_set (TitleLink) and not is_set (URL) then
			local ws_url;
			ws_url = wikisource_url_make (TitleLink);							-- ignore ws_label return; not used here
			if ws_url then
				Title = external_link (ws_url, Title .. '&amp;nbsp;', 'ws link in title-link');	-- space char after Title to move icon away from italic text; TODO: a better way to do this?
				Title = substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], TitleLink, Title});				
				Title = Title .. TransTitle .. TransError;
			else
				Title = make_wikilink (TitleLink, Title) .. TransTitle .. TransError;
			end
		else
			local ws_url, ws_label;												-- Title has italic or quote markup by the time we get here which causes is_wikilink() to return 0 (not a wikilink)
			ws_url, ws_label, L = wikisource_url_make (Title:gsub('[\'"](.-)[\'"]', '%1'));	-- make ws url from |title= interwiki link (strip italic or quote markup); link portion L becomes tool tip label
			if ws_url then
				Title = Title:gsub ('%b[]', ws_label);							-- replace interwiki link with ws_label to retain markup
				Title = external_link (ws_url, Title .. '&amp;nbsp;', 'ws link in title');	-- space char after Title to move icon away from italic text; TODO: a better way to do this?
				Title = substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, Title});				
				Title = Title .. TransTitle .. TransError;
			else
				Title = Title .. TransTitle .. TransError;
			end
		end
	else
		Title = TransTitle .. TransError;
	end

	if is_set(Place) then
		Place = " " .. wrap_msg ('written', Place, use_lowercase) .. sepc .. " ";
	end

	if is_set (Conference) then
		if is_set (ConferenceURL) then
			Conference = external_link( ConferenceURL, Conference, ConferenceURLorigin, nil );
		end
		Conference = sepc .. " " .. Conference .. ConferenceFormat;
	elseif is_set(ConferenceURL) then
		Conference = sepc .. " " .. external_link( ConferenceURL, nil, ConferenceURLorigin, nil );
	end

	if not is_set(Position) then
		local Minutes = A['Minutes'];
		local Time = A['Time'];

		if is_set(Minutes) then
			if is_set (Time) then
				table.insert( z.message_tail, { set_error( 'redundant_parameters', {wrap_style ('parameter', 'minutes') .. ' and ' .. wrap_style ('parameter', 'time')}, true ) } );
			end
			Position = " " .. Minutes .. " " .. cfg.messages['minutes'];
		else
			if is_set(Time) then
				local TimeCaption = A['TimeCaption']
				if not is_set(TimeCaption) then
					TimeCaption = cfg.messages['event'];
					if sepc ~= '.' then
						TimeCaption = TimeCaption:lower();
					end
				end
				Position = " " .. TimeCaption .. " " .. Time;
			end
		end
	else
		Position = " " .. Position;
		At = '';
	end

	Page, Pages, Sheet, Sheets = format_pages_sheets (Page, Pages, Sheet, Sheets, config.CitationClass, Periodical_origin, sepc, NoPP, use_lowercase);

	At = is_set(At) and (sepc .. " " .. At) or "";
	Position = is_set(Position) and (sepc .. " " .. Position) or "";
	if config.CitationClass == 'map' then										-- TODO copy this line and
		local Section = A['Section'];											-- TODO move this line to c. line 2337 so that separate Sections in aliases{} not required? then unset Chapter?
		local Sections = A['Sections'];
		local Inset = A['Inset'];
		
		if is_set( Inset ) then
			Inset = sepc .. " " .. wrap_msg ('inset', Inset, use_lowercase);
		end			

		if is_set( Sections ) then
			Section = sepc .. " " .. wrap_msg ('sections', Sections, use_lowercase);
		elseif is_set( Section ) then
			Section = sepc .. " " .. wrap_msg ('section', Section, use_lowercase);
		end
		At = At .. Inset .. Section;		
	end	

	if is_set (Language) then
		Language = language_parameter (Language);								-- format, categories, name from ISO639-1, etc
	else
		Language="";															-- language not specified so make sure this is an empty string;
	--[[ TODO: need to extract the wrap_msg from language_parameter
	so that we can solve parentheses bunching problem with Format/Language/TitleType
	]]
	end

	Others = is_set(Others) and (sepc .. " " .. Others) or "";
	
	if is_set (Translators) then
		Others = safe_join ({sepc .. ' ', wrap_msg ('translated', Translators, use_lowercase), Others}, sepc);
	end
	if is_set (Interviewers) then
		Others = safe_join ({sepc .. ' ', wrap_msg ('interview', Interviewers, use_lowercase), Others}, sepc);
	end
	
	TitleNote = is_set(TitleNote) and (sepc .. " " .. TitleNote) or "";
	if is_set (Edition) then
		if Edition:match ('%f[%a][Ee]d%.?$') or Edition:match ('%f[%a][Ee]dition$') then
			add_maint_cat ('extra_text', 'edition');
		end
		Edition = " " .. wrap_msg ('edition', Edition);
	else
		Edition = '';
	end

	Series = is_set (Series) and wrap_msg ('series', {sepc, Series}) or "";		-- not the same as SeriesNum
	OrigYear = is_set (OrigYear) and wrap_msg ('origyear', OrigYear) or '';
	Agency = is_set (Agency) and wrap_msg ('agency', {sepc, Agency}) or "";
	Volume = format_volume_issue (Volume, Issue, config.CitationClass, Periodical_origin, sepc, use_lowercase);

	------------------------------------ totally unrelated data
	Via = is_set (Via) and  wrap_msg ('via', Via) or '';

	if is_set(AccessDate) then
		local retrv_text = " " .. cfg.messages['retrieved']

		AccessDate = nowrap_date (AccessDate);									-- wrap in nowrap span if date in appropriate format
		if (sepc ~= ".") then retrv_text = retrv_text:lower() end				-- if mode is cs2, lower case
		AccessDate = substitute (retrv_text, AccessDate);						-- add retrieved text

		AccessDate = substitute (cfg.presentation['accessdate'], {sepc, AccessDate});	-- allow editors to hide accessdates
	end
	
	if is_set(ID) then ID = sepc .." ".. ID; end
   	if "thesis" == config.CitationClass and is_set(Docket) then
		ID = sepc .." Docket ".. Docket .. ID;
	end
   	if "report" == config.CitationClass and is_set(Docket) then					-- for cite report when |docket= is set
		ID = sepc .. ' ' .. Docket;												-- overwrite ID even if |id= is set
	end

	ID_list = build_id_list( ID_list, {IdAccessLevels=ID_access_levels, DoiBroken = DoiBroken, ASINTLD = ASINTLD, IgnoreISBN = IgnoreISBN, Embargo=Embargo, Class = Class} );

	if is_set(URL) then
		URL = " " .. external_link( URL, nil, URLorigin, UrlAccess );
	end

	if is_set(Quote) then
		if Quote:sub(1,1) == '"' and Quote:sub(-1,-1) == '"' then				-- if first and last characters of quote are quote marks
			Quote = Quote:sub(2,-2);											-- strip them off
		end
		Quote = sepc .." " .. wrap_style ('quoted-text', Quote ); 				-- wrap in &lt;q&gt;...&lt;/q&gt; tags
		PostScript = "";														-- cs1|2 does not supply terminal punctuation when |quote= is set
	end
	
	local Archived
	if is_set(ArchiveURL) then
		local arch_text;
		if not is_set(ArchiveDate) then
			ArchiveDate = set_error('archive_missing_date');
		end
		if "live" == UrlStatus then
			arch_text = cfg.messages['archived'];
			if sepc ~= "." then arch_text = arch_text:lower() end
			Archived = sepc .. " " .. substitute( cfg.messages['archived-live'],
				{ external_link( ArchiveURL, arch_text, A:ORIGIN('ArchiveURL'), nil ) .. ArchiveFormat, ArchiveDate } );
			if not is_set (OriginalURL) then
				Archived = Archived .. " " .. set_error('archive_missing_url');							   
			end
		elseif is_set(OriginalURL) then											-- UrlStatus is empty, 'dead', 'unfit', 'usurped', 'bot: unknown'
			if in_array (UrlStatus, {'unfit', 'usurped', 'bot: unknown'}) then
				arch_text = cfg.messages['archived-unfit'];
				if sepc ~= "." then arch_text = arch_text:lower() end
				Archived = sepc .. " " .. arch_text .. ArchiveDate;				-- format already styled
				if 'bot: unknown' == UrlStatus then
					add_maint_cat ('bot:_unknown');								-- and add a category if not already added
				else
					add_maint_cat ('unfit');									-- and add a category if not already added
				end
			else																-- UrlStatus is empty, 'dead'
				arch_text = cfg.messages['archived-dead'];
				if sepc ~= "." then arch_text = arch_text:lower() end
				Archived = sepc .. " " .. substitute( arch_text,
					{ external_link( OriginalURL, cfg.messages['original'], OriginalURLorigin, OriginalAccess ) .. OriginalFormat, ArchiveDate } );	-- format already styled
			end	
		else																	-- OriginalUrl not set
			arch_text = cfg.messages['archived-missing'];
			if sepc ~= "." then arch_text = arch_text:lower() end
			Archived = sepc .. " " .. substitute( arch_text, 
				{ set_error('archive_missing_url'), ArchiveDate } );
		end
	elseif is_set (ArchiveFormat) then
		Archived = ArchiveFormat;												-- if set and ArchiveURL not set ArchiveFormat has error message
	else
		Archived = ""
	end
	
	local Lay = '';
	if is_set(LayURL) then
		if is_set(LayDate) then LayDate = " (" .. LayDate .. ")" end
		if is_set(LaySource) then 
			LaySource = " &amp;ndash; ''" .. safe_for_italics(LaySource) .. "''";
		else
			LaySource = "";
		end
		if sepc == '.' then
			Lay = sepc .. " " .. external_link( LayURL, cfg.messages['lay summary'], A:ORIGIN('LayURL'), nil ) .. LayFormat .. LaySource .. LayDate
		else
			Lay = sepc .. " " .. external_link( LayURL, cfg.messages['lay summary']:lower(), A:ORIGIN('LayURL'), nil ) .. LayFormat .. LaySource .. LayDate
		end			
	elseif is_set (LayFormat) then												-- Test if |lay-format= is given without giving a |lay-url=
		Lay = sepc .. LayFormat;												-- if set and LayURL not set, then LayFormat has error message
	end

	if is_set(Transcript) then
		if is_set(TranscriptURL) then
			Transcript = external_link( TranscriptURL, Transcript, TranscriptURLorigin, nil );
		end
		Transcript = sepc .. ' ' .. Transcript .. TranscriptFormat;
	elseif is_set(TranscriptURL) then
		Transcript = external_link( TranscriptURL, nil, TranscriptURLorigin, nil );
	end

	local Publisher;
	if is_set(PublicationDate) then
		PublicationDate = wrap_msg ('published', PublicationDate);
	end
	if is_set(PublisherName) then
		if is_set(PublicationPlace) then
			Publisher = sepc .. " " .. PublicationPlace .. ": " .. PublisherName .. PublicationDate;
		else
			Publisher = sepc .. " " .. PublisherName .. PublicationDate;  
		end			
	elseif is_set(PublicationPlace) then 
		Publisher= sepc .. " " .. PublicationPlace .. PublicationDate;
	else 
		Publisher = PublicationDate;
	end
	
	-- Several of the above rely upon detecting this as nil, so do it last.
	if (is_set (Periodical) or is_set (ScriptPeriodical) or is_set (TransPeriodical)) then
		if is_set(Title) or is_set(TitleNote) then 
			Periodical = sepc .. " " .. format_periodical (ScriptPeriodical, ScriptPeriodical_origin, Periodical, TransPeriodical);
		else 
			Periodical = format_periodical (ScriptPeriodical, ScriptPeriodical_origin, Periodical, TransPeriodical);
		end
	end

	--[[
	Handle the oddity that is cite speech.  This code overrides whatever may be the value assigned to TitleNote (through |department=) and forces it to be " (Speech)" so that
	the annotation directly follows the |title= parameter value in the citation rather than the |event= parameter value (if provided).
	]]
	if "speech" == config.CitationClass then									-- cite speech only
		TitleNote = " (Speech)";												-- annotate the citation
		if is_set (Periodical) then												-- if Periodical, perhaps because of an included |website= or |journal= parameter 
			if is_set (Conference) then											-- and if |event= is set
				Conference = Conference .. sepc .. " ";							-- then add appropriate punctuation to the end of the Conference variable before rendering
			end
		end
	end

	-- Piece all bits together at last.  Here, all should be non-nil.
	-- We build things this way because it is more efficient in LUA
	-- not to keep reassigning to the same string variable over and over.

	local tcommon;
	local tcommon2;																-- used for book cite when |contributor= is set
	
	if in_array(config.CitationClass, {"journal","citation"}) and is_set(Periodical) then
		if is_set(Others) then Others = safe_join ({Others, sepc .. " "}, sepc) end		-- add terminal punctuation &amp; space; check for dup sepc; TODO why do we need to do this here?
		tcommon = safe_join( {Others, Title, TitleNote, Conference, Periodical, Format, TitleType, Series, Language, Edition, Publisher, Agency, Volume}, sepc );
	elseif in_array(config.CitationClass, {"book","citation"}) and not is_set(Periodical) then		-- special cases for book cites
		if is_set (Contributors) then											-- when we are citing foreword, preface, introduction, etc
			tcommon = safe_join( {Title, TitleNote}, sepc );					-- author and other stuff will come after this and before tcommon2
			tcommon2 = safe_join( {Conference, Periodical, Format, TitleType, Series, Language, Volume, Others, Edition, Publisher, Agency}, sepc );
		else
			tcommon = safe_join( {Title, TitleNote, Conference, Periodical, Format, TitleType, Series, Language, Volume, Others, Edition, Publisher, Agency}, sepc );
		end

	elseif 'map' == config.CitationClass then									-- special cases for cite map
		if is_set (Chapter) then												-- map in a book; TitleType is part of Chapter
			tcommon = safe_join( {Title, Format, Edition, Scale, Series, Language, Cartography, Others, Publisher, Volume}, sepc );
		elseif is_set (Periodical) then											-- map in a periodical
			tcommon = safe_join( {Title, TitleType, Format, Periodical, Scale, Series, Language, Cartography, Others, Publisher, Volume}, sepc );
		else																	-- a sheet or stand-alone map
			tcommon = safe_join( {Title, TitleType, Format, Edition, Scale, Series, Language, Cartography, Others, Publisher}, sepc );
		end
		
	elseif 'episode' == config.CitationClass then								-- special case for cite episode
		tcommon = safe_join( {Title, TitleNote, TitleType, Series, Language, Edition, Publisher}, sepc );

	else																		-- all other CS1 templates
		tcommon = safe_join( {Title, TitleNote, Conference, Periodical, Format, TitleType, Series, Language, 
			Volume, Others, Edition, Publisher, Agency}, sepc );
	end
	
	if #ID_list &gt; 0 then
		ID_list = safe_join( { sepc .. " ",  table.concat( ID_list, sepc .. " " ), ID }, sepc );
	else
		ID_list = ID;
	end
	
	local idcommon;
	if 'audio-visual' == config.CitationClass or 'episode' == config.CitationClass then	-- special case for cite AV media &amp; cite episode position transcript
		idcommon = safe_join( { ID_list, URL, Archived, Transcript, AccessDate, Via, Lay, Quote }, sepc );
	else
		idcommon = safe_join( { ID_list, URL, Archived, AccessDate, Via, Lay, Quote }, sepc );
	end
	
	local text;
	local pgtext = Position .. Sheet .. Sheets .. Page .. Pages .. At;

	if is_set(Date) then
		if is_set (Authors) or is_set (Editors) then							-- date follows authors or editors when authors not set
			Date = " (" .. Date ..")" .. OrigYear .. sepc .. " ";				-- in paranetheses
		else																	-- neither of authors and editors set
			if (string.sub(tcommon,-1,-1) == sepc) then							-- if the last character of tcommon is sepc
				Date = " " .. Date .. OrigYear;									-- Date does not begin with sepc
			else
				Date = sepc .. " " .. Date .. OrigYear;							-- Date begins with sepc
			end
		end
	end	
	if is_set(Authors) then
		if (not is_set (Date)) then												-- when date is set it's in parentheses; no Authors termination
			Authors = terminate_name_list (Authors, sepc);						-- when no date, terminate with 0 or 1 sepc and a space
		end
		if is_set(Editors) then
			local in_text = " ";
			local post_text = "";
			if is_set(Chapter) and 0 == #c then
				in_text = in_text .. cfg.messages['in'] .. " "
				if (sepc ~= '.') then
					in_text = in_text:lower()									-- lowercase for cs2
				end
			end
			if EditorCount &lt;= 1 then
				post_text = " (" .. cfg.messages['editor'] .. ")";				-- be consistent with no-author, no-date case
			else
				post_text = " (" .. cfg.messages['editors'] .. ")";
			end
			Editors = terminate_name_list (in_text .. Editors .. post_text, sepc);	-- terminate with 0 or 1 sepc and a space
		end
		if is_set (Contributors) then											-- book cite and we're citing the intro, preface, etc
			local by_text = sepc .. ' ' .. cfg.messages['by'] .. ' ';
			if (sepc ~= '.') then by_text = by_text:lower() end					-- lowercase for cs2
			Authors = by_text .. Authors;										-- author follows title so tweak it here
			if is_set (Editors) and is_set (Date) then							-- when Editors make sure that Authors gets terminated
				Authors = terminate_name_list (Authors, sepc);					-- terminate with 0 or 1 sepc and a space
			end
			if (not is_set (Date)) then											-- when date is set it's in parentheses; no Contributors termination
				Contributors = terminate_name_list (Contributors, sepc);		-- terminate with 0 or 1 sepc and a space
			end
			text = safe_join( {Contributors, Date, Chapter, tcommon, Authors, Place, Editors, tcommon2, pgtext, idcommon }, sepc );
		else
			text = safe_join( {Authors, Date, Chapter, Place, Editors, tcommon, pgtext, idcommon }, sepc );
		end
	elseif is_set(Editors) then
		if is_set(Date) then
			if EditorCount &lt;= 1 then
				Editors = Editors .. ", " .. cfg.messages['editor'];
			else
				Editors = Editors .. ", " .. cfg.messages['editors'];
			end
		else
			if EditorCount &lt;= 1 then
				Editors = Editors .. " (" .. cfg.messages['editor'] .. ")" .. sepc .. " "
			else
				Editors = Editors .. " (" .. cfg.messages['editors'] .. ")" .. sepc .. " "
			end
		end
		text = safe_join( {Editors, Date, Chapter, Place, tcommon, pgtext, idcommon}, sepc );
	else
		if in_array(config.CitationClass, {"journal","citation"}) and is_set(Periodical) then
			text = safe_join( {Chapter, Place, tcommon, pgtext, Date, idcommon}, sepc );
		else
			text = safe_join( {Chapter, Place, tcommon, Date, pgtext, idcommon}, sepc );
		end
	end
	
	if is_set(PostScript) and PostScript ~= sepc then
		text = safe_join( {text, sepc}, sepc ); 								--Deals with italics, spaces, etc.
		text = text:sub(1,-sepc:len()-1);
	end	
	
	text = safe_join( {text, PostScript}, sepc );

	-- Now enclose the whole thing in a &lt;cite/&gt; element
	local options = {};
	
	if is_set(config.CitationClass) and config.CitationClass ~= "citation" then
		options.class = config.CitationClass;
		options.class = "citation " .. config.CitationClass;					-- class=citation required for blue highlight when used with |ref=
	else
		options.class = "citation";
	end
	
	if is_set(Ref) and 'none' ~= cfg.keywords_xlate[Ref:lower()] then
		local id = Ref
		if ('harv' == Ref ) then
			local namelist = {};												-- holds selected contributor, author, editor name list
			local year = first_set ({Year, anchor_year}, 2);					-- Year first for legacy citations and for YMD dates that require disambiguation

			if #c &gt; 0 then														-- if there is a contributor list
				namelist = c;													-- select it
			elseif #a &gt; 0 then													-- or an author list
				namelist = a;
			elseif #e &gt; 0 then													-- or an editor list
				namelist = e;
			end
			if #namelist &gt; 0 then												-- if there are names in namelist
				id = anchor_id (namelist, year);								-- go make the CITEREF anchor
			else
				id = '';														-- unset
			end
		end
		options.id = id;
	end
	
	if string.len(text:gsub("&lt;span[^&gt;/]*&gt;(.-)&lt;/span&gt;", "%1"):gsub("%b&lt;&gt;","")) &lt;= 2 then	-- remove &lt;span&gt; tags and other html-like markup; then get length of what remains
		z.error_categories = {};
		text = set_error('empty_citation');
		z.message_tail = {};
	end
	
	local render = {};															-- here we collect the final bits for concatenation into the rendered citation

	if is_set(options.id) then													-- here we wrap the rendered citation in &lt;cite ...&gt;...&lt;/cite&gt; tags
		table.insert (render, substitute (cfg.presentation['cite-id'], {mw.uri.anchorEncode(options.id), mw.text.nowiki(options.class), text}));	-- when |ref= is set
	else
		table.insert (render, substitute (cfg.presentation['cite'], {mw.text.nowiki(options.class), text}));	-- all other cases
	end		

	table.insert (render, substitute (cfg.presentation['ocins'], {OCinSoutput}));	-- append metadata to the citation

	if 0 ~= #z.message_tail then
		table.insert (render, ' ');
		for i,v in ipairs( z.message_tail ) do
			if is_set(v[1]) then
				if i == #z.message_tail then
					table.insert (render, error_comment( v[1], v[2] ));
				else
					table.insert (render, error_comment( v[1] .. "; ", v[2] ));
				end
			end
		end
	end

	if 0 ~= #z.maintenance_cats then
		local maint_msgs = {};													-- here we collect all of the maint messages
		for _, v in ipairs( z.maintenance_cats ) do								-- append maintenance categories
			local maint = {};													-- here we assemble a maintenence message
			table.insert (maint, v);											-- maint msg is the category name
			table.insert (maint, ' (');											-- open the link text
			table.insert (maint, make_wikilink (':Category:' .. v, 'link'));	-- add the link
			table.insert (maint, ')');											-- and close it
			table.insert (maint_msgs, table.concat (maint));					-- assemble new maint message and add it to the maint_msgs table
		end
		table.insert (render, substitute (cfg.presentation['hidden-maint'], table.concat (maint_msgs, ' ')));	-- wrap the group of maint message with proper presentation and save
	end
	
	if not no_tracking_cats then
		for _, v in ipairs( z.error_categories ) do
			table.insert (render, make_wikilink ('Category:' .. v));
		end
		for _, v in ipairs( z.maintenance_cats ) do								-- append maintenance categories
			table.insert (render, make_wikilink ('Category:' .. v));
		end
		for _, v in ipairs( z.properties_cats ) do								-- append properties categories
			table.insert (render, make_wikilink ('Category:' .. v));
		end
	end

	return table.concat (render);	
end


--[[--------------------------&lt; V A L I D A T E &gt;--------------------------------------------------------------

Looks for a parameter's name in one of several whitelists.

Parameters in the whitelist can have three values:
	true - active, supported parameters
	false - deprecated, supported parameters
	nil - unsupported parameters
	
]]

local function validate (name, cite_class)
	local name = tostring (name);
	local state;
	local function state_test (state, name)										-- local function to do testing of state values
		if true == state then return true; end									-- valid actively supported parameter
		if false == state then
			deprecated_parameter (name);										-- parameter is deprecated but still supported
			return true;
		end
		return nil;
	end		

	if name:find ('#') then														-- # is a cs1|2 reserved character so parameters with # not permitted
		return nil;
	end

	if in_array (cite_class, whitelist.preprint_template_list ) then			-- limited parameter sets allowed for these templates
		state = whitelist.limited_basic_arguments[name];
		if true == state_test (state, name) then return true; end

		state = whitelist.preprint_arguments[cite_class][name];					-- look in the parameter-list for the template identified by cite_class
		if true == state_test (state, name) then return true; end

																				-- limited enumerated parameters list
		name = name:gsub("%d+", "#" );											-- replace digit(s) with # (last25 becomes last#) (mw.ustring because non-Western 'local' digits)
		state = whitelist.limited_numbered_arguments[name];
		if true == state_test (state, name) then return true; end

		return false;															-- not supported because not found or name is set to nil
	end																			-- end limited parameter-set templates

	if in_array (cite_class, whitelist.unique_param_template_list) then			-- experiment for template-specific parameters for templates that accept parameters from the basic argument list
		state = whitelist.unique_arguments[cite_class][name];					-- look in the template-specific parameter-lists for the template identified by cite_class
		if true == state_test (state, name) then return true; end
	end																			-- if here, fall into general validation
		
	state = whitelist.basic_arguments[name];									-- all other templates; all normal parameters allowed
	if true == state_test (state, name) then return true; end

																				-- all enumerated parameters allowed
	name = name:gsub("%d+", "#" );												-- replace digit(s) with # (last25 becomes last#) (mw.ustring because non-Western 'local' digits)
	state = whitelist.numbered_arguments[name];
	if true == state_test (state, name) then return true; end

	return false;																-- not supported because not found or name is set to nil
end


--[[--------------------------&lt; M I S S I N G _ P I P E _ C H E C K &gt;------------------------------------------

Look at the contents of a parameter. If the content has a string of characters and digits followed by an equal
sign, compare the alphanumeric string to the list of cs1|2 parameters.  If found, then the string is possibly a
parameter that is missing its pipe:
	{{cite ... |title=Title access-date=2016-03-17}}

cs1|2 shares some parameter names with xml/html atributes: class=, title=, etc.  To prevent false positives xml/html
tags are removed before the search.

If a missing pipe is detected, this function adds the missing pipe maintenance category.

]]

local function missing_pipe_check (parameter, value)
	local capture;
	value = value:gsub ('%b&lt;&gt;', '');											-- remove xml/html tags because attributes: class=, title=, etc 

	capture = value:match ('%s+(%a[%w%-]+)%s*=') or value:match ('^(%a[%w%-]+)%s*=');	-- find and categorize parameters with possible missing pipes
	if capture and validate (capture) then								-- if the capture is a valid parameter name
		table.insert( z.message_tail, {set_error ('missing_pipe',parameter)});
	end
end


--[[--------------------------&lt; H A S _ E X T R A N E O U S _ P U N C T &gt;--------------------------------------

look for extraneous terminal punctuation in most parameter values; parameters listed in skip table are not checked

]]

local function has_extraneous_punc (param, value)
	if cfg.punct_skip[param] then
		return;																	-- parameter name found in the skip table so done
	end
	
	if value:match ('[,;:]$') then
		add_maint_cat ('extra_punct');											-- has extraneous punctuation; add maint cat
	end
end


--[[--------------------------&lt; C I T A T I O N &gt;--------------------------------------------------------------

This is used by templates such as {{cite book}} to create the actual citation text.

]]

local function citation(frame)
	Frame = frame;																-- save a copy incase we need to display an error message in preview mode
	local pframe = frame:getParent()
	local validation, utilities, identifiers, metadata, styles;
	
	if nil ~= string.find (frame:getTitle(), 'sandbox', 1, true) then			-- did the {{#invoke:}} use sandbox version?
		cfg = mw.loadData ('Module:Citation/CS1/Configuration/sandbox');		-- load sandbox versions of support modules
		whitelist = mw.loadData ('Module:Citation/CS1/Whitelist/sandbox');
		utilities = require ('Module:Citation/CS1/Utilities/sandbox');
		validation = require ('Module:Citation/CS1/Date_validation/sandbox');
		identifiers = require ('Module:Citation/CS1/Identifiers/sandbox');
		metadata = require ('Module:Citation/CS1/COinS/sandbox');
		styles = 'Module:Citation/CS1/sandbox/styles.css';
		
	else																		-- otherwise
		cfg = mw.loadData ('Module:Citation/CS1/Configuration');				-- load live versions of support modules
		whitelist = mw.loadData ('Module:Citation/CS1/Whitelist');
		utilities = require ('Module:Citation/CS1/Utilities');
		validation = require ('Module:Citation/CS1/Date_validation');
		identifiers = require ('Module:Citation/CS1/Identifiers');
		metadata = require ('Module:Citation/CS1/COinS');
		styles = 'Module:Citation/CS1/styles.css';

	end

	utilities.set_selected_modules (cfg);										-- so that functions in Utilities can see the cfg tables
	identifiers.set_selected_modules (cfg, utilities);							-- so that functions in Identifiers can see the selected cfg tables and selected Utilities module
	validation.set_selected_modules (cfg, utilities);							-- so that functions in Date validataion can see selected cfg tables and the selected Utilities module
	metadata.set_selected_modules (cfg, utilities);								-- so that functions in COinS can see the selected cfg tables and selected Utilities module

	dates = validation.dates;													-- imported functions from Module:Citation/CS1/Date validation
	year_date_check = validation.year_date_check;
	reformat_dates = validation.reformat_dates;
	date_hyphen_to_dash = validation.date_hyphen_to_dash;
	date_name_xlate = validation.date_name_xlate;

	is_set = utilities.is_set;													-- imported functions from Module:Citation/CS1/Utilities
	in_array = utilities.in_array;
	substitute = utilities.substitute;
	error_comment = utilities.error_comment;
	set_error = utilities.set_error;
	select_one = utilities.select_one;
	add_maint_cat = utilities.add_maint_cat;
	wrap_style = utilities.wrap_style;
	safe_for_italics = utilities.safe_for_italics;
	is_wikilink = utilities.is_wikilink;
	make_wikilink = utilities.make_wikilink;
	strip_apostrophe_markup = utilities.strip_apostrophe_markup;

	z = utilities.z;															-- table of error and category tables in Module:Citation/CS1/Utilities

	extract_ids = identifiers.extract_ids;										-- imported functions from Module:Citation/CS1/Identifiers
	build_id_list = identifiers.build_id_list;
	is_embargoed = identifiers.is_embargoed;
	extract_id_access_levels = identifiers.extract_id_access_levels;
	
	make_coins_title = metadata.make_coins_title;								-- imported functions from Module:Citation/CS1/COinS
	get_coins_pages = metadata.get_coins_pages;
	COinS = metadata.COinS;

	local args = {};															-- table where we store all of the template's arguments
	local suggestions = {};														-- table where we store suggestions if we need to loadData them
	local error_text, error_state;

	local config = {};															-- table to store parameters from the module {{#invoke:}}
	for k, v in pairs( frame.args ) do
		config[k] = v;
--		args[k] = v;															-- debug tool that allows us to render a citation from module {{#invoke:}}
	end	

	local capture;																-- the single supported capture when matching unknown parameters using patterns
	for k, v in pairs( pframe.args ) do
		if v ~= '' then
			if ('string' == type (k)) then
				k = mw.ustring.gsub (k, '%d', cfg.date_names.local_digits);		-- for enumerated parameters, translate 'local' digits to Western 0-9
			end
			if not validate( k, config.CitationClass ) then			
				error_text = "";
				if type( k ) ~= 'string' then
					-- Exclude empty numbered parameters
					if v:match("%S+") ~= nil then
						error_text, error_state = set_error( 'text_ignored', {v}, true );
					end
				elseif validate( k:lower(), config.CitationClass ) then 
					error_text, error_state = set_error( 'parameter_ignored_suggest', {k, k:lower()}, true );	-- suggest the lowercase version of the parameter
				else
					if nil == suggestions.suggestions then						-- if this table is nil then we need to load it
						if nil ~= string.find (frame:getTitle(), 'sandbox', 1, true) then			-- did the {{#invoke:}} use sandbox version?
							suggestions = mw.loadData( 'Module:Citation/CS1/Suggestions/sandbox' );	-- use the sandbox version
						else
							suggestions = mw.loadData( 'Module:Citation/CS1/Suggestions' );			-- use the live version
						end
					end
					for pattern, param in pairs (suggestions.patterns) do		-- loop through the patterns to see if we can suggest a proper parameter
						capture = k:match (pattern);							-- the whole match if no caputre in pattern else the capture if a match
						if capture then											-- if the pattern matches 
							param = substitute (param, capture);				-- add the capture to the suggested parameter (typically the enumerator)
							if validate (param, config.CitationClass) then		-- validate the suggestion to make sure that the suggestion is supported by this template (necessary for limited parameter lists)
								error_text, error_state = set_error ('parameter_ignored_suggest', {k, param}, true);	-- set the suggestion error message
							else
								error_text, error_state = set_error( 'parameter_ignored', {param}, true );	-- suggested param not supported by this template
								v = '';											-- unset
							end
						end
					end
					if not is_set (error_text) then								-- couldn't match with a pattern, is there an expicit suggestion?
						if suggestions.suggestions[ k:lower() ] ~= nil then
							error_text, error_state = set_error( 'parameter_ignored_suggest', {k, suggestions.suggestions[ k:lower() ]}, true );
						else
							error_text, error_state = set_error( 'parameter_ignored', {k}, true );
							v = '';												-- unset value assigned to unrecognized parameters (this for the limited parameter lists)
						end
					end
				end				  
				if error_text ~= '' then
					table.insert( z.message_tail, {error_text, error_state} );
				end				
			end
			missing_pipe_check (k, v);												-- do we think that there is a parameter that is missing a pipe?
																				-- TODO: is this the best place for this translation?
			args[k] = v;
		elseif args[k] ~= nil or (k == 'postscript') then						-- here when v is empty string
			args[k] = v;														-- why do we do this?  we don't support 'empty' parameters
		end		
	end	

	for k, v in pairs( args ) do
		if 'string' == type (k) then											-- don't evaluate positional parameters
			has_invisible_chars (k, v);
			has_extraneous_punc (k, v);											-- look for extraneous terminal punctuation in parameter values
		end
	end

	return table.concat ({citation0( config, args), frame:extensionTag ('templatestyles', '', {src=styles})});
end

--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {citation = citation};</text>
      <sha1>17ti8zx1nn1o0u381j04ctr9nfjwvis</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/COinS</title>
    <ns>828</ns>
    <id>48828620</id>
    <revision>
      <id>913814839</id>
      <parentid>893307448</parentid>
      <timestamp>2019-09-03T11:05:48Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>sync from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="15310" xml:space="preserve">
--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local is_set, in_array, remove_wiki_link, strip_apostrophe_markup;				-- functions in Module:Citation/CS1/Utilities

local cfg;																		-- table of configuration tables that are defined in Module:Citation/CS1/Configuration


--[[--------------------------&lt; M A K E _ C O I N S _ T I T L E &gt;----------------------------------------------

Makes a title for COinS from Title and / or ScriptTitle (or any other name-script pairs)

Apostrophe markup (bold, italics) is stripped from each value so that the COinS metadata isn't corrupted with strings
of %27%27...

]]

local function make_coins_title (title, script)
	if is_set (title) then
		title = strip_apostrophe_markup (title);								-- strip any apostrophe markup
	else
		title='';																-- if not set, make sure title is an empty string
	end
	if is_set (script) then
		script = script:gsub ('^%l%l%s*:%s*', '');								-- remove language prefix if present (script value may now be empty string)
		script = strip_apostrophe_markup (script);								-- strip any apostrophe markup
	else
		script='';																-- if not set, make sure script is an empty string
	end
	if is_set (title) and is_set (script) then
		script = ' ' .. script;													-- add a space before we concatenate
	end
	return title .. script;														-- return the concatenation
end


--[[--------------------------&lt; E S C A P E _ L U A _ M A G I C _ C H A R S &gt;----------------------------------

Returns a string where all of lua's magic characters have been escaped.  This is important because functions like
string.gsub() treat their pattern and replace strings as patterns, not literal strings.
]]

local function escape_lua_magic_chars (argument)
	argument = argument:gsub("%%", "%%%%");										-- replace % with %%
	argument = argument:gsub("([%^%$%(%)%.%[%]%*%+%-%?])", "%%%1");				-- replace all other lua magic pattern characters
	return argument;
end


--[[--------------------------&lt; G E T _ C O I N S _ P A G E S &gt;------------------------------------------------

Extract page numbers from external wikilinks in any of the |page=, |pages=, or |at= parameters for use in COinS.

]]

local function get_coins_pages (pages)
	local pattern;
	if not is_set (pages) then return pages; end								-- if no page numbers then we're done
	
	while true do
		pattern = pages:match("%[(%w*:?//[^ ]+%s+)[%w%d].*%]");					-- pattern is the opening bracket, the url and following space(s): "[url "
		if nil == pattern then break; end										-- no more urls
		pattern = escape_lua_magic_chars (pattern);								-- pattern is not a literal string; escape lua's magic pattern characters
		pages = pages:gsub(pattern, "");										-- remove as many instances of pattern as possible
	end
	pages = pages:gsub("[%[%]]", "");											-- remove the brackets
	pages = pages:gsub("–", "-" );							-- replace endashes with hyphens
	pages = pages:gsub("&amp;%w+;", "-" );						-- and replace html entities (&amp;ndash; etc.) with hyphens; do we need to replace numerical entities like &amp;#32; and the like?
	return pages;
end


--[=[-------------------------&lt; C O I N S _ R E P L A C E _ M A T H _ S T R I P M A R K E R &gt;------------------

There are three options for math markup rendering that depend on the editor's math preference settings.  These
settings are at [[Special:Preferences#mw-prefsection-rendering]] and are
	PNG images
	TeX source
	MathML with SVG or PNG fallback

All three are heavy with html and css which doesn't belong in the metadata.

Without this function, the metadata saved in the raw wikitext contained the rendering determined by the settings
of the last editor to save the page.

This function gets the rendered form of an equation according to the editor's preference before the page is saved.  It
then searches the rendering for the text equivalent of the rendered equation and replaces the rendering with that so
that the page is saved without extraneous html/css markup and with a reasonably readable text form of the equation.

When a replacement is made, this function returns true and the value with replacement; otherwise false and the intital
value.  To replace multipe equations it is necesary to call this function from within a loop.

]=]

local function coins_replace_math_stripmarker (value)
	local stripmarker = cfg.stripmarkers['math'];
	local rendering = value:match (stripmarker);								-- is there a math stripmarker

	if not rendering then														-- when value doesn't have a math stripmarker, abandon this test
		return false, value;
	end
	
	rendering = mw.text.unstripNoWiki (rendering);								-- convert stripmarker into rendered value (or nil? ''? when math render error)
	
	if rendering:match ('alt="[^"]+"') then										-- if PNG math option
		rendering = rendering:match ('alt="([^"]+)"');							-- extract just the math text
	elseif rendering:match ('$%s+.+%s+%$') then									-- if TeX math option; $ is legit character that is escapes as \$
		rendering = rendering:match ('$%s+(.+)%s+%$')							-- extract just the math text
	elseif rendering:match ('&lt;annotation[^&gt;]+&gt;.+&lt;/annotation&gt;') then			-- if MathML math option
		rendering = rendering:match ('&lt;annotation[^&gt;]+&gt;(.+)&lt;/annotation&gt;')		-- extract just the math text
	else
		return false, value;													-- had math stripmarker but not one of the three defined forms
	end
	
	return true, value:gsub (stripmarker, rendering, 1);
end


--[[--------------------------&lt; C O I N S _ C L E A N U P &gt;----------------------------------------------------

Cleanup parameter values for the metadata by removing or replacing invisible characters and certain html entities.

2015-12-10: there is a bug in mw.text.unstripNoWiki ().  It replaces math stripmarkers with the appropriate content
when it shouldn't.  See https://phabricator.wikimedia.org/T121085 and Wikipedia_talk:Lua#stripmarkers_and_mw.text.unstripNoWiki.28.29

TODO: move the replacement patterns and replacement values into a table in /Configuration similar to the invisible
characters table?

]]

local function coins_cleanup (value)
	local replaced = true;														-- default state to get the do loop running

	while replaced do															-- loop until all math stripmarkers replaced
		replaced, value = coins_replace_math_stripmarker (value);				-- replace math stripmarker with text representation of the equation
	end

	value = value:gsub (cfg.stripmarkers['math'], "MATH RENDER ERROR");						-- one or more couldn't be replaced; insert vague error message
	
	value = mw.text.unstripNoWiki (value);										-- replace nowiki stripmarkers with their content
	value = value:gsub ('&lt;span class="nowrap" style="padding%-left:0%.1em;"&gt;&amp;#39;(s?)&lt;/span&gt;', "'%1");	-- replace {{'}} or {{'s}} with simple apostrophe or apostrophe-s
	value = value:gsub ('&amp;nbsp;', ' ');											-- replace &amp;nbsp; entity with plain space
	value = value:gsub ('\226\128\138', ' ');									-- replace hair space with plain space
	if not mw.ustring.find (value, cfg.indic_script) then						-- don't remove zero width joiner characters from indic script
		value = value:gsub ('&amp;zwj;', '');											-- remove &amp;zwj; entities
		value = mw.ustring.gsub (value, '[\226\128\141\226\128\139\194\173]', '');	-- remove zero-width joiner, zero-width space, soft hyphen
	end
	value = value:gsub ('[\009\010\013]', ' ');									-- replace horizontal tab, line feed, carriage return with plain space
	return value;
end


--[[--------------------------&lt; C O I N S &gt;--------------------------------------------------------------------

COinS metadata (see &lt;http://ocoins.info/&gt;) allows automated tools to parse the citation information.

]]

local function COinS(data, class)
	if 'table' ~= type(data) or nil == next(data) then
		return '';
	end

	for k, v in pairs (data) do													-- spin through all of the metadata parameter values
		if 'ID_list' ~= k and 'Authors' ~= k then								-- except the ID_list and Author tables (author nowiki stripmarker done when Author table processed)
			data[k] = coins_cleanup (v);
		end
	end

	local ctx_ver = "Z39.88-2004";
	
	-- treat table strictly as an array with only set values.
	local OCinSoutput = setmetatable( {}, {
		__newindex = function(self, key, value)
			if is_set(value) then
				rawset( self, #self+1, table.concat{ key, '=', mw.uri.encode( remove_wiki_link( value ) ) } );
			end
		end
	});
	
	if in_array (class, {'arxiv', 'biorxiv', 'citeseerx', 'ssrn', 'journal', 'news', 'magazine'}) or (in_array (class, {'conference', 'interview', 'map', 'press release', 'web'}) and is_set(data.Periodical)) or 
		('citation' == class and is_set(data.Periodical) and not is_set (data.Encyclopedia)) then
			OCinSoutput.rft_val_fmt = "info:ofi/fmt:kev:mtx:journal";			-- journal metadata identifier
			if in_array (class, {'arxiv', 'biorxiv', 'citeseerx', 'ssrn'}) then	-- set genre according to the type of citation template we are rendering
				OCinSoutput["rft.genre"] = "preprint";							-- cite arxiv, cite biorxiv, cite citeseerx, cite ssrn
			elseif 'conference' == class then
				OCinSoutput["rft.genre"] = "conference";						-- cite conference (when Periodical set)
			elseif 'web' == class then
				OCinSoutput["rft.genre"] = "unknown";							-- cite web (when Periodical set)
			else
				OCinSoutput["rft.genre"] = "article";							-- journal and other 'periodical' articles
			end
			OCinSoutput["rft.jtitle"] = data.Periodical;						-- journal only
			OCinSoutput["rft.atitle"] = data.Title;								-- 'periodical' article titles

																				-- these used only for periodicals
			OCinSoutput["rft.ssn"] = data.Season;								-- keywords: winter, spring, summer, fall
			OCinSoutput["rft.chron"] = data.Chron;								-- free-form date components
			OCinSoutput["rft.volume"] = data.Volume;							-- does not apply to books
			OCinSoutput["rft.issue"] = data.Issue;
			OCinSoutput["rft.pages"] = data.Pages;								-- also used in book metadata

	elseif 'thesis' ~= class then												-- all others except cite thesis are treated as 'book' metadata; genre distinguishes
		OCinSoutput.rft_val_fmt = "info:ofi/fmt:kev:mtx:book";					-- book metadata identifier
		if 'report' == class or 'techreport' == class then						-- cite report and cite techreport
			OCinSoutput["rft.genre"] = "report";
		elseif 'conference' == class then										-- cite conference when Periodical not set
			OCinSoutput["rft.genre"] = "conference";
			OCinSoutput["rft.atitle"] = data.Chapter;							-- conference paper as chapter in proceedings (book)
		elseif in_array (class, {'book', 'citation', 'encyclopaedia', 'interview', 'map'}) then
			if is_set (data.Chapter) then
				OCinSoutput["rft.genre"] = "bookitem";
				OCinSoutput["rft.atitle"] = data.Chapter;						-- book chapter, encyclopedia article, interview in a book, or map title
			else
				if 'map' == class or 'interview' == class then
					OCinSoutput["rft.genre"] = 'unknown';						-- standalone map or interview
				else
					OCinSoutput["rft.genre"] = 'book';							-- book and encyclopedia
				end
			end
		else	--{'audio-visual', 'AV-media-notes', 'DVD-notes', 'episode', 'interview', 'mailinglist', 'map', 'newsgroup', 'podcast', 'press release', 'serial', 'sign', 'speech', 'web'}
			OCinSoutput["rft.genre"] = "unknown";
		end
		OCinSoutput["rft.btitle"] = data.Title;									-- book only
		OCinSoutput["rft.place"] = data.PublicationPlace;						-- book only
		OCinSoutput["rft.series"] = data.Series;								-- book only
		OCinSoutput["rft.pages"] = data.Pages;									-- book, journal
		OCinSoutput["rft.edition"] = data.Edition;								-- book only
		OCinSoutput["rft.pub"] = data.PublisherName;							-- book and dissertation
		
	else																		-- cite thesis
		OCinSoutput.rft_val_fmt = "info:ofi/fmt:kev:mtx:dissertation";			-- dissertation metadata identifier
		OCinSoutput["rft.title"] = data.Title;									-- dissertation (also patent but that is not yet supported)
		OCinSoutput["rft.degree"] = data.Degree;								-- dissertation only
		OCinSoutput['rft.inst'] = data.PublisherName;							-- book and dissertation
	end
																				-- and now common parameters (as much as possible)
	OCinSoutput["rft.date"] = data.Date;										-- book, journal, dissertation
	
	for k, v in pairs( data.ID_list ) do										-- what to do about these? For now assume that they are common to all?
		if k == 'ISBN' then v = v:gsub( "[^-0-9X]", "" ); end
		local id = cfg.id_handlers[k].COinS;
		if string.sub( id or "", 1, 4 ) == 'info' then							-- for ids that are in the info:registry
			OCinSoutput["rft_id"] = table.concat{ id, "/", v };
		elseif string.sub (id or "", 1, 3 ) == 'rft' then						-- for isbn, issn, eissn, etc that have defined COinS keywords
			OCinSoutput[ id ] = v;
		elseif id then															-- when cfg.id_handlers[k].COinS is not nil
			OCinSoutput["rft_id"] = table.concat{ cfg.id_handlers[k].prefix, v };	-- others; provide a url
		end
	end

	local last, first;
	for k, v in ipairs( data.Authors ) do
		last, first = coins_cleanup (v.last), coins_cleanup (v.first or '');	-- replace any nowiki strip markers, non-printing or invisible characers
		if k == 1 then															-- for the first author name only
			if is_set(last)  and is_set(first) then								-- set these COinS values if |first= and |last= specify the first author name
				OCinSoutput["rft.aulast"] = last;								-- book, journal, dissertation
				OCinSoutput["rft.aufirst"] = first;								-- book, journal, dissertation
			elseif is_set(last) then 
				OCinSoutput["rft.au"] = last;									-- book, journal, dissertation -- otherwise use this form for the first name
			end
		else																	-- for all other authors
			if is_set(last) and is_set(first) then
				OCinSoutput["rft.au"] = table.concat{ last, ", ", first };		-- book, journal, dissertation
			elseif is_set(last) then
				OCinSoutput["rft.au"] = last;									-- book, journal, dissertation
			end
		end
	end

	OCinSoutput.rft_id = data.URL;
	OCinSoutput.rfr_id = table.concat{ "info:sid/", mw.site.server:match( "[^/]*$" ), ":", data.RawPage };
	OCinSoutput = setmetatable( OCinSoutput, nil );
	
	-- sort with version string always first, and combine.
	--table.sort( OCinSoutput );
	table.insert( OCinSoutput, 1, "ctx_ver=" .. ctx_ver );  -- such as "Z39.88-2004"
	return table.concat(OCinSoutput, "&amp;");
end


--[[--------------------------&lt; S E T _ S E L E C T E D _ M O D U L E S &gt;--------------------------------------

Sets local cfg table and imported functions table to same (live or sandbox) as that used by the other modules.

]]

local function set_selected_modules (cfg_table_ptr, utilities_page_ptr)
	cfg = cfg_table_ptr;

	is_set = utilities_page_ptr.is_set;											-- import functions from selected Module:Citation/CS1/Utilities module
	in_array = utilities_page_ptr.in_array;
	remove_wiki_link = utilities_page_ptr.remove_wiki_link;
	strip_apostrophe_markup = utilities_page_ptr.strip_apostrophe_markup;
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {
	make_coins_title = make_coins_title,
	get_coins_pages = get_coins_pages,
	COinS = COinS,
	set_selected_modules = set_selected_modules,
	}</text>
      <sha1>l8s94fpb0lbhviey5aqaamradc5q20u</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Configuration</title>
    <ns>828</ns>
    <id>39043527</id>
    <revision>
      <id>951745145</id>
      <parentid>951737713</parentid>
      <timestamp>2020-04-18T17:24:06Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <minor/>
      <comment>biorxiv fix;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="75942" xml:space="preserve">
--[[--------------------------&lt; U N C A T E G O R I Z E D _ N A M E S P A C E S &gt;------------------------------

List of namespaces that should not be included in citation error categories.  Same as setting notracking = true by default

Note: Namespace names should use underscores instead of spaces.

]]
local uncategorized_namespaces = { 'User', 'Talk', 'User_talk', 'Wikipedia_talk', 'File_talk', 'Template_talk', 'Help_talk', 'Category_talk', 'Portal_talk', 'Book_talk', 'Draft_talk', 'Education_Program_talk', 'Module_talk', 'MediaWiki_talk' };

local uncategorized_subpages = {'/[Ss]andbox', '/[Tt]estcases'};				-- list of Lua patterns found in page names of pages we should not categorize


--[[--------------------------&lt; M E S S A G E S &gt;--------------------------------------------------------------

Translation table

The following contains fixed text that may be output as part of a citation.
This is separated from the main body to aid in future translations of this
module.

]]

local messages = {
	['agency'] = '$1 $2',														-- $1 is sepc, $2 is agency
	['archived-dead'] = 'Archived from $1 on $2',
	['archived-live'] = '$1 from the original on $2',
	['archived-missing'] = 'Archived from the original$1 on $2',
	['archived-unfit'] = 'Archived from the original on ',
	['archived'] = 'Archived',
	['by'] = 'By',																-- contributions to authored works: introduction, foreword, afterword
	['cartography'] = 'Cartography by $1',
	['editor'] = 'ed.',
	['editors'] = 'eds.',
	['edition'] = '($1 ed.)',
	['episode'] = 'Episode $1',
	['et al'] = 'et al.',
	['in'] = 'In',																-- edited works
	['inactive'] = 'inactive',
	['inset'] = '$1 inset',
	['interview'] = 'Interviewed by $1',										
	['lay summary'] = 'Lay summary',
	['newsgroup'] = '[[Usenet newsgroup|Newsgroup]]:&amp;nbsp;$1',
	['original'] = 'the original',
	['origyear'] = ' [$1]',
	['published'] = ' (published $1)',
	['retrieved'] = 'Retrieved $1',
	['season'] = 'Season $1',
	['section'] = '§ $1',
	['sections'] = '§§ $1',
	['series'] = '$1 $2',														-- $1 is sepc, $2 is series
	['seriesnum'] = 'Series $1',
	['translated'] = 'Translated by $1',
	['type'] = ' ($1)',															-- for titletype
	['written'] = 'Written at $1',

	['vol'] = '$1 Vol.&amp;nbsp;$2',												-- $1 is sepc; bold journal style volume is in presentation{}
	['vol-no'] = '$1 Vol.&amp;nbsp;$2 no.&amp;nbsp;$3',									-- sepc, volume, issue
	['issue'] = '$1 No.&amp;nbsp;$2',												-- $1 is sepc

	['j-vol'] = '$1 $2',														-- sepc, volume; bold journal volume is in presentation{}
	['j-issue'] = ' ($1)',

	['nopp'] = '$1 $2';															-- page(s) without prefix; $1 is sepc

	['p-prefix'] = "$1 p.&amp;nbsp;$2",												-- $1 is sepc
	['pp-prefix'] = "$1 pp.&amp;nbsp;$2",											-- $1 is sepc
	['j-page(s)'] = ': $1',														-- same for page and pages

	['sheet'] = '$1 Sheet&amp;nbsp;$2',												-- $1 is sepc
	['sheets'] = '$1 Sheets&amp;nbsp;$2',											-- $1 is sepc
	['j-sheet'] = ': Sheet&amp;nbsp;$1',
	['j-sheets'] = ': Sheets&amp;nbsp;$1',
	
	['language'] = '(in $1)',
	['via'] = " &amp;ndash; via $1",
	['event'] = 'Event occurs at',
	['minutes'] = 'minutes in',
	
	['parameter-separator'] = ', ',
	['parameter-final-separator'] = ', and ',
	['parameter-pair-separator'] = ' and ',
	
	-- Determines the location of the help page
	['help page link'] = 'Help:CS1 errors',
	['help page label'] = 'help',
	
	-- Internal errors (should only occur if configuration is bad)
	['undefined_error'] = 'Called with an undefined error condition',
	['unknown_manual_ID'] = 'Unrecognized manual ID mode',
	['unknown_ID_mode'] = 'Unrecognized ID mode',
	['unknown_argument_map'] = 'Argument map not defined for this variable',
	['bare_url_no_origin'] = 'Bare url found but origin indicator is nil or empty',
	}


--[=[-------------------------&lt; E T _ A L _ P A T T E R N S &gt;--------------------------------------------------

This table provides Lua patterns for the phrase "et al" and variants in name text
(author, editor, etc.). The main module uses these to identify and emit the 'etal' message.

]=]

local et_al_patterns = {
	"[;,]? *[\"']*%f[%a][Ee][Tt]%.? *[Aa][Ll][%.\"']*$",						-- variations on the 'et al' theme
	"[;,]? *[\"']*%f[%a][Ee][Tt]%.? *[Aa][Ll][Ii][Aa][%.\"']*$",				-- variations on the 'et alia' theme
	"[;,]? *%f[%a]and [Oo]thers",												-- and alternate to et al.
	"%[%[ *[Ee][Tt]%.? *[Aa][Ll]%.? *%]%]",										-- a wikilinked form
	"[%(%[] *[Ee][Tt]%.? *[Aa][Ll]%.? *[%)%]]",									-- a bracketed form
	}


--[[--------------------------&lt; E D I T O R _ M A R K U P _ P A T T E R N S &gt;----------------------------------

This table provides Lua patterns for the phrase "ed" and variants in name text
(author, editor, etc.). The main module uses these to identify and emit the
'extra_text_names' message. (It is not the only series of patterns for this message.)

]]
local editor_markup_patterns = {												-- these patterns match annotations at end of name
	'%f[%(%[][%(%[]%s*[Ee][Dd][Ss]?%.?%s*[%)%]]?$',								-- (ed) or (eds): leading '(', case insensitive 'ed', optional 's', '.' and/or ')'
	'[,%.%s]%f[e]eds?%.?$',														-- ed or eds: without '('or ')'; case sensitive (ED could be initials Ed could be name)
	'%f[%(%[][%(%[]%s*[Ee][Dd][Ii][Tt][Oo][Rr][Ss]?%.?%s*[%)%]]?$',				-- (editor) or (editors): leading '(', case insensitive, optional '.' and/or ')'
	'[,%.%s]%f[Ee][Dd][Ii][Tt][Oo][Rr][Ss]?%.?$',								-- editor or editors: without '('or ')'; case insensitive
		
																				-- these patterns match annotations at beginning of name
	'^eds?[%.,;]',																-- ed. or eds.: lower case only, optional 's', requires '.'
	'^[%(%[]%s*[Ee][Dd][Ss]?%.?%s*[%)%]]',										-- (ed) or (eds): also sqare brackets, case insensitive, optional 's', '.'
	'^[%(%[]?%s*[Ee][Dd][Ii][Tt][Oo][Rr][Ss]?%A',								-- (editor or (editors: also sq brackets, case insensitive, optional brackets, 's'
	'^[%(%[]?%s*[Ee][Dd][Ii][Tt][Ee][Dd]%A',									-- (edited: also sq brackets, case insensitive, optional brackets

																				-- these patterns match annotations that are the 'name'	
	'^[Ee][Dd][Ii][Tt][Oo][Rr][Ss]?%.?$',										-- editor or editors; case insensitive
	}


--[[--------------------------&lt; P R E S E N T A T I O N &gt;------------------------------------------------------

Fixed presentation markup.  Originally part of citation_config.messages it has been moved into its own, more semantically
correct place.

]]

local presentation = 
	{
	-- Error output
	-- .error class is specified at https://git.wikimedia.org/blob/mediawiki%2Fcore.git/9553bd02a5595da05c184f7521721fb1b79b3935/skins%2Fcommon%2Fshared.css#L538
	-- .citation-comment class is specified at Help:CS1_errors#Controlling_error_message_display
	['hidden-error'] = '&lt;span class="cs1-hidden-error error citation-comment"&gt;$1&lt;/span&gt;',
	['visible-error'] = '&lt;span class="cs1-visible-error error citation-comment"&gt;$1&lt;/span&gt;',
	['hidden-maint'] = '&lt;span class="cs1-maint citation-comment"&gt;$1&lt;/span&gt;',
	
	['accessdate'] = '&lt;span class="reference-accessdate"&gt;$1$2&lt;/span&gt;',			-- to allow editors to hide accessdate using personal css

	['bdi'] = '&lt;bdi$1&gt;$2&lt;/bdi&gt;',												-- bidirectional isolation used with |script-title= and the like

	['cite'] = '&lt;cite class="$1"&gt;$2&lt;/cite&gt;';									-- |ref= not set so no id="..." attribute
	['cite-id'] = '&lt;cite id="$1" class="$2"&gt;$3&lt;/cite&gt;';							-- for use when |ref= is set

	['format'] = ' &lt;span class="cs1-format"&gt;($1)&lt;/span&gt;',						-- for |format=, |chapter-format=, etc
	
																				-- various access levels, for |access=, |doi-access=, |arxiv=, ...
																				-- narrow no-break space &amp;#8239; may work better than nowrap css. Or not? browser support?

	['ext-link-access-signal'] = '&lt;span class="$1" title="$2"&gt;$3&lt;/span&gt;',		-- external link with appropriate lock icon
		['free'] = {class='cs1-lock-free', title='Freely accessible'},			-- classes defined in Module:Citation/CS1/styles.css
		['registration'] = {class='cs1-lock-registration', title='Free registration required'},
		['limited'] = {class='cs1-lock-limited', title='Free access subject to limited trial, subscription normally required'},
		['subscription'] = {class='cs1-lock-subscription', title='Paid subscription required'},

	['interwiki-icon'] = '&lt;span class="$1" title="$2"&gt;$3&lt;/span&gt;',
		['class-wikisource'] = 'cs1-ws-icon',

	['italic-title'] = "''$1''",

	['kern-left'] = '&lt;span class="cs1-kern-left"&gt;$1&lt;/span&gt;$2',					-- spacing to use when title contains leading single or double quote mark
	['kern-right'] = '$1&lt;span class="cs1-kern-right"&gt;$2&lt;/span&gt;',				-- spacing to use when title contains trailing single or double quote mark

																				-- these for simple wikilinked titles [["text]], [[text"]] and [["text"]]
																				-- span wraps entire wikilink
	['kern-wl-left'] = '&lt;span class="cs1-kern-wl-left"&gt;$1&lt;/span&gt;',				-- when title contains leading single or double quote mark
	['kern-wl-right'] = '&lt;span class="cs1-kern-wl-left"&gt;$1&lt;/span&gt;',				-- when title contains trailing single or double quote mark
	['kern-wl-both'] = '&lt;span class="cs1-kern-wl-left cs1-kern-wl-right"&gt;$1&lt;/span&gt;',	-- when title contains leading and trailing single or double quote marks

	['nowrap1'] = '&lt;span class="nowrap"&gt;$1&lt;/span&gt;',								-- for nowrapping an item: &lt;span ...&gt;yyyy-mm-dd&lt;/span&gt;
	['nowrap2'] = '&lt;span class="nowrap"&gt;$1&lt;/span&gt; $2',							-- for nowrapping portions of an item: &lt;span ...&gt;dd mmmm&lt;/span&gt; yyyy (note white space)

	['ocins'] = '&lt;span title="$1" class="Z3988"&gt;&lt;/span&gt;',
	
	['parameter'] = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',
 
	['ps_cs1'] = '.';															-- cs1 style postscript (terminal) character
	['ps_cs2'] = '';															-- cs2 style postscript (terminal) character (empty string)

	['quoted-text'] = '&lt;q&gt;$1&lt;/q&gt;',												-- for wrapping |quote= content
	['quoted-title'] = '"$1"',

	['sep_cs1'] = '.',															-- cs1 element separator
	['sep_cs2'] = ',',															-- cs2 separator
	['sep_nl'] = ';',															-- cs1|2 style name-list separator between authors is a semicolon
	['sep_name'] = ', ',														-- cs1|2 style last/first separator is &lt;comma&gt;&lt;space&gt;
	['sep_nl_vanc'] = ',',														-- Vancouver style name-list separator between authors is a comma
	['sep_name_vanc'] = ' ',													-- Vancouver style last/first separator is a space

	['trans-italic-title'] = "&amp;#91;''$1''&amp;#93;",
	['trans-quoted-title'] = "&amp;#91;$1&amp;#93;",
	['vol-bold'] = '$1 &lt;b&gt;$2&lt;/b&gt;',												-- sepc, volume; for bold journal cites; for other cites ['vol'] in messages{}
	}

	
--[[--------------------------&lt; A L I A S E S &gt;----------------------------------------------------------------

Aliases table for commonly passed parameters.

Parameter names on the right side in the assignements in this table must have been defined in the Whitelist
before they will be recognized as valid parameter names

]]

local aliases = {
	['AccessDate'] = {'access-date', 'accessdate'},								-- Used by InternetArchiveBot
	['Agency'] = 'agency',
--	['AirDate'] = {'air-date', 'airdate'},
	['ArchiveDate'] = {'archive-date', 'archivedate'},							-- Used by InternetArchiveBot
	['ArchiveFormat'] = 'archive-format',
	['ArchiveURL'] = {'archive-url', 'archiveurl'},								-- Used by InternetArchiveBot
	['ASINTLD'] = 'asin-tld',
	['At'] = 'at',																-- Used by InternetArchiveBot
	['Authors'] = {'authors', 'people', 'credits'},
	['BookTitle'] = {'book-title', 'booktitle'},
	['Cartography'] = 'cartography',
	['Chapter'] = {'chapter', 'contribution', 'entry', 'article', 'section'},
	['ChapterFormat'] = {'chapter-format', 'contribution-format', 'entry-format', 'article-format', 'section-format'};
	['ChapterURL'] = {'chapter-url', 'chapterurl', 'contribution-url', 'contributionurl', 'entry-url', 'article-url', 'section-url', 'sectionurl'},	-- Used by InternetArchiveBot
	['ChapterUrlAccess'] = {'chapter-url-access', 'contribution-url-access', 'entry-url-access', 'article-url-access', 'section-url-access'},	-- Used by InternetArchiveBot
	['Class'] = 'class',														-- cite arxiv and arxiv identifiers
	['Collaboration'] = 'collaboration',
	['Conference'] = {'conference', 'event'},
	['ConferenceFormat'] = {'conference-format', 'event-format'},
	['ConferenceURL'] = {'conference-url', 'conferenceurl', 'event-url', 'eventurl'},	-- Used by InternetArchiveBot
	['Contribution'] = 'contribution',											-- introduction, foreword, afterword, etc; required when |contributor= set; TODO: make internal only see TODO in main module
--	['Date'] = 'date',
	['Date'] = {'date', 'air-date', 'airdate'},									-- air-date and airdate for cite episode and cite serial only
	['Degree'] = 'degree',
	['DF'] = 'df',
	['DisplayAuthors'] = {'display-authors', 'displayauthors'},
	['DisplayContributors'] = 'display-contributors',
	['DisplayEditors'] = {'display-editors', 'displayeditors'},
	['DisplayInterviewers'] = 'display-interviewers',
	['DisplayTranslators'] = 'display-translators',
	['Docket'] = 'docket',
	['DoiBroken'] = {'doi-broken', 'doi-broken-date', 'doi-inactive-date'},
	['Edition'] = 'edition',
	['Editors'] = 'editors',
	['Embargo'] = 'embargo',
	['Encyclopedia'] = {'encyclopedia', 'encyclopaedia'},						-- this one only used by citation
	['Episode'] = 'episode',													-- cite serial only TODO: make available to cite episode?
	['Format'] = 'format',
	['ID'] = {'id', 'ID'},
	['IgnoreISBN'] = {'ignore-isbn-error', 'ignoreisbnerror'},
	['Inset'] = 'inset',
	['Issue'] = {'issue', 'number'},
	['Language'] = {'language', 'lang'},
	['LastAuthorAmp'] = {'last-author-amp', 'lastauthoramp'},
	['LayDate'] = {'lay-date', 'laydate'},
	['LayFormat'] = 'lay-format',
	['LaySource'] = {'lay-source', 'laysource'},
	['LayURL'] = {'lay-url', 'layurl'},											-- Used by InternetArchiveBot
	['MailingList'] = {'mailing-list', 'mailinglist'},							-- cite mailing list only
	['Map'] = 'map',															-- cite map only
	['MapFormat'] = 'map-format',												-- cite map only
	['MapURL'] = {'map-url', 'mapurl'},											-- cite map only -- Used by InternetArchiveBot
	['MapUrlAccess'] = 'map-url-access',										-- cite map only -- Used by InternetArchiveBot
--	['MessageID'] = 'message-id',
	['Minutes'] = 'minutes',
	['Mode'] = 'mode',
	['NameListFormat'] = 'name-list-format',
	['Network'] = 'network',
	['Newsgroup'] = 'newsgroup',												-- cite newsgroup only
	['NoPP'] = {'no-pp', 'nopp'},
	['NoTracking'] = {'template-doc-demo', 'no-cat', 'nocat', 'no-tracking', 'notracking'},
	['Number'] = 'number',														-- this case only for cite techreport
	['OrigYear'] = {'orig-year', 'origyear'},
	['Others'] = 'others',
	['Page'] = {'page', 'p'},													-- Used by InternetArchiveBot
	['Pages'] = {'pages', 'pp'},												-- Used by InternetArchiveBot
	['Periodical'] = {'journal', 'magazine', 'newspaper', 'periodical', 'website', 'work',
		'encyclopedia', 'encyclopaedia', 'dictionary', 'mailinglist'},			-- these masquerade as periodicals but aren't TODO: find a better way to handle these?
	['Place'] = {'place', 'location'},
	['PostScript'] = 'postscript',
	['PublicationDate'] = {'publication-date', 'publicationdate'},
	['PublicationPlace'] = {'publication-place', 'publicationplace'},
--	['PublisherName'] = {'publisher', 'institution', 'newsgroup'},
	['PublisherName'] = {'publisher', 'institution'},
	['Quote'] = {'quote', 'quotation'},
	['Ref'] = 'ref',
	['Scale'] = 'scale',
	['ScriptChapter'] = {'script-chapter', 'script-contribution', 'script-entry', 'script-article', 'script-section'},
	['ScriptMap'] = 'script-map',
	['ScriptPeriodical'] = {'script-journal', 'script-magazine', 'script-newspaper', 'script-periodical', 'script-website', 'script-work'},
	['ScriptTitle'] = 'script-title',											-- Used by InternetArchiveBot
	['Section'] = 'section',
	['Season'] = 'season',
	['Sections'] = 'sections',													-- cite map only
	['Series'] = {'series', 'version'},
	['SeriesSeparator'] = 'series-separator',
	['SeriesLink'] = {'series-link', 'serieslink'},
	['SeriesNumber'] = {'series-number', 'series-no', 'seriesnumber', 'seriesno'},
	['Sheet'] = 'sheet',														-- cite map only
	['Sheets'] = 'sheets',														-- cite map only
	['Station'] = 'station',
	['Time'] = 'time',
	['TimeCaption'] = {'time-caption', 'timecaption'},
	['Title'] = 'title',														-- Used by InternetArchiveBot
	['TitleLink'] = {'title-link', 'episode-link', 'titlelink', 'episodelink'},	-- Used by InternetArchiveBot
	['TitleNote'] = 'department',
	['TitleType'] = {'type', 'medium'},
	['TransChapter'] = {'trans-article', 'trans-chapter', 'trans-contribution', 'trans-entry', 'trans-section'},
	['Transcript'] = 'transcript',
	['TranscriptFormat'] = 'transcript-format',	
	['TranscriptURL'] = {'transcript-url', 'transcripturl'},					-- Used by InternetArchiveBot
	['TransMap'] = 'trans-map',													-- cite map only
	['TransPeriodical'] = {'trans-journal', 'trans-magazine', 'trans-newspaper', 'trans-periodical', 'trans-website', 'trans-work'},
	['TransTitle'] = 'trans-title',												-- Used by InternetArchiveBot
	['URL'] = {'url', 'URL'},													-- Used by InternetArchiveBot
	['UrlAccess'] = 'url-access',												-- Used by InternetArchiveBot
	['UrlStatus'] = 'url-status',												-- Used by InternetArchiveBot
	['Vauthors'] = 'vauthors',
	['Veditors'] = 'veditors',
	['Via'] = 'via',
	['Volume'] = 'volume',
	['Year'] = 'year',

	['AuthorList-First'] = {"first#", "author-first#", "author#-first", "given#"},
	['AuthorList-Last'] = {"last#", "author-last#", "author#-last", "author#", "surname#", "subject#", 'host#'},
	['AuthorList-Link'] = {"author-link#", "author#-link", "authorlink#", "author#link", "subject-link#", "subject#-link", "subjectlink#", "subject#link"},
	['AuthorList-Mask'] = {"author-mask#", "author#-mask", "authormask#", "author#mask"},
	
	['ContributorList-First'] = {'contributor-first#', 'contributor#-first', 'contributor-given#', 'contributor#-given'},
	['ContributorList-Last'] = {'contributor-last#', 'contributor#-last', 'contributor#', 'contributor-surname#', 'contributor#-surname'},
	['ContributorList-Link'] = {'contributor-link#', 'contributor#-link'},
	['ContributorList-Mask'] = {'contributor-mask#', 'contributor#-mask'},

	['EditorList-First'] = {"editor-first#", "editor#-first", "editor-given#", "editor#-given"},
	['EditorList-Last'] = {"editor-last#", "editor#-last", "editor#", "editor-surname#", "editor#-surname"},
	['EditorList-Link'] = {"editor-link#", "editor#-link", "editorlink#", "editor#link"},
	['EditorList-Mask'] = {"editor-mask#", "editor#-mask", "editormask#", "editor#mask"},
	
	['InterviewerList-First'] = {'interviewer-first#', 'interviewer#-first'},
	['InterviewerList-Last'] = {'interviewer-last#', 'interviewer#-last', 'interviewer#'},
	['InterviewerList-Link'] = {'interviewer-link#', 'interviewer#-link'},
	['InterviewerList-Mask'] = {'interviewer-mask#', 'interviewer#-mask'},

	['TranslatorList-First'] = {'translator-first#', 'translator#-first', 'translator-given#', 'translator#-given'},
	['TranslatorList-Last'] = {'translator-last#', 'translator#-last', 'translator#', 'translator-surname#', 'translator#-surname'},
	['TranslatorList-Link'] = {'translator-link#', 'translator#-link'},
	['TranslatorList-Mask'] = {'translator-mask#', 'translator#-mask'},
	}


--[[--------------------------&lt; P U N C T _ S K I P &gt;----------------------------------------------------------

builds a table of parameter names that the extraneous terminal punctuation check should not check.

]]

local punct_skip = {};

local meta_params = {															-- table of aliases[] keys (meta parameters); each key has a table of parameter names for a value
	'BookTitle', 'Chapter', 'ScriptChapter', 'ScriptTitle', 'Title', 'TransChapter', 'Transcript', 'TransMap',	'TransTitle',	-- title-holding parameters
	'PostScript', 'Quote', 'Ref',																				-- miscellaneous
	'ArchiveURL', 'ChapterURL', 'ConferenceURL', 'LayURL', 'MapURL', 'TranscriptURL', 'URL',			-- url-holding parameters
	}

	for _, meta_param in ipairs (meta_params) do								-- for each meta parameter key
		local params = aliases[meta_param];										-- get the parameter or the table of parameters associated with the meta parameter name
		if 'string' == type (params) then
			punct_skip[params] = 1;												-- just a single parameter
		else
			for _, param in ipairs (params) do									-- get the parameter name
				punct_skip[param] = 1;											-- add the parameter name to the skip table
			end
		end
	end


--[[--------------------------&lt; S P E C I A L   C A S E   T R A N S L A T I O N S &gt;----------------------------

This table is primarily here to support internationalization.  Translations in this table are used, for example,
when an error message, category name, etc is extracted from the English alias key.  There may be other cases where
this translation table may be useful.

]]

local special_case_translation = {
	['AuthorList'] = 'authors list',											-- used to assemble maintenance category names
	['ContributorList'] = 'contributors list',									-- translation of these names plus translation of the base mainenance category names in maint_cats{} table below
	['EditorList'] = 'editors list',											-- must match the names of the actual categories
	['InterviewerList'] = 'interviewers list',									-- this group or translations used by name_has_ed_markup() and name_has_mult_names()
	['TranslatorList'] = 'translators list',
	
	['authors'] = 'authors',													-- used to assemble maintenance category names
	['contributors'] = 'contributors',											-- translation of these names plus translation of the base mainenance category names in maint_cats{} table below
	['editors'] = 'editors',													-- must match the names of the actual categories
	['interviewers'] = 'interviewers',											-- this group of translations used by get_display_names()
	['translators'] = 'translators',

																				-- lua patterns to match pseudo title used by Internet Archive bot and others as place holder for unknown |title= value
	['archived_copy'] = {														-- used with CS1 maint: Archived copy as title
		['en'] = '^archived?%s+copy$',											-- for English; translators: keep this because templates imported from en.wiki
		['local'] = '^archived?%s+copy$',										-- for the local language; lowercase only
		}
	}


--[[--------------------------&lt; D A T E _ N A M E S &gt;----------------------------------------------------------

This table of tables lists local language date names and fallback English date names.  The code in Date_validation
will look first in the local table for valid date names.  If date names are not found in the local table, the code
will look in the English table.

Because citations can be copied to the local wiki from en.wiki, the English is required when the date-name translation
function date_name_xlate() is used.

In these tables, season numbering is defined by ISO DIS 8601:2016 part 2 §4.7 'Divisions of a year'.  The standard
defines various divisions using numbers 21-41.  cs1|2 only supports generic seasons.  ISO DIS 8601:2016 does support
the distinction between north and south hemispere seasons but cs1|2 has no way to make that distinction.

The standard does not address 'named' dates so, for the purposes of cs1|2, Christmas is defined here as 99, which
should be out of the ISO DIS 8601:2016 range of uses for a while.

]]

local date_names = {
	['en'] = {			-- English
		['long']	= {['January']=1, ['February']=2, ['March']=3, ['April']=4, ['May']=5, ['June']=6, ['July']=7, ['August']=8, ['September']=9, ['October']=10, ['November']=11, ['December']=12},
		['short']	= {['Jan']=1, ['Feb']=2, ['Mar']=3, ['Apr']=4, ['May']=5, ['Jun']=6, ['Jul']=7, ['Aug']=8, ['Sep']=9, ['Oct']=10, ['Nov']=11, ['Dec']=12},
		['season']	= {['Winter']=24, ['Spring']=21, ['Summer']=22, ['Fall']=23, ['Autumn']=23},
		['named']	= {['Christmas']=99},
		},
	['local'] = {		-- replace these English date names with the local language equivalents
		['long']	= {['January']=1, ['February']=2, ['March']=3, ['April']=4, ['May']=5, ['June']=6, ['July']=7, ['August']=8, ['September']=9, ['October']=10, ['November']=11, ['December']=12},
		['short']	= {['Jan']=1, ['Feb']=2, ['Mar']=3, ['Apr']=4, ['May']=5, ['Jun']=6, ['Jul']=7, ['Aug']=8, ['Sep']=9, ['Oct']=10, ['Nov']=11, ['Dec']=12},
		['season']	= {['Winter']=24, ['Spring']=21, ['Summer']=22, ['Fall']=23, ['Autumn']=23},
		['named']	= {['Christmas']=99},
		},
	['inv_local_l'] = {},														-- used in date reformatting; copy of date_names['local'].long where k/v are inverted: [1]='&lt;local name&gt;' etc
	['inv_local_s'] = {},														-- used in date reformatting; copy of date_names['local'].short where k/v are inverted: [1]='&lt;local name&gt;' etc
	['local_digits'] = {['0'] = '0', ['1'] = '1', ['2'] = '2', ['3'] = '3', ['4'] = '4', ['5'] = '5', ['6'] = '6', ['7'] = '7', ['8'] = '8', ['9'] = '9'},	-- used to convert local language digits to Western 0-9
	['xlate_digits'] = {},
	}

for name, i in pairs (date_names['local'].long) do								-- this table is ['name'] = i
	date_names['inv_local_l'][i] = name;										-- invert to get [i] = 'name' for conversions from ymd
end

for name, i in pairs (date_names['local'].short) do								-- this table is ['name'] = i
	date_names['inv_local_s'][i] = name;										-- invert to get [i] = 'name' for conversions from ymd
end

for ld, ed in pairs (date_names.local_digits) do								-- make a digit translation table for simple date translation from en to local language using local_digits table
	date_names.xlate_digits [ed] = ld;											-- en digit becomes index with local digit as the value
end

local df_template_patterns = {													-- table of redirects to {{Use dmy dates}} and {{Use mdy dates}}
	'{{ *[Uu]se (dmy) dates *[|}]',		-- 915k									-- sorted by approximate transclusion count
	'{{ *[Uu]se *(mdy) *dates *[|}]',	-- 161k
	'{{ *[Uu]se (DMY) dates *[|}]',		-- 2929
	'{{ *[Uu]se *(dmy) *[|}]',			-- 250 + 34
	'{{ *([Dd]my) *[|}]',				-- 272
	'{{ *[Uu]se (MDY) dates *[|}]',		-- 173
	'{{ *[Uu]se *(mdy) *[|}]',			-- 59 + 12
	'{{ *([Mm]dy) *[|}]',				-- 9
	'{{ *[Uu]se (MDY) *[|}]',			-- 3
	'{{ *([Dd]MY) *[|}]',				-- 2
	'{{ *([Mm]DY) *[|}]',				-- 0
--	'{{ *[Uu]se(mdy) *[|}]',
--	'{{ *[Uu]se(mdy)dates *[|}]',
--	'{{ *[Uu]se(dmy) *[|}]',
	}

local function get_date_format ()
	local content = mw.title.getCurrentTitle():getContent() or '';				-- get the content of the article or ''; new pages edited w/ve do not have 'content' until saved; ve does not preview; phab:T221625
	for _, pattern in ipairs (df_template_patterns) do							-- loop through the patterns looking for {{Use dmy dates}} or {{Use mdy dates}} or any of their redirects
		local start, _, match = content:find(pattern);							-- match is the three letters indicating desired date format
		if match then
			content = content:match ('%b{}', start);							-- get the whole template
			if content:match ('| *cs1%-dates *= *[lsy][sy]?') then				-- look for |cs1-dates=publication date length access-/archive-date length
				return match:lower() .. '-' .. content:match ('| *cs1%-dates *= *([lsy][sy]?)');
			else
				return match:lower() .. '-all';									-- no |cs1-dates= k/v pair; return value appropriate for use in |df=
			end
		end
	end
end

local global_df = get_date_format ();


--[[--------------------------&lt; V O L U M E ,  I S S U E ,  P A G E S &gt;----------------------------------------

These tables hold cite class values (from the template invocation) and identify those templates that support
|volume=, |issue=, and |page(s)= parameters.  Cite conference and cite map require further qualification which
is handled in the main module.

]]

local templates_using_volume = {'citation', 'audio-visual', 'book', 'conference', 'encyclopaedia', 'interview', 'journal', 'magazine', 'map', 'news', 'report', 'techreport', 'thesis'}
local templates_using_issue = {'citation', 'conference', 'episode', 'interview', 'journal', 'magazine', 'map', 'news', 'podcast'}
local templates_not_using_page = {'audio-visual', 'episode', 'mailinglist', 'newsgroup', 'podcast', 'serial', 'sign', 'speech'}


--[[--------------------------&lt; K E Y W O R D S &gt;--------------------------------------------------------------

These tables hold keywords for those parameters that have defined sets of acceptible keywords.

]]

--[[--------------------------&lt; K E Y W O R D S   T A B L E &gt;--------------------------------------------------

this is a list of keywords; each key in the list is associated with a table of synonymous keywords possibly from
different languages.

for i18n: add local-language keywords to value table; do not change the key.  For example, adding the German keyword 'ja':
	['affirmative'] = {'yes', 'true', 'y', 'ja'},

Because cs1|2 templates from en.wiki articles are often copied to other local wikis, it is recommended that the English
keywords remain in these tables.

]]

local keywords = {
	['affirmative'] = {'yes', 'true', 'y'},										-- ignore-isbn-error, last-author-amp, no-tracking, nopp -- Used by InternetArchiveBot
	['afterword'] = {'afterword'},												-- contribution
	['bot: unknown'] = {'bot: unknown'},										-- url-status -- Used by InternetArchiveBot
	['cs1'] = {'cs1'},															-- mode
	['cs2'] = {'cs2'},															-- mode
	['dead'] = {'dead'},														-- url-status -- Used by InternetArchiveBot
	['dmy'] = {'dmy'},															-- df
	['dmy-all'] = {'dmy-all'},													-- df
	['foreword'] = {'foreword'},												-- contribution
	['free'] = {'free'},														-- url-access -- Used by InternetArchiveBot
	['introduction'] = {'introduction'},										-- contribution
	['limited'] = {'limited'},													-- url-access -- Used by InternetArchiveBot
	['live'] = {'live'},														-- url-status -- Used by InternetArchiveBot
	['mdy'] = {'mdy'},															-- df
	['mdy-all'] = {'mdy-all'},													-- df
	['none'] = {'none'},														-- postscript, ref, title, type -- Used by InternetArchiveBot
	['preface'] = {'preface'},													-- contribution
	['registration'] = {'registration'},										-- url-access -- Used by InternetArchiveBot
	['subscription'] = {'subscription'},										-- url-access -- Used by InternetArchiveBot
	['unfit'] = {'unfit'},														-- url-status -- Used by InternetArchiveBot
	['usurped'] = {'usurped'},													-- url-status -- Used by InternetArchiveBot
	['vanc'] = {'vanc'},														-- name-list-format
	['ymd'] = {'ymd'},															-- df
	['ymd-all'] = {'ymd-all'},													-- df
--	['yMd'] = {'yMd'},															-- df; not supported at en.wiki
--	['yMd-all'] = {'yMd-all'},													-- df; not supported at en.wiki
	}


--[[--------------------------&lt; X L A T E _ K E Y W O R D S &gt;--------------------------------------------------

this function builds a list, keywords_xlate{}, of the keywords found in keywords{} where the values from keywords{}
become the keys in keywords_xlate{} and the keys from keywords{} become the values in keywords_xlate{}:
	['affirmative'] = {'yes', 'true', 'y'},		-- in keywords{}
becomes
	['yes'] = 'affirmative',					-- in keywords_xlate{}
	['true'] = 'affirmative',
	['y'] = 'affirmative',

the purpose of this function is to act as a translator between a non-English keyword and its English equivalent
that may be used in other modules of this suite

]]

local function xlate_keywords ()
	local out_table = {};														-- output goes here
	for k, keywords_t in pairs (keywords) do									-- spin through the keywords table
		for _, keyword in ipairs (keywords_t) do								-- for each keyword
			out_table[keyword] = k;												-- create an entry in the output table where keyword is the key
		end
	end
	
	return out_table;
end

local keywords_xlate = xlate_keywords ();										-- the list of translated keywords


--[[--------------------------&lt; M A K E _ K E Y W O R D S _ L I S T &gt;------------------------------------------

this function assembles, for parameter-value validation, the list of keywords appropriate to that parameter.

keywords_lists{}, is a table of tables from keywords{}

]]

local function make_keywords_list (keywords_lists)
	local out_table = {};														-- output goes here
	
	for _, keyword_list in ipairs (keywords_lists) do							-- spin through keywords_lists{} and get a table of keywords
		for _, keyword in ipairs (keyword_list) do								-- spin through keyword_list{} and add each keyword, ...
			table.insert (out_table, keyword);									-- ... as plain text, to the output list
		end
	end
	return out_table;
end


--[[--------------------------&lt; K E Y W O R D S _ L I S T S &gt;--------------------------------------------------

this is a list of lists of valid keywords for the various parameters in [key].  Generally the keys in this table
are the canonical en.wiki parameter names though some are contrived because of use in multiple differently named
parameters: ['yes_true_y'], ['id-access'].

The function make_keywords_list() extracts the individual keywords from the appropriate list in keywords{}.

The lists in this table are used to validate the keyword assignment for the parameters named in this table's keys.

]]

local keywords_lists = {
	['yes_true_y'] = make_keywords_list ({keywords.affirmative}),
	['contribution'] = make_keywords_list ({keywords.afterword, keywords.foreword, keywords.introduction, keywords.preface}),
	['df'] = make_keywords_list ({keywords.dmy, keywords['dmy-all'], keywords.mdy, keywords['mdy-all'], keywords.ymd, keywords['ymd-all']}),
--	['df'] = make_keywords_list ({keywords.dmy, keywords['dmy-all'], keywords.mdy, keywords['mdy-all'], keywords.ymd, keywords['ymd-all'], keywords.yMd, keywords['yMd-all']}),	-- not supported at en.wiki
	['mode'] = make_keywords_list ({keywords.cs1, keywords.cs2}),
	['name-list-format'] = make_keywords_list ({keywords.vanc}),
	['url-access'] = make_keywords_list ({keywords.subscription, keywords.limited, keywords.registration}),
	['url-status'] = make_keywords_list ({keywords.dead, keywords.live, keywords.unfit, keywords.usurped, keywords['bot: unknown']}),
	['id-access'] = make_keywords_list ({keywords.free}),
	}


--[[--------------------------&lt; S T R I P M A R K E R S &gt;------------------------------------------------------

Common pattern definition location for stripmarkers so that we don't have to go hunting for them if (when)
MediaWiki changes their form.

]]

local stripmarkers = {
	['any'] = '\127[^\127]*UNIQ%-%-(%a+)%-[%a%d]+%-QINU[^\127]*\127',			-- capture returns name of stripmarker
	['math'] = '\127[^\127]*UNIQ%-%-math%-[%a%d]+%-QINU[^\127]*\127'			-- math stripmarkers used in coins_cleanup() and coins_replace_math_stripmarker()
	}


--[[--------------------------&lt; I N V I S I B L E _ C H A R A C T E R S &gt;--------------------------------------

This table holds non-printing or invisible characters indexed either by name or by Unicode group. Values are decimal
representations of UTF-8 codes.  The table is organized as a table of tables because the lua pairs keyword returns
table data in an arbitrary order.  Here, we want to process the table from top to bottom because the entries at
the top of the table are also found in the ranges specified by the entries at the bottom of the table.

Also here is a pattern that recognizes stripmarkers that begin and end with the delete characters.  The nowiki
stripmarker is not an error but some others are because the parameter values that include them become part of the
template's metadata before stripmarker replacement.

]]

local invisible_chars = {
	{'replacement', '\239\191\189'},											-- U+FFFD, EF BF BD
	{'zero width joiner', '\226\128\141'},										-- U+200D, E2 80 8D
	{'zero width space', '\226\128\139'},										-- U+200B, E2 80 8B
	{'hair space', '\226\128\138'},												-- U+200A, E2 80 8A
	{'soft hyphen', '\194\173'},												-- U+00AD, C2 AD
	{'horizontal tab', '\009'},													-- U+0009 (HT), 09
	{'line feed', '\010'},														-- U+000A (LF), 0A
	{'no-break space', '\194\160'},												-- U+00A0 (NBSP), C2 A0
	{'carriage return', '\013'},												-- U+000D (CR), 0D
	{'stripmarker', stripmarkers.any},											-- stripmarker; may or may not be an error; capture returns the stripmaker type
	{'delete', '\127'},															-- U+007F (DEL), 7F; must be done after stripmarker test
	{'C0 control', '[\000-\008\011\012\014-\031]'},								-- U+0000–U+001F (NULL–US), 00–1F (except HT, LF, CR (09, 0A, 0D))
	{'C1 control', '[\194\128-\194\159]'},										-- U+0080–U+009F (XXX–APC), C2 80 – C2 9F
--	{'Specials', '[\239\191\185-\239\191\191]'},								-- U+FFF9-U+FFFF, EF BF B9 – EF BF BF
--	{'Private use area', '[\238\128\128-\239\163\191]'},						-- U+E000–U+F8FF, EE 80 80 – EF A3 BF
--	{'Supplementary Private Use Area-A', '[\243\176\128\128-\243\191\191\189]'},	-- U+F0000–U+FFFFD, F3 B0 80 80 – F3 BF BF BD
--	{'Supplementary Private Use Area-B', '[\244\128\128\128-\244\143\191\189]'},	-- U+100000–U+10FFFD, F4 80 80 80 – F4 8F BF BD
	}

--[[
Indic script makes use of zero width joiner as a character modifier so zwj characters must be left in.  This
pattern covers all of the unicode characters for these languages:
	Devanagari					0900–097F – https://unicode.org/charts/PDF/U0900.pdf
		Devanagari extended		A8E0–A8FF – https://unicode.org/charts/PDF/UA8E0.pdf
	Bengali						0980–09FF – https://unicode.org/charts/PDF/U0980.pdf
	Gurmukhi					0A00–0A7F – https://unicode.org/charts/PDF/U0A00.pdf
	Gujarati					0A80–0AFF – https://unicode.org/charts/PDF/U0A80.pdf
	Oriya						0B00–0B7F – https://unicode.org/charts/PDF/U0B00.pdf
	Tamil						0B80–0BFF – https://unicode.org/charts/PDF/U0B80.pdf
	Telugu						0C00–0C7F – https://unicode.org/charts/PDF/U0C00.pdf
	Kannada						0C80–0CFF – https://unicode.org/charts/PDF/U0C80.pdf
	Malayalam					0D00–0D7F – https://unicode.org/charts/PDF/U0D00.pdf
plus the not-necessarily Indic scripts for Sinhala and Burmese:
	Sinhala						0D80-0DFF - https://unicode.org/charts/PDF/U0D80.pdf
	Myanmar						1000-109F - https://unicode.org/charts/PDF/U1000.pdf
		Myanmar extended A		AA60-AA7F - https://unicode.org/charts/PDF/UAA60.pdf
		Myanmar extended B		A9E0-A9FF - https://unicode.org/charts/PDF/UA9E0.pdf
the pattern is used by has_invisible_chars() and coins_cleanup()
TODO: find a better place for this?
]]

local indic_script = '[\224\164\128-\224\181\191\224\163\160-\224\183\191\225\128\128-\225\130\159\234\167\160-\234\167\191\234\169\160-\234\169\191]';




--[[--------------------------&lt; L A N G U A G E   S U P P O R T &gt;----------------------------------------------

These tables and constants support various language-specific functionality.

]]

local this_wiki_code = mw.getContentLanguage():getCode();						-- get this wiki's language code
	if string.match (mw.site.server, 'wikidata') then
		this_wiki_code = mw.getCurrentFrame():preprocess('{{int:lang}}');		-- on wikidata so use interface language setting instead
	end

local local_lang_cat_enable = false;											-- set to true to categorize pages where |language=&lt;local wiki's language&gt;


--[[--------------------------&lt; S C R I P T _ L A N G _ C O D E S &gt;--------------------------------------------

This table is used to hold ISO 639-1 two-character language codes that apply only to |script-title= and |script-chapter=

]]

local script_lang_codes = {
	'am', 'ar', 'be', 'bg', 'bn', 'bo', 'bs', 'dv', 'dz', 'el', 'fa',			-- ISO 639-1 codes only for |script-title= and |script-chapter=
	'gu', 'he', 'hi', 'hy', 'ja', 'ka', 'kk', 'km', 'kn', 'ko', 'ku',
	'mk', 'ml', 'mn', 'mr', 'my', 'ne', 'ota', 'ps', 'ru', 'sd', 'si',
	'sr', 'ta', 'tg', 'th', 'ug', 'uk', 'ur', 'uz', 'yi', 'zh'
	};


--[[--------------------------&lt; L A N G U A G E   R E M A P P I N G &gt;------------------------------------------

These tables hold language information that is different (correct) from MediaWiki's definitions

For each ['code'] = 'language name' in lang_code_remap{} there must be a matching ['language name'] = {'language name', 'code'} in lang_name_remap{}

lang_code_remap{}:
	key is always lowercase ISO 639-1, -2, -3 language code or a valid lowercase IETF language tag
	value is properly spelled and capitalized language name associated with key
	only one language name per key;
	key/value pair must have matching entry in lang_name_remap{}

lang_name_remap{}:
	key is always lowercase language name
	value is a table the holds correctly spelled and capitalized language name [1] and associated code [2] (code must match a code key in lang_code_remap{})
	may have multiple keys referring to a common preferred name and code; For example:
		['kolsch'] and ['kölsch'] both refer to 'Kölsch' and 'ksh'

]]

local lang_code_remap = {														-- used for |language= and |script-title= / |script-chapter=
	['als'] = 'Tosk Albanian',													-- MediaWiki returns Alemannisch 
	['bh'] = 'Bihari',															-- MediaWiki uses 'bh' as a subdomain name for Bhojpuri Wikipedia: bh.wikipedia.org
	['bla'] = 'Blackfoot',														-- MediaWiki/IANA/ISO 639: Siksika; use en.wiki preferred name
	['bn'] = 'Bengali',															-- MediaWiki returns Bangla
	['ca-valencia'] = 'Valencian',												-- IETF variant of Catalan
	['crh'] = 'Crimean Tatar',													-- synonymous with Crimean Turkish (return value from {{#language:crh|en}})
	['ilo'] = 'Ilocano',														-- MediaWiki/IANA/ISO 639: Iloko; use en.wiki preferred name
	['ksh'] = 'Kölsch',															-- MediaWiki: Colognian; use IANA/ISO 639 preferred name
	['ksh-x-colog'] = 'Colognian',												-- override MediaWiki ksh; no IANA/ISO 639 code for Colognian; IETF private code created at Module:Lang/data
	['mis-x-ripuar'] = 'Ripuarian',												-- override MediaWiki ksh; no IANA/ISO 639 code for Ripuarian; IETF private code created at Module:Lang/data
	['nan-tw'] = 'Taiwanese Hokkien',											-- make room for MediaWiki/IANA/ISO 639 nan: Min Nan Chinese and support en.wiki preferred name
	}

local lang_name_remap = {														-- used for |language=
	['alemannisch'] = {'Swiss German', 'gsw'},									-- not an ISO or IANA language name; MediaWiki uses 'als' as a subdomain name for Alemannic Wikipedia: als.wikipedia.org
	['bangla'] = {'Bengali', 'bn'},												-- MediaWiki returns Bangla (the endonym) but we want Bengali (the exonym); here we remap
	['bengali'] = {'Bengali', 'bn'},											-- MediaWiki doesn't use exonym so here we provide correct language name and 639-1 code
	['bhojpuri'] = {'Bhojpuri', 'bho'},											-- MediaWiki uses 'bh' as a subdomain name for Bhojpuri Wikipedia: bh.wikipedia.org
	['bihari'] = {'Bihari', 'bh'},												-- MediaWiki replaces 'Bihari' with 'Bhojpuri' so 'Bihari' cannot be found
	['blackfoot'] = {'Blackfoot', 'bla'},										-- MediaWiki/IANA/ISO 639: Siksika; use en.wiki preferred name
	['colognian'] = {'Colognian', 'ksh-x-colog'},								-- MediaWiki preferred name for ksh
	['crimean tatar'] = {'Crimean Tatar', 'crh'},								-- MediaWiki uses 'crh' as a subdomain name for Crimean Tatar Wikipedia: crh.wikipedia.org
	['ilocano'] = {'Ilocano', 'ilo'},											-- MediaWiki/IANA/ISO 639: Iloko; use en.wiki preferred name
	['kolsch'] = {'Kölsch', 'ksh'},												-- use IANA/ISO 639 preferred name (use non-diacritical o instead of umlaut ö)
	['kölsch'] = {'Kölsch', 'ksh'},												-- use IANA/ISO 639 preferred name
	['ripuarian'] = {'Ripuarian', 'mis-x-ripuar'},								-- group of dialects; no code in MediaWiki or in IANA/ISO 639
--	['siksika'] = {'Siksika', 'bla'},											-- MediaWiki/IANA/ISO 639 preferred name: Siksika
	['taiwanese hokkien'] = {'Taiwanese Hokkien', 'nan-TW'},					-- make room for MediaWiki/IANA/ISO 639 nan: Min Nan Chinese 
	['tosk albanian'] = {'Tosk Albanian', 'als'},								-- MediaWiki replaces 'Tosk Albanian' with 'Alemannisch' so 'Tosk Albanian' cannot be found
	['valencian'] = {'Valencian', 'ca'},										-- variant of Catalan; categorizes as Catalan
	}


--[[--------------------------&lt; M A I N T E N A N C E _ C A T E G O R I E S &gt;----------------------------------

Here we name maintenance categories to be used in maintenance messages.

]]

local maint_cats = {
	['ASIN'] = 'CS1 maint: ASIN uses ISBN',
	['archived_copy'] = 'CS1 maint: archived copy as title',
	['authors'] = 'CS1 maint: uses authors parameter',
	['bot:_unknown'] = 'CS1 maint: BOT: original-url status unknown',
	['date_format'] = 'CS1 maint: date format',
	['date_year'] = 'CS1 maint: date and year',
	['disp_name'] = 'CS1 maint: display-$1',									-- $1 is 'authors', 'contributors', 'editors', 'interviewers', 'translators'; gets value from special_case_translation table
	['editors'] = 'CS1 maint: uses editors parameter',
	['embargo'] = 'CS1 maint: PMC embargo expired',
	['extra_punct'] = 'CS1 maint: extra punctuation',
	['extra_text'] = 'CS1 maint: extra text',
	['extra_text_names'] = 'CS1 maint: extra text: $1',							-- $1 is '&lt;name&gt;s list'; gets value from special_case_translation table
	['ignore_isbn_err'] = 'CS1 maint: ignored ISBN errors',
	['location'] = 'CS1 maint: location',
	['mult_names'] = 'CS1 maint: multiple names: $1',							-- $1 is '&lt;name&gt;s list'; gets value from special_case_translation table
	['numeric_names'] = 'CS1 maint: numeric names: $1',							-- $1 is '&lt;name&gt;s list'; gets value from special_case_translation table
	['others'] = 'CS1 maint: others',
	['pmc_format'] = 'CS1 maint: PMC format',
	['ref_harv'] = 'CS1 maint: ref=harv',
	['unfit'] = 'CS1 maint: unfit url',
	['unknown_lang'] = 'CS1 maint: unrecognized language',
	['untitled'] = 'CS1 maint: untitled periodical',
	['zbl'] = 'CS1 maint: ZBL',
	}


--[[--------------------------&lt; P R O P E R T I E S _ C A T E G O R I E S &gt;------------------------------------

Here we name properties categories

]]

local prop_cats = {
	['foreign_lang_source'] = 'CS1 $1-language sources ($2)',					-- |language= categories; $1 is foreign-language name, $2 is ISO639-1 code
	['foreign_lang_source_2'] = 'CS1 foreign language sources (ISO 639-2)|$1',	-- |language= category; a cat for ISO639-2 languages; $1 is the ISO 639-2 code used as a sort key
	['local_lang_source'] = 'CS1 $1-language sources ($2)',						-- |language= categories; $1 is local-language name, $2 is ISO639-1 code; not emitted when local_lang_cat_enable is false
	['location test'] = 'CS1 location test',
	['script'] = 'CS1 uses foreign language script',							-- when language specified by |script-title=xx: doesn't have its own category
	['script_with_name'] = 'CS1 uses $1-language script ($2)',					-- |script-title=xx: has matching category; $1 is language name, $2 is ISO639-1 code
	['jul_greg_uncertainty'] = 'CS1: Julian–Gregorian uncertainty',				-- probably temporary cat to identify scope of template with dates 1 October 1582 – 1 January 1926
	['long_vol'] = 'CS1: long volume value',									-- probably temporary cat to identify scope of |volume= values longer than 4 charachters
	}


--[[--------------------------&lt; T I T L E _ T Y P E S &gt;--------------------------------------------------------

Here we map a template's CitationClass to TitleType (default values for |type= parameter)

]]

local title_types = {
	['AV-media-notes'] = 'Media notes',
	['interview'] = 'Interview',
	['mailinglist'] = 'Mailing list',
	['map'] = 'Map',
	['podcast'] = 'Podcast',
	['pressrelease'] = 'Press release',
	['report'] = 'Report',
	['techreport'] = 'Technical report',
	['thesis'] = 'Thesis',
	}


--[[=========================&lt;&lt; E R R O R   M E S S A G I N G &gt;&gt;===============================================

]]


--[[--------------------------&lt; E R R O R   M E S S A G E   S U P P L I M E N T S &gt;----------------------------

i18n for those messages that are supplimented with additional specific text that describes the reason for
the error

TODO: merge this with special_case_translations{}?
]]

local err_msg_supl = {
	['char'] = 'invalid character',												-- isbn, sbn
	['check'] = 'checksum',														-- isbn, sbn
	['flag'] = 'flag',															-- archive-url
	['form'] = 'invalid form',													-- isbn, sbn
	['group'] = 'invalid group id',												-- isbn
	['initials'] = 'initials',													-- vancouver
	['journal'] = 'journal',													-- bibcode
	['length'] = 'length',														-- isbn, bibcode, sbn
	['liveweb'] = 'liveweb',													-- archive-url
	['missing comma'] = 'missing comma',										-- vancouver
	['name'] = 'name',															-- vancouver
	['non-Latin char'] = 'non-Latin character',									-- vancouver
	['path'] = 'path',															-- archive-url
	['prefix'] = 'invalid prefix',												-- isbn
	['punctuation'] = 'punctuation',											-- vancouver
	['save'] = 'save command',													-- archive-url
	['suffix'] = 'suffix',														-- vancouver
	['timestamp'] = 'timestamp',												-- archive-url
	['value'] = 'value',														-- bibcode
	['year'] = 'year',															-- bibcode
	}


--[[--------------------------&lt; E R R O R _ C O N D I T I O N S &gt;----------------------------------------------

Error condition table

The following contains a list of IDs for various error conditions defined in the code.  For each ID, we specify a
text message to display, an error category to include, and whether the error message should be wrapped as a hidden comment.

Anchor changes require identical changes to matching anchor in Help:CS1 errors

]]

local error_conditions = {
	accessdate_missing_url = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;access-date=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;url=&lt;/code&gt;',
		anchor = 'accessdate_missing_url',
		category = 'Pages using citations with accessdate and no URL',
		hidden = false
 		},
	apostrophe_markup = {
		message = 'Italic or bold markup not allowed in: &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'apostrophe_markup',
		category = 'CS1 errors: markup',
		hidden = false
 		},
	archive_missing_date = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;archive-url=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;archive-date=&lt;/code&gt;',
		anchor = 'archive_missing_date',
		category = 'Pages with archiveurl citation errors',
		hidden = false
		},
	archive_missing_url = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;archive-url=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;url=&lt;/code&gt;',
		anchor = 'archive_missing_url',
		category = 'Pages with archiveurl citation errors',
		hidden = false
		},
	archive_url = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;archive-url=&lt;/code&gt; is malformed: $1',	-- $1 is error message detail
		anchor = 'archive_url',
		category = 'Pages with archiveurl citation errors',
		hidden = false
		},
	arxiv_missing = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;arxiv=&lt;/code&gt; required',
		anchor = 'arxiv_missing',
		category = 'CS1 errors: arXiv',											-- same as bad arxiv
		hidden = false
		},
	arxiv_params_not_supported = {
		message = 'Unsupported parameter(s) in cite arXiv',
		anchor = 'arxiv_params_not_supported',
		category = 'CS1 errors: arXiv',											-- same as bad arxiv
		hidden = false
		},
	bad_arxiv = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;arxiv=&lt;/code&gt; value',
		anchor = 'bad_arxiv',
		category = 'CS1 errors: arXiv',
		hidden = false
		},
	bad_asin = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;asin=&lt;/code&gt; value',
		anchor = 'bad_asin',
		category ='CS1 errors: ASIN',
		hidden = false
		},
	bad_bibcode = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;bibcode=&lt;/code&gt; $1',		-- $1 is error message detail
		anchor = 'bad_bibcode',
		category = 'CS1 errors: bibcode',
		hidden = false
		},
	bad_biorxiv = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;biorxiv=&lt;/code&gt; value',
		anchor = 'bad_biorxiv',
		category = 'CS1 errors: bioRxiv',
		hidden = false
		},
	bad_citeseerx = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;citeseerx=&lt;/code&gt; value',
		anchor = 'bad_citeseerx',
		category = 'CS1 errors: citeseerx',
		hidden = false
		},
	bad_date = {
		message = 'Check date values in: &lt;code class="cs1-code"&gt;$1&lt;/code&gt;',		-- $1 is parameter name
		anchor = 'bad_date',
		category = 'CS1 errors: dates',
		hidden = false
		},
	bad_doi = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;doi=&lt;/code&gt; value',
		anchor = 'bad_doi',
		category = 'CS1 errors: DOI',
		hidden = false
		},
	bad_hdl = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;hdl=&lt;/code&gt; value',
		anchor = 'bad_hdl',
		category = 'CS1 errors: HDL',
		hidden = false
		},
	bad_isbn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;isbn=&lt;/code&gt; value: $1',	-- $1 is error message detail
		anchor = 'bad_isbn',
		category = 'CS1 errors: ISBN',
		hidden = false
		},
	bad_ismn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;ismn=&lt;/code&gt; value',
		anchor = 'bad_ismn',
		category = 'CS1 errors: ISMN',
		hidden = false
		},
	bad_issn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;$1issn=&lt;/code&gt; value',	-- $1 is 'e' or '' for eissn or issn
		anchor = 'bad_issn',
		category = 'CS1 errors: ISSN',
		hidden = false
		},
	bad_jfm = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;jfm=&lt;/code&gt; value',
		anchor = 'bad_jfm',
		category = 'CS1 errors: JFM',
		hidden = false
		},
	bad_lccn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;lccn=&lt;/code&gt; value',
		anchor = 'bad_lccn',
		category = 'CS1 errors: LCCN',
		hidden = false
		},
	bad_usenet_id = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;message-id=&lt;/code&gt; value',
		anchor = 'bad_message_id',
		category = 'CS1 errors: message-id',
		hidden = false
		},
	bad_mr = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;mr=&lt;/code&gt; value',
		anchor = 'bad_mr',
		category = 'CS1 errors: MR',
		hidden = false
		},
	bad_ol = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;ol=&lt;/code&gt; value',
		anchor = 'bad_ol',
		category = 'CS1 errors: OL',
		hidden = false
		},
	bad_paramlink = {															-- for |title-link=, |author/editor/translator-link=, |series-link=, |episode-link=
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; value',		-- $1 is parameter name
		anchor = 'bad_paramlink',
		category = 'CS1 errors: parameter link',
		hidden = false
		},
	bad_pmc = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;pmc=&lt;/code&gt; value',
		anchor = 'bad_pmc',
		category = 'CS1 errors: PMC',
		hidden = false
		},
	bad_pmid = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;pmid=&lt;/code&gt; value',
		anchor = 'bad_pmid',
		category = 'CS1 errors: PMID',
		hidden = false
		},
	bad_oclc = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;oclc=&lt;/code&gt; value',
		anchor = 'bad_oclc',
		category = 'CS1 errors: OCLC',
		hidden = false
		},
	bad_s2cid = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;s2cid=&lt;/code&gt; value',
		anchor = 'bad_s2cid',
		category = 'CS1 errors: S2CID',
		hidden = false
		},
	bad_sbn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;sbn=&lt;/code&gt; value: $1',	-- $1 is error message detail
		anchor = 'bad_sbn',
		category = 'CS1 errors: SBN',
		hidden = false
		},
	bad_ssrn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;ssrn=&lt;/code&gt; value',
		anchor = 'bad_ssrn',
		category = 'CS1 errors: SSRN',
		hidden = false
		},
	bad_url = {
		message = 'Check $1 value',												-- $1 is parameter name
		anchor = 'bad_url',
		category = 'Pages with URL errors',
		hidden = false
		},
	bad_zbl = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;zbl=&lt;/code&gt; value',
		anchor = 'bad_zbl',
		category = 'CS1 errors: ZBL',
		hidden = false
		},
	bare_url_missing_title = {
		message = '$1 missing title',											-- $1 is parameter name
		anchor = 'bare_url_missing_title',
		category = 'Pages with citations having bare URLs',
		hidden = false
		},
	biorxiv_missing = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;biorxiv=&lt;/code&gt; required',
		anchor = 'biorxiv_missing',
		category = 'CS1 errors: bioRxiv',										-- same as bad bioRxiv
		hidden = false
		},
	chapter_ignored = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; ignored',			-- $1 is parameter name
		anchor = 'chapter_ignored',
		category = 'CS1 errors: chapter ignored',
		hidden = false
		},
	citation_missing_title = {
		message = 'Missing or empty &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'citation_missing_title',
		category = 'Pages with citations lacking titles',
		hidden = false
		},
	citeseerx_missing = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;citeseerx=&lt;/code&gt; required',
		anchor = 'citeseerx_missing',
		category = 'CS1 errors: citeseerx',										-- same as bad citeseerx
		hidden = false
		},
	cite_web_url = {															-- this error applies to cite web and to cite podcast
		message = 'Missing or empty &lt;code class="cs1-code"&gt;&amp;#124;url=&lt;/code&gt;',
		anchor = 'cite_web_url',
		category = 'Pages using web citations with no URL',
		hidden = false
		},
	class_ignored = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;class=&lt;/code&gt; ignored',
		anchor = 'class_ignored',
		category = 'CS1 errors: class',
		hidden = false
		},
	contributor_ignored = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;contributor=&lt;/code&gt; ignored',
		anchor = 'contributor_ignored',
		category = 'CS1 errors: contributor',
		hidden = false
		},
	contributor_missing_required_param = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;contributor=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'contributor_missing_required_param',
		category = 'CS1 errors: contributor',
		hidden = false
		},
	deprecated_params = {
		message = 'Cite uses deprecated parameter &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'deprecated_params',
		category = 'CS1 errors: deprecated parameters',
		hidden = false
		},
	doibroken_missing_doi = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;doi=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'doibroken_missing_doi',
		category = 'CS1 errors: DOI',
		hidden = false
		},
	empty_citation = {
		message = 'Empty citation',
		anchor = 'empty_citation',
		category = 'Pages with empty citations',
		hidden = false
		},
	etal = {
		message = 'Explicit use of et al. in: &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'explicit_et_al',
		category = 'CS1 errors: explicit use of et al.',
		hidden = false
		},
	first_missing_last = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; missing &lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt;',	-- $1 is first alias, $2 is matching last alias
		anchor = 'first_missing_last',
		category = 'CS1 errors: missing name',									-- author, contributor, editor, interviewer, translator
		hidden = false
		},
	format_missing_url = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt;',	-- $1 is format parameter $2 is url parameter
		anchor = 'format_missing_url',
		category = 'Pages using citations with format and no URL',
		hidden = false
		},
	invalid_param_val = {
		message = 'Invalid &lt;code class="cs1-code"&gt;&amp;#124;$1=$2&lt;/code&gt;',			-- $1 is parameter name $2 is paramter value
		anchor = 'invalid_param_val',
		category = 'CS1 errors: invalid parameter value',
		hidden = false
		},
	invisible_char = {
		message = '$1 in $2 at position $3',									-- $1 is invisible char $2 is parameter name $3 is position number
		anchor = 'invisible_char',
		category = 'CS1 errors: invisible characters',
		hidden = false
		},
	missing_name = {
		message = 'Missing &lt;code class="cs1-code"&gt;&amp;#124;$1$2=&lt;/code&gt;',			-- $1 is modified NameList; $2 is enumerator
		anchor = 'missing_name',
		category = 'CS1 errors: missing name',									-- author, contributor, editor, interviewer, translator
		hidden = false
		},
	missing_periodical = {
		message = 'Cite $1 requires &lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt;',	-- $1 is cs1 template name; $2 is canonical periodical parameter name for cite $1
		anchor = 'missing_periodical',
		category = 'CS1 errors: missing periodical',
		hidden = true
		},
	missing_pipe = {
		message = 'Missing pipe in: &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'missing_pipe',
		category = 'CS1 errors: missing pipe',
		hidden = false
		},
	param_access_requires_param = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1-access=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'param_access_requires_param',
		category = 'CS1 errors: param-access',
		hidden = false
		},
	param_has_ext_link = {
		message = 'External link in &lt;code class="cs1-code"&gt;$1&lt;/code&gt;',			-- $1 is parameter name
		anchor = 'param_has_ext_link',
		category = 'CS1 errors: external links',
		hidden = false
		},
	parameter_ignored = {
		message = 'Unknown parameter &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; ignored',	-- $1 is parameter name
		anchor = 'parameter_ignored',
		category = 'Pages with citations using unsupported parameters',
		hidden = false
		},
	parameter_ignored_suggest = {
		message = 'Unknown parameter &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; ignored (&lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt; suggested)',	-- $1 is unknown paramter $2 is suggested parameter name
		anchor = 'parameter_ignored_suggest',
		category = 'Pages with citations using unsupported parameters',
		hidden = false
		},
	redundant_parameters = {
		message = 'More than one of $1 specified',								-- $1 is error message detail
		anchor = 'redundant_parameters',
		category = 'Pages with citations having redundant parameters',
		hidden = false
		},
	script_parameter = {
		message = 'Invalid &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;: $2',		-- $1 is parameter name $2 is script language code or error detail
		anchor = 'script_parameter',
		category = 'CS1 errors: script parameters',
		hidden = false
		},
	ssrn_missing = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;ssrn=&lt;/code&gt; required',
		anchor = 'ssrn_missing',
		category = 'CS1 errors: ssrn',											-- same as bad arxiv
		hidden = false
		},
	text_ignored = {
		message = 'Text "$1" ignored',											-- $1 is ignored text
		anchor = 'text_ignored',
		category = 'Pages with citations using unnamed parameters',
		hidden = false
		},
	trans_missing_title = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;trans-$1=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is base parameter name
		anchor = 'trans_missing_title',
		category = 'CS1 errors: translated title',
		hidden = false
		},
	vancouver = {
		message = 'Vancouver style error: $1',									-- $1 is error detail
		anchor = 'vancouver',
		category = 'CS1 errors: Vancouver style',
		hidden = false
		},
	wikilink_in_url = {
		message = 'URL–wikilink conflict',										-- uses ndash
		anchor = 'wikilink_in_url',
		category = 'CS1 errors: URL–wikilink conflict',							-- uses ndash
		hidden = false
		},
	}


--[[--------------------------&lt; I D _ L I M I T S &gt;------------------------------------------------------------

certain identifiers have limits set upon their values so that typographic errors may be detected.  These (max)
limits are defined here so that those limits may be automatically included in the template documentation and error
message help text.

]]

local id_limits = {
	pmc = 7500000,																-- |pmc=
	pmid = 33000000,															-- |pmid=
	ssrn = 4000000,																-- |ssrn=
	s2cid = 230000000,															-- |s2cid=
	}


--[[--------------------------&lt; I D _ H A N D L E R S &gt;--------------------------------------------------------

The following contains a list of values for various defined identifiers.  For each identifier we specify a
variety of information necessary to properly render the identifier in the citation.

	parameters: a list of parameter aliases for this identifier; first in the list is the canonical form
	link: Wikipedia article name
	redirect: a local redirect to a local Wikipedia article name;  at en.wiki, 'ISBN (identifier)' is a redirect to 'International Standard Book Number'
	q: wikidata q number for the identifier
	label: the label preceeding the identifier; label is linked to a wikipedia article (in this order):
		redirect from id_handlers['&lt;id&gt;'].redirect when use_identifier_redirects is true
		wikidata-supplied article name for the local wiki from id_handlers['&lt;id&gt;'].q
		local article name from id_handlers['&lt;id&gt;'].link
	mode: 	'manual' when there is a specific function in the code to handle the identifier;
			'external' for identifiers that link outside of Wikipedia;
	prefix: the first part of a url that will be concatenated with a second part which usually contains the identifier
	encode: true if uri should be percent encoded; otherwise false
	COinS: identifier link or keyword for use in COinS:
		for identifiers registered at info-uri.info use: info:....
		for identifiers that have COinS keywords, use the keyword: rft.isbn, rft.issn, rft.eissn
		for others make a url using the value in prefix, use the keyword: pre (not checked; any text other than 'info' or 'rft' works here)
		set to nil to leave the identifier out of the COinS
	separator: character or text between label and the identifier in the rendered citation
	access: use this parameter to set the access level for all instances of this identifier.
			the value must be a valid access level for an identifier (see ['id-access'] in this file).
	custom_access: to enable custom access level for an identifier, set this parameter
			to the parameter that should control it (normally 'id-access')
]]

local id_handlers = {
	['ARXIV'] = {
		parameters = {'arxiv', 'eprint'},
		link = 'arXiv',
		redirect = 'arXiv (identifier)',
		q = 'Q118398',
		label = 'arXiv',
		mode = 'manual',
		prefix = '//arxiv.org/abs/', 											-- protocol relative tested 2013-09-04
		encode = false,
		COinS = 'info:arxiv',
		separator = ':',
		access = 'free',														-- free to read
		},
	['ASIN'] = {
		parameters = { 'asin', 'ASIN' },
		link = 'Amazon Standard Identification Number',
		redirect = 'ASIN (identifier)',
		q = 'Q1753278',
		label = 'ASIN',
		mode = 'manual',
		prefix = '//www.amazon.',
		COinS = nil,															-- no COinS for this id (needs thinking on implementation because |asin-tld=)
		separator = '&amp;nbsp;',
		encode = false;
		},
	['BIBCODE'] = {
		parameters = {'bibcode'},
		link = 'Bibcode',
		redirect = 'Bibcode (identifier)',
		q = 'Q25754',
		label = 'Bibcode',
		mode = 'manual',
		prefix = 'https://ui.adsabs.harvard.edu/abs/',
		encode = false,
		COinS = 'info:bibcode',
		separator = ':',
		custom_access = 'bibcode-access',
		},
	['BIORXIV'] = {
		parameters = {'biorxiv'},
		link = 'bioRxiv',
		redirect = 'bioRxiv (identifier)',
		q = 'Q19835482',
		label = 'bioRxiv',
		mode = 'manual',
		prefix = '//doi.org/',
		COinS = 'pre',															-- use prefix value
		access = 'free',														-- free to read
		encode = true,
		separator = '&amp;nbsp;',
		},
	['CITESEERX'] = {
		parameters = {'citeseerx'},
		link = 'CiteSeerX',
		redirect = 'CiteSeerX (identifier)',
		q = 'Q2715061',
		label = 'CiteSeerX',
		mode = 'manual',														-- manual for custom validation of the "doi"
		prefix = '//citeseerx.ist.psu.edu/viewdoc/summary?doi=',
		COinS =  'pre',															-- use prefix value
		access = 'free',														-- free to read
		encode = true,
		separator = '&amp;nbsp;',
		},
	['DOI'] = {																	-- Used by InternetArchiveBot
		parameters = { 'doi', 'DOI' },
		link = 'Digital object identifier',
		redirect = 'doi (identifier)',
		q = 'Q25670',
		label = 'doi',
		mode = 'manual',
		prefix = '//doi.org/',
		COinS = 'info:doi',
		separator = ':',
		encode = true,
		custom_access = 'doi-access',
		},
	['EISSN'] = {
		parameters = {'eissn', 'EISSN'},
		link = 'International_Standard_Serial_Number#Electronic_ISSN',
		redirect = 'eISSN (identifier)',
		q = 'Q46339674',
		label = 'eISSN',
		mode = 'manual',
		prefix = '//www.worldcat.org/issn/',
		COinS = 'rft.eissn',
		encode = false,
		separator = '&amp;nbsp;',
		},
	['HDL'] = {
		parameters = { 'hdl', 'HDL' },
		link = 'Handle System',
		redirect = 'hdl (identifier)',
		q = 'Q3126718',
		label = 'hdl',
		mode = 'manual',
		prefix = '//hdl.handle.net/',
		COinS = 'info:hdl',
		separator = ':',
		encode = true,
		custom_access = 'hdl-access',
		},
	['ISBN'] = {																-- Used by InternetArchiveBot
		parameters = {'isbn', 'ISBN', 'isbn13', 'ISBN13'},
		link = 'International Standard Book Number',
		redirect = 'ISBN (identifier)',
		q = 'Q33057',
		label = 'ISBN',
		mode = 'manual',
		prefix = 'Special:BookSources/',
		COinS = 'rft.isbn',
		separator = '&amp;nbsp;',
		},
	['ISMN'] = {
		parameters = {'ismn', 'ISMN'},
		link = 'International Standard Music Number',
		redirect = 'ISMN (identifier)',
		q = 'Q1666938',
		label = 'ISMN',
		mode = 'manual',
		prefix = '',															-- not currently used;
		COinS = 'nil',															-- nil because we can't use pre or rft or info:
		separator = '&amp;nbsp;',
		},
	['ISSN'] = {
		parameters = {'issn', 'ISSN'},
		link = 'International Standard Serial Number',
		redirect = 'ISSN (identifier)',
		q = 'Q131276',
		label = 'ISSN',
		mode = 'manual',
		prefix = '//www.worldcat.org/issn/',
		COinS = 'rft.issn',
		encode = false,
		separator = '&amp;nbsp;',
		},
	['JFM'] = {
		parameters = {'jfm', 'JFM'},
		link = 'Jahrbuch über die Fortschritte der Mathematik',
		redirect = 'JFM (identifier)',
		q = '',
		label = 'JFM',
		mode = 'manual',
		prefix = '//zbmath.org/?format=complete&amp;q=an:',
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		},
	['JSTOR'] = {
		parameters = {'jstor', 'JSTOR'},
		link = 'JSTOR',
		redirect = 'JSTOR (identifier)',
		q = 'Q1420342',
		label = 'JSTOR',
		mode = 'external',
		prefix = '//www.jstor.org/stable/', 									-- protocol relative tested 2013-09-04
		COinS = 'pre',															-- use prefix value
		encode = false,
		separator = '&amp;nbsp;',
		custom_access = 'jstor-access',
		},
	['LCCN'] = {
		parameters = {'lccn', 'LCCN'},
		link = 'Library of Congress Control Number',
		redirect = 'LCCN (identifier)',
		q = 'Q620946',
		label = 'LCCN',
		mode = 'manual',
		prefix = '//lccn.loc.gov/', 											-- protocol relative tested 2015-12-28
		COinS = 'info:lccn',													-- use prefix value
		encode = false,
		separator = '&amp;nbsp;',
		},
	['MR'] = {
		parameters = {'mr', 'MR'},
		link = 'Mathematical Reviews',
		redirect = 'MR (identifier)',
		q = 'Q211172',
		label = 'MR',
		mode = 'manual',
		prefix = '//www.ams.org/mathscinet-getitem?mr=', 						-- protocol relative tested 2013-09-04
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		},
	['OCLC'] = {
		parameters = {'oclc', 'OCLC'},
		link = 'OCLC',
		redirect = 'OCLC (identifier)',
		q = 'Q190593',
		label = 'OCLC',
		mode = 'manual',
		prefix = '//www.worldcat.org/oclc/',
		COinS = 'info:oclcnum',
		encode = true,
		separator = '&amp;nbsp;',
		},
	['OL'] = {
		parameters = { 'ol', 'OL' },
		link = 'Open Library',
		redirect = 'OL (identifier)',
		q = 'Q1201876',
		label = 'OL',
		mode = 'manual',
		prefix = '//openlibrary.org/',
		COinS = nil,															-- no COinS for this id (needs thinking on implementation because /authors/books/works/OL)
		separator = '&amp;nbsp;',
		encode = true,
		custom_access = 'ol-access',
		},
	['OSTI'] = {
		parameters = {'osti', 'OSTI'},
		link = 'Office of Scientific and Technical Information',
		redirect = 'OSTI (identifier)',
		q = 'Q2015776',
		label = 'OSTI',
		mode = 'external',
		prefix = '//www.osti.gov/biblio/',										-- protocol relative tested 2018-09-12
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		custom_access = 'osti-access',
		},
	['PMC'] = {
		parameters = {'pmc', 'PMC'},
		link = 'PubMed Central',
		redirect = 'PMC (identifier)',
		q = 'Q229883',
		label = 'PMC',
		mode = 'manual',
		prefix = '//www.ncbi.nlm.nih.gov/pmc/articles/PMC',
		suffix = " ",
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		access = 'free',														-- free to read
		},
	['PMID'] = {
		parameters = {'pmid', 'PMID'},
		link = 'PubMed Identifier',
		redirect = 'PMID (identifier)',
		q = '',
		label = 'PMID',
		mode = 'manual',
		prefix = '//pubmed.ncbi.nlm.nih.gov/',
		COinS = 'info:pmid',
		encode = false,
		separator = '&amp;nbsp;',
		},
	['RFC'] = {
		parameters = {'rfc', 'RFC'},
		link = 'Request for Comments',
		redirect = 'RFC (identifier)',
		q = 'Q212971',
		label = 'RFC',
		mode = 'external',
		prefix = '//tools.ietf.org/html/rfc',
		COinS = 'pre',															-- use prefix value
		encode = false,
		separator = '&amp;nbsp;',
		access = 'free',														-- free to read
		},
	['SBN'] = {
		parameters = {'sbn', 'SBN'},
		link = 'Standard Book Number',											-- redirect to International_Standard_Book_Number#History
		redirect = 'SBN (identifier)',
		label = 'SBN',
		mode = 'manual',
		prefix = 'Special:BookSources/0-',										-- prefix has leading zero necessary to make 9-digit sbn a 10-digit isbn
		COinS = nil,															-- nil because we can't use pre or rft or info:
		separator = '&amp;nbsp;',
		},
	['SSRN'] = {
		parameters = {'ssrn', 'SSRN'},
		link = 'Social Science Research Network',
		redirect = 'SSRN (identifier)',
		q = 'Q7550801',
		label = 'SSRN',
		mode = 'manual',
		prefix = '//ssrn.com/abstract=', 										-- protocol relative tested 2013-09-04
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		access = 'free',														-- always free to read
		},
	['S2CID'] = {
		parameters = {'s2cid', 'S2CID'},
		link = 'Semantic Scholar',
		redirect = 'S2CID (identifier)',
		q = 'Q22908627',
		label = 'S2CID',
		mode = 'manual',
		prefix = 'https://api.semanticscholar.org/CorpusID:',
		COinS = 'pre',															-- use prefix value
		encode = false,
		separator = '&amp;nbsp;',
		custom_access = 's2cid-access',
		},
	['USENETID'] = {
		parameters = {'message-id'},
		link = 'Usenet',
		redirect = 'Usenet (identifier)',
		q = 'Q193162',
		label = 'Usenet:',
		mode = 'manual',
		prefix = 'news:',
		encode = false,
		COinS = 'pre',															-- use prefix value
		separator = '&amp;nbsp;',
		},
	['ZBL'] = {
		parameters = {'zbl', 'ZBL' },
		link = 'Zentralblatt MATH',
		redirect = 'Zbl (identifier)',
		q = 'Q190269',
		label = 'Zbl',
		mode = 'manual',
		prefix = '//zbmath.org/?format=complete&amp;q=an:',
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		},
	}


--[[--------------------------&lt; E X P O R T S &gt;----------------------------------------------------------------
]]

return 	{
	use_identifier_redirects = true,											-- when true use redirect name for identifier label links

	aliases = aliases,
	special_case_translation = special_case_translation,
	date_names = date_names,
	err_msg_supl = err_msg_supl,
	error_conditions = error_conditions,
	editor_markup_patterns = editor_markup_patterns,
	et_al_patterns = et_al_patterns,
	global_df = global_df,
	id_handlers = id_handlers,
	id_limits = id_limits,
	keywords_lists = keywords_lists,
	keywords_xlate = keywords_xlate,
	stripmarkers=stripmarkers,
	invisible_chars = invisible_chars,
	indic_script = indic_script,
	local_lang_cat_enable = local_lang_cat_enable,
	maint_cats = maint_cats,
	messages = messages,
	presentation = presentation,
	prop_cats = prop_cats,
	punct_skip = punct_skip,
	script_lang_codes = script_lang_codes,
	lang_code_remap = lang_code_remap,
	lang_name_remap = lang_name_remap,
	this_wiki_code = this_wiki_code,
	title_types = title_types,
	uncategorized_namespaces = uncategorized_namespaces,
	uncategorized_subpages = uncategorized_subpages,
	templates_using_volume = templates_using_volume,
	templates_using_issue = templates_using_issue,
	templates_not_using_page = templates_not_using_page,
	}</text>
      <sha1>7esfe02mxgjv1qsyq13suvaz7fkdz51</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Date validation</title>
    <ns>828</ns>
    <id>42164542</id>
    <revision>
      <id>951705301</id>
      <parentid>936384842</parentid>
      <timestamp>2020-04-18T12:50:48Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>sync from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="57727" xml:space="preserve">
--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local is_set, in_array;															-- imported functions from selected Module:Citation/CS1/Utilities
local cfg;																		-- table of tables imported from selected Module:Citation/CS1/Configuration


--[[--------------------------&lt; F I L E - S C O P E   D E C L A R A T I O N S &gt;--------------------------------

File-scope variables are declared here

]]

local lang_object = mw.getContentLanguage();									-- used by is_valid_accessdate(), is_valid_year(), date_name_xlate(); TODO: move to ~/Configuration?
local year_limit;																-- used by is_valid_year()


--[=[-------------------------&lt; I S _ V A L I D _ A C C E S S D A T E &gt;----------------------------------------

returns true if:
	Wikipedia start date &lt;= accessdate &lt; today + 2 days

Wikipedia start date is 2001-01-15T00:00:00 UTC which is 979516800 seconds after 1970-01-01T00:00:00 UTC (the start of Unix time)
accessdate is the date provided in |accessdate= at time 00:00:00 UTC
today is the current date at time 00:00:00 UTC plus 48 hours
	if today is 2015-01-01T00:00:00 then
		adding 24 hours gives 2015-01-02T00:00:00 – one second more than today
		adding 24 hours gives 2015-01-03T00:00:00 – one second more than tomorrow

This function does not work if it is fed month names for languages other than English.  Wikimedia #time: parser
apparently doesn't understand non-Engish date month names. This function will always return false when the date
contains a non-English month name because good1 is false after the call to lang.formatDate().  To get around that
call this function with YYYY-MM-DD format dates.

]=]

local function is_valid_accessdate (accessdate)
	local good1, good2;
	local access_ts, tomorrow_ts;												-- to hold unix time stamps representing the dates

	good1, access_ts = pcall (lang_object.formatDate, lang_object, 'U', accessdate );			-- convert accessdate value to unix timesatmp 
	good2, tomorrow_ts = pcall (lang_object.formatDate, lang_object, 'U', 'today + 2 days' );	-- today midnight + 2 days is one second more than all day tomorrow
	
	if good1 and good2 then														-- lang.formatDate() returns a timestamp in the local script which which tonumber() may not understand
		access_ts = tonumber (access_ts) or lang_object:parseFormattedNumber (access_ts);			-- convert to numbers for the comparison;
		tomorrow_ts = tonumber (tomorrow_ts) or lang_object:parseFormattedNumber (tomorrow_ts);
	else
		return false;															-- one or both failed to convert to unix time stamp
	end

	if 979516800 &lt;= access_ts and access_ts &lt; tomorrow_ts then					-- Wikipedia start date &lt;= accessdate &lt; tomorrow's date
		return true;
	else
		return false;															-- accessdate out of range
	end
end


--[[--------------------------&lt; G E T _ M O N T H _ N U M B E R &gt;----------------------------------------------

returns a number according to the month in a date: 1 for January, etc.  Capitalization and spelling must be correct. If not a valid month, returns 0

]]

local function get_month_number (month)
	return cfg.date_names['local'].long[month] or cfg.date_names['local'].short[month] or		-- look for local names first
			cfg.date_names['en'].long[month] or	cfg.date_names['en'].short[month] or			-- failing that, look for English names
			0;																					-- not a recognized month name
end


--[[--------------------------&lt; I S _ V A L I D _ E M B A R G O _ D A T E &gt;------------------------------------

returns true and date value if that value has proper dmy, mdy, ymd format.

returns false and 9999 (embargoed forever) when date value is not proper format; assumes that when |embargo= is
set, the editor intended to embargo a pmc but |embargo= does not hold a single date.

]]

local function is_valid_embargo_date (v)
	if v:match ('^%d%d%d%d%-%d%d%-%d%d$') or									-- ymd
		v:match ('^%d%d?%s+%a+%s+%d%d%d%d$') or									-- dmy
		v:match ('^%a+%s+%d%d?%s*,%s*%d%d%d%d$') then							-- mdy
			return true, v;
	end
	return false, '9999';														-- if here not good date so return false and set embargo date to long time in future
end


--[[--------------------------&lt; G E T _ S E A S O N _ N U M B E R &gt;--------------------------------------------

returns a number according to the sequence of seasons in a year: 1 for Winter, etc.  Capitalization and spelling must be correct. If not a valid season, returns 0

Uses ISO DIS 8601 2016 part 2 §4.7  Divisions of a year for hemishpere-independent seasons:
	21-24 = Spring, Summer, Autumn, Winter, independent of “Hemisphere”

These additional divisions not currently supported:
	25-28 = Spring - Northern Hemisphere, Summer- Northern Hemisphere, Autumn - Northern Hemisphere, Winter - Northern Hemisphere
	29-32 = Spring – Southern Hemisphere, Summer– Southern Hemisphere, Autumn – Southern Hemisphere, Winter - Southern Hemisphere
	33-36 = Quarter 1, Quarter 2, Quarter 3, Quarter 4 (3 months each)
	37-39 = Quadrimester 1, Quadrimester 2, Quadrimester 3 (4 months each)
	40-41 = Semestral 1, Semestral-2 (6 months each)

]]

local function get_season_number (season)
	return cfg.date_names['local'].season[season] or							-- look for local names first
			cfg.date_names['en'].season[season] or								-- failing that, look for English names
			0;																	-- not a recognized season name
end


--[[--------------------------&lt; I S _ P R O P E R _ N A M E &gt;--------------------------------------------------

returns a non-zero number if date contains a recognized proper name.  Capitalization and spelling must be correct.

]]

local function is_proper_name (name)
	return cfg.date_names['local'].named[name] or								-- look for local names dates first
			cfg.date_names['en'].named[name] or									-- failing that, look for English names
			0;																	-- not a recognized named date
end


--[[--------------------------&lt; I S _ V A L I D _ M O N T H _ O R _ S E A S O N &gt;------------------------------

--returns true if month or season is valid (properly spelled, capitalized, abbreviated)

]]

local function is_valid_month_or_season (month_season)
	if 0 == get_month_number (month_season) then								-- if month text isn't one of the twelve months, might be a season
		if 0 == get_season_number (month_season) then							-- not a month, is it a season?
			return false;														-- return false not a month or one of the five seasons
		end
	end
	return true;
end


--[[--------------------------&lt; I S _ V A L I D _ Y E A R &gt;----------------------------------------------------

Function gets current year from the server and compares it to year from a citation parameter.  Years more than one year in the future are not acceptable.

]]

local function is_valid_year(year)
	if not is_set(year_limit) then
		year_limit = tonumber(os.date("%Y"))+1;									-- global variable so we only have to fetch it once
	end

	year = tonumber (year) or lang_object:parseFormattedNumber (year);			-- convert to numbers for the comparison;
	return year and (year &lt;= year_limit) or false;
end


--[[--------------------------&lt; I S _ V A L I D _ D A T E &gt;----------------------------------------------------
Returns true if day is less than or equal to the number of days in month and year is no farther into the future
than next year; else returns false.

Assumes Julian calendar prior to year 1582 and Gregorian calendar thereafter. Accounts for Julian calendar leap
years before 1582 and Gregorian leap years after 1582. Where the two calendars overlap (1582 to approximately
1923) dates are assumed to be Gregorian.

]]

local function is_valid_date (year, month, day)
local days_in_month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
local month_length;
	if not is_valid_year(year) then												-- no farther into the future than next year
		return false;
	end
	
	month = tonumber(month);													-- required for YYYY-MM-DD dates
	
	if (2==month) then															-- if February
		month_length = 28;														-- then 28 days unless
		if 1582 &gt; tonumber(year) then											-- Julian calendar
			if 0==(year%4) then													-- is a leap year?
				month_length = 29;												-- if leap year then 29 days in February
			end
		else																	-- Gregorian calendar
			if (0==(year%4) and (0~=(year%100) or 0==(year%400))) then			-- is a leap year?
				month_length = 29;												-- if leap year then 29 days in February
			end
		end
	else
		month_length=days_in_month[month];
	end

	if tonumber (day) &gt; month_length then
		return false;
	end
	return true;
end


--[[--------------------------&lt; I S _ V A L I D _ M O N T H _ R A N G E _ S T Y L E &gt;--------------------------

Months in a range are expected to have the same style: Jan–Mar or October–December but not February–Mar or Jul–August. 
There is a special test for May because it can be either short or long form.

Returns true when style for both months is the same

]]

local function is_valid_month_range_style (month1, month2)
local len1 = month1:len();
local len2 = month2:len();
	if len1 == len2 then
		return true;															-- both months are short form so return true
	elseif 'May' == month1 or 'May'== month2 then
		return true;															-- both months are long form so return true
	elseif 3 == len1 or 3 == len2 then
		return false;															-- months are mixed form so return false
	else
		return true;															-- both months are long form so return true
	end
end


--[[--------------------------&lt; I S _ V A L I D _ M O N T H _ S E A S O N _ R A N G E &gt;------------------------

Check a pair of months or seasons to see if both are valid members of a month or season pair.

Month pairs are expected to be left to right, earliest to latest in time.

All season ranges are accepted as valid because there are publishers out there who have published a Summer–Spring YYYY issue so ... ok

]]

local function is_valid_month_season_range(range_start, range_end)
	local range_start_number = get_month_number (range_start);
	local range_end_number;
	
	if 0 == range_start_number then												-- is this a month range?
		range_start_number = get_season_number (range_start);					-- not a month; is it a season? get start season number
		range_end_number = get_season_number (range_end);						-- get end season number

		if (0 ~= range_start_number) and (0 ~= range_end_number) then
			return true;														-- any season pairing is accepted
		end
		return false;															-- range_start and/or range_end is not a season
	end
																				-- here when range_start is a month
	range_end_number = get_month_number (range_end);							-- get end month number
	if range_start_number &lt; range_end_number then								-- range_start is a month; does range_start precede range_end?
		if is_valid_month_range_style (range_start, range_end) then				-- do months have the same style?
			return true;														-- proper order and same style
		end
	end
	return false;																-- range_start month number is greater than or equal to range end number; or range end isn't a month
end


--[[--------------------------&lt; M A K E _ C O I N S _ D A T E &gt;------------------------------------------------

This function receives a table of date parts for one or two dates and an empty table reference declared in
Module:Citation/CS1.  The function is called only for |date= parameters and only if the |date=&lt;value&gt; is 
determined to be a valid date format.  The question of what to do with invalid date formats is not answered here.

The date parts in the input table are converted to an ISO 8601 conforming date string:
	single whole dates:		yyyy-mm-dd
	month and year dates:	yyyy-mm
	year dates:				yyyy
	ranges:					yyyy-mm-dd/yyyy-mm-dd
							yyyy-mm/yyyy-mm
							yyyy/yyyy

Dates in the Julian calendar are reduced to year or year/year so that we don't have to do calendar conversion from
Julian to Proleptic Gregorian.

The input table has:
	year, year2 – always present; if before 1582, ignore months and days if present
	month, month2 – 0 if not provided, 1-12 for months, 21-24 for seasons; 99 Christmas
	day, day2 –  0 if not provided, 1-31 for days
	
the output table receives:
	rftdate:	an IS8601 formatted date
	rftchron:	a free-form version of the date, usually without year which is in rftdate (season ranges and propername dates)
	rftssn:		one of four season keywords: winter, spring, summer, fall (lowercase)

]]

local function make_COinS_date (input, tCOinS_date)
	local date;																	-- one date or first date in a range
	local date2 = '';															-- end of range date
-- start temporary Julian / Gregorian calendar uncertainty detection
	local year = tonumber(input.year);											-- this temporary code to determine the extent of sources dated to the Julian/Gregorian
	local month = tonumber(input.month);										-- interstice 1 October 1582 – 1 January 1926
	local day = tonumber (input.day);
	if (0 ~= day) and															-- day must have a value for this to be a whole date
		(((1582 == year) and (10 &lt;= month) and (12 &gt;= month)) or				-- any whole 1582 date from 1 october to 31 December or
			((1926 == year) and (1 == month) and (1 == input.day)) or			-- 1 January 1926 or
				((1582 &lt; year) and (1925 &gt;= year))) then						-- any date 1 January 1583 – 31 December 1925
					tCOinS_date.inter_cal_cat = true;							-- set category flag true
	end
-- end temporary Julian / Gergorian calendar uncertainty detection
	
	if 1582 &gt; tonumber(input.year) or 20 &lt; tonumber(input.month) then			-- Julian calendar or season so &amp;rft.date gets year only
		date = input.year;
		if 0 ~= input.year2 and input.year ~= input.year2 then					-- if a range, only the second year portion when not the same as range start year
			date = string.format ('%.4d/%.4d', tonumber(input.year), tonumber(input.year2))		-- assemble the date range
		end
		if 20 &lt; tonumber(input.month) then										-- if season or propername date
			local season = {[24]='winter', [21]='spring', [22]='summer', [23]='fall', [99]='Christmas'};	-- seasons lowercase, no autumn; proper names use title case
			if 0 == input.month2 then											-- single season date
				if 30 &lt;tonumber(input.month) then
					tCOinS_date.rftchron = season[input.month];					-- proper name dates
				else
					tCOinS_date.rftssn = season[input.month];					-- seasons
				end
			else																-- season range with a second season specified
				if input.year ~= input.year2 then								-- season year – season year range or season year–year
					tCOinS_date.rftssn = season[input.month];					-- start of range season; keep this?
					if 0~= input.month2 then
						tCOinS_date.rftchron = string.format ('%s %s – %s %s', season[input.month], input.year, season[input.month2], input.year2);
					end
				else															-- season–season year range
					tCOinS_date.rftssn = season[input.month];					-- start of range season; keep this?
					tCOinS_date.rftchron = season[input.month] .. '–' .. season[input.month2];	-- season–season year range
				end
			end
		end
		tCOinS_date.rftdate = date;
		return;																	-- done
	end
	
	if 0 ~= input.day then
		date = string.format ('%s-%.2d-%.2d', input.year, tonumber(input.month), tonumber(input.day));	-- whole date
	elseif 0 ~= input.month then
		date = string.format ('%s-%.2d', input.year, tonumber(input.month));	-- year and month
	else
		date = string.format ('%s', input.year);								-- just year
	end

	if 0 ~= input.year2 then
		if 0 ~= input.day2 then
			date2 = string.format ('/%s-%.2d-%.2d', input.year2, tonumber(input.month2), tonumber(input.day2));		-- whole date
		elseif 0 ~= input.month2 then
			date2 = string.format ('/%s-%.2d', input.year2, tonumber(input.month2));	-- year and month
		else
			date2 = string.format ('/%s', input.year2);							-- just year
		end
	end
	
	tCOinS_date.rftdate = date .. date2;										-- date2 has the '/' separator
	return;
end


--[[--------------------------&lt; P A T T E R N S &gt;--------------------------------------------------------------

this is the list of patterns for date formats that this module recognizes.  Approximately the first half of these
patterns represent formats that might be reformatted into another format.  Those that might be reformatted have
'indicator' letters that identify the content of the matching capture: 'd' (day), 'm' (month), 'a' (anchor year),
'y' (year); second day, month, year have a '2' suffix.

These patterns are used for both date validation and for reformatting.  This table should not be moved to ~/Configuration
because changes to this table require changes to check_date() and to reformatter() and reformat_date()

]]

local patterns = {
	 																			-- year-initial numerical year-month-day
	['ymd'] = {'^(%d%d%d%d)%-(%d%d)%-(%d%d)$', 'y', 'm', 'd'},					
																				-- month-initial: month day, year
	['Mdy'] = {'^(%D-) +([1-9]%d?), +((%d%d%d%d?)%a?)$', 'm', 'd', 'a', 'y'},
																				-- month-initial day range: month day–day, year; days are separated by endash
	['Md-dy'] = {'^(%D-) +([1-9]%d?)[%-–]([1-9]%d?), +((%d%d%d%d)%a?)$', 'm', 'd', 'd2', 'a', 'y'},
																				-- day-initial: day month year
	['dMy'] = {'^([1-9]%d?) +(%D-) +((%d%d%d%d?)%a?)$', 'd', 'm', 'a', 'y'},
																				-- year-initial: year month day; day: 1 or 2 two digits, leading zero allowed; not supported at en.wiki
--	['yMd'] = {'^((%d%d%d%d?)%a?) +(%D-) +(%d%d?)$', 'a', 'y', 'm', 'd'},
																				-- day-range-initial: day–day month year; days are separated by endash
	['d-dMy'] = {'^([1-9]%d?)[%-–]([1-9]%d?) +(%D-) +((%d%d%d%d)%a?)$', 'd', 'd2', 'm', 'a', 'y'},
																				-- day initial month-day-range: day month - day month year; uses spaced endash
	['dM-dMy'] = {'^([1-9]%d?) +(%D-) +[%-–] +([1-9]%d?) +(%D-) +((%d%d%d%d)%a?)$', 'd', 'm', 'd2', 'm2', 'a', 'y'},
																				-- month initial month-day-range: month day – month day, year;  uses spaced endash
	['Md-Mdy'] = {'^(%D-) +([1-9]%d?) +[%-–] +(%D-) +([1-9]%d?), +((%d%d%d%d)%a?)$','m', 'd', 'm2', 'd2', 'a', 'y'},
																				-- day initial month-day-year-range: day month year - day month year; uses spaced endash
	['dMy-dMy'] = {'^([1-9]%d?) +(%D-) +(%d%d%d%d) +[%-–] +([1-9]%d?) +(%D-) +((%d%d%d%d)%a?)$', 'd', 'm', 'y', 'd2', 'm2', 'a', 'y2'},
																				-- month initial month-day-year-range: month day, year – month day, year;  uses spaced endash
	['Mdy-Mdy'] = {'^(%D-) +([1-9]%d?), +(%d%d%d%d) +[%-–] +(%D-) +([1-9]%d?), +((%d%d%d%d)%a?)$', 'm', 'd', 'y', 'm2', 'd2', 'a', 'y2'},

																				-- these date formats cannot be converted, per se, but month name can be rendered short or long
																				-- month/season year - month/season year; separated by spaced endash
	['My-My'] = {'^(%D-) +(%d%d%d%d) +[%-–] +(%D-) +((%d%d%d%d)%a?)$', 'm', 'y', 'm2', 'a', 'y2'},
																				-- month/season range year; months separated by endash
	['M-My'] = {'^(%D-)[%-–](%D-) +((%d%d%d%d)%a?)$', 'm', 'm2', 'a', 'y'},
																				-- month/season year or proper-name year
	['My'] = {'^([^%d–]-) +((%d%d%d%d)%a?)$', 'm', 'a', 'y'},					-- this way because endash is a member of %D; %D- will match January–March 2019 when it shouldn't
																				-- these date formats cannot be converted
	['Sy4-y2'] = {'^(%D-) +((%d%d)%d%d)[%-–]((%d%d)%a?)$'},						-- special case Winter/Summer year-year (YYYY-YY); year separated with unspaced endash
	['Sy-y'] = {'^(%D-) +(%d%d%d%d)[%-–]((%d%d%d%d)%a?)$'},						-- special case Winter/Summer year-year; year separated with unspaced endash
	['y-y'] = {'^(%d%d%d%d?)[%-–]((%d%d%d%d?)%a?)$'},							-- year range: YYY-YYY or YYY-YYYY or YYYY–YYYY; separated by unspaced endash; 100-9999
	['y4-y2'] = {'^((%d%d)%d%d)[%-–]((%d%d)%a?)$'},								-- year range: YYYY–YY; separated by unspaced endash
	['y'] = {'^((%d%d%d%d?)%a?)$'},												-- year; here accept either YYY or YYYY
	}


--[[--------------------------&lt; C H E C K _ D A T E &gt;----------------------------------------------------------

Check date format to see that it is one of the formats approved by WP:DATESNO or WP:DATERANGE. Exception: only
allowed range separator is endash.  Additionally, check the date to see that it is a real date: no 31 in 30-day
months; no 29 February when not a leap year.  Months, both long-form and three character abbreviations, and seasons
must be spelled correctly.  Future years beyond next year are not allowed.

If the date fails the format tests, this function returns false and does not return values for anchor_year and
COinS_date.  When this happens, the date parameter is used in the COinS metadata and the CITEREF identifier gets
its year from the year parameter if present otherwise CITEREF does not get a date value.

Inputs:
	date_string - date string from date-holding parameters (date, year, accessdate, embargo, archivedate, etc.)

Returns:
	false if date string is not a real date; else
	true, anchor_year, COinS_date
		anchor_year can be used in CITEREF anchors
		COinS_date is ISO 8601 format date; see make_COInS_date()

]]

local function check_date (date_string, tCOinS_date, test_accessdate)
	local year;			-- assume that year2, months, and days are not used;
	local year2=0;		-- second year in a year range
	local month=0;
	local month2=0;		-- second month in a month range
	local day=0;
	local day2=0;		-- second day in a day range
	local anchor_year;
	local coins_date;

	if date_string:match (patterns['ymd'][1]) then								-- year-initial numerical year month day format
		year, month, day=date_string:match (patterns['ymd'][1]);
		if 12 &lt; tonumber(month) or 1 &gt; tonumber(month) or 1582 &gt; tonumber(year) or 0 == tonumber(day) then return false; end	-- month or day number not valid or not Gregorian calendar
		anchor_year = year;
	
	elseif mw.ustring.match(date_string, patterns['Mdy'][1]) then				-- month-initial: month day, year
		month, day, anchor_year, year=mw.ustring.match(date_string, patterns['Mdy'][1]);
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months
				
	elseif mw.ustring.match(date_string, patterns['Md-dy'][1]) then				-- month-initial day range: month day–day, year; days are separated by endash
		month, day, day2, anchor_year, year=mw.ustring.match(date_string, patterns['Md-dy'][1]);
		if tonumber(day) &gt;= tonumber(day2) then return false; end				-- date range order is left to right: earlier to later; dates may not be the same;
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months
		month2=month;															-- for metadata
		year2=year;

	elseif mw.ustring.match(date_string, patterns['dMy'][1]) then				-- day-initial: day month year
		day, month, anchor_year, year=mw.ustring.match(date_string, patterns['dMy'][1]);
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months

--[[ NOT supported at en.wiki
	elseif mw.ustring.match(date_string, patterns['yMd'][1]) then				-- year-initial: year month day; day: 1 or 2 two digits, leading zero allowed
		anchor_year, year, month, day=mw.ustring.match(date_string, patterns['yMd'][1]);
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months
-- end NOT supported at en.wiki ]]

	elseif mw.ustring.match(date_string, patterns['d-dMy'][1]) then				-- day-range-initial: day–day month year; days are separated by endash
		day, day2, month, anchor_year, year=mw.ustring.match(date_string, patterns['d-dMy'][1]);
		if tonumber(day) &gt;= tonumber(day2) then return false; end				-- date range order is left to right: earlier to later; dates may not be the same;
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months
		month2=month;															-- for metadata
		year2=year;

	elseif mw.ustring.match(date_string, patterns['dM-dMy'][1]) then			-- day initial month-day-range: day month - day month year; uses spaced endash
		day, month, day2, month2, anchor_year, year=mw.ustring.match(date_string, patterns['dM-dMy'][1]);
		if (not is_valid_month_season_range(month, month2)) or not is_valid_year(year) then return false; end	-- date range order is left to right: earlier to later;
		month = get_month_number (month);										-- for metadata
		month2 = get_month_number (month2);
		year2=year;

	elseif mw.ustring.match(date_string, patterns['Md-Mdy'][1]) then			-- month initial month-day-range: month day – month day, year;  uses spaced endash
		month, day, month2, day2, anchor_year, year=mw.ustring.match(date_string, patterns['Md-Mdy'][1]);
		if (not is_valid_month_season_range(month, month2)) or not is_valid_year(year) then return false; end
		month = get_month_number (month);										-- for metadata
		month2 = get_month_number (month2);
		year2=year;

	elseif mw.ustring.match(date_string, patterns['dMy-dMy'][1]) then			-- day initial month-day-year-range: day month year - day month year; uses spaced endash
		day, month, year, day2, month2, anchor_year, year2=mw.ustring.match(date_string, patterns['dMy-dMy'][1]);
		if tonumber(year2) &lt;= tonumber(year) then return false; end				-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) or not is_valid_month_range_style(month, month2) then return false; end		-- year2 no more than one year in the future; months same style
		month = get_month_number (month);										-- for metadata
		month2 = get_month_number (month2);

	elseif mw.ustring.match(date_string, patterns['Mdy-Mdy'][1]) then			-- month initial month-day-year-range: month day, year – month day, year;  uses spaced endash
		month, day, year, month2, day2, anchor_year, year2=mw.ustring.match(date_string, patterns['Mdy-Mdy'][1]);
		if tonumber(year2) &lt;= tonumber(year) then return false; end				-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) or not is_valid_month_range_style(month, month2) then return false; end		-- year2 no more than one year in the future; months same style
		month = get_month_number (month);										-- for metadata
		month2 = get_month_number (month2);

	elseif mw.ustring.match(date_string, patterns['Sy4-y2'][1]) then			-- special case Winter/Summer year-year (YYYY-YY); year separated with unspaced endash
		local century;
		month, year, century, anchor_year, year2=mw.ustring.match(date_string, patterns['Sy4-y2'][1]);
		if 'Winter' ~= month and 'Summer' ~= month then return false end;		-- 'month' can only be Winter or Summer
		anchor_year=year..'–'..anchor_year;										-- assemble anchor_year from both years
		year2 = century..year2;													-- add the century to year2 for comparisons
		if 1 ~= tonumber(year2) - tonumber(year) then return false; end			-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year
		month = get_season_number (month);

	elseif mw.ustring.match(date_string, patterns['Sy-y'][1]) then				-- special case Winter/Summer year-year; year separated with unspaced endash
		month, year, anchor_year, year2=mw.ustring.match(date_string, patterns['Sy-y'][1]);
		if 'Winter' ~= month and 'Summer' ~= month then return false end;		-- 'month' can only be Winter or Summer
		anchor_year=year..'–'..anchor_year;										-- assemble anchor_year from both years
		if 1 ~= tonumber(year2) - tonumber(year) then return false; end			-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year
		month = get_season_number (month);										-- for metadata

	elseif mw.ustring.match(date_string, patterns['My-My'][1]) then				-- month/season year - month/season year; separated by spaced endash
		month, year, month2, anchor_year, year2=mw.ustring.match(date_string, patterns['My-My'][1]);
		anchor_year=year..'–'..anchor_year;										-- assemble anchor_year from both years
		if tonumber(year) &gt;= tonumber(year2) then return false; end				-- left to right, earlier to later, not the same
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year
		if 0 ~= get_month_number(month) and 0 ~= get_month_number(month2) and is_valid_month_range_style(month, month2) then 	-- both must be month year, same month style
			month = get_month_number(month);
			month2 = get_month_number(month2);
		elseif 0 ~= get_season_number(month) and 0 ~= get_season_number(month2) then	-- both must be or season year, not mixed
			month = get_season_number(month);
			month2 = get_season_number(month2);
		else
			 return false;
		end

	elseif mw.ustring.match(date_string, patterns['M-My'][1]) then				-- month/season range year; months separated by endash 
		month, month2, anchor_year, year=mw.ustring.match(date_string, patterns['M-My'][1]);
		if (not is_valid_month_season_range(month, month2)) or (not is_valid_year(year)) then return false; end
		if 0 ~= get_month_number(month) then									-- determined to be a valid range so just check this one to know if month or season
			month = get_month_number(month);
			month2 = get_month_number(month2);
		else
			month = get_season_number(month);
			month2 = get_season_number(month2);
		end
		year2=year;
		
	elseif mw.ustring.match(date_string, patterns['My'][1]) then				-- month/season year or proper-name year
		month, anchor_year, year=mw.ustring.match(date_string, patterns['My'][1]);
		if not is_valid_year(year) then return false; end
		if not is_valid_month_or_season (month) and 0 == is_proper_name (month) then return false; end
		if 0 ~= get_month_number(month) then									-- determined to be a valid range so just check this one to know if month or season
			month = get_month_number(month);
		elseif 0 ~= get_season_number(month) then
			month = get_season_number(month);
		else
			month = is_proper_name (month);										-- must be proper name; not supported in COinS
		end

	elseif mw.ustring.match(date_string, patterns['y-y'][1]) then				-- Year range: YYY-YYY or YYY-YYYY or YYYY–YYYY; separated by unspaced endash; 100-9999
		year, anchor_year, year2=mw.ustring.match(date_string, patterns['y-y'][1]);
		anchor_year=year..'–'..anchor_year;										-- assemble anchor year from both years
		if tonumber(year) &gt;= tonumber(year2) then return false; end				-- left to right, earlier to later, not the same
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year

	elseif mw.ustring.match(date_string, patterns['y4-y2'][1]) then				-- Year range: YYYY–YY; separated by unspaced endash
		local century;
		year, century, anchor_year, year2=mw.ustring.match(date_string, patterns['y4-y2'][1]);
		anchor_year=year..'–'..anchor_year;										-- assemble anchor year from both years
		if 13 &gt; tonumber(year2) then return false; end							-- don't allow 2003-05 which might be May 2003
		year2 = century..year2;													-- add the century to year2 for comparisons
		if tonumber(year) &gt;= tonumber(year2) then return false; end				-- left to right, earlier to later, not the same
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year

	elseif mw.ustring.match (date_string, patterns['y'][1]) then				-- year; here accept either YYY or YYYY
		anchor_year, year=mw.ustring.match (date_string, patterns['y'][1]);
		if false == is_valid_year(year) then
			return false;
		end

	else
		return false;															-- date format not one of the MOS:DATE approved formats
	end

	if test_accessdate then														-- test accessdate here because we have numerical date parts
		if 0 ~= year and 0 ~= month and 0 ~= day and 							-- all parts of a single date required
			0 == year2 and 0 == month2 and 0 == day2 then						-- none of these; accessdate must not be a range
				if not is_valid_accessdate (year..'-'..month..'-'..day) then	
					return false;												-- return false when accessdate out of bounds
				end
		else
			return false;														-- return false when accessdate is a range of two dates
		end
	end

	local result=true;															-- check whole dates for validity; assume true because not all dates will go through this test
	if 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 == month2 and 0 == day2 then		-- YMD (simple whole date)
		result=is_valid_date(year,month,day);

	elseif 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 == month2 and 0 ~= day2 then	-- YMD-d (day range)
		result=is_valid_date(year,month,day);
		result=result and is_valid_date(year,month,day2);

	elseif 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 ~= month2 and 0 ~= day2 then	-- YMD-md (day month range)
		result=is_valid_date(year,month,day);
		result=result and is_valid_date(year,month2,day2);

	elseif 0 ~= year and 0 ~= month and 0 ~= day and 0 ~= year2 and 0 ~= month2 and 0 ~= day2 then	-- YMD-ymd (day month year range)
		result=is_valid_date(year,month,day);
		result=result and is_valid_date(year2,month2,day2);
	end
	
	if false == result then return false; end

	if nil ~= tCOinS_date then													-- this table only passed into this function when testing |date= parameter values
		make_COinS_date ({year=year, month=month, day=day, year2=year2, month2=month2, day2=day2}, tCOinS_date);	-- make an ISO 8601 date string for COinS
	end
	
	return true, anchor_year;													-- format is good and date string represents a real date
end	


--[[--------------------------&lt; D A T E S &gt;--------------------------------------------------------------------

Cycle the date-holding parameters in passed table date_parameters_list through check_date() to check compliance with MOS:DATE. For all valid dates, check_date() returns
true. The |date= parameter test is unique, it is the only date holding parameter from which values for anchor_year (used in CITEREF identifiers) and COinS_date (used in
the COinS metadata) are derived.  The |date= parameter is the only date-holding parameter that is allowed to contain the no-date keywords "n.d." or "nd" (without quotes).

Unlike most error messages created in this module, only one error message is created by this function. Because all of the date holding parameters are processed serially,
a single error message is created as the dates are tested.

]]

local function dates(date_parameters_list, tCOinS_date)
	local anchor_year;		-- will return as nil if the date being tested is not |date=
	local COinS_date;		-- will return as nil if the date being tested is not |date=
	local embargo_date;															-- if embargo date is a good dmy, mdy, ymd date then holds original value else reset to 9999
	local error_message = "";
	local good_date = false;
	
	for k, v in pairs(date_parameters_list) do									-- for each date-holding parameter in the list
		if is_set(v.val) then													-- if the parameter has a value
			v.val = mw.ustring.gsub (v.val, '%d', cfg.date_names.local_digits);	-- translate 'local' digits to Western 0-9
			if v.val:match("^c%. [1-9]%d%d%d?%a?$") then						-- special case for c. year or with or without CITEREF disambiguator - only |date= and |year=
				local year = v.val:match("c%. ([1-9]%d%d%d?)%a?");				-- get the year portion so it can be tested
				if 'date'==k then
					anchor_year, COinS_date = v.val:match("((c%. [1-9]%d%d%d?)%a?)");	-- anchor year and COinS_date only from |date= parameter
					good_date = is_valid_year(year);
				elseif 'year'==k then
					good_date = is_valid_year(year);
				end
			elseif 'date'==k then												-- if the parameter is |date=
				if v.val:match("^n%.d%.%a?$") then								-- if |date=n.d. with or without a CITEREF disambiguator
					good_date, anchor_year, COinS_date = true, v.val:match("((n%.d%.)%a?)");	--"n.d."; no error when date parameter is set to no date
				elseif v.val:match("^nd%a?$") then								-- if |date=nd with or without a CITEREF disambiguator
					good_date, anchor_year, COinS_date = true, v.val:match("((nd)%a?)");	--"nd";	no error when date parameter is set to no date
				else
					good_date, anchor_year, COinS_date = check_date (v.val, tCOinS_date);	-- go test the date
				end
			elseif 'year'==k then												-- if the parameter is |year= it should hold only a year value
				if v.val:match("^[1-9]%d%d%d?%a?$") then						-- if |year= 3 or 4 digits only with or without a CITEREF disambiguator
					good_date, anchor_year, COinS_date = true, v.val:match("((%d+)%a?)");
				end
			elseif 'access-date'==k then										-- if the parameter is |date=
				good_date = check_date (v.val, nil, true);						-- go test the date; nil is a placeholder; true is the test_accessdate flag
			elseif 'embargo'==k then											-- if the parameter is |embargo=
				good_date = check_date (v.val);									-- go test the date
				if true == good_date then										-- if the date is a valid date
					good_date, embargo_date = is_valid_embargo_date (v.val);	-- is |embargo= date a single dmy, mdy, or ymd formatted date? yes:returns embargo; no: returns 9999
				end
			else																-- any other date-holding parameter
				good_date = check_date (v.val);									-- go test the date
			end
			if false==good_date then											-- assemble one error message so we don't add the tracking category multiple times
				if is_set(error_message) then									-- once we've added the first portion of the error message ...
					error_message=error_message .. ", ";						-- ... add a comma space separator
				end
				error_message=error_message .. "&amp;#124;" .. v.name .. "=";		-- add the failed parameter
			end
		end
	end
	return anchor_year, embargo_date, error_message;							-- and done
end


--[[--------------------------&lt; Y E A R _ D A T E _ C H E C K &gt;------------------------------------------------

Compare the value provided in |year= with the year value(s) provided in |date=.  This function returns a numeric value:
	0 - year value does not match the year value in date
	1 - (default) year value matches the year value in date or one of the year values when date contains two years
	2 - year value matches the year value in date when date is in the form YYYY-MM-DD and year is disambiguated (|year=YYYYx)

]]

local function year_date_check (year_string, date_string)
	local year;
	local date1;
	local date2;
	local result = 1;															-- result of the test; assume that the test passes
	
	year = year_string:match ('(%d%d%d%d?)');

	if date_string:match ('%d%d%d%d%-%d%d%-%d%d') and year_string:match ('%d%d%d%d%a') then	--special case where both date and year are required YYYY-MM-DD and YYYYx
		date1 = date_string:match ('(%d%d%d%d)');
		year = year_string:match ('(%d%d%d%d)');
		if year ~= date1 then
			result = 0;															-- years don't match
		else
			result = 2;															-- years match; but because disambiguated, don't add to maint cat
		end
		
	elseif date_string:match ("%d%d%d%d?.-%d%d%d%d?") then						-- any of the standard range formats of date with two three- or four-digit years
		date1, date2 = date_string:match ("(%d%d%d%d?).-(%d%d%d%d?)");
		if year ~= date1 and year ~= date2 then
			result = 0;
		end

	elseif mw.ustring.match(date_string, "%d%d%d%d[%-–]%d%d") then				-- YYYY-YY date ranges
		local century;
		date1, century, date2 = mw.ustring.match(date_string, "((%d%d)%d%d)[%-–]+(%d%d)");
		date2 = century..date2;													-- convert YY to YYYY
		if year ~= date1 and year ~= date2 then
			result = 0;
		end

	elseif date_string:match ("%d%d%d%d?") then									-- any of the standard formats of date with one year
		date1 = date_string:match ("(%d%d%d%d?)");
		if year ~= date1 then
			result = 0;
		end
	else
		result = 0;																-- no recognizable year in date
	end
	return result;
end


--[[--------------------------&lt; R E F O R M A T T E R &gt;--------------------------------------------------------

reformat 'date' into new format specified by format_param if pattern_idx (the current format of 'date') can be
reformatted.  Does the grunt work for reformat_dates().

The table re_formats maps patern_idx (current format) and format_param (desired format) to a table that holds:
	format string used by string.format()
	identifier letters ('d', 'm', 'y', 'd2', 'm2', 'y2') that serve as indexes into a table t{} that holds captures
		from mw.ustring.match() for the various date parts specified by  patterns[pattern_idx][1]

Items in patterns{} have the general form:
	['ymd'] = {'^(%d%d%d%d)%-(%d%d)%-(%d%d)$', 'y', 'm', 'd'}, where:
		['ymd'] is pattern_idx
		patterns['ymd'][1] is the match pattern with captures for mw.ustring.match()
		patterns['ymd'][2] is an indicator letter identifying the content of the first capture
		patterns['ymd'][3] ... the second capture etc

when a pattern matches a date, the captures are loaded into table t{} in capture order using the idemtifier
characters as indexes into t{}  For the above, a ymd date is in t{} as:
	t.y = first capture (year), t.m = second capture (month), t.d = third capture (day)

To reformat, this function is called with the pattern_idx that matches the current format of the date and with
format_param set to the desired format.  This function loads table t{} as described and then calls string.format()
with the format string specified by re_format[pattern_idx][format_param][1] using values taken from t{} according
to the capture identifier letters specified by patterns[pattern_idx][format_param][n] where n is 2..

]]

local re_formats = {
	['ymd'] = {																	-- date format is ymd; reformat to:
		['mdy'] = {'%s %s, %s', 'm', 'd', 'y'},									-- |df=mdy
		['dmy'] = {'%s %s %s', 'd', 'm', 'y'},									-- |df=dmy
--		['yMd'] = {'%s %s %s', 'y', 'm', 'd'},									-- |df=yMd; not supported at en.wiki
		},
	['Mdy'] = {																	-- date format is Mdy; reformat to:
		['mdy'] = {'%s %s, %s', 'm', 'd', 'y'},									-- for long/short reformatting
		['dmy'] = {'%s %s %s', 'd', 'm', 'y'},									-- |df=dmy
		['ymd'] = {'%s-%s-%s', 'y', 'm', 'd'},									-- |df=ymd
--		['yMd'] = {'%s %s %s', 'y', 'm', 'd'},									-- |df=yMd; not supported at en.wiki
		},
	['dMy'] = {																	-- date format is dMy; reformat to:
		['dmy'] = {'%s %s %s', 'd', 'm', 'y'},									-- for long/short reformatting
		['mdy'] = {'%s %s, %s', 'm', 'd', 'y'},									-- |df=mdy
		['ymd'] = {'%s-%s-%s', 'y', 'm', 'd'},									-- |df=ymd
--		['yMd'] = {'%s %s %s', 'y', 'm', 'd'},									-- |df=yMd; not supported at en.wiki
		},
	['Md-dy'] = {																-- date format is Md-dy; reformat to:
		['mdy'] = {'%s %s–%s, %s', 'm', 'd', 'd2', 'y'},						-- for long/short reformatting
		['dmy'] = {'%s–%s %s %s', 'd', 'd2', 'm', 'y'},							-- |df=dmy -&gt; d-dMy 
		},
	['d-dMy'] = {																-- date format is d-d&gt;y; reformat to:
		['dmy'] = {'%s–%s %s %s', 'd', 'd2', 'm', 'y'},							-- for long/short reformatting
		['mdy'] = {'%s %s–%s, %s', 'm', 'd', 'd2', 'y'},						-- |df=mdy -&gt; Md-dy 
		},
	['dM-dMy'] = {																-- date format is dM-dMy; reformat to:
		['dmy'] = {'%s %s – %s %s %s', 'd', 'm', 'd2', 'm2', 'y'},				-- for long/short reformatting
		['mdy'] = {'%s %s – %s %s, %s', 'm', 'd', 'm2', 'd2', 'y'},				-- |df=mdy -&gt; Md-Mdy 
		},
	['Md-Mdy'] = {																-- date format is Md-Mdy; reformat to:
		['mdy'] = {'%s %s – %s %s, %s', 'm', 'd',  'm2', 'd2', 'y'},			-- for long/short reformatting
		['dmy'] = {'%s %s – %s %s %s', 'd', 'm', 'd2', 'm2', 'y'},				-- |df=dmy -&gt; dM-dMy 
		},
	['dMy-dMy'] = {																-- date format is dMy-dMy; reformat to:
		['dmy'] = {'%s %s %s – %s %s %s', 'd', 'm', 'y', 'd2', 'm2', 'y2'},		-- for long/short reformatting
		['mdy'] = {'%s %s, %s – %s %s, %s', 'm', 'd', 'y', 'm2', 'd2', 'y2'},	-- |df=mdy -&gt; Mdy-Mdy 
		},
	['Mdy-Mdy'] = {																-- date format is Mdy-Mdy; reformat to:
		['mdy'] = {'%s %s, %s – %s %s, %s', 'm', 'd', 'y', 'm2', 'd2', 'y2'},	-- for long/short reformatting
		['dmy'] = {'%s %s %s – %s %s %s', 'd', 'm', 'y', 'd2', 'm2', 'y2'},		-- |df=dmy -&gt; dMy-dMy 
		},
	['My-My'] = {																-- these for long/short reformatting
		['any'] = {'%s %s – %s %s', 'm', 'y', 'm2', 'y2'},						-- dmy/mdy agnostic
		},
	['M-My'] = {																-- these for long/short reformatting
		['any'] = {'%s–%s %s', 'm', 'm2', 'y'},									-- dmy/mdy agnostic
		},
	['My'] = {																	-- these for long/short reformatting
		['any'] = {'%s %s', 'm', 'y'},											-- dmy/mdy agnostic
		},
--	['yMd'] = {																	-- not supported at en.wiki
--		['mdy'] = {'%s %s, %s', 'm', 'd', 'y'},									-- |df=mdy
--		['dmy'] = {'%s %s %s', 'd', 'm', 'y'},									-- |df=dmy
--		['ymd'] = {'%s-%s-%s', 'y', 'm', 'd'},									-- |df=ymd
--		},
	}


local function reformatter (date, pattern_idx, format_param, mon_len)
	if not in_array (pattern_idx, {'ymd', 'Mdy', 'Md-dy', 'dMy', 'yMd', 'd-dMy', 'dM-dMy', 'Md-Mdy', 'dMy-dMy', 'Mdy-Mdy', 'My-My', 'M-My', 'My'}) then
		return;																	-- not in this set of date format patterns then not a reformattable date
	end
	
	if 'ymd' == format_param and in_array (pattern_idx, {'ymd', 'Md-dy', 'd-dMy', 'dM-dMy', 'Md-Mdy', 'dMy-dMy', 'Mdy-Mdy', 'My-My', 'M-My', 'My'}) then
		return;																	-- ymd date ranges not supported at en.wiki; no point in reformatting ymd to ymd
	end

	if in_array (pattern_idx, {'My', 'M-My', 'My-My'}) then						-- these are not dmy/mdy so can't be 'reformatted' into either
		format_param = 'any';													-- so format-agnostic 
	end

--	if 'yMd' == format_param and in_array (pattern_idx, {'yMd', 'Md-dy', 'd-dMy', 'dM-dMy', 'Md-Mdy', 'dMy-dMy', 'Mdy-Mdy'}) then	-- not supported at en.wiki
	if 'yMd' == format_param then												-- not supported at en.wiki
		return;																	-- not a reformattable date
	end
	
	local c1, c2, c3, c4, c5, c6, c7;											-- these hold the captures specified in patterns[pattern_idx][1]
	c1, c2, c3, c4, c5, c6, c7 = mw.ustring.match (date, patterns[pattern_idx][1]);	-- get the captures

	local t = {																	-- table that holds k/v pairs of date parts from the captures and patterns[pattern_idx][2..]
		[patterns[pattern_idx][2]] = c1;										-- at minimum there is always one capture with a matching indicator letter
		[patterns[pattern_idx][3] or 'x'] = c2;									-- patterns can have a variable number of captures; each capture requires an indicator letter;
		[patterns[pattern_idx][4] or 'x'] = c3;									-- where there is no capture, there is no indicator letter so n in patterns[pattern_idx][n] will be nil;
		[patterns[pattern_idx][5] or 'x'] = c4;									-- the 'x' here spoofs an indicator letter to prevent 'table index is nil' error
		[patterns[pattern_idx][6] or 'x'] = c5;
		[patterns[pattern_idx][7] or 'x'] = c6;
		[patterns[pattern_idx][8] or 'x'] = c7;
		};

	if tonumber(t.m) then														-- if raw month is a number (converting from ymd)
		if 's' == mon_len then													-- if we are to use abbreviated month names
			t.m = cfg.date_names['inv_local_s'][tonumber(t.m)];					-- convert it to a month name
		else
			t.m = cfg.date_names['inv_local_l'][tonumber(t.m)];					-- convert it to a month name
		end
		t.d = t.d:gsub ('0(%d)', '%1');											-- strip leading '0' from day if present
	elseif 'ymd' == format_param then											-- when converting to ymd
		if 1582 &gt; tonumber(t.y) then											-- ymd format dates not allowed before 1582
			return;
		end
		t.m = string.format ('%02d', get_month_number (t.m));					-- make sure that month and day are two digits
		t.d = string.format ('%02d', t.d);
	elseif mon_len then															-- if mon_len is set to either 'short' or 'long'
		for _, mon in ipairs ({'m', 'm2'}) do									-- because there can be two month names, check both 
			if t[mon] then
				t[mon] = get_month_number (t[mon]);								-- get the month number for this month (is length agnostic)
				if 0 == t[mon] then return; end									-- seasons and named dates can't be converted
				t[mon] = (('s' == mon_len) and cfg.date_names['inv_local_s'][t[mon]]) or cfg.date_names['inv_local_l'][t[mon]];	-- fetch month name according to length
			end
		end
	end

	local new_date = string.format (re_formats[pattern_idx][format_param][1],	-- format string
		t[re_formats[pattern_idx][format_param][2]],							-- named captures from t{}
		t[re_formats[pattern_idx][format_param][3]],
		t[re_formats[pattern_idx][format_param][4]],
		t[re_formats[pattern_idx][format_param][5]],
		t[re_formats[pattern_idx][format_param][6]],
		t[re_formats[pattern_idx][format_param][7]],
		t[re_formats[pattern_idx][format_param][8]]
		);

	return new_date;
end


--[[-------------------------&lt; R E F O R M A T _ D A T E S &gt;--------------------------------------------------

Reformats existing dates into the format specified by format.

format is one of several manual keywords: dmy, dmy-all, mdy, mdy-all, ymd, ymd-all.  The -all version includes
access- and archive-dates; otherwise these dates are not reformatted.

This function allows automatic date formatting.  In ~/Configuration, the article source is searched for one of
the {{use xxx dates}} templates.  If found, xxx becomes the global date format as xxx-all.  If |cs1-dates= in
{{use xxx dates}} has legitimate value then that value determines how cs1|2 dates will be rendered.  Legitimate
values for |cs1-dates= are:
	l - all dates are rendered with long month names
	ls - publication dates use long month names; access-/archive-dates use abbreviated month names
	ly - publication dates use long month names; access-/archive-dates rendered in ymd format
	s - all dates are rendered with abbreviated (short) month names
	sy - publication dates use abbreviated month names; access-/archive-dates rendered in ymd format
	y - all dates are rendered in ymd format

the format argument for automatic date formatting will be the format specified by {{use xxx dates}} with the
value supplied by |cs1-dates so one of: xxx-l, xxx-ls, xxx-ly, xxx-s, xxx-sy, xxx-y, or simply xxx (|cs1-dates=
empty, omitted, or invalid) where xxx shall be either of dmy or mdy.

dates are extracted from date_parameters_list, reformatted (if appropriate), and then written back into the
list in the new format.  Dates in date_parameters_list are presumed here to be valid (no errors).  This function
returns true when a date has been reformatted, false else.  Actual reformatting is done by reformatter().

]]

local function reformat_dates (date_parameters_list, format)
	local all = false;															-- set to false to skip access- and archive-dates
	local len_p = 'l';															-- default publication date length shall be long
	local len_a = 'l';															-- default access-/archive-date length shall be long
	local result = false;
	local new_date;																
	
	if format:match('%a+%-all') then											-- manual df keyword; auto df keyword when length not specified in {{use xxx dates}}; 
		format = format:match('(%a+)%-all');									-- extract the format
		all = true;																-- all dates are long format dates because this keyword doesn't specify length
	elseif format:match('%a+%-[lsy][sy]?') then									-- auto df keywords; internal only
		all = true;																-- auto df applies to all dates; use length specified by capture len_p for all dates
		format, len_p, len_a = format:match('(%a+)%-([lsy])([sy]?)');			-- extract the format and length keywords
		if 'y' == len_p then													-- because allowed by MOS:DATEUNIFY (sort of) range dates and My dates not reformatted
			format = 'ymd';														-- override {{use xxx dates}}
		elseif (not is_set(len_a)) or (len_p == len_a) then						-- no access-/archive-date length specified or same length as publication dates then
			len_a = len_p;														-- in case len_a not set
		end
	end																			-- else only publication dates and they are long

	for param_name, param_val in pairs (date_parameters_list) do				-- for each date-holding parameter in the list
		if is_set (param_val.val) then											-- if the parameter has a value
			if not (not all and in_array (param_name, {'access-date', 'archive-date'})) then	-- skip access- or archive-date unless format is xxx-all; yeah, ugly; TODO: find a better way
				for pattern_idx, pattern in pairs (patterns) do
					if mw.ustring.match (param_val.val, pattern[1]) then
						if all and in_array (param_name, {'access-date', 'archive-date'}) then	-- if this date is an access- or archive-date
							new_date = reformatter (param_val.val, pattern_idx, (('y' == len_a) and 'ymd') or format, len_a);	-- choose ymd or dmy/mdy according to len_a setting
						else													-- all other dates
							new_date = reformatter (param_val.val, pattern_idx, format, len_p);
						end
						
						if new_date then										-- set when date was reformatted
							date_parameters_list[param_name].val = new_date;	-- update date in date list
							result = true;										-- and announce that changes have been made
						end
					end	-- if
				end		-- for
			end			-- if
		end				-- if
	end					-- for
return result;																	-- declare boolean result and done
end


--[[--------------------------&lt; D A T E _ H Y P H E N _ T O _ D A S H &gt;----------------------------------------

Loops through the list of date-holding parameters and converts any hyphen to an ndash.  Not called if the cs1|2
template has any date errors.

Modifies the date_parameters_list and returns true if hyphens are replaced, else returns false.

]]

local function date_hyphen_to_dash (date_parameters_list)
	local result = false;
	local n;
	for param_name, param_val in pairs(date_parameters_list) do					-- for each date-holding parameter in the list
		if is_set (param_val.val) then
			if not mw.ustring.match (param_val.val, '%d%d%d%d%-%d%d%-%d%d') then	-- for those that are not ymd dates (ustring because here digits may not be western)
				param_val.val, n = param_val.val:gsub ('%-', '–');				-- replace any hyphen with ndash
				if 0 ~= n then
					date_parameters_list[param_name].val = param_val.val;		-- update the list
					result = true;
				end
			end
		end
	end
	return result;																-- so we know if any hyphens were replaced
end


--[[-------------------------&lt; D A T E _ N A M E _ X L A T E &gt;------------------------------------------------

Attempts to translate English month names to local-language month names using names supplied by MediaWiki's
date parser function.  This is simple name-for-name replacement and may not work for all languages.

if xlat_dig is true, this function will also translate western (English) digits to the local language's digits.
This will also translate ymd dates.

]]

local function	date_name_xlate (date_parameters_list, xlt_dig)
	local xlate;
	local mode;																	-- long or short month names
	local modified = false;
	local date;
	
	for param_name, param_val in pairs(date_parameters_list) do					-- for each date-holding parameter in the list
		if is_set(param_val.val) then											-- if the parameter has a value
			date = param_val.val;
			for month in mw.ustring.gmatch (date, '%a+') do						-- iterate through all dates in the date (single date or date range)
				if cfg.date_names.en.long[month] then
					mode = 'F';													-- English name is long so use long local name
				elseif cfg.date_names.en.short[month] then
					mode = 'M';													-- English name is short so use short local name
				else
					mode = nil;													-- not an English month name; could be local language month name or an English season name
				end
		
				if mode then													-- might be a season
					xlate = lang_object:formatDate(mode, '1' .. month);			-- translate the month name to this local language
					date = mw.ustring.gsub (date, month, xlate);				-- replace the English with the translation
					date_parameters_list[param_name].val = date;				-- save the translated date
					modified = true;
				end
			end

			if xlt_dig then														-- shall we also translate digits?
				date = date:gsub ('%d', cfg.date_names.xlate_digits);			-- translate digits from western to 'local digits'
				date_parameters_list[param_name].val = date;					-- save the translated date
				modified = true;
			end
		end
	end
	
	return modified;
	end


--[[--------------------------&lt; S E T _ S E L E C T E D _ M O D U L E S &gt;--------------------------------------

Sets local imported functions table to same (live or sandbox) as that used by the other modules.

]]

local function set_selected_modules (cfg_table_ptr, utilities_page_ptr)
	is_set = utilities_page_ptr.is_set;											-- import functions from selected Module:Citation/CS1/Utilities module
	in_array = utilities_page_ptr.in_array;										-- import functions from selected Module:Citation/CS1/Utilities module
	cfg = cfg_table_ptr;														-- import tables from selected Module:Citation/CS1/Configuration
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {																		-- return exported functions
	dates = dates,
	year_date_check = year_date_check,
	reformat_dates = reformat_dates,
	date_hyphen_to_dash = date_hyphen_to_dash,
	date_name_xlate = date_name_xlate,
	set_selected_modules = set_selected_modules
	}</text>
      <sha1>2ksocezo4158y8wxm8kabhtrvrzutja</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Identifiers</title>
    <ns>828</ns>
    <id>48812124</id>
    <revision>
      <id>951753347</id>
      <parentid>951705298</parentid>
      <timestamp>2020-04-18T18:14:50Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>biorxiv cat fix?</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="61119" xml:space="preserve">
--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local is_set, in_array, set_error, select_one, add_maint_cat, substitute, make_wikilink;	-- functions in Module:Citation/CS1/Utilities

local z;																		-- table of tables defined in Module:Citation/CS1/Utilities

local cfg;																		-- table of configuration tables that are defined in Module:Citation/CS1/Configuration


--============================&lt;&lt; H E L P E R   F U N C T I O N S &gt;&gt;============================================

--[[--------------------------&lt; W I K I D A T A _ A R T I C L E _ N A M E _ G E T &gt;----------------------------

as an aid to internationalizing identifier-label wikilinks, gets identifier article names from wikidata.

returns :&lt;lang code&gt;:&lt;article title&gt; when &lt;q&gt; has an &lt;article title&gt; for &lt;lang code&gt;; nil else

for identifiers that do not have q, returns nil

for wikis that do not have mw.wikibase installed, returns nil

The call to mw.wikibase.getEntity() bumps the expensive parser function count

]]

local function wikidata_article_name_get (q)
	if not is_set (q) or (q and not mw.wikibase) then							-- when no q number or when a q number but mw.wikibase not installed on this wiki
		return nil;																-- abandon
	end

	local wd_article;
	local this_wiki_code = cfg.this_wiki_code;									-- wikipedia subdomain; 'en' for en.wikipedia.org

	wd_article = mw.wikibase.getEntity (q):getSitelink (this_wiki_code .. 'wiki');	-- fetch article title from wd; nil when no title available at this wiki; bumps expensive parser function count

	if wd_article then
		wd_article = table.concat ({':', this_wiki_code, ':', wd_article});		-- interwiki-style link without brackets if taken from wd; leading colon required
	end

	return wd_article;															-- article title from wd; nil else
end


--[[--------------------------&lt; E X T E R N A L _ L I N K _ I D &gt;----------------------------------------------

Formats a wiki style external link

]]

local function external_link_id(options)
	local url_string = options.id;
	local ext_link;
	local this_wiki_code = cfg.this_wiki_code;									-- wikipedia subdomain; 'en' for en.wikipedia.org
	local wd_article;															-- article title from wikidata
	
	if options.encode == true or options.encode == nil then
		url_string = mw.uri.encode( url_string );
	end

	ext_link = mw.ustring.format ('[%s%s%s %s]', options.prefix, url_string, options.suffix or "", mw.text.nowiki(options.id));
	if is_set(options.access) then
		ext_link = substitute (cfg.presentation['ext-link-access-signal'], {cfg.presentation[options.access].class, cfg.presentation[options.access].title, ext_link});	-- add the free-to-read / paywall lock
	end

	if not (cfg.use_identifier_redirects and is_set (options.redirect)) then	-- redirect has priority so if enabled and available don't fetch from wikidata because expensive
		wd_article = wikidata_article_name_get (options.q);						-- if wikidata has an article title for this wiki, get it;
	end
	
	local label_link = (cfg.use_identifier_redirects and is_set (options.redirect) and options.redirect) or wd_article or options.link;

	return table.concat	({
		make_wikilink (label_link, options.label),								-- redirect, wikidata link, or locally specified link (in that order)
		options.separator or '&amp;nbsp;',
		ext_link
		});
end


--[[--------------------------&lt; I N T E R N A L _ L I N K _ I D &gt;----------------------------------------------

Formats a wiki style internal link

]]

local function internal_link_id(options)
	local id = mw.ustring.gsub (options.id, '%d', cfg.date_names.local_digits);	-- translate 'local' digits to Western 0-9

	if not (cfg.use_identifier_redirects and is_set (options.redirect)) then	-- redirect has priority so if enabled and available don't fetch from wikidata because expensive
		wd_article = wikidata_article_name_get (options.q);						-- if wikidata has an article title for this wiki, get it;
	end

	local label_link = (cfg.use_identifier_redirects and is_set (options.redirect) and options.redirect) or wd_article or options.link;

	return table.concat (
		{
		make_wikilink (label_link, options.label),								-- wiki link the identifier label
		options.separator or '&amp;nbsp;',											-- add the separator
		make_wikilink (
			table.concat (
				{
				options.prefix,
				id,																-- translated to western digits
				options.suffix or ''
				}),
			substitute (cfg.presentation['bdi'], {'', mw.text.nowiki (options.id)})	-- bdi tags to prevent Latn script identifiers from being reversed at rtl language wikis
			);																	-- nowiki because MediaWiki still has magic links for ISBN and the like; TODO: is it really required?
		});
end


--[[--------------------------&lt; I S _ E M B A R G O E D &gt;------------------------------------------------------

Determines if a PMC identifier's online version is embargoed. Compares the date in |embargo= against today's date.  If embargo date is
in the future, returns the content of |embargo=; otherwise, returns and empty string because the embargo has expired or because
|embargo= was not set in this cite.

]]

local function is_embargoed (embargo)
	if is_set (embargo) then
		local lang = mw.getContentLanguage();
		local good1, embargo_date, good2, todays_date;
		good1, embargo_date = pcall( lang.formatDate, lang, 'U', embargo );
		good2, todays_date = pcall( lang.formatDate, lang, 'U' );
	
		if good1 and good2 then													-- if embargo date and today's date are good dates
			if tonumber( embargo_date ) &gt;= tonumber( todays_date ) then			-- is embargo date is in the future?
				return embargo;													-- still embargoed
			else
				add_maint_cat ('embargo')
				return '';														-- unset because embargo has expired
			end
		end
	end
	return '';																	-- |embargo= not set return empty string
end


--[=[-------------------------&lt; I S _ V A L I D _ B I O R X I V _ D A T E &gt;------------------------------------

returns true if:
	2019-12-11T00:00Z &lt;= biorxiv_date &lt; today + 2 days
	
The dated form of biorxiv identifier has a start date of 2019-12-11.  The unix timestamp for that date is {{#time:U|2019-12-11}} = 1576022400

biorxiv_date is the date provided in those |biorxiv= parameter values that are dated at time 00:00:00 UTC
today is the current date at time 00:00:00 UTC plus 48 hours
	if today is 2015-01-01T00:00:00 then
		adding 24 hours gives 2015-01-02T00:00:00 – one second more than today
		adding 24 hours gives 2015-01-03T00:00:00 – one second more than tomorrow

This function does not work if it is fed month names for languages other than English.  Wikimedia #time: parser
apparently doesn't understand non-Engish date month names. This function will always return false when the date
contains a non-English month name because good1 is false after the call to lang.formatDate().  To get around that
call this function with YYYY-MM-DD format dates.

]=]

local function is_valid_biorxiv_date (biorxiv_date)
	local good1, good2;
	local biorxiv_ts, tomorrow_ts;												-- to hold unix time stamps representing the dates
	local lang_object = mw.getContentLanguage();

	good1, biorxiv_ts = pcall (lang_object.formatDate, lang_object, 'U', biorxiv_date );		-- convert biorxiv_date value to unix timesatmp 
	good2, tomorrow_ts = pcall (lang_object.formatDate, lang_object, 'U', 'today + 2 days' );	-- today midnight + 2 days is one second more than all day tomorrow
	
	if good1 and good2 then														-- lang.formatDate() returns a timestamp in the local script which which tonumber() may not understand
		biorxiv_ts = tonumber (biorxiv_ts) or lang_object:parseFormattedNumber (biorxiv_ts);	-- convert to numbers for the comparison;
		tomorrow_ts = tonumber (tomorrow_ts) or lang_object:parseFormattedNumber (tomorrow_ts);
	else
		return false;															-- one or both failed to convert to unix time stamp
	end

	return ((1576022400 &lt;= biorxiv_ts) and (biorxiv_ts &lt; tomorrow_ts))			-- 2012-12-11T00:00Z &lt;= biorxiv_date &lt; tomorrow's date
end


--[[--------------------------&lt; IS _ V A L I D _ I S X N &gt;-----------------------------------------------------

ISBN-10 and ISSN validator code calculates checksum across all isbn/issn digits including the check digit.
ISBN-13 is checked in isbn().

If the number is valid the result will be 0. Before calling this function, issbn/issn must be checked for length
and stripped of dashes, spaces and other non-isxn characters.

]]

local function is_valid_isxn (isxn_str, len)
	local temp = 0;
	isxn_str = { isxn_str:byte(1, len) };										-- make a table of byte values '0' → 0x30 .. '9' → 0x39, 'X' → 0x58
	len = len+1;																-- adjust to be a loop counter
	for i, v in ipairs( isxn_str ) do											-- loop through all of the bytes and calculate the checksum
		if v == string.byte( "X" ) then											-- if checkdigit is X (compares the byte value of 'X' which is 0x58)
			temp = temp + 10*( len - i );										-- it represents 10 decimal
		else
			temp = temp + tonumber( string.char(v) )*(len-i);
		end
	end
	return temp % 11 == 0;														-- returns true if calculation result is zero
end


--[[--------------------------&lt; IS _ V A L I D _ I S X N _ 1 3 &gt;-----------------------------------------------

ISBN-13 and ISMN validator code calculates checksum across all 13 isbn/ismn digits including the check digit.
If the number is valid, the result will be 0. Before calling this function, isbn-13/ismn must be checked for length
and stripped of dashes, spaces and other non-isxn-13 characters.

]]

local function is_valid_isxn_13 (isxn_str)
	local temp=0;
	
	isxn_str = { isxn_str:byte(1, 13) };										-- make a table of byte values '0' → 0x30 .. '9' → 0x39
	for i, v in ipairs( isxn_str ) do
		temp = temp + (3 - 2*(i % 2)) * tonumber( string.char(v) );				-- multiply odd index digits by 1, even index digits by 3 and sum; includes check digit
	end
	return temp % 10 == 0;														-- sum modulo 10 is zero when isbn-13/ismn is correct
end


--[[--------------------------&lt; N O R M A L I Z E _ L C C N &gt;--------------------------------------------------

lccn normalization (http://www.loc.gov/marc/lccn-namespace.html#normalization)
1. Remove all blanks.
2. If there is a forward slash (/) in the string, remove it, and remove all characters to the right of the forward slash.
3. If there is a hyphen in the string:
	a. Remove it.
	b. Inspect the substring following (to the right of) the (removed) hyphen. Then (and assuming that steps 1 and 2 have been carried out):
		1. All these characters should be digits, and there should be six or less. (not done in this function)
		2. If the length of the substring is less than 6, left-fill the substring with zeroes until the length is six.

Returns a normalized lccn for lccn() to validate.  There is no error checking (step 3.b.1) performed in this function.
]]

local function normalize_lccn (lccn)
	lccn = lccn:gsub ("%s", "");									-- 1. strip whitespace

	if nil ~= string.find (lccn,'/') then
		lccn = lccn:match ("(.-)/");								-- 2. remove forward slash and all character to the right of it
	end

	local prefix
	local suffix
	prefix, suffix = lccn:match ("(.+)%-(.+)");						-- 3.a remove hyphen by splitting the string into prefix and suffix

	if nil ~= suffix then											-- if there was a hyphen
		suffix=string.rep("0", 6-string.len (suffix)) .. suffix;	-- 3.b.2 left fill the suffix with 0s if suffix length less than 6
		lccn=prefix..suffix;										-- reassemble the lccn
	end
	
	return lccn;
	end

--============================&lt;&lt; I D E N T I F I E R   F U N C T I O N S &gt;&gt;====================================

--[[--------------------------&lt; A R X I V &gt;--------------------------------------------------------------------

See: http://arxiv.org/help/arxiv_identifier

format and error check arXiv identifier.  There are three valid forms of the identifier:
the first form, valid only between date codes 9108 and 0703 is:
	arXiv:&lt;archive&gt;.&lt;class&gt;/&lt;date code&gt;&lt;number&gt;&lt;version&gt;
where:
	&lt;archive&gt; is a string of alpha characters - may be hyphenated; no other punctuation
	&lt;class&gt; is a string of alpha characters - may be hyphenated; no other punctuation; not the same as |class= parameter which is not supported in this form
	&lt;date code&gt; is four digits in the form YYMM where YY is the last two digits of the four-digit year and MM is the month number January = 01
		first digit of YY for this form can only 9 and 0
	&lt;number&gt; is a three-digit number
	&lt;version&gt; is a 1 or more digit number preceded with a lowercase v; no spaces (undocumented)
	
the second form, valid from April 2007 through December 2014 is:
	arXiv:&lt;date code&gt;.&lt;number&gt;&lt;version&gt;
where:
	&lt;date code&gt; is four digits in the form YYMM where YY is the last two digits of the four-digit year and MM is the month number January = 01
	&lt;number&gt; is a four-digit number
	&lt;version&gt; is a 1 or more digit number preceded with a lowercase v; no spaces

the third form, valid from January 2015 is:
	arXiv:&lt;date code&gt;.&lt;number&gt;&lt;version&gt;
where:
	&lt;date code&gt; and &lt;version&gt; are as defined for 0704-1412
	&lt;number&gt; is a five-digit number
]]

local function arxiv (id, class)
	local handler = cfg.id_handlers['ARXIV'];
	local year, month, version;
	local err_cat = false;														-- assume no error message
	local text;																	-- output text
	
	if id:match("^%a[%a%.%-]+/[90]%d[01]%d%d%d%d$") or id:match("^%a[%a%.%-]+/[90]%d[01]%d%d%d%dv%d+$") then	-- test for the 9108-0703 format w/ &amp; w/o version
		year, month = id:match("^%a[%a%.%-]+/([90]%d)([01]%d)%d%d%d[v%d]*$");
		year = tonumber(year);
		month = tonumber(month);
		if ((not (90 &lt; year or 8 &gt; year)) or (1 &gt; month or 12 &lt; month)) or		-- if invalid year or invalid month
			((91 == year and 7 &gt; month) or (7 == year and 3 &lt; month)) then		-- if years ok, are starting and ending months ok?
				err_cat = true;													-- flag for error message
		end

	elseif id:match("^%d%d[01]%d%.%d%d%d%d$") or id:match("^%d%d[01]%d%.%d%d%d%dv%d+$") then	-- test for the 0704-1412 w/ &amp; w/o version
		year, month = id:match("^(%d%d)([01]%d)%.%d%d%d%d[v%d]*$");
		year = tonumber(year);
		month = tonumber(month);
		if ((7 &gt; year) or (14 &lt; year) or (1 &gt; month or 12 &lt; month)) or			-- is year invalid or is month invalid? (doesn't test for future years)
			((7 == year) and (4 &gt; month)) then --or									-- when year is 07, is month invalid (before April)?
				err_cat = true;													-- flag for error message
		end

	elseif id:match("^%d%d[01]%d%.%d%d%d%d%d$") or id:match("^%d%d[01]%d%.%d%d%d%d%dv%d+$") then	-- test for the 1501- format w/ &amp; w/o version
		year, month = id:match("^(%d%d)([01]%d)%.%d%d%d%d%d[v%d]*$");
		year = tonumber(year);
		month = tonumber(month);
		if ((15 &gt; year) or (1 &gt; month or 12 &lt; month)) then						-- is year invalid or is month invalid? (doesn't test for future years)
				err_cat = true;													-- flag for error message
		end

	else
		err_cat = true;															-- not a recognized format; flag for error message
	end

	err_cat = err_cat and table.concat ({' ', set_error ('bad_arxiv')}) or '';	-- set error message if flag is true
	
	text = external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
			prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode, access=handler.access}) .. err_cat;

	if is_set (class) then
		if id:match ('^%d+') then
			text = table.concat ({text, ' [[//arxiv.org/archive/', class, ' ', class, ']]'});	-- external link within square brackets, not wikilink
		else
			text = table.concat ({text, ' ', set_error ('class_ignored')});		
		end
	end

	return text;	
end


--[[--------------------------&lt; B I B C O D E &gt;--------------------------------------------------------------------

Validates (sort of) and formats a bibcode id.

Format for bibcodes is specified here: http://adsabs.harvard.edu/abs_doc/help_pages/data.html#bibcodes

But, this: 2015arXiv151206696F is apparently valid so apparently, the only things that really matter are length, 19 characters
and first four digits must be a year.  This function makes these tests:
	length must be 19 characters
	characters in position
		1–4 must be digits and must represent a year in the range of 1000 – next year
		5 must be a letter
		6–8 must be letter, digit, ampersand, or dot (ampersand cannot directly precede a dot; &amp;. )
		9–18 must be letter, digit, or dot
		19 must be a letter or dot

]]

local function bibcode (id, access)
	local handler = cfg.id_handlers['BIBCODE'];
	local err_type;
	local year;

	local text = external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
		prefix=handler.prefix, id=id, separator=handler.separator, encode=handler.encode,
		access=access});
	
	if 19 ~= id:len() then
		err_type = cfg.err_msg_supl.length;
	else
		year = id:match ("^(%d%d%d%d)[%a][%w&amp;%.][%w&amp;%.][%w&amp;%.][%w.]+[%a%.]$")	-- 
		if not year then														-- if nil then no pattern match
			err_type = cfg.err_msg_supl.value;													-- so value error
		else
			local next_year = tonumber(os.date ('%Y'))+1;						-- get the current year as a number and add one for next year
			year = tonumber (year);												-- convert year portion of bibcode to a number
			if (1000 &gt; year) or (year &gt; next_year) then
				err_type = cfg.err_msg_supl.year;												-- year out of bounds
			end
			if id:find('&amp;%.') then
				err_type = cfg.err_msg_supl.journal;											-- journal abbreviation must not have '&amp;.' (if it does its missing a letter)
			end
		end
	end

	if is_set (err_type) then													-- if there was an error detected
		text = text .. ' ' .. set_error( 'bad_bibcode', {err_type});
	end
	return text;
end


--[[--------------------------&lt; B I O R X I V &gt;-----------------------------------------------------------------

Format bioRxiv id and do simple error checking.  Before 2019-12-11, biorXiv ids were 10.1101/ followed by exactly
6 digits.  After 2019-12-11, biorXiv ids retained the six-digit identifier but prefixed that with a yyyy.mm.dd. 
date and suffixed with an optional version identifier.

The bioRxiv id is the string of characters:
	https://doi.org/10.1101/078733 -&gt; 10.1101/078733
or a date followed by a six-digit number followed by an optional version indicator 'v' and one or more digits:
	https://www.biorxiv.org/content/10.1101/2019.12.11.123456v2 -&gt; 10.1101/2019.12.11.123456v2
	
see https://www.biorxiv.org/about-biorxiv

]]

local function biorxiv(id)
	local handler = cfg.id_handlers['BIORXIV'];
	local err_cat = true;														-- flag; assume that there will be an error
	
	local patterns = {
		'^10.1101/%d%d%d%d%d%d$',												-- simple 6-digit identifier (before 2019-12-11)
		'^10.1101/(20[1-9]%d)%.([01]%d)%.([0-3]%d)%.%d%d%d%d%d%dv%d+$',			-- y.m.d. date + 6-digit identifier + version (after 2019-12-11)
		'^10.1101/(20[1-9]%d)%.([01]%d)%.([0-3]%d)%.%d%d%d%d%d%d$',				-- y.m.d. date + 6-digit identifier (after 2019-12-11)
	}
	
	for _, pattern in ipairs (patterns) do										-- spin through the patterns looking for a match
		if id:match (pattern) then
			local y, m, d = id:match (pattern);									-- found a match, attempt to get year, month and date from the identifier

			if m then															-- m is nil when id is the six-digit form
				if not is_valid_biorxiv_date (y .. '-' .. m .. '-' .. d) then	-- validate the encoded date; TODO: don't ignore leapyear and actual month lengths ({{#time:}} is a poor date validator)
					break;														-- date fail; break out early so we don't unset the error message
				end
			end
			err_cat = nil;														-- we found a match so unset the error message
			break;																-- and done
		end
	end																			-- err_cat remains set here when no match

	return external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
			prefix=handler.prefix,id=id,separator=handler.separator,
			encode=handler.encode, access=handler.access}) .. (err_cat and (' ' .. set_error( 'bad_biorxiv')) or '');
end


--[[--------------------------&lt; C I T E S E E R X &gt;------------------------------------------------------------

CiteSeerX use their own notion of "doi" (not to be confused with the identifiers resolved via doi.org).

The description of the structure of this identifier can be found at Help_talk:Citation_Style_1/Archive_26#CiteSeerX_id_structure
]]

local function citeseerx (id)
	local handler = cfg.id_handlers['CITESEERX'];
	local matched;
	
	local text = external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
		prefix=handler.prefix, id=id, separator=handler.separator, encode=handler.encode,
		access=handler.access});
	
	matched = id:match ("^10%.1%.1%.[1-9]%d?%d?%d?%.[1-9]%d?%d?%d?$");
	if not matched then
		text = text .. ' ' .. set_error( 'bad_citeseerx' );
	end
	return text;
end


--[[--------------------------&lt; D O I &gt;------------------------------------------------------------------------

Formats a DOI and checks for DOI errors.

DOI names contain two parts: prefix and suffix separated by a forward slash.
	Prefix: directory indicator '10.' followed by a registrant code
	Suffix: character string of any length chosen by the registrant

This function checks a DOI name for: prefix/suffix.  If the doi name contains spaces or endashes, or, if it ends
with a period or a comma, this function will emit a bad_doi error message.

DOI names are case-insensitive and can incorporate any printable Unicode characters so the test for spaces, endash,
and terminal punctuation may not be technically correct but it appears, that in practice these characters are rarely
if ever used in doi names.

]]

local function doi(id, inactive, access)
	local cat = ""
	local handler = cfg.id_handlers['DOI'];
	
	local text;
	if is_set(inactive) then
		local inactive_year = inactive:match("%d%d%d%d") or '';					-- try to get the year portion from the inactive date
		local inactive_month, good;

		if is_set (inactive_year) then
			if 4 &lt; inactive:len() then											-- inactive date has more than just a year (could be anything)
				local lang_obj = mw.getContentLanguage();						-- get a language object for this wiki
				good, inactive_month = pcall (lang_obj.formatDate, lang_obj, 'F', inactive);	-- try to get the month name from the inactive date
				if not good then
					inactive_month = nil;										-- something went wrong so make sure this is unset
				end
			end
		else
			inactive_year = nil;												-- |doi-broken= has something but it isn't a date
		end
		
		if is_set(inactive_year) and is_set (inactive_month) then
			table.insert( z.error_categories, 'Pages with DOIs inactive as of ' .. inactive_year .. ' ' .. inactive_month);	-- use inactive month in category name
		elseif is_set(inactive_year) then
			table.insert( z.error_categories, 'Pages with DOIs inactive as of ' .. inactive_year);
		else
			table.insert( z.error_categories, 'Pages with inactive DOIs');		-- when inactive doesn't contain a recognizable date
		end
		inactive = " (" .. cfg.messages['inactive'] .. ' ' .. inactive .. ')';
	end

	text = external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
		prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode, access=access}) .. (inactive or '')

	local registrant = id:match ('^10%.([^/]+)/[^%s–]-[^%.,]$');				-- registrant set when doi has the proper basic form
	
	registrant_err_patterns = {													-- these patterns are for code ranges that are not supported 
		'^[^1-3]%d%d%d%d%.%d%d*$',												-- 5 digits with subcode (0xxxx, 40000+); accecpts: 10000–39999
		'^[^1-3]%d%d%d%d$',														-- 5 digits without subcode (0xxxx, 40000+); accecpts: 10000–39999
		'^[^1-9]%d%d%d%.%d%d*$',												-- 4 digits with subcode (0xxx); accecpts: 1000–9999
		'^[^1-9]%d%d%d$',														-- 4 digits without subcode (0xxx); accecpts: 1000–9999
		'^%d%d%d%d%d%d+',														-- 6 or more digits
		'^%d%d?%d?$',															-- less than 4 digits without subcode (with subcode is legitimate)
		'^5555$',																-- test registrant will never resolve
		'%s',																	-- any space character in registrant
		}
	
	if registrant then															-- when doi has proper form
		for i, pattern in ipairs (registrant_err_patterns) do					-- spin through error patterns
			if registrant:match (pattern) then									-- to validate registrant codes
				cat = ' ' .. set_error ('bad_doi');								-- when found, mark this doi as bad
				break;															-- and done
			end
		end
	else
		cat = ' ' .. set_error ('bad_doi');										-- invalid directory or malformed
	end

	return text .. cat 
end


--[[--------------------------&lt; H D L &gt;------------------------------------------------------------------------

Formats an HDL with minor error checking.

HDL names contain two parts: prefix and suffix separated by a forward slash.
	Prefix: character string using any character in the UCS-2 character set except '/'
	Suffix: character string of any length using any character in the UCS-2 character set chosen by the registrant

This function checks a HDL name for: prefix/suffix.  If the HDL name contains spaces, endashes, or, if it ends
with a period or a comma, this function will emit a bad_hdl error message.

HDL names are case-insensitive and can incorporate any printable Unicode characters so the test for endashes and
terminal punctuation may not be technically correct but it appears, that in practice these characters are rarely
if ever used in HDLs.

Query string parameters are named here: http://www.handle.net/proxy_servlet.html.  query strings are not displayed
but since '?' is anallowed character in an hdl, '?' followed by one of the query parameters is the only way we
have to detect the query string so that it isn't url encoded with the rest of the identifier.

]]

local function hdl(id, access)
	local handler = cfg.id_handlers['HDL'];
	local query_params = {														-- list of known query parameters from http://www.handle.net/proxy_servlet.html
		'noredirect',
		'ignore_aliases',
		'auth',
		'cert',
		'index',
		'type',
		'urlappend',
		'locatt',
		'action',
		}
	
	local hdl, suffix, param = id:match ('(.-)(%?(%a+).+)$');					-- look for query string
	local found;

	if hdl then																	-- when there are query strings, this is the handle identifier portion
		for _, q in ipairs (query_params) do									-- spin through the list of query parameters
			if param:match ('^' .. q) then										-- if the query string begins with one of the parameters
				found = true;													-- announce a find
				break;															-- and stop looking
			end
		end
	end

	if found then
		id = hdl;																-- found so replace id with the handle portion; this will be url encoded, suffix will not
	else
		suffix = '';															-- make sure suffix is empty string for concatenation else
	end

	local text = external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
			prefix=handler.prefix, id=id, suffix=suffix, separator=handler.separator, encode=handler.encode, access=access})

	if nil == id:match("^[^%s–]-/[^%s–]-[^%.,]$") then							-- hdl must contain a fwd slash, must not contain spaces, endashes, and must not end with period or comma
		text = text .. ' ' .. set_error( 'bad_hdl' );
	end
	return text;
end


--[[--------------------------&lt; I S B N &gt;----------------------------------------------------------------------

Determines whether an ISBN string is valid

]]

local function isbn( isbn_str )
	if nil ~= isbn_str:match("[^%s-0-9X]") then
		return false, cfg.err_msg_supl.char;									-- fail if isbn_str contains anything but digits, hyphens, or the uppercase X
	end
	isbn_str = isbn_str:gsub( "-", "" ):gsub( " ", "" );						-- remove hyphens and spaces
	local len = isbn_str:len();
 
	if len ~= 10 and len ~= 13 then
		return false, cfg.err_msg_supl.length;									-- fail if incorrect length
	end

	if len == 10 then
		if isbn_str:match( "^%d*X?$" ) == nil then								-- fail if isbn_str has 'X' anywhere but last position
			return false, cfg.err_msg_supl.form;									
		end
		return is_valid_isxn(isbn_str, 10), cfg.err_msg_supl.check;
	else
		if isbn_str:match( "^%d+$" ) == nil then
			return false, cfg.err_msg_supl.char;								-- fail if isbn13 is not all digits
		end
		if isbn_str:match( "^97[89]%d*$" ) == nil then
			return false, cfg.err_msg_supl.prefix;								-- fail when isbn13 does not begin with 978 or 979
		end
		if isbn_str:match ('^9790') then
			return false, cfg.err_msg_supl.group;								-- group identifier '0' is reserved to ismn
		end
		return is_valid_isxn_13 (isbn_str), cfg.err_msg_supl.check;
	end
end


--[[--------------------------&lt; A M A Z O N &gt;------------------------------------------------------------------

Formats a link to Amazon.  Do simple error checking: asin must be mix of 10 numeric or uppercase alpha
characters.  If a mix, first character must be uppercase alpha; if all numeric, asins must be 10-digit
isbn. If 10-digit isbn, add a maintenance category so a bot or awb script can replace |asin= with |isbn=.
Error message if not 10 characters, if not isbn10, if mixed and first character is a digit.

This function is positioned here because it calls isbn()

]]

local function asin(id, domain)
	local err_cat = ""

	if not id:match("^[%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u]$") then
		err_cat = ' ' .. set_error ('bad_asin');								-- asin is not a mix of 10 uppercase alpha and numeric characters
	else
		if id:match("^%d%d%d%d%d%d%d%d%d[%dX]$") then							-- if 10-digit numeric (or 9 digits with terminal X)
			if isbn( id ) then													-- see if asin value is isbn10
				add_maint_cat ('ASIN');
			elseif not is_set (err_cat) then
				err_cat = ' ' .. set_error ('bad_asin');						-- asin is not isbn10
			end
		elseif not id:match("^%u[%d%u]+$") then
			err_cat = ' ' .. set_error ('bad_asin');							-- asin doesn't begin with uppercase alpha
		end
	end
	if not is_set(domain) then 
		domain = "com";
	elseif in_array (domain, {'jp', 'uk'}) then			-- Japan, United Kingdom
		domain = "co." .. domain;
	elseif in_array (domain, {'au', 'br', 'mx'}) then	-- Australia, Brazil, Mexico
		domain = "com." .. domain;
	end
	local handler = cfg.id_handlers['ASIN'];
	return external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
		prefix=handler.prefix .. domain .. "/dp/",
		id=id, encode=handler.encode, separator = handler.separator}) .. err_cat;
end


--[[--------------------------&lt; I S M N &gt;----------------------------------------------------------------------

Determines whether an ISMN string is valid.  Similar to isbn-13, ismn is 13 digits begining 979-0-... and uses the
same check digit calculations.  See http://www.ismn-international.org/download/Web_ISMN_Users_Manual_2008-6.pdf
section 2, pages 9–12.

]]

local function ismn (id)
	local handler = cfg.id_handlers['ISMN'];
	local text;
	local valid_ismn = true;
	local id_copy;

	id_copy = id;																-- save a copy because this testing is destructive
	id=id:gsub( "[%s-–]", "" );													-- strip spaces, hyphens, and endashes from the ismn

	if 13 ~= id:len() or id:match( "^9790%d*$" ) == nil then					-- ismn must be 13 digits and begin 9790
		valid_ismn = false;
	else
		valid_ismn=is_valid_isxn_13 (id);										-- validate ismn
	end

--	text = internal_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,		-- use this (or external version) when there is some place to link to
--		prefix=handler.prefix, id=id_copy, separator=handler.separator, encode=handler.encode})
 
	text = table.concat (
		{
		make_wikilink (handler.link, handler.label),
		handler.separator,
		id_copy
		});		-- because no place to link to yet

	if false == valid_ismn then
		text = text .. ' ' .. set_error( 'bad_ismn' )							-- add an error message if the ismn is invalid
	end 
	
	return text;
end


--[[--------------------------&lt; I S S N &gt;----------------------------------------------------------------------

Validate and format an issn.  This code fixes the case where an editor has included an ISSN in the citation but
has separated the two groups of four digits with a space.  When that condition occurred, the resulting link looked
like this:

	|issn=0819 4327 gives: [http://www.worldcat.org/issn/0819 4327 0819 4327]	-- can't have spaces in an external link
	
This code now prevents that by inserting a hyphen at the issn midpoint.  It also validates the issn for length
and makes sure that the checkdigit agrees with the calculated value.  Incorrect length (8 digits), characters
other than 0-9 and X, or checkdigit / calculated value mismatch will all cause a check issn error message.  The
issn is always displayed with a hyphen, even if the issn was given as a single group of 8 digits.

]]

local function issn(id, e)
	local issn_copy = id;														-- save a copy of unadulterated issn; use this version for display if issn does not validate
	local handler;
	local text;
	local valid_issn = true;
	
	if e then
		 handler = cfg.id_handlers['EISSN'];
	else
		 handler = cfg.id_handlers['ISSN'];
	end

	id=id:gsub( "[%s-–]", "" );													-- strip spaces, hyphens, and endashes from the issn

	if 8 ~= id:len() or nil == id:match( "^%d*X?$" ) then						-- validate the issn: 8 digits long, containing only 0-9 or X in the last position
		valid_issn=false;														-- wrong length or improper character
	else
		valid_issn=is_valid_isxn(id, 8);										-- validate issn
	end

	if true == valid_issn then
		id = string.sub( id, 1, 4 ) .. "-" .. string.sub( id, 5 );				-- if valid, display correctly formatted version
	else
		id = issn_copy;															-- if not valid, use the show the invalid issn with error message
	end
	
	text = external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
		prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode})

	if false == valid_issn then
		text = text .. ' ' .. set_error( 'bad_issn', e and 'e' or '' )			-- add an error message if the issn is invalid
	end 
	
	return text
end


--[[--------------------------&lt; J F M &gt;-----------------------------------------------------------------------

A numerical identifier in the form nn.nnnn.nn

]]

local function jfm (id)
	local handler = cfg.id_handlers['JFM'];
	local id_num;
	local err_cat = '';
	
	id_num = id:match ('^[Jj][Ff][Mm](.*)$');									-- identifier with jfm prefix; extract identifier

	if is_set (id_num) then
		add_maint_cat ('jfm_format');
	else																		-- plain number without mr prefix
		id_num = id;															-- if here id does not have prefix
	end

	if id_num and id_num:match('^%d%d%.%d%d%d%d%.%d%d$') then
		id = id_num;															-- jfm matches pattern
	else
		err_cat = ' ' .. set_error( 'bad_jfm' );								-- set an error message
	end
	
	return external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
			prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode}) .. err_cat;
end


--[[--------------------------&lt; L C C N &gt;----------------------------------------------------------------------

Format LCCN link and do simple error checking.  LCCN is a character string 8-12 characters long. The length of
the LCCN dictates the character type of the first 1-3 characters; the rightmost eight are always digits.
http://info-uri.info/registry/OAIHandler?verb=GetRecord&amp;metadataPrefix=reg&amp;identifier=info:lccn/

length = 8 then all digits
length = 9 then lccn[1] is lower case alpha
length = 10 then lccn[1] and lccn[2] are both lower case alpha or both digits
length = 11 then lccn[1] is lower case alpha, lccn[2] and lccn[3] are both lower case alpha or both digits
length = 12 then lccn[1] and lccn[2] are both lower case alpha

]]

local function lccn(lccn)
	local handler = cfg.id_handlers['LCCN'];
	local err_cat = '';															-- presume that LCCN is valid
	local id = lccn;															-- local copy of the lccn

	id = normalize_lccn (id);													-- get canonical form (no whitespace, hyphens, forward slashes)
	local len = id:len();														-- get the length of the lccn

	if 8 == len then
		if id:match("[^%d]") then												-- if LCCN has anything but digits (nil if only digits)
			err_cat = ' ' .. set_error( 'bad_lccn' );							-- set an error message
		end
	elseif 9 == len then														-- LCCN should be adddddddd
		if nil == id:match("%l%d%d%d%d%d%d%d%d") then							-- does it match our pattern?
			err_cat = ' ' .. set_error( 'bad_lccn' );							-- set an error message
		end
	elseif 10 == len then														-- LCCN should be aadddddddd or dddddddddd
		if id:match("[^%d]") then												-- if LCCN has anything but digits (nil if only digits) ...
			if nil == id:match("^%l%l%d%d%d%d%d%d%d%d") then					-- ... see if it matches our pattern
				err_cat = ' ' .. set_error( 'bad_lccn' );						-- no match, set an error message
			end
		end
	elseif 11 == len then														-- LCCN should be aaadddddddd or adddddddddd
		if not (id:match("^%l%l%l%d%d%d%d%d%d%d%d") or id:match("^%l%d%d%d%d%d%d%d%d%d%d")) then	-- see if it matches one of our patterns
			err_cat = ' ' .. set_error( 'bad_lccn' );							-- no match, set an error message
		end
	elseif 12 == len then														-- LCCN should be aadddddddddd
		if not id:match("^%l%l%d%d%d%d%d%d%d%d%d%d") then						-- see if it matches our pattern
			err_cat = ' ' .. set_error( 'bad_lccn' );							-- no match, set an error message
		end
	else
		err_cat = ' ' .. set_error( 'bad_lccn' );								-- wrong length, set an error message
	end

	if not is_set (err_cat) and nil ~= lccn:find ('%s') then
		err_cat = ' ' .. set_error( 'bad_lccn' );								-- lccn contains a space, set an error message
	end

	return external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
			prefix=handler.prefix,id=lccn,separator=handler.separator, encode=handler.encode}) .. err_cat;
end


--[[--------------------------&lt; M R &gt;--------------------------------------------------------------------------

A seven digit number; if not seven digits, zero-fill leading digits to make seven digits.

]]

local function mr (id)
	local handler = cfg.id_handlers['MR'];
	local id_num;
	local id_len;
	local err_cat = '';
	
	id_num = id:match ('^[Mm][Rr](%d+)$');										-- identifier with mr prefix

	if is_set (id_num) then
		add_maint_cat ('mr_format');
	else																		-- plain number without mr prefix
		id_num = id:match ('^%d+$');											-- if here id is all digits
	end

	id_len = id_num and id_num:len() or 0;
	if (7 &gt;= id_len) and (0 ~= id_len) then
		id = string.rep ('0', 7-id_len ) .. id_num;								-- zero-fill leading digits
	else
		err_cat = ' ' .. set_error( 'bad_mr' );									-- set an error message
	end
	
	return external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
			prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode}) .. err_cat;
end


--[[--------------------------&lt; O C L C &gt;----------------------------------------------------------------------

Validate and format an oclc id.  https://www.oclc.org/batchload/controlnumber.en.html {{dead link}}
archived at: https://web.archive.org/web/20161228233804/https://www.oclc.org/batchload/controlnumber.en.html

]]

local function oclc (id)
	local handler = cfg.id_handlers['OCLC'];
	local number;
	local err_msg = '';															-- empty string for concatenation
	
	if id:match('^ocm%d%d%d%d%d%d%d%d$') then									-- ocm prefix and 8 digits; 001 field (12 characters)
		number = id:match('ocm(%d+)');											-- get the number
	elseif id:match('^ocn%d%d%d%d%d%d%d%d%d$') then								-- ocn prefix and 9 digits; 001 field (12 characters)
		number = id:match('ocn(%d+)');											-- get the number
	elseif id:match('^on%d%d%d%d%d%d%d%d%d%d+$') then							-- on prefix and 10 or more digits; 001 field (12 characters)
		number = id:match('^on(%d%d%d%d%d%d%d%d%d%d+)$');						-- get the number
	elseif id:match('^%(OCoLC%)[1-9]%d*$') then									-- (OCoLC) prefix and variable number digits; no leading zeros; 035 field
		number = id:match('%(OCoLC%)([1-9]%d*)');								-- get the number
		if 9 &lt; number:len() then
			number = nil;														-- contrain to 1 to 9 digits; change this when oclc issues 10-digit numbers
		end
	elseif id:match('^%d+$') then												-- no prefix
		number = id;															-- get the number
		if 10 &lt; number:len() then
			number = nil;														-- contrain to 1 to 10 digits; change this when oclc issues 11-digit numbers
		end
	end

	if number then																-- proper format
		id = number;															-- exclude prefix, if any, from external link
	else
		err_msg = ' ' .. set_error( 'bad_oclc' )								-- add an error message if the id is malformed
	end
	
	local text = external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
		prefix=handler.prefix, id=id, separator=handler.separator, encode=handler.encode}) .. err_msg;

	return text;
end


--[[--------------------------&lt; O P E N L I B R A R Y &gt;--------------------------------------------------------

Formats an OpenLibrary link, and checks for associated errors.

]]

local function openlibrary(id, access)
	local code;
	local handler = cfg.id_handlers['OL'];
	local ident;
	
	ident, code = id:gsub('^OL', ''):match("^(%d+([AMW]))$");					-- optional OL prefix followed immediately by digits followed by 'A', 'M', or 'W'; remove OL prefix

	if not is_set (ident) then													-- if malformed return an error
		return external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
			prefix=handler.prefix .. 'OL',
			id=id, separator=handler.separator,	encode = handler.encode,
			access = access}) .. ' ' .. set_error( 'bad_ol' );
	end
	
	id = ident;																	-- use ident without the optional OL prefix (it has been removed)
	
	if ( code == "A" ) then
		return external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
			prefix=handler.prefix .. 'authors/OL',
			id=id, separator=handler.separator,	encode = handler.encode,
			access = access})
	end
	
	if ( code == "M" ) then
		return external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
			prefix=handler.prefix .. 'books/OL',
			id=id, separator=handler.separator,	encode = handler.encode,
			access = access})
	end

	if ( code == "W" ) then
		return external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
			prefix=handler.prefix .. 'works/OL',
			id=id, separator=handler.separator,	encode = handler.encode,
			access = access})
	end
end


--[[--------------------------&lt; P M C &gt;------------------------------------------------------------------------

Format a PMC, do simple error checking, and check for embargoed articles.

The embargo parameter takes a date for a value. If the embargo date is in the future the PMC identifier will not
be linked to the article.  If the embargo date is today or in the past, or if it is empty or omitted, then the
PMC identifier is linked to the article through the link at cfg.id_handlers['PMC'].prefix.

PMC embargo date testing is done in function is_embargoed () which is called earlier because when the citation
has |pmc=&lt;value&gt; but does not have a |url= then |title= is linked with the PMC link.  Function is_embargoed ()
returns the embargo date if the PMC article is still embargoed, otherwise it returns an empty string.

PMCs are sequential numbers beginning at 1 and counting up.  This code checks the PMC to see that it contains only digits and is less
than test_limit; the value in local variable test_limit will need to be updated periodically as more PMCs are issued.

]]

local function pmc(id, embargo)
	local test_limit = cfg.id_limits.pmc;													-- update this value as PMCs approach
	local handler = cfg.id_handlers['PMC'];
	local err_cat = '';															-- presume that PMC is valid
	local id_num;
	local text;
	
	id_num = id:match ('^[Pp][Mm][Cc](%d+)$');									-- identifier with pmc prefix

	if is_set (id_num) then
		add_maint_cat ('pmc_format');
	else																		-- plain number without pmc prefix
		id_num = id:match ('^%d+$');											-- if here id is all digits
	end

	if is_set (id_num) then														-- id_num has a value so test it
		id_num = tonumber(id_num);												-- convert id_num to a number for range testing
		if 1 &gt; id_num or test_limit &lt; id_num then								-- if PMC is outside test limit boundaries
			err_cat = ' ' .. set_error( 'bad_pmc' );							-- set an error message
		else
			id = tostring (id_num);												-- make sure id is a string
		end
	else																		-- when id format incorrect
		err_cat = ' ' .. set_error( 'bad_pmc' );								-- set an error message
	end
	
	if is_set (embargo) then													-- is PMC is still embargoed?
		text = table.concat (													-- still embargoed so no external link
			{
			make_wikilink (handler.link, handler.label),
			handler.separator,
			id,
			err_cat
			});
	else
		text = external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,	-- no embargo date or embargo has expired, ok to link to article
			prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode, access=handler.access}) .. err_cat;
	end
	return text;
end


--[[--------------------------&lt; P M I D &gt;----------------------------------------------------------------------

Format PMID and do simple error checking.  PMIDs are sequential numbers beginning at 1 and counting up.  This
code checks the PMID to see that it contains only digits and is less than test_limit; the value in local variable
test_limit will need to be updated periodically as more PMIDs are issued.

]]

local function pmid(id)
	local test_limit = cfg.id_limits.pmid;											-- update this value as PMIDs approach
	local handler = cfg.id_handlers['PMID'];
	local err_cat = '';															-- presume that PMID is valid
	
	if id:match("[^%d]") then													-- if PMID has anything but digits
		err_cat = ' ' .. set_error( 'bad_pmid' );								-- set an error message
	else																		-- PMID is only digits
		local id_num = tonumber(id);											-- convert id to a number for range testing
		if 1 &gt; id_num or test_limit &lt; id_num then								-- if PMID is outside test limit boundaries
			err_cat = ' ' .. set_error( 'bad_pmid' );							-- set an error message
		end
	end
	
	return external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
			prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode}) .. err_cat;
end


--[[--------------------------&lt; S 2 C I D &gt;--------------------------------------------------------------------

Format an s2cid, do simple error checking

S2CIDs are sequential numbers beginning at 1 and counting up.  This code checks the s2cid to see that it is only
digits and is less than test_limit; the value in local variable test_limit will need to be updated periodically
as more S2CIDs are issued.

]]

local function s2cid (id, access)
	local test_limit = cfg.id_limits.s2cid;										-- update this value as S2CIDs approach
	local handler = cfg.id_handlers['S2CID'];
	local err_cat = '';															-- presume that S2CID is valid
	local id_num;
	local text;
	
	id_num = id:match ('^[1-9]%d+$');											-- id must be all digits; must not begin with 0; no open access flag

 	if is_set (id_num) then														-- id_num has a value so test it
		id_num = tonumber(id_num);												-- convert id_num to a number for range testing
		if test_limit &lt; id_num then												-- if S2CID is outside test limit boundaries
			err_cat = ' ' .. set_error( 'bad_s2cid' );							-- set an error message
		end

	else																		-- when id format incorrect
		err_cat = ' ' .. set_error( 'bad_s2cid' );								-- set an error message
	end

	text = external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
		prefix=handler.prefix, id=id:gsub ('%.%a%a', ''), separator=handler.separator, encode=handler.encode, access=access}) .. err_cat;

	return text;
end


--[[--------------------------&lt; S B N &gt;------------------------------------------------------------------------

9-digit form of isbn10; uses same check-digit validation when sbn is prefixed with an additional '0' to make 10 digits

]]

local function sbn (id)
	local check;
	local err_type = '';

	if nil ~= id:match("[^%s-0-9X]") then
		return false, cfg.err_msg_supl.char;									-- fail if sbn contains anything but digits, hyphens, or the uppercase X
	end

	id=id:gsub( "[%s-]", "" );													-- strip spaces and hyphens from the sbn

	if  9 ~= id:len() then
		return false, cfg.err_msg_supl.length;									-- fail if incorrect length
	end

	if id:match( "^%d*X?$" ) == nil then										-- fail if sbn has 'X' anywhere but last position
		return false, cfg.err_msg_supl.form;									
	end

	return is_valid_isxn('0' .. id, 10), cfg.err_msg_supl.check;				-- prefix sbn with '0' and validate as isbn10
end


--[[--------------------------&lt; S S R N &gt;----------------------------------------------------------------------

Format an ssrn, do simple error checking

SSRNs are sequential numbers beginning at 100? and counting up.  This code checks the ssrn to see that it is
only digits and is greater than 99 and less than test_limit; the value in local variable test_limit will need
to be updated periodically as more SSRNs are issued.

]]

local function ssrn (id)
	local test_limit = cfg.id_limits.ssrn;													-- update this value as SSRNs approach
	local handler = cfg.id_handlers['SSRN'];
	local err_cat = '';															-- presume that SSRN is valid
	local id_num;
	local text;
	
	id_num = id:match ('^%d+$');												-- id must be all digits

	if is_set (id_num) then														-- id_num has a value so test it
		id_num = tonumber(id_num);												-- convert id_num to a number for range testing
		if 100 &gt; id_num or test_limit &lt; id_num then								-- if SSRN is outside test limit boundaries
			err_cat = ' ' .. set_error( 'bad_ssrn' );							-- set an error message
		end
	else																		-- when id format incorrect
		err_cat = ' ' .. set_error( 'bad_ssrn' );								-- set an error message
	end
	
	text = external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
		prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode, access=handler.access}) .. err_cat;

	return text;
end


--[[--------------------------&lt; U S E N E T _ I D &gt;------------------------------------------------------------

Validate and format a usenet message id.  Simple error checking, looks for 'id-left@id-right' not enclosed in
'&lt;' and/or '&gt;' angle brackets.

]]

local function usenet_id (id)
	local handler = cfg.id_handlers['USENETID'];

	local text = external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
		prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode})
 
	if not id:match('^.+@.+$') or not id:match('^[^&lt;].*[^&gt;]$')then				-- doesn't have '@' or has one or first or last character is '&lt; or '&gt;'
		text = text .. ' ' .. set_error( 'bad_usenet_id' )						-- add an error message if the message id is invalid
	end 
	
	return text
end


--[[--------------------------&lt; Z B L &gt;-----------------------------------------------------------------------

A numerical identifier in the form nnnn.nnnnn - leading zeros in the first quartet optional

format described here: http://emis.mi.sanu.ac.rs/ZMATH/zmath/en/help/search/

temporary format is apparently eight digits.  Anything else is an error

]]

local function zbl (id)
	local handler = cfg.id_handlers['ZBL'];
	local err_cat = '';
	
	if id:match('^%d%d%d%d%d%d%d%d$') then										-- is this identifier using temporary format?
		add_maint_cat ('zbl');													-- yes, add maint cat
	elseif not id:match('^%d?%d?%d?%d%.%d%d%d%d%d$') then						-- not temporary, is it normal format?
		err_cat = ' ' .. set_error( 'bad_zbl' );								-- no, set an error message
	end
	
	return external_link_id ({link=handler.link, label=handler.label, q=handler.q, redirect=handler.redirect,
			prefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode}) .. err_cat;
end


--============================&lt;&lt; I N T E R F A C E   F U N C T I O N S &gt;&gt;==========================================

--[[--------------------------&lt; B U I L D _ I D _ L I S T &gt;--------------------------------------------------------

Takes a table of IDs created by extract_ids() and turns it into a table of formatted ID outputs.

inputs:
	id_list – table of identifiers built by extract_ids()
	options – table of various template parameter values used to modify some manually handled identifiers

]]

local function build_id_list( id_list, options )
	local new_list, handler = {};

	local function fallback(k) return { __index = function(t,i) return cfg.id_handlers[k][i] end } end;
	
	for k, v in pairs( id_list ) do												-- k is uc identifier name as index to cfg.id_handlers; e.g. cfg.id_handlers['ISBN'], v is a table
		-- fallback to read-only cfg
		handler = setmetatable( { ['id'] = v, ['access'] = options.IdAccessLevels[k] }, fallback(k) );

		if handler.mode == 'external' then
			table.insert( new_list, {handler.label, external_link_id( handler ) } );
		elseif handler.mode == 'internal' then
			table.insert( new_list, {handler.label, internal_link_id( handler ) } );
		elseif handler.mode ~= 'manual' then
			error( cfg.messages['unknown_ID_mode'] );
		elseif k == 'ARXIV' then
			table.insert( new_list, {handler.label, arxiv( v, options.Class ) } ); 
		elseif k == 'ASIN' then
			table.insert( new_list, {handler.label, asin( v, options.ASINTLD ) } ); 
		elseif k == 'BIBCODE' then
			table.insert( new_list, {handler.label, bibcode( v, handler.access ) } );
		elseif k == 'BIORXIV' then
			table.insert( new_list, {handler.label, biorxiv( v ) } );
		elseif k == 'CITESEERX' then
			table.insert( new_list, {handler.label, citeseerx( v ) } );
		elseif k == 'DOI' then
			table.insert( new_list, {handler.label, doi( v, options.DoiBroken, handler.access ) } );
		elseif k == 'EISSN' then
			table.insert( new_list, {handler.label, issn( v, true ) } );		-- true distinguishes eissn from issn
		elseif k == 'HDL' then
			table.insert( new_list, {handler.label, hdl( v, handler.access ) } );
		elseif k == 'ISBN' then
			local ISBN = internal_link_id( handler );
			local check;
			local err_type = '';
			check, err_type = isbn( v );
			if not check then
				if is_set(options.IgnoreISBN) then								-- ISBN is invalid; if |ignore-isbn-error= set
					add_maint_cat ('ignore_isbn_err');							-- ad a maint category
				else
					ISBN = ISBN .. set_error( 'bad_isbn', {err_type}, false, " ", "" );	-- else display an error message
				end
			elseif is_set(options.IgnoreISBN) then								-- ISBN is OK; if |ignore-isbn-error= set
				add_maint_cat ('ignore_isbn_err');								-- because |ignore-isbn-error= unnecessary
			end
			table.insert( new_list, {handler.label, ISBN } );				
		elseif k == 'ISMN' then
			table.insert( new_list, {handler.label, ismn( v ) } );
		elseif k == 'ISSN' then
			table.insert( new_list, {handler.label, issn( v ) } );
		elseif k == 'JFM' then
			table.insert( new_list, {handler.label, jfm( v ) } );
		elseif k == 'LCCN' then
			table.insert( new_list, {handler.label, lccn( v ) } );
		elseif k == 'MR' then
			table.insert( new_list, {handler.label, mr( v ) } );
		elseif k == 'OCLC' then
			table.insert( new_list, {handler.label, oclc( v ) } );
		elseif k == 'OL' or k == 'OLA' then
			table.insert( new_list, {handler.label, openlibrary( v, handler.access ) } );
		elseif k == 'PMC' then
			table.insert( new_list, {handler.label, pmc( v, options.Embargo ) } );
		elseif k == 'PMID' then
			table.insert( new_list, {handler.label, pmid( v ) } );
		elseif k == 'S2CID' then
			table.insert( new_list, {handler.label, s2cid( v, handler.access ) } );
		elseif k == 'SBN' then
			local SBN = internal_link_id (handler);
			local check;														-- boolean validation result
			local err_type = '';
			check, err_type = sbn (v);
			if not check then
				SBN = SBN .. set_error( 'bad_sbn', {err_type}, false, " ", "" );	-- display an error message
			end
			table.insert( new_list, {handler.label, SBN } );				
		elseif k == 'SSRN' then
			table.insert( new_list, {handler.label, ssrn( v ) } );
		elseif k == 'USENETID' then
			table.insert( new_list, {handler.label, usenet_id( v ) } );
		elseif k == 'ZBL' then
			table.insert( new_list, {handler.label, zbl( v ) } );
		else
			error( cfg.messages['unknown_manual_ID'] );
		end
	end
	
	local function comp( a, b )	-- used in following table.sort()
		return a[1]:lower() &lt; b[1]:lower();
	end
	
	table.sort( new_list, comp );
	for k, v in ipairs( new_list ) do
		new_list[k] = v[2];
	end
	
	return new_list;
end


--[[--------------------------&lt; E X T R A C T _ I D S &gt;------------------------------------------------------------

Populates ID table from arguments using configuration settings. Loops through cfg.id_handlers and searches args for
any of the parameters listed in each cfg.id_handlers['...'].parameters.  If found, adds the parameter and value to
the identifier list.  Emits redundant error message is more than one alias exists in args

]]

local function extract_ids( args )
	local id_list = {};															-- list of identifiers found in args
	for k, v in pairs( cfg.id_handlers ) do										-- k is uc identifier name as index to cfg.id_handlers; e.g. cfg.id_handlers['ISBN'], v is a table
		v = select_one( args, v.parameters, 'redundant_parameters' );			-- v.parameters is a table of aliases for k; here we pick one from args if present
		if is_set(v) then id_list[k] = v; end									-- if found in args, add identifier to our list
	end
	return id_list;
end


--[[--------------------------&lt; E X T R A C T _ I D _ A C C E S S _ L E V E L S &gt;--------------------------------------

Fetches custom id access levels from arguments using configuration settings.
Parameters which have a predefined access level (e.g. arxiv) do not use this
function as they are directly rendered as free without using an additional parameter.

access-level values must match the case used in cfg.keywords_lists['id-access'] (lowercase unless there is some special reason for something else)

]]

local function extract_id_access_levels( args, id_list )
	local id_accesses_list = {};
	for k, v in pairs( cfg.id_handlers ) do
		local access_param = v.custom_access;									-- name of identifier's access-level parameter
		if is_set(access_param) then
			local access_level = args[access_param];							-- get the assigned value if there is one
			if is_set (access_level) then
				if not in_array (access_level, cfg.keywords_lists['id-access']) then	-- exact match required
					table.insert( z.message_tail, { set_error( 'invalid_param_val', {access_param, access_level}, true ) } );	
					access_level = nil;											-- invalid so unset
				end
				if not is_set(id_list[k]) then									-- identifer access-level must have a matching identifier
					table.insert( z.message_tail, { set_error( 'param_access_requires_param', {k:lower()}, true ) } );	-- param name is uppercase in cfg.id_handlers (k); lowercase for error message
				end
				id_accesses_list[k] = cfg.keywords_xlate[access_level];			-- get translated keyword
			end
		end
	end
	return id_accesses_list;
end


--[[--------------------------&lt; S E T _ S E L E C T E D _ M O D U L E S &gt;--------------------------------------

Sets local cfg table and imported functions table to same (live or sandbox) as that used by the other modules.

]]

local function set_selected_modules (cfg_table_ptr, utilities_page_ptr)
	cfg = cfg_table_ptr;

	is_set = utilities_page_ptr.is_set;											-- import functions from select Module:Citation/CS1/Utilities module
	in_array = utilities_page_ptr.in_array;
	set_error = utilities_page_ptr.set_error;
	select_one = utilities_page_ptr.select_one;
	add_maint_cat = utilities_page_ptr.add_maint_cat;
	substitute = utilities_page_ptr.substitute;
	make_wikilink = utilities_page_ptr.make_wikilink;

	z = utilities_page_ptr.z;													-- table of tables in Module:Citation/CS1/Utilities
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {
	build_id_list = build_id_list,
	extract_ids = extract_ids,
	extract_id_access_levels = extract_id_access_levels,
	is_embargoed = is_embargoed;
	set_selected_modules = set_selected_modules;
	}</text>
      <sha1>3blms0k8weuk0elr5ur90yji32ow8pj</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Utilities</title>
    <ns>828</ns>
    <id>48808487</id>
    <revision>
      <id>935243617</id>
      <parentid>913997315</parentid>
      <timestamp>2020-01-11T12:32:44Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>sync from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="15414" xml:space="preserve">
local z = {
	error_categories = {};														-- for categorizing citations that contain errors
	error_ids = {};
	message_tail = {};
	maintenance_cats = {};														-- for categorizing citations that aren't erroneous per se, but could use a little work
	properties_cats = {};														-- for categorizing citations based on certain properties, language of source for instance
};


--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local cfg;																		-- table of tables imported from selected Module:Citation/CS1/Configuration


--[[--------------------------&lt; I S _ S E T &gt;------------------------------------------------------------------

Returns true if argument is set; false otherwise. Argument is 'set' when it exists (not nil) or when it is not an empty string.

]]

local function is_set( var )
	return not (var == nil or var == '');
end


--[[--------------------------&lt; I N _ A R R A Y &gt;--------------------------------------------------------------

Whether needle is in haystack

]]

local function in_array( needle, haystack )
	if needle == nil then
		return false;
	end
	for n,v in ipairs( haystack ) do
		if v == needle then
			return n;
		end
	end
	return false;
end


--[[--------------------------&lt; S U B S T I T U T E &gt;----------------------------------------------------------

Populates numbered arguments in a message string using an argument table.

]]

local function substitute( msg, args )
	return args and mw.message.newRawMessage( msg, args ):plain() or msg;
end


--[[--------------------------&lt; E R R O R _ C O M M E N T &gt;----------------------------------------------------

Wraps error messages with css markup according to the state of hidden.

]]

local function error_comment( content, hidden )
	return substitute( hidden and cfg.presentation['hidden-error'] or cfg.presentation['visible-error'], content );
end


--[=[-------------------------&lt; M A K E _ W I K I L I N K &gt;----------------------------------------------------

Makes a wikilink; when bot link and display text is provided, returns a wikilink in the form [[L|D]]; if only
link is provided, returns a wikilink in the form [[L]]; if neither are provided or link is omitted, returns an
empty string.

]=]

local function make_wikilink (link, display)
	if is_set (link) then
		if is_set (display) then
			return table.concat ({'[[', link, '|', display, ']]'});
		else
			return table.concat ({'[[', link, ']]'});
		end
	else
		return '';
	end
end


--[[--------------------------&lt; S E T _ E R R O R &gt;--------------------------------------------------------------

Sets an error condition and returns the appropriate error message.  The actual placement of the error message in the output is
the responsibility of the calling function.

]]

local function set_error( error_id, arguments, raw, prefix, suffix )
	local error_state = cfg.error_conditions[ error_id ];
	
	prefix = prefix or "";
	suffix = suffix or "";
	
	if error_state == nil then
		error( cfg.messages['undefined_error'] );								-- because missing error handler in Module:Citation/CS1/Configuration
	elseif is_set( error_state.category ) then
		table.insert( z.error_categories, error_state.category );
	end
	
	local message = substitute( error_state.message, arguments );

	message = table.concat (
		{
		message,
		' (',
		make_wikilink (
			table.concat (
				{
				cfg.messages['help page link'],
				'#',
				error_state.anchor
				}),
			cfg.messages['help page label']),
		')'
		});

	z.error_ids[ error_id ] = true;
	if in_array( error_id, { 'bare_url_missing_title', 'trans_missing_title' } )
			and z.error_ids['citation_missing_title'] then
		return '', false;
	end
	
	message = table.concat({ prefix, message, suffix });
	
	if raw == true then
		return message, error_state.hidden;
	end		
		
	return error_comment( message, error_state.hidden );
end


--[[-------------------------&lt; I S _ A L I A S _ U S E D &gt;-----------------------------------------------------

This function is used by select_one() to determine if one of a list of alias parameters is in the argument list
provided by the template.

Input:
	args – pointer to the arguments table from calling template
	alias – one of the list of possible aliases in the aliases lists from Module:Citation/CS1/Configuration
	index – for enumerated parameters, identifies which one
	enumerated – true/false flag used choose how enumerated aliases are examined
	value – value associated with an alias that has previously been selected; nil if not yet selected
	selected – the alias that has previously been selected; nil if not yet selected
	error_list – list of aliases that are duplicates of the alias already selected

Returns:
	value – value associated with alias we selected or that was previously selected or nil if an alias not yet selected
	selected – the alias we selected or the alias that was previously selected or nil if an alias not yet selected

]]

local function is_alias_used (args, alias, index, enumerated, value, selected, error_list)
	if enumerated then															-- is this a test for an enumerated parameters?
		alias = alias:gsub ('#', index);										-- replace '#' with the value in index
	else
		alias = alias:gsub ('#', '');											-- remove '#' if it exists
	end

	if is_set(args[alias]) then													-- alias is in the template's argument list
		if value ~= nil and selected ~= alias then								-- if we have already selected one of the aliases
			local skip;
			for _, v in ipairs(error_list) do									-- spin through the error list to see if we've added this alias
				if v == alias then
					skip = true;
					break;														-- has been added so stop looking 
				end
			end
			if not skip then													-- has not been added so
				table.insert( error_list, alias );								-- add error alias to the error list
			end
		else
			value = args[alias];												-- not yet selected an alias, so select this one
			selected = alias;
		end
	end
	return value, selected;														-- return newly selected alias, or previously selected alias
end


--[[--------------------------&lt; A D D _ M A I N T _ C A T &gt;------------------------------------------------------

Adds a category to z.maintenance_cats using names from the configuration file with additional text if any.
To prevent duplication, the added_maint_cats table lists the categories by key that have been added to z.maintenance_cats.

]]

local added_maint_cats = {}														-- list of maintenance categories that have been added to z.maintenance_cats
local function add_maint_cat (key, arguments)
	if not added_maint_cats [key] then
		added_maint_cats [key] = true;											-- note that we've added this category
		table.insert( z.maintenance_cats, substitute (cfg.maint_cats [key], arguments));	-- make name then add to table
	end
end


--[[--------------------------&lt; S A F E _ F O R _ I T A L I C S &gt;----------------------------------------------

Protects a string that will be wrapped in wiki italic markup '' ... ''

Note: We cannot use &lt;i&gt; for italics, as the expected behavior for italics specified by ''...'' in the title is that
they will be inverted (i.e. unitalicized) in the resulting references.  In addition, &lt;i&gt; and '' tend to interact
poorly under Mediawiki's HTML tidy.

]]

local function safe_for_italics( str )
	if not is_set(str) then
		return str;
	else
		if str:sub(1,1) == "'" then str = "&lt;span&gt;&lt;/span&gt;" .. str; end
		if str:sub(-1,-1) == "'" then str = str .. "&lt;span&gt;&lt;/span&gt;"; end
		
		-- Remove newlines as they break italics.
		return str:gsub( '\n', ' ' );
	end
end


--[[--------------------------&lt; W R A P _ S T Y L E &gt;----------------------------------------------------------

Applies styling to various parameters.  Supplied string is wrapped using a message_list configuration taking one
argument; protects italic styled parameters.  Additional text taken from citation_config.presentation - the reason
this function is similar to but separate from wrap_msg().

]]

local function wrap_style (key, str)
	if not is_set( str ) then
		return "";
	elseif in_array( key, { 'italic-title', 'trans-italic-title' } ) then
		str = safe_for_italics( str );
	end

	return substitute( cfg.presentation[key], {str} );
end


--[[--------------------------&lt; S E L E C T _ O N E &gt;----------------------------------------------------------

Chooses one matching parameter from a list of parameters to consider.  The list of parameters to consider is just
names.  For parameters that may be enumerated, the position of the numerator in the parameter name is identified
by the '#' so |author-last1= and |author1-last= are represented as 'author-last#' and 'author#-last'.

Because enumerated parameter |&lt;param&gt;1= is an alias of |&lt;param&gt;= we must test for both possibilities.


Generates an error if more than one match is present.

]]

local function select_one( args, aliases_list, error_condition, index )
	local value = nil;															-- the value assigned to the selected parameter
	local selected = '';														-- the name of the parameter we have chosen
	local error_list = {};

	if index ~= nil then index = tostring(index); end

	for _, alias in ipairs( aliases_list ) do									-- for each alias in the aliases list
		if alias:match ('#') then												-- if this alias can be enumerated
			if '1' == index then												-- when index is 1 test for enumerated and non-enumerated aliases
				value, selected = is_alias_used (args, alias, index, false, value, selected, error_list);	-- first test for non-enumerated alias
			end
			value, selected = is_alias_used (args, alias, index, true, value, selected, error_list);		-- test for enumerated alias
		else
			value, selected = is_alias_used (args, alias, index, false, value, selected, error_list);		--test for non-enumerated alias
		end
	end

	if #error_list &gt; 0 and 'none' ~= error_condition then						-- for cases where this code is used outside of extract_names()
		local error_str = "";
		for _, k in ipairs( error_list ) do
			if error_str ~= "" then error_str = error_str .. cfg.messages['parameter-separator'] end
			error_str = error_str .. wrap_style ('parameter', k);
		end
		if #error_list &gt; 1 then
			error_str = error_str .. cfg.messages['parameter-final-separator'];
		else
			error_str = error_str .. cfg.messages['parameter-pair-separator'];
		end
		error_str = error_str .. wrap_style ('parameter', selected);
		table.insert( z.message_tail, { set_error( error_condition, {error_str}, true ) } );
	end
	
	return value, selected;
end


--[=[-------------------------&lt; R E M O V E _ W I K I _ L I N K &gt;----------------------------------------------

Gets the display text from a wikilink like [[A|B]] or [[B]] gives B

The str:gsub() returns either A|B froma [[A|B]] or B from [[B]] or B from B (no wikilink markup).

In l(), l:gsub() removes the link and pipe (if they exist); the second :gsub() trims white space from the label
if str was wrapped in wikilink markup.  Presumably, this is because without wikimarkup in str, there is no match
in the initial gsub, the replacement function l() doesn't get called.

]=]

local function remove_wiki_link (str)
	return (str:gsub( "%[%[([^%[%]]*)%]%]", function(l)
		return l:gsub( "^[^|]*|(.*)$", "%1" ):gsub("^%s*(.-)%s*$", "%1");
	end));
end


--[=[-------------------------&lt; I S _ W I K I L I N K &gt;--------------------------------------------------------

Determines if str is a wikilink, extracts, and returns the the wikilink type, link text, and display text parts.
If str is a complex wikilink ([[L|D]]):
	returns wl_type 2 and D and L from [[L|D]];
if str is a simple wikilink ([[D]])
	returns wl_type 1 and D from [[D]] and L as empty string;
if not a wikilink:
	returns wl_type 0, str as D, and L as empty string.

trims leading and trailing white space and pipes from L and D ([[L|]] and [[|D]] are accepted by MediaWiki and
treated like [[D]]; while [[|D|]] is not accepted by MediaWiki, here, we accept it and return D without the pipes).

]=]

local function is_wikilink (str)
	local D, L
	local wl_type = 2;															-- assume that str is a complex wikilink [[L|D]]

	if not str:match ('^%[%[[^%]]+%]%]$') then									-- is str some sort of a wikilink (must have some sort of content)
		return 0, str, '';														-- not a wililink; return wl_type as 0, str as D, and empty string as L
	end
	
	L, D = str:match ('^%[%[([^|]+)|([^%]]+)%]%]$');							-- get L and D from [[L|D]] 

	if not is_set (D) then														-- if no separate display
		D = str:match ('^%[%[([^%]]*)|*%]%]$');									-- get D from [[D]] or [[D|]]
		wl_type = 1; 
	end
	
	D = mw.text.trim (D, '%s|');												-- trim white space and pipe characters 
--	L = L and mw.text.trim (L, '%s|');
	return wl_type, D, L or '';
end


--[[--------------------------&lt; S T R I P _ A P O S T R O P H E _ M A R K U P &gt;--------------------------------

Strip wiki italic and bold markup from argument so that it doesn't contaminate COinS metadata.
This function strips common patterns of apostrophe markup.  We presume that editors who have taken the time to
markup a title have, as a result, provided valid markup. When they don't, some single apostrophes are left behind.

Returns the argument without wiki markup and a number; the number is more-or-less meaningless except as a flag
to indicate that markup was replaced; do not rely on it as an indicator of how many of any kind of markup was
removed; returns the argument and nil when no markup removed

]]

local function strip_apostrophe_markup (argument)
	if not is_set (argument) then
		return argument, nil;													-- no argument, nothing to do
	end

	if nil == argument:find ( "''", 1, true ) then								-- Is there at least one double apostrophe?  If not, exit.
		return argument, nil;
	end

	local flag;
	while true do
		if argument:find ( "'''''", 1, true ) then								-- bold italic (5)
			argument, flag=argument:gsub("%'%'%'%'%'", "");						-- remove all instances of it
		elseif argument:find ( "''''", 1, true ) then							-- italic start and end without content (4)
			argument, flag=argument:gsub("%'%'%'%'", "");
		elseif argument:find ( "'''", 1, true ) then							-- bold (3)
			argument, flag=argument:gsub("%'%'%'", "");
		elseif argument:find ( "''", 1, true ) then								-- italic (2)
			argument, flag=argument:gsub("%'%'", "");
		else
			break;
		end
	end

	return argument, flag;														-- done
end


--[[--------------------------&lt; S E T _ S E L E C T E D _ M O D U L E S &gt;--------------------------------------

Sets local cfg table to same (live or sandbox) as that used by the other modules.

]]

local function set_selected_modules (cfg_table_ptr)
	cfg = cfg_table_ptr;
	
end


--[[--------------------------&lt; E X P O R T S &gt;----------------------------------------------------------------
]]

return {
	is_set = is_set,															-- exported functions
	in_array = in_array,
	substitute = substitute,
	error_comment = error_comment,
	set_error = set_error,
	select_one = select_one,
	add_maint_cat = add_maint_cat,
	wrap_style = wrap_style,
	safe_for_italics = safe_for_italics,
	remove_wiki_link = remove_wiki_link,
	is_wikilink = is_wikilink,
	make_wikilink = make_wikilink,
	set_selected_modules = set_selected_modules,
	strip_apostrophe_markup = strip_apostrophe_markup,
	z = z,																		-- exported table
	}</text>
      <sha1>5rfrtuc4s7uvjwnzsho5aib4ou956cd</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Whitelist</title>
    <ns>828</ns>
    <id>39013723</id>
    <revision>
      <id>951705311</id>
      <parentid>935243634</parentid>
      <timestamp>2020-04-18T12:50:50Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>sync from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="15386" xml:space="preserve">
--[[--------------------------&lt; S U P P O R T E D   P A R A M E T E R S &gt;--------------------------------------

Because a steady-state signal conveys no useful information, whitelist.basic_arguments[] list items can have three values:
	true - these parameters are valid and supported parameters
	false - these parameters are deprecated but still supported
	nil - these parameters are no longer supported. remove entirely
	
]]

local whitelist = {}

local basic_arguments = {
	['accessdate'] = true,
	['access-date'] = true,
	['agency'] = true,
--	['airdate'] = true,															-- cite episode and cite serial only
--	['air-date'] = true,														-- cite episode and cite serial only
	['archivedate'] = true,
	['archive-date'] = true,
	['archive-format'] = true,
	['archiveurl'] = true,
	['archive-url'] = true,
	['article'] = true,
	['article-format'] = true,
	['article-url'] = true,
	['article-url-access'] = true,
	['arxiv'] = true,
	['asin'] = true,
	['ASIN'] = true,
	['asin-tld'] = true,
	['at'] = true,
	['author'] = true,
	['author-first'] = true,
	['author-last'] = true,
	['authorlink'] = true,
	['author-link'] = true,
	['authormask'] = true,
	['author-mask'] = true,
	['authors'] = true,
	['bibcode'] = true,
	['bibcode-access'] = true,
	['biorxiv'] = true,
	['booktitle'] = true,
	['book-title'] = true,
	['cartography'] = true,
	['chapter'] = true,
	['chapter-format'] = true,
	['chapterurl'] = true,
	['chapter-url'] = true,
	['chapter-url-access'] = true,
	['citeseerx'] = true,
	['collaboration'] = true,
	['conference'] = true,
	['conference-format'] = true,
	['conferenceurl'] = true,
	['conference-url'] = true,
	['contribution'] = true,
	['contribution-format'] = true,
	['contributionurl'] = true,
	['contribution-url'] = true,
	['contribution-url-access'] = true,
	['contributor'] = true,
	['contributor-first'] = true,
	['contributor-last'] = true,
	['contributor-given'] = true,
	['contributor-surname'] = true,
	['contributor-link'] = true,
	['contributor-mask'] = true,
--	['credits'] = true,															-- cite episode, cite serial
	['date'] = true,
	['degree'] = true,
	['department'] = true,
	['df'] = true,
	['dictionary'] = true,
	['displayauthors'] = true,
	['display-authors'] = true,
	['display-contributors'] = true,
	['displayeditors'] = true,
	['display-editors'] = true,
	['display-interviewers'] = true,
	['display-translators'] = true,
	['docket'] = true,
	['doi'] = true,
	['DOI'] = true,
	['doi-access'] = true,
	['doi-broken'] = true,
	['doi-broken-date'] = true,
	['doi-inactive-date'] = true,
	['edition'] = true,
	['editor'] = true,
	['editor-first'] = true,
	['editor-given'] = true,
	['editor-last'] = true,
	['editorlink'] = true,
	['editor-link'] = true,
	['editormask'] = true,
	['editor-mask'] = true,
	['editors'] = true,
	['editor-surname'] = true,
	['eissn'] = true,
	['EISSN'] = true,
	['embargo'] = true,
	['encyclopaedia'] = true,
	['encyclopedia'] = true,
	['entry'] = true,
	['entry-format'] = true,
	['entry-url'] = true,
	['entry-url-access'] = true,
--	['episode'] = true,															-- cite serial only TODO: make available to cite episode?
--	['episodelink'] = true,														-- cite episode and cite serial
--	['episode-link'] = true,													-- cite episode and cite serial
	['eprint'] = true,															-- cite arxiv; here because allowed in cite ... as identifier
	['event'] = true,
	['event-format'] = true,
	['eventurl'] = true,
	['event-url'] = true,
	['first'] = true,
	['format'] = true,
	['given'] = true,
	['hdl'] = true,
	['HDL'] = true,
	['hdl-access'] = true,
	['host'] = true,
	['id'] = true,
	['ID'] = true,
	['ignoreisbnerror'] = true,
	['ignore-isbn-error'] = true,
	['inset'] = true,
	['institution'] = true,
	['interviewer'] = true,
	['interviewer-first'] = true,
	['interviewer-last'] = true,
	['interviewerlink'] = true,
	['interviewer-link'] = true,
	['interviewermask'] = true,
	['interviewer-mask'] = true,
	['isbn'] = true,
	['ISBN'] = true,
	['isbn13'] = true,
	['ISBN13'] = true,
	['ismn'] = true,
	['ISMN'] = true,
	['issn'] = true,
	['ISSN'] = true,
	['issue'] = true,
	['jfm'] = true,
	['JFM'] = true,
	['journal'] = true,
	['jstor'] = true,
	['JSTOR'] = true,
	['jstor-access'] = true,
	['lang'] = true,
	['language'] = true,
	['last'] = true,
	['lastauthoramp'] = true,
	['last-author-amp'] = true,
	['laydate'] = true,
	['lay-date'] = true,
	['laysource'] = true,
	['lay-source'] = true,
	['lay-format'] = true,
	['layurl'] = true,
	['lay-url'] = true,
	['lccn'] = true,
	['LCCN'] = true,
	['location'] = true,
	['magazine'] = true,
	['mailinglist'] = true,														-- cite mailing list only
	['mailing-list'] = true,													-- cite mailing list only
	['map'] = true,																-- cite map only
	['map-format'] = true,														-- cite map only
	['mapurl'] = true,															-- cite map only
	['map-url'] = true,															-- cite map only
	['map-url-access'] = true,													-- cite map only
	['medium'] = true,
--	['message-id'] = true,														-- cite newsgroup
	['minutes'] = true,
	['mode'] = true,
	['mr'] = true,
	['MR'] = true,
	['name-list-format'] = true,
--	['network'] = true,															-- cite episode and cite serial only
--	['newsgroup'] = true,														-- cite newsgroup
	['newspaper'] = true,
	['nocat'] = true,
	['no-cat'] = true,
	['nopp'] = true,
	['no-pp'] = true,
	['notracking'] = true,
	['no-tracking'] = true,
	['number'] = true,
	['oclc'] = true,
	['OCLC'] = true,
	['ol'] = true,
	['OL'] = true,
	['ol-access'] = true,
	['origyear'] = true,
	['orig-year'] = true,
	['osti'] = true,
	['OSTI'] = true,
	['osti-access'] = true,
	['others'] = true,
	['p'] = true,
	['page'] = true,
	['pages'] = true,
	['people'] = true,
	['periodical'] = true,
	['place'] = true,
	['pmc'] = true,
	['PMC'] = true,
	['pmid'] = true,
	['PMID'] = true,
	['postscript'] = true,
	['pp'] = true,
	['publicationdate'] = true,
	['publication-date'] = true,
	['publicationplace'] = true,
	['publication-place'] = true,
	['publisher'] = true,
	['quotation'] = true,
	['quote'] = true,
	['ref'] = true,
	['rfc'] = true,
	['RFC'] = true,
	['sbn'] = true,
	['SBN'] = true,
	['scale'] = true,
	['script-article'] = true,
	['script-chapter'] = true,
	['script-contribution'] = true,
	['script-entry'] = true,
	['script-journal'] = true,
	['script-magazine'] = true,
	['script-map'] = true,
	['script-newspaper'] = true,
	['script-periodical'] = true,
	['script-section'] = true,
	['script-title'] = true,
	['script-website'] = true,
	['script-work'] = true,
	['season'] = true,
	['section'] = true,
	['section-format'] = true,
	['sections'] = true,														-- cite map only
	['sectionurl'] = true,
	['section-url'] = true,
	['section-url-access'] = true,
	['series'] = true,
	['serieslink'] = true,
	['series-link'] = true,
	['seriesno'] = true,
	['series-no'] = true,
	['seriesnumber'] = true,
	['series-number'] = true,
	['series-separator'] = true,
	['sheet'] = true,															-- cite map only
	['sheets'] = true,															-- cite map only
	['ssrn'] = true,
	['SSRN'] = true,
--	['station'] = true,															-- cite episode and cite serial only
	['subject'] = true,
	['subjectlink'] = true,
	['subject-link'] = true,
	['surname'] = true,
	['s2cid'] = true,
	['S2CID'] = true,
	['s2cid-access'] = true,
	['template-doc-demo'] = true,
	['time'] = true,
	['timecaption'] = true,
	['time-caption'] = true,
	['title'] = true,
	['titlelink'] = true,
	['title-link'] = true,
	['trans-map'] = true,
	['transcript'] = true,
	['transcript-format'] = true,
	['transcripturl'] = true,
	['transcript-url'] = true,
	['translator'] = true,
	['translator-first'] = true,
	['translator-last'] = true,
	['translator-given'] = true,
	['translator-surname'] = true,
	['translator-link'] = true,
	['translator-mask'] = true,
	['trans-article'] = true,
	['trans-chapter'] = true,
	['trans-contribution'] = true,
	['trans-entry'] = true,
	['trans-journal'] = true,
	['trans-magazine'] = true,
	['trans-newspaper'] = true,
	['trans-periodical'] = true,
	['trans-section'] = true,
	['trans-title'] = true,
	['trans-website'] = true,
	['trans-work'] = true,
	['type'] = true,
	['url'] = true,
	['URL'] = true,
	['url-access'] = true,
	['url-status'] = true,
	['vauthors'] = true,
	['veditors'] = true,
	['version'] = true,
	['via'] = true,
	['volume'] = true,
	['website'] = true,
	['work'] = true,
	['year'] = true,
	['zbl'] = true,
	['ZBL'] = true,
}

local numbered_arguments = {
	['author#'] = true,
	['author-first#'] = true,
	['author#-first'] = true,
	['author-last#'] = true,
	['author#-last'] = true,
	['author-link#'] = true,
	['author#link'] = true,
	['author#-link'] = true,
	['authorlink#'] = true,
	['author-mask#'] = true,
	['author#mask'] = true,
	['author#-mask'] = true,
	['authormask#'] = true,
	['contributor#'] = true,
	['contributor-first#'] = true,
	['contributor#-first'] = true,
	['contributor-last#'] = true,
	['contributor#-last'] = true,
	['contributor-given#'] = true,
	['contributor#-given'] = true,
	['contributor-surname#'] = true,
	['contributor#-surname'] = true,
	['contributor-link#'] = true,
	['contributor#-link'] = true,
	['contributor-mask#'] = true,
	['contributor#-mask'] = true,
	['editor#'] = true,
	['editor-first#'] = true,
	['editor#-first'] = true,
	['editor#-given'] = true,
	['editor-given#'] = true,
	['editor-last#'] = true,
	['editor#-last'] = true,
	['editor-link#'] = true,
	['editor#link'] = true,
	['editor#-link'] = true,
	['editorlink#'] = true,
	['editor-mask#'] = true,
	['editor#mask'] = true,
	['editor#-mask'] = true,
	['editormask#'] = true,
	['editor#-surname'] = true,
	['editor-surname#'] = true,
	['first#'] = true,
	['given#'] = true,
	['host#'] = true,
	['interviewer#'] = true,
	['interviewer-first#'] = true,
	['interviewer#-first'] = true,
	['interviewer-last#'] = true,
	['interviewer#-last'] = true,
	['interviewer-link#'] = true,
	['interviewer#-link'] = true,
	['interviewer-mask#'] = true,
	['interviewer#-mask'] = true,
	['last#'] = true,
	['subject#'] = true,
	['subject-link#'] = true,
	['subject#link'] = true,
	['subject#-link'] = true,
	['subjectlink#'] = true,
	['surname#'] = true,
	['translator#'] = true,
	['translator-first#'] = true,
	['translator#-first'] = true,
	['translator-last#'] = true,
	['translator#-last'] = true,
	['translator-given#'] = true,
	['translator#-given'] = true,
	['translator-surname#'] = true,
	['translator#-surname'] = true,
	['translator-link#'] = true,
	['translator#-link'] = true,
	['translator-mask#'] = true,
	['translator#-mask'] = true,
}


--[[--------------------------&lt; P R E P R I N T   S U P P O R T E D   P A R A M E T E R S &gt;--------------------

Cite arXiv, cite biorxiv, cite citeseerx, and cite ssrn are preprint templates that use the limited set of parameters
defined in the limited_basic_arguments and limited_numbered_arguments tables.  Those lists are supplemented with a
template-specific list of parameters that are required by the particular template and may be exclusive to one of the
preprint templates.  Some of these parameters may also be available to the general cs1|2 templates.

Same conventions for true/false/nil as above.

]]

local preprint_arguments = {
	arxiv = {
		['arxiv'] = true,														-- cite arxiv and arxiv identifiers
		['class'] = true,														-- cite arxiv only
		['eprint'] = true,														-- cite arxiv and arxiv identifiers
		},
	biorxiv = {
		['biorxiv'] = true,
		},
	citeseerx = {
		['citeseerx'] = true,
		},
	ssrn = {
		['ssrn'] = true,
		['SSRN'] = true,
		},
	}


--[[--------------------------&lt; L I M I T E D   S U P P O R T E D   P A R A M E T E R S &gt;----------------------

This is an experiment that attempts to use validate() and a limited list of valid parameters to validate the
parameters provided in a cite arxiv, cite biorxiv, or cite citeseerx templates.  These parameters are common to
all three templates

Same conventions for true/false/nil as above.
	
]]

local limited_basic_arguments = {
	['at'] = true,
	['author'] = true,
	['author-first'] = true,
	['author-last'] = true,
	['authorlink'] = true,
	['author-link'] = true,
	['authormask'] = true,
	['author-mask'] = true,
	['authors'] = true,
	['collaboration'] = true,
	['date'] = true,
	['df'] = true,
	['displayauthors'] = true,
	['display-authors'] = true,
	['first'] = true,
	['given'] = true,
	['language'] = true,
	['last'] = true,
	['lastauthoramp'] = true,
	['last-author-amp'] = true,
	['mode'] = true,
	['name-list-format'] = true,
	['nocat'] = true,
	['no-cat'] = true,
	['notracking'] = true,
	['no-tracking'] = true,
	['p'] = true,
	['page'] = true,
	['pages'] = true,
	['postscript'] = true,
	['pp'] = true,
	['quotation'] = true,
	['quote'] = true,
	['ref'] = true,
	['surname'] = true,
	['template-doc-demo'] = true,
	['title'] = true,
	['url'] = true,
	['URL'] = true,
	['vauthors'] = true,
	['year'] = true,
}

local limited_numbered_arguments = {
	['author#'] = true,
	['author-first#'] = true,
	['author#-first'] = true,
	['author-last#'] = true,
	['author#-last'] = true,
	['author-link#'] = true,
	['author#link'] = true,
	['author#-link'] = true,
	['authorlink#'] = true,
	['author-mask#'] = true,
	['author#mask'] = true,
	['author#-mask'] = true,
	['authormask#'] = true,
	['first#'] = true,
	['given#'] = true,
	['last#'] = true,
	['surname#'] = true,
	}


--[[--------------------------&lt; U N I Q U E _ A R G U M E N T S &gt;----------------------------------------------

some templates have unique parameters.  Those templates and their unique parameters are listed here. Keys in this
table are the template's CitationClass parameter value

Same conventions for true/false/nil as above.

]]

local unique_arguments = {
	episode = {
		['airdate'] = true,
		['air-date'] = true,
		['credits'] = true,
		['episodelink'] = true,													-- aliases of |title-link=
		['episode-link'] = true,
		['network'] = true,
		['station'] = true,
		},
	newsgroup = {
		['message-id'] = true,
		['newsgroup'] = true,
		},
	serial = {
		['airdate'] = true,
		['air-date'] = true,
		['credits'] = true,
		['episode'] = true,														-- cite serial only TODO: make available to cite episode?
		['episodelink'] = true,													-- aliases of |title-link=
		['episode-link'] = true,
		['network'] = true,
		['station'] = true,
		},
	}


--[[--------------------------&lt; T E M P L A T E _ L I S T _ G E T &gt;--------------------------------------------

gets a list of the templates from table t

]]

local function template_list_get (t)
	local out = {};																-- a table for output
	for k, _ in pairs (t) do													-- spin through the table and collect the keys
		table.insert (out, k)													-- add each key to the output table
	end
	return out;																	-- and done
end


--[[--------------------------&lt; E X P O R T E D   T A B L E S &gt;------------------------------------------------
]]

return {
	basic_arguments = basic_arguments,
	numbered_arguments = numbered_arguments,
	limited_basic_arguments = limited_basic_arguments,
	limited_numbered_arguments = limited_numbered_arguments,

	preprint_arguments = preprint_arguments,
	preprint_template_list = template_list_get (preprint_arguments),			-- make a template list from preprint_arguments{} table
	unique_arguments = unique_arguments,
	unique_param_template_list = template_list_get (unique_arguments),			-- make a template list from unique_arguments{} table
	};</text>
      <sha1>6busmgl196te3keptqmitbtxfaxtdia</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/styles.css</title>
    <ns>828</ns>
    <id>57940169</id>
    <revision>
      <id>951705291</id>
      <parentid>935243608</parentid>
      <timestamp>2020-04-18T12:50:43Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>sync from sandbox;</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="4767" xml:space="preserve">/*-------------------------&lt; P R O T E C T I O N   I C O N &gt;--------------------

the following line controls the page-protection icon in the upper right corner
it must remain within this comment
	{{sandbox other||{{pp-template}}}}

*/


/*-------------------------&lt; O V E R R I D E S &gt;--------------------------------

cs1|2 references are wrapped in &lt;cite&gt;...&lt;/cite&gt; tags.  Some wikis have not
chosen to override the generic user agent italic styling as en.wiki has.  This
(untested) styling should override the user agent default when cs1|2 templates
are rendered.

Similarly, some languages use different quotation punctuation so that setting
is also made available here.
*/
cite.citation {
	/* Reset italic styling set by user agent (only for cs1|2 templates; the
	reason for the .citation qualifier) */
	font-style: inherit;
}

.citation q {
	/* Straight quote marks for &lt;q&gt;; keep same as [[MediaWiki:Common.css]] */
	quotes: '"' '"' "'" "'";
}

/* ID and URL access
Both core and Common.css have selector .mw-parser-output a[href$=".pdf"].external
for PDF pages. All TemplateStyles pages are hoisted to .mw-parser-output. We need
to have specificity equal to a[href$=".pdf"].external for locks to override PDF icon.

the .id-lock-... selectors are for use by non-citation templates like {{Catalog lookup link}}
*/

.id-lock-free a,
.citation .cs1-lock-free a {
	background-image: url(//upload.wikimedia.org/wikipedia/commons/thumb/6/65/Lock-green.svg/9px-Lock-green.svg.png);
	background-image: linear-gradient(transparent, transparent), url(//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg);
	background-repeat: no-repeat;
	background-size: 9px;
	background-position: right .1em center;
}

.id-lock-limited a,
.id-lock-registration a,
.citation .cs1-lock-limited a,
.citation .cs1-lock-registration a {
	background-image: url(//upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Lock-gray-alt-2.svg/9px-Lock-gray-alt-2.svg.png);
	background-image: linear-gradient(transparent, transparent), url(//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg);
	background-repeat: no-repeat;
	background-size: 9px;
	background-position: right .1em center;
}

.id-lock-subscription a,
.citation .cs1-lock-subscription a {
	background-image: url(//upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Lock-red-alt-2.svg/9px-Lock-red-alt-2.svg.png);
	background-image: linear-gradient(transparent, transparent), url(//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg);
	background-repeat: no-repeat;
	background-size: 9px;
	background-position: right .1em center; 
}

.cs1-subscription,
.cs1-registration {
	color: #555;
}

.cs1-subscription span,
.cs1-registration span {
	border-bottom: 1px dotted;
	cursor: help;
}

/* Wikisource icon
Experiment to see if it is possible/practical to add support for a wikisource
icon when |chapter= or |title= is wikilinked to a source in wikisource ala cite wikisource
*/
.cs1-ws-icon a {
	background-image: url(//upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Wikisource-logo.svg/12px-Wikisource-logo.svg.png);
	background-image: linear-gradient(transparent, transparent), url(//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg);
	background-repeat: no-repeat;
	background-size: 12px;
	background-position: right .1em center;
}

/* Errors and maintenance */
code.cs1-code {
	/* &lt;code&gt;...&lt;/code&gt; style override: mediawiki's css definition is specified here:
	https://git.wikimedia.org/blob/mediawiki%2Fcore.git/69cd73811f7aadd093050dbf20ed70ef0b42a713/skins%2Fcommon%2FcommonElements.css#L199
	*/
	color: inherit;
	background: inherit;
	border: inherit;	/* code editor doesn't like inherit with border?
						https://www.w3.org/wiki/CSS/Properties/border
						suggests that inherit is ok
						the actual spec says the code editor is correct:
						https://www.w3.org/TR/css-backgrounds-3/#borders
						*/
	padding: inherit;
}

.cs1-hidden-error {
	display: none;
	font-size: 100%;
}

.cs1-visible-error {
	font-size: 100%;
}

.cs1-maint {
	display: none;
	color: #33aa33;
	margin-left: 0.3em;
}

/* Small text size
Set small text size in one place. 0.95 (here) * 0.9 (from references list) is
~0.85, which is the lower bound for size for accessibility. Old styling for this
was just 0.85. We could write the rule so that when this template is inside
references/reflist, only then does it multiply by 0.95; else multiply by 0.85 */
.cs1-subscription,
.cs1-registration,
.cs1-format {
	font-size: 95%;
}

/* kerning */
.cs1-kern-left,
.cs1-kern-wl-left {
	padding-left: 0.2em;
}

.cs1-kern-right,
.cs1-kern-wl-right {
	padding-right: 0.2em;
}

/* selflinks – avoid bold font style when cs1|2 template links to the current page */
.citation .mw-selflink {
	font-weight: inherit;
}</text>
      <sha1>8ryajwyk0nayscee4lq07orx1ekke4v</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Delink</title>
    <ns>828</ns>
    <id>38999128</id>
    <revision>
      <id>695173753</id>
      <parentid>617654635</parentid>
      <timestamp>2015-12-14T07:03:21Z</timestamp>
      <contributor>
        <username>The Earwig</username>
        <id>7418060</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Module:Delink]]": [[WP:High-risk templates|Highly visible template]]: 55,000+ mainspace transclusions ([Edit=Allow only template editors and admins] (indefinite) [Move=Allow only template editors and admins] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6545" xml:space="preserve">-- This module de-links most wikitext.

require('Module:No globals')

local p = {}

local getArgs

local function delinkReversePipeTrick(s)
    if s:match("^%[%[|.*[|\n]") then -- Check for newlines or multiple pipes.
        return s
    else
        return s:match("%[%[|(.*)%]%]")
    end
end

local function delinkPipeTrick(s)
    local linkarea, display = "", ""
    -- We need to deal with colons, brackets, and commas, per [[Help:Pipe trick]].
    
    -- First, remove the text before the first colon, if any.
    if s:match(":") then
        s = s:match("%[%[.-:(.*)|%]%]")
    -- If there are no colons, grab all of the text apart from the square brackets and the pipe.
    else
        s = s:match("%[%[(.*)|%]%]")
    end
    
    -- Next up, brackets and commas.
    if s:match("%(.-%)$") then -- Brackets trump commas.
        s = s:match("(.-) ?%(.-%)$")
    elseif s:match(",") then -- If there are no brackets, display only the text before the first comma.
        s = s:match("(.-),.*$")
    end
    return s
end

local function delinkWikilink(s)
    local result = s
    -- Deal with the reverse pipe trick.
    if result:match("%[%[|") then
        return delinkReversePipeTrick(result)
    end
    
    result = mw.uri.decode(result, "PATH") -- decode percent-encoded entities. Leave underscores and plus signs.
    result = mw.text.decode(result, true) -- decode HTML entities.
    
    -- Check for bad titles. To do this we need to find the
    -- title area of the link, i.e. the part before any pipes.
    local titlearea
    if result:match("|") then -- Find if we're dealing with a piped link.
        titlearea = result:match("^%[%[(.-)|.*%]%]")
    else
        titlearea = result:match("^%[%[(.-)%]%]")
    end
    -- Check for bad characters.
    if mw.ustring.match(titlearea, "[%[%]&lt;&gt;{}%%%c\n]") then
        return s
    end
    
    -- Check for categories, interwikis, and files.
    local colonprefix = result:match("%[%[(.-):.*%]%]") or "" -- Get the text before the first colon.
    local ns = mw.site.namespaces[colonprefix] -- see if this is a known namespace
    if mw.language.isKnownLanguageTag(colonprefix)
    or ( ns and ( ns.canonicalName == "File" or ns.canonicalName == "Category" ) ) then
        return ""
    end
    
    -- Remove the colon if the link is using the [[Help:Colon trick]].
    if result:match("%[%[:") then
        result = "[[" .. result:match("%[%[:(.*%]%])")
    end
    
    -- Deal with links using the [[Help:Pipe trick]].
    if mw.ustring.match(result, "^%[%[[^|]*|%]%]") then
        return delinkPipeTrick(result)
    end
    
    -- Find the display area of the wikilink
    if result:match("|") then -- Find if we're dealing with a piped link.
        result = result:match("^%[%[.-|(.+)%]%]")
        -- Remove new lines from the display of multiline piped links,
        -- where the pipe is before the first new line.
        result = result:gsub("\n", "")
    else
        result = result:match("^%[%[(.-)%]%]")
    end

    return result
end

local function delinkURL(s)
    -- Assume we have already delinked internal wikilinks, and that
    -- we have been passed some text between two square brackets [foo].
    
    -- If the text contains a line break it is not formatted as a URL, regardless of other content.
    if s:match("\n") then
        return s
    end
    
    -- Check if the text has a valid URL prefix and at least one valid URL character.
    local valid_url_prefixes = {"//", "http://", "https://", "ftp://", "gopher://", "mailto:", "news:", "irc://"} 
    local url_prefix
    for i,v in ipairs(valid_url_prefixes) do
        if mw.ustring.match(s, '^%[' .. v ..'[^"%s].*%]' ) then
            url_prefix = v
            break
        end
    end
    
    -- Get display text
    if not url_prefix then
        return s
    end
    s = s:match("^%[" .. url_prefix .. "(.*)%]") -- Grab all of the text after the URL prefix and before the final square bracket.
    s = s:match('^.-(["&lt;&gt; ].*)') or "" -- Grab all of the text after the first URL separator character ("&lt;&gt; ).
    s = mw.ustring.match(s, "^%s*(%S.*)$") or "" -- If the separating character was a space, trim it off.
    
    local s_decoded = mw.text.decode(s, true)
    if mw.ustring.match(s_decoded, "%c") then
        return s
    else    
        return s_decoded
    end
end

local function delinkLinkClass(s, pattern, delinkFunction)
    if not type(s) == "string" then
        error("Attempt to de-link non-string input.", 2)
    end
    if not ( type(pattern) == "string" and mw.ustring.sub(pattern, 1, 1) == "^" ) then
        error('Invalid pattern detected. Patterns must begin with "^".', 2)
    end
    -- Iterate over the text string, and replace any matched text. using the 
    -- delink function. We need to iterate character by character rather 
    -- than just use gsub, otherwise nested links aren't detected properly.
    local result = ""
    while s ~= '' do
        -- Replace text using one iteration of gsub.
        s = mw.ustring.gsub(s, pattern, delinkFunction, 1)
        -- Append the left-most character to the result string.
        result = result .. mw.ustring.sub(s, 1, 1)
        s = mw.ustring.sub(s, 2, -1)
    end
    return result
end

function p._delink(args)
    local text = args[1] or ""
    if args.refs == "yes" then
        -- Remove any [[Help:Strip markers]] representing ref tags. In most situations 
        -- this is not a good idea - only use it if you know what you are doing!
        text = mw.ustring.gsub(text, "UNIQ%w*%-ref%-%d*%-QINU", "")
    end
    if not (args.comments == "no") then
        text = text:gsub("&lt;!%-%-.-%-%-&gt;", "") -- Remove html comments.
    end
    if not (args.wikilinks == "no") then
        text = delinkLinkClass(text, "^%[%[.-%]%]", delinkWikilink) -- De-link wikilinks.
    end
    if not (args.urls == "no") then
        text = delinkLinkClass(text, "^%[.-%]", delinkURL) -- De-link URLs.
    end
    if not (args.whitespace == "no") then
        -- Replace single new lines with a single space, but leave double new lines
        -- and new lines only containing spaces or tabs before a second new line.
        text = mw.ustring.gsub(text, "([^\n \t][ \t]*)\n([ \t]*[^\n \t])", "%1 %2")
        text = text:gsub("[ \t]+", " ") -- Remove extra tabs and spaces.
    end
    return text
end

function p.delink(frame)
    if not getArgs then
    	getArgs = require('Module:Arguments').getArgs
    end
    return p._delink(getArgs(frame, {wrappers = 'Template:Delink'}))
end

return p</text>
      <sha1>9uut60bk5e8nnvyxo8jbf7qt3b17a4v</sha1>
    </revision>
  </page>
  <page>
    <title>Module:EditAtWikidata</title>
    <ns>828</ns>
    <id>51464265</id>
    <revision>
      <id>915181788</id>
      <parentid>907414980</parentid>
      <timestamp>2019-09-11T18:11:45Z</timestamp>
      <contributor>
        <username>WOSlinker</username>
        <id>3138265</id>
      </contributor>
      <comment>copy over nbsp option from sandbox</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2125" xml:space="preserve">-- Module to display an icon with a tooltip such as "Edit this at Wikidata".
-- Icon will be linked to the Wikidata entry for the article where this is placed.
-- This message is only displayed if a local_parameter is not supplied
-- i.e. when called from a template, it can be coded not to display the message
-- when a local parameter is in use, preventing the value form Wikidata being fetched.
-- The qid of a Wikidata entry can optionally be supplied for testing outside the article.
-- Usage:
-- {{#invoke:EditAtWikidata|showMessage|local_parameter}}
-- {{#invoke:EditAtWikidata|showMessage|qid=&lt;ArticleID&gt;|local_parameter}}

local p = {}

local i18n =
{
	["message"] = "Edit this at Wikidata"
}

p.showMessage = function(frame)
	-- There may be a local parameter supplied, if it's blank, set it to nil
	local local_parm =  mw.text.trim(frame.args[1] or "")
	if local_parm and (local_parm == "") then local_parm = nil end

	-- If there is a local parameter used, we don't want to display the message
	if local_parm then return nil end

	-- Can take a named parameter |qid which is the Wikidata ID for the article.
	-- This will not normally be used except for testing outside the article.
	local qid = frame.args.qid
	if qid and (qid == "") then qid = nil end

	-- The module can take a parameter pid=
	-- which will create a link to that property in the Wikidata entry for the article
	local propertyID = mw.text.trim(frame.args.pid or "")

	-- Get the object containing all the claims for the article
	local entity = mw.wikibase.getEntityObject(qid)
	if entity then
		local thisQid
		if qid then thisQid = qid else thisQid = entity.id end

		-- Named parameter nbsp allows replacing the leading space with &amp;nbsp;
		local space
		if frame.args.nbsp and (frame.args.nbsp ~= "") then
			space = "&amp;nbsp;"
		else
			space = " "
		end

		return
			space .. "[[File:OOjs UI icon edit-ltr-progressive.svg |frameless |text-top |10px |alt=" ..
			i18n.message ..
			" |link=https://www.wikidata.org/wiki/" ..
			thisQid ..
			(propertyID == "" and "" or ("#" .. propertyID)) ..
			"|" .. i18n.message .. "]]"
	end
end

return p</text>
      <sha1>o4d9gud4xssetqk3mqm4x4v7qgokh43</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Effective protection expiry</title>
    <ns>828</ns>
    <id>48785459</id>
    <revision>
      <id>948472505</id>
      <parentid>948472504</parentid>
      <timestamp>2020-04-01T06:12:42Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1494" xml:space="preserve">local p = {}

-- Returns the expiry of a restriction of an action on a given title, or unknown if it cannot be known.
-- If no title is specified, the title of the page being displayed is used.
function p._main(action, pagename)
	local title
	if type(pagename) == 'table' and pagename.prefixedText then
		title = pagename
	elseif pagename then
		title = mw.title.new(pagename)
	else
		title = mw.title.getCurrentTitle()
	end
	pagename = title.prefixedText
	if action == 'autoreview' then
		local stabilitySettings = mw.ext.FlaggedRevs.getStabilitySettings(title)
		return stabilitySettings and stabilitySettings.expiry or 'unknown'
	elseif action ~= 'edit' and action ~= 'move' and action ~= 'create' and action ~= 'upload' then
		error( 'First parameter must be one of edit, move, create, upload, autoreview', 2 )
	end
	local rawExpiry = mw.getCurrentFrame():callParserFunction('PROTECTIONEXPIRY', action, pagename)
	if rawExpiry == 'infinity' then
		return 'infinity'
	elseif rawExpiry == '' then
		return 'unknown'
	else
		local year, month, day, hour, minute, second = rawExpiry:match(
			'^(%d%d%d%d)(%d%d)(%d%d)(%d%d)(%d%d)(%d%d)$'
		)
		if year then
			return string.format(
				'%s-%s-%sT%s:%s:%s',
				year, month, day, hour, minute, second
			)
		else
			error('internal error in Module:Effective protection expiry; malformed expiry timestamp')
		end
	end
end

setmetatable(p, { __index = function(t, k)
	return function(frame)
		return t._main(k, frame.args[1])
	end
end })

return p</text>
      <sha1>i1wms02y1w048cq6uttka18a5pjzp63</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Effective protection level</title>
    <ns>828</ns>
    <id>41617327</id>
    <revision>
      <id>948472507</id>
      <parentid>887507941</parentid>
      <timestamp>2020-04-01T06:12:43Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3288" xml:space="preserve">local p = {}

-- Returns the permission required to perform a given action on a given title.
-- If no title is specified, the title of the page being displayed is used.
function p._main(action, pagename)
	local title
	if type(pagename) == 'table' and pagename.prefixedText then
		title = pagename
	elseif pagename then
		title = mw.title.new(pagename)
	else
		title = mw.title.getCurrentTitle()
	end
	pagename = title.prefixedText
	if action == 'autoreview' then
		local level = mw.ext.FlaggedRevs.getStabilitySettings(title)
		level = level and level.autoreview
		if level == 'review' then
			return 'reviewer'
		elseif level ~= '' then
			return level
		else
			return nil -- not '*'. a page not being PC-protected is distinct from it being PC-protected with anyone able to review. also not '', as that would mean PC-protected but nobody can review
		end
	elseif action ~= 'edit' and action ~= 'move' and action ~= 'create' and action ~= 'upload' then
		error( 'First parameter must be one of edit, move, create, upload, autoreview', 2 )
	end
	if title.namespace == 8 then -- MediaWiki namespace
		if title.contentModel == 'javascript' or title.contentModel == 'css' then -- site JS or CSS page
			return 'interfaceadmin'
		else -- any non-JS/CSS MediaWiki page
			return 'sysop'
		end
	elseif title.namespace == 2 and title.isSubpage then
		if title.contentModel == 'javascript' or title.contentModel == 'css' then -- user JS or CSS page
			return 'interfaceadmin'
		elseif title.contentModel == 'json' then -- user JSON page
			return 'sysop'
		end
	end
	local level = title.protectionLevels[action] and title.protectionLevels[action][1]
	if level == 'sysop' or level == 'editprotected' then
		return 'sysop'
	elseif title.cascadingProtection.restrictions[action] and title.cascadingProtection.restrictions[action][1] then -- used by a cascading-protected page
		return 'sysop'
	elseif level == 'templateeditor' then
		return 'templateeditor'
	elseif action == 'move' then
		local blacklistentry = mw.ext.TitleBlacklist.test('edit', pagename) -- Testing action edit is correct, since this is for the source page. The target page name gets tested with action move.
		if blacklistentry and not blacklistentry.params.autoconfirmed then
			return 'templateeditor'
		elseif title.namespace == 6 then
			return 'filemover'
		elseif level == 'extendedconfirmed' then
			return 'extendedconfirmed'
		else
			return 'autoconfirmed'
		end
	end
	local blacklistentry = mw.ext.TitleBlacklist.test(action, pagename)
	if blacklistentry then
		if not blacklistentry.params.autoconfirmed then
			return 'templateeditor'
		elseif level == 'extendedconfirmed' then
			return 'extendedconfirmed'
		else
			return 'autoconfirmed'
		end
	elseif level == 'editsemiprotected' then -- create-semiprotected pages return this for some reason
		return 'autoconfirmed'
	elseif level then
		return level
	elseif action == 'upload' then
		return 'autoconfirmed'
	elseif action == 'create' and title.namespace % 2 == 0 and title.namespace ~= 118 then -- You need to be registered, but not autoconfirmed, to create non-talk pages other than drafts
		return 'user'
	else
		return '*'
	end
end

setmetatable(p, { __index = function(t, k)
	return function(frame)
		return t._main(k, frame.args[1])
	end
end })

return p</text>
      <sha1>o3wd8v4s0af0nabjp4xwsgqxlffn3mz</sha1>
    </revision>
  </page>
  <page>
    <title>Module:File link</title>
    <ns>828</ns>
    <id>42903140</id>
    <revision>
      <id>948474149</id>
      <parentid>948472509</parentid>
      <timestamp>2020-04-01T06:31:54Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <comment>Undid revision 948472508 by [[Special:Contributions/w&gt;IPad365|w&gt;IPad365]] ([[User talk:w&gt;IPad365|talk]])</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2544" xml:space="preserve">-- This module provides a library for formatting file wikilinks.

local yesno = require('Module:Yesno')
local checkType = require('libraryUtil').checkType

local p = {}

function p._main(args)
	checkType('_main', 1, args, 'table')

	-- This is basically libraryUtil.checkTypeForNamedArg, but we are rolling our
	-- own function to get the right error level.
	local function checkArg(key, val, level)
		if type(val) ~= 'string' then
			error(string.format(
				"type error in '%s' parameter of '_main' (expected string, got %s)",
				key, type(val)
			), level)
		end
	end

	local ret = {}

	-- Adds a positional parameter to the buffer.
	local function addPositional(key)
		local val = args[key]
		if not val then
			return nil
		end
		checkArg(key, val, 4)
		ret[#ret + 1] = val
	end

	-- Adds a named parameter to the buffer. We assume that the parameter name
	-- is the same as the argument key.
	local function addNamed(key)
		local val = args[key]
		if not val then
			return nil
		end
		checkArg(key, val, 4)
		ret[#ret + 1] = key .. '=' .. val
	end

	-- Filename
	checkArg('file', args.file, 3)
	ret[#ret + 1] = 'File:' .. args.file

	-- Format
	if args.format then
		checkArg('format', args.format)
		if args.formatfile then
			checkArg('formatfile', args.formatfile)
			ret[#ret + 1] = args.format .. '=' .. args.formatfile
		else
			ret[#ret + 1] = args.format
		end
	end

	-- Border
	if yesno(args.border) then
		ret[#ret + 1] = 'border'
	end

	addPositional('location')
	addPositional('alignment')
	addPositional('size')
	addNamed('upright')
	addNamed('link')
	addNamed('alt')
	addNamed('page')
	addNamed('class')
	addNamed('lang')
	addNamed('start')
	addNamed('end')
	addNamed('thumbtime')
	addPositional('caption')

	return string.format('[[%s]]', table.concat(ret, '|'))
end

function p.main(frame)
	local origArgs = require('Module:Arguments').getArgs(frame, {
		wrappers = 'Template:File link'
	})
	if not origArgs.file then
		error("'file' parameter missing from [[Template:File link]]", 0)
	end

	-- Copy the arguments that were passed to a new table to avoid looking up
	-- every possible parameter in the frame object.
	local args = {}
	for k, v in pairs(origArgs) do
		-- Make _BLANK a special argument to add a blank parameter. For use in
		-- conditional templates etc. it is useful for blank arguments to be
		-- ignored, but we still need a way to specify them so that we can do
		-- things like [[File:Example.png|link=]].
		if v == '_BLANK' then
			v = ''
		end
		args[k] = v
	end
	return p._main(args)
end

return p</text>
      <sha1>bzc22v133v9z5yc4aisazripn6l94p8</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Find sources</title>
    <ns>828</ns>
    <id>43953355</id>
    <revision>
      <id>856427561</id>
      <parentid>723339502</parentid>
      <timestamp>2018-08-25T03:29:20Z</timestamp>
      <contributor>
        <username>Johnuniq</username>
        <id>6036800</id>
      </contributor>
      <comment>change how results are displayed per [[Template talk:Find sources#Appearance]]</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5053" xml:space="preserve">-- This module implements {{find sources}} and other similar templates, and
-- also provides a mechanism to easily create new source-finding templates.

-- Define constants
local ROOT_PAGE = 'Module:Find sources'
local TEMPLATE_ROOT = ROOT_PAGE .. '/templates/' -- for template config modules
local LINK_ROOT = ROOT_PAGE .. '/links/' -- for link config modules
local CONFIG_PAGE = ROOT_PAGE .. '/config' -- for global config

-- Load required modules
local checkType = require('libraryUtil').checkType
local cfg = mw.loadData(CONFIG_PAGE)

local p = {}

local function maybeLoadData(page)
	local success, data = pcall(mw.loadData, page)
	return success and data
end

local function substituteParams(msg, ...)
	return mw.message.newRawMessage(msg, ...):plain()
end

local function renderSearchString(searchTerms, separator, transformFunc)
	-- This takes a table of search terms and turns it into a search string
	-- that can be used in a URL or in a display value. The transformFunc
	-- parameter can be used to transform each search term in some way (for
	-- example, URL-encoding them).
	local searchStrings = {}
	for i, s in ipairs(searchTerms) do
		searchStrings[i] = s
	end
	if transformFunc then
		for i, s in ipairs(searchStrings) do
			searchStrings[i] = transformFunc(s)
		end
	end
	return table.concat(searchStrings, separator)
end

function p._renderLink(code, searchTerms, display)
	-- Renders the external link wikicode for one link, given the link code,
	-- a table of search terms, and an optional display value.

	-- Get link config.
	local linkCfg = maybeLoadData(LINK_ROOT .. code)
	if not linkCfg then
		error(string.format(
			"invalid link code '%s'; no link config found at [[%s]]",
			code,
			LINK_ROOT .. code
		))
	end

	-- Make URL.
	local url
	do
		local separator = linkCfg.separator or "+"
		local searchString = renderSearchString(
			searchTerms,
			separator,
			mw.uri.encode
		)
		url = substituteParams(linkCfg.url, searchString)
	end

	return string.format('[%s %s]', url, display or linkCfg.display)
end

function p._main(template, args)
	-- The main access point from Lua.
	checkType('_main', 1, template, 'string')
	checkType('_main', 2, args, 'table', true)
	args = args or {}
	local title = mw.title.getCurrentTitle()

	-- Get the template config.
	local templateCfgPage = TEMPLATE_ROOT .. template
	local templateCfg = maybeLoadData(templateCfgPage)
	if not templateCfg then
		error(string.format(
			"invalid template name '%s'; no template config found at [[%s]]",
			template, templateCfgPage
		))
	end

	-- Namespace check.
	if not templateCfg.isUsedInMainspace and title.namespace == 0 then
		local formatString = '&lt;strong class="error"&gt;%s&lt;/strong&gt;'
		if cfg['namespace-error-category'] then
			formatString = formatString .. '[[%s:%s]]'
		end
		return string.format(
			formatString,
			cfg['namespace-error'],
			mw.site.namespaces[14].name,
			cfg['namespace-error-category']
		)
	end

	-- Get the search terms from the arguments.
	local searchTerms = {}
	for i, s in ipairs(args) do
		searchTerms[i] = s
	end
	if not searchTerms[1] then
		-- Use the current subpage name as the default search term. If the page
		-- uses a disambiguator like "Foo (bar)", make "Foo" the first term and
		-- "bar" the second.
		local term, dab = title.subpageText:match('^(.*) (%b())$')
		if dab then
			dab = dab:sub(2, -2) -- Remove parens
		end
		if term and dab then
			searchTerms[1] = term
			searchTerms[2] = dab
		else
			searchTerms[1] = title.subpageText
		end
	end
	searchTerms[1] = '"' .. searchTerms[1] .. '"'

	-- Make the intro link
	local introLink
	if templateCfg.introLink then
		local code = templateCfg.introLink.code
		local display = templateCfg.introLink.display or renderSearchString(
			searchTerms,
			'&amp;nbsp;'
		)
		introLink = p._renderLink(code, searchTerms, display)
	else
		introLink = ''
	end

	-- Make the other links
	local links = {}
	local separator = templateCfg.separator or cfg['default-separator']
	local sep = ''
	for i, t in ipairs(templateCfg.links) do
		links[i] = sep .. p._renderLink(t.code, searchTerms, t.display) ..
			(t.afterDisplay or '')
		sep = t.separator or separator
	end
	links = table.concat(links)

	-- Make the blurb.
	local blurb = substituteParams(templateCfg.blurb, introLink, links)
	local span = mw.html.create('span')
	span
		:addClass('plainlinks')
		:addClass(templateCfg.class)
		:cssText(templateCfg.style)
		:wikitext(blurb)

	return tostring(span)
end

setmetatable(p, { __index = function(t, template)
	-- The main access point from #invoke.
	-- Invocations will look like {{#invoke:Find sources|template name}},
	-- where "template name" is a subpage of [[Module:Find sources/templates]].
	local tname = template
	if tname:sub(-8) == '/sandbox' then
		-- This makes {{Find sources/sandbox|Albert Einstein}} work.
		tname = tname:sub(1, -9)
	end
	return function(frame)
		local args = require('Module:Arguments').getArgs(frame, {
			wrappers = mw.site.namespaces[10].name .. ':' .. tname
		})
		return t._main(template, args)
	end
end})

return p</text>
      <sha1>ek5h13uptp7weqiz5slz7iyx0xhepi6</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Find sources/config</title>
    <ns>828</ns>
    <id>43955540</id>
    <revision>
      <id>627555846</id>
      <parentid>627387651</parentid>
      <timestamp>2014-09-29T15:41:50Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <minor/>
      <comment>Protected Module:Find sources/config: [[WP:High-risk templates|High-risk Lua module]] ([Edit=Allow only template editors and admins] (indefinite) [Move=Allow only template editors and admins] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="611" xml:space="preserve">-- Configuration data for [[Module:Find sources]].

return {

-- Define the error message and category to be used if the module is used in
-- the main namespace and the template config doesn't set the
-- isUsedInMainspace key to true. The category is optional; if it is not
-- wanted, it can be removed.
['namespace-error'] = 'Error: Please do not use this template in articles.',
['namespace-error-category'] = 'Pages with templates in the wrong namespace',
 
-- The separator to be used if no separator is specified in the template
-- config.
['default-separator'] = mw.message.new('Dot-separator'):plain()

}</text>
      <sha1>7m3rfryxbtzywc5g6f1j85l2czfqd1t</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Find sources/links/google</title>
    <ns>828</ns>
    <id>43953792</id>
    <revision>
      <id>883390443</id>
      <parentid>627555989</parentid>
      <timestamp>2019-02-15T03:46:04Z</timestamp>
      <contributor>
        <username>LLarson</username>
        <id>46261</id>
      </contributor>
      <comment>Don’t force 50 search results per page per [[Special:PermanentLink/728464554#Google|unopposed talk page proposal]]</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="85" xml:space="preserve">return {
	url = '//www.google.com/search?as_eq=wikipedia&amp;q=$1',
	display = 'Google'
}</text>
      <sha1>8r4vqewnpbi78qi1kbka7kj7kz2o3a2</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Find sources/links/google books</title>
    <ns>828</ns>
    <id>43955182</id>
    <revision>
      <id>842038710</id>
      <parentid>627556010</parentid>
      <timestamp>2018-05-19T20:19:36Z</timestamp>
      <contributor>
        <username>LLarson</username>
        <id>46261</id>
      </contributor>
      <comment>Hide Wikipedia from search results</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="96" xml:space="preserve">return {
	url = '//www.google.com/search?tbs=bks:1&amp;q=$1+-wikipedia',
	display = 'Google Books'
}</text>
      <sha1>5whnt2vjy680iquvb2zgypq7vubb2rx</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Find sources/links/google news</title>
    <ns>828</ns>
    <id>43953803</id>
    <revision>
      <id>842038755</id>
      <parentid>627556060</parentid>
      <timestamp>2018-05-19T20:19:53Z</timestamp>
      <contributor>
        <username>LLarson</username>
        <id>46261</id>
      </contributor>
      <comment>Hide Wikipedia from search results; move query to end of string</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="93" xml:space="preserve">return {
	url = '//www.google.com/search?tbm=nws&amp;q=$1+-wikipedia',
	display = 'Google News'
}</text>
      <sha1>1yq35q1ohjyu4z4nlbtwmdadipbw7kf</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Find sources/links/google newspapers</title>
    <ns>828</ns>
    <id>43955176</id>
    <revision>
      <id>627556086</id>
      <parentid>627146341</parentid>
      <timestamp>2014-09-29T15:44:02Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <minor/>
      <comment>Protected Module:Find sources/links/google newspapers: [[WP:High-risk templates|High-risk Lua module]] ([Edit=Allow only template editors and admins] (indefinite) [Move=Allow only template editors and admins] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="131" xml:space="preserve">return {
	url = '//www.google.com/search?&amp;q=$1+site:news.google.com/newspapers&amp;source=newspapers',
	display = 'Google Newspapers'
}</text>
      <sha1>sli9tprkqmb7t48hk2z50q6vs3cjs1h</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Find sources/links/google scholar</title>
    <ns>828</ns>
    <id>43955203</id>
    <revision>
      <id>627556123</id>
      <parentid>627146675</parentid>
      <timestamp>2014-09-29T15:44:15Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <minor/>
      <comment>Protected Module:Find sources/links/google scholar: [[WP:High-risk templates|High-risk Lua module]] ([Edit=Allow only template editors and admins] (indefinite) [Move=Allow only template editors and admins] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="82" xml:space="preserve">return {
	url = '//scholar.google.com/scholar?q=$1',
	display = 'Google Scholar'
}</text>
      <sha1>jrze2cyoydfmpnj1at1xheuwgun9yed</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Find sources/links/jstor</title>
    <ns>828</ns>
    <id>43955213</id>
    <revision>
      <id>780788535</id>
      <parentid>627556152</parentid>
      <timestamp>2017-05-17T06:11:21Z</timestamp>
      <contributor>
        <username>John of Reading</username>
        <id>11308236</id>
      </contributor>
      <comment>http &gt; https per edit request at [[Module talk:Find sources#Please use HTTPS URL for JSTOR link]]</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="104" xml:space="preserve">return {
	url = 'https://www.jstor.org/action/doBasicSearch?Query=$1&amp;acc=on&amp;wc=on',
	display = 'JSTOR'
}</text>
      <sha1>tcz1j83nzesvlb9wjwe27phlt4woyyo</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Find sources/templates/Find sources mainspace</title>
    <ns>828</ns>
    <id>43983923</id>
    <revision>
      <id>777053998</id>
      <parentid>627620342</parentid>
      <timestamp>2017-04-24T23:44:15Z</timestamp>
      <contributor>
        <username>Train2104</username>
        <id>10341578</id>
      </contributor>
      <comment>removing google images, primary use is notability template.</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="427" xml:space="preserve">return {
	blurb = "''Find sources:''&amp;nbsp;$1&amp;nbsp;–&amp;nbsp;$2",
	introLink = {
		code = 'google'
	},
	links = {
		{
			code = 'google news',
			display = 'news'
		},
		{
			code = 'google newspapers',
			display = 'newspapers'
		},
		{
			code = 'google books',
			display = 'books'
		},
		{
			code = 'google scholar',
			display = 'scholar'
		},
		{
			code = 'jstor',
			display = 'JSTOR'
		}
	},
	isUsedInMainspace = true
}</text>
      <sha1>k39u38p2vc24ts3y9zywym3jkiq7787</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Footnotes</title>
    <ns>828</ns>
    <id>38969239</id>
    <revision>
      <id>952487244</id>
      <parentid>950469904</parentid>
      <timestamp>2020-04-22T13:59:23Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>split categories;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="18088" xml:space="preserve">require('Module:No globals');

local anchor_id_list_module = mw.loadData ('Module:Footnotes/anchor_id_list');
local anchor_id_list = anchor_id_list_module.anchor_id_list;
local article_whitelist = anchor_id_list_module.article_whitelist;
local template_list = anchor_id_list_module.template_list;

local whitelist_module = mw.loadData ('Module:Footnotes/whitelist');
local whitelist = whitelist_module.whitelist;
local special_patterns = whitelist_module.special_patterns;
local DNB_special_patterns = whitelist_module.DNB_special_patterns;
local DNB_template_names = whitelist_module.DNB_template_names;


--[[--------------------------&lt; A R G S _ D E F A U L T &gt;------------------------------------------------------

a table to specify initial values.

]]

local args_default = {
	bracket_left = '',
	bracket_right = '',
	bracket_year_left = '',
	bracket_year_right = '',
	postscript = '',
	page = '',
	pages = '',
	location = '',
	page_sep = ", p.&amp;nbsp;",
	pages_sep = ", pp.&amp;nbsp;",
	ref = '',
	template = 'harv',															-- if template name not provided in {{#invoke:}} use this
	};


--[[--------------------------&lt; T A R G E T _ C H E C K &gt;------------------------------------------------------

look for anchor_id (CITEREF name-list and year or text from |ref=) in anchor_id_list

the 'no target' error may be suppressed with |ignore-err=yes when target cannot be found because target is inside
a template that wraps another template; 'multiple targets' error may not be suppressed

]]

local function target_check (anchor_id, args)
	local namespace = mw.title.getCurrentTitle().namespace;

	if 10 == namespace then
		return '';																-- automatic form of |template-doc-demo=true; TODO: is this too broad?
	end

	local tally = anchor_id_list[anchor_id];									-- nil when anchor_id not in list; else a tally
	local msg;
	local category;

	if not tally then
		if args.ignore then
			return '';															-- if ignore is true then no message, no category
		end
		
		if article_whitelist and article_whitelist[anchor_id] then				-- if an article-local whitelist and anchor ID is in it
			return '';															-- done
		end
		
		local wl_anchor_id = anchor_id;											-- copy to be modified to index into the whitelist
		
		if args.year then														-- for anchor IDs created by this template (not in |ref=) that have a date
			if args.year:match ('%d%l$') or										-- use the date value to determine if we should remove the disambiguator
				args.year:match ('n%.d%.%l$') or
				args.year:match ('nd%l$') then
					wl_anchor_id = wl_anchor_id:gsub ('%l$', '');				-- remove the disambiguator
			end
		end		

		local t_tbl = whitelist[wl_anchor_id];									-- get list of templates associated with this anchor ID

		if t_tbl then															-- when anchor ID not whitelisted t_tbl is nil
			for _, t in ipairs (t_tbl) do										-- spin through the list of templates associated with this anchor ID
				if template_list[t] then										-- if associated template is found in the list of templates in the article
					return '';													-- anchor ID is whitlisted and article has matching template so no error
				end
			end
		end

		for _, pattern in ipairs (special_patterns) do							-- spin through the spcial patterns and try to match
			if anchor_id:match (pattern) then
				return '';
			end
		end

		for _, dnb_t in ipairs (DNB_template_names or {}) do					-- getting desparate now, are there any DNB templates? DNB_template_names may be nil; empty table prevents script error
			if template_list[dnb_t] then										-- if the article has this DNB template
				for _, pattern in ipairs (DNB_special_patterns) do				-- spin through the DNB-specifiec wildcard patterns
					if anchor_id:match (pattern) then							-- and attempt a match
						return '';												-- found a match
					end
				end
			end
		end

		msg = 'no target: ' .. anchor_id;										-- anchor_id not found
		category = '[[Category:Harv and Sfn no-target errors]]';

	elseif 1 &lt; tally then
		msg = 'multiple targets (' .. tally .. '×): ' .. anchor_id;				-- more than one anchor_id in this article
		category = '[[Category:Harv and Sfn multiple-target errors]]';
	end

--	category = 0 == namespace and '[[Category:Harv and Sfn template errors]]' or '';	-- only categorize in article space
	category = 0 == namespace and category or '';								-- only categorize in article space

--use this version to show error messages
--	return msg and '&lt;span class="error harv-error" style="display: inline; font-size:100%"&gt; ' .. args.template .. ' error: ' .. msg .. ' ([[:Category:Harv and Sfn template errors|help]])&lt;/span&gt;' .. category or '';
--use this version to hide error messages
	return msg and '&lt;span class="error harv-error" style="display: none; font-size:100%"&gt; ' .. args.template .. ' error: ' .. msg .. ' ([[:Category:Harv and Sfn template errors|help]])&lt;/span&gt;' .. category or '';

end


--[[--------------------------&lt; I S _ Y E A R &gt;----------------------------------------------------------------

evaluates param to see if it is one of these forms with or without lowercase letter disambiguator:
	YYYY
	n.d.
	nd	
	c. YYYY
	YYYY–YYYY	(separator is endash)
	YYYY–YY		(separator is endash)

return true when param has a recognized form; false else

]]

local function is_year (param, args)
	args.year = '';																-- used for harv error; 
	
	if mw.ustring.match (param, '^%d%d%d%d?%l?$') or
		mw.ustring.match (param, '^n%.d%.%l?$') or
		mw.ustring.match (param, '^nd%l?$') or
		mw.ustring.match (param, '^c%. %d%d%d%d?%l?$') or
		mw.ustring.match (param, '^%d%d%d%d–%d%d%d%d%l?$') or
		mw.ustring.match (param, '^%d%d%d%d–%d%d%l?$') then
			args.year = param;													-- used for harv error; 
			return true;
	end
--	return mw.ustring.match (param, '^%d%d%d%d?%l?$') or
--		mw.ustring.match (param, '^n%.d%.%l?$') or
--		mw.ustring.match (param, '^nd%l?$') or
--		mw.ustring.match (param, '^c%. %d%d%d%d?%l?$') or
--		mw.ustring.match (param, '^%d%d%d%d–%d%d%d%d%l?$') or
--		mw.ustring.match (param, '^%d%d%d%d–%d%d%l?$');
end


--[[--------------------------&lt; C O R E &gt;----------------------------------------------------------------------

returns an anchor link (CITEREF) formed from one to four author names, year, and insource location (|p=, |pp=, loc=)

]]

local function core( args )
	local result;
	local err_msg = ''

	if args.P5 ~= '' then
		if is_year (args.P5, args) then
			result = table.concat ({args.P1, ' et al. ', args.bracket_year_left, args.P5, args.bracket_year_right});
		else
			args.P5 = '';														-- when P5 not a year don't include in anchor
			result = table.concat ({args.P1, ' et al.'});						-- and don't render it
		end

	elseif args.P4 ~= '' then
		if is_year (args.P4, args) then
			result = table.concat ({args.P1, ', ', args.P2, ' &amp;amp; ', args.P3, ' ', args.bracket_year_left, args.P4, args.bracket_year_right});	-- three names and a year
		else
			result = table.concat ({args.P1, ' et al.'});						-- four names
		end

	elseif args.P3 ~= '' then
		if is_year (args.P3, args) then
			result = table.concat ({args.P1, ' &amp;amp; ', args.P2, ' ', args.bracket_year_left, args.P3, args.bracket_year_right});	-- two names and a year
		else
			result = table.concat ({args.P1, ', ', args.P2, ' ', ' &amp;amp; ', args.P3});	-- three names
		end
			
	elseif args.P2 ~= '' then
		if is_year (args.P2, args) then
			result = table.concat ({args.P1, ' ', args.bracket_year_left, args.P2, args.bracket_year_right});	-- one name and year
		else
			result = table.concat ({args.P1, ' &amp;amp; ', args.P2});				-- two names
		end
		
	else
		result = args.P1;														-- one name
	end
																				-- when author-date result ends with a dot (typically when the last positional parameter holds 'n.d.')
																				-- and when no in-source location (no |p=, |pp=, or |loc=)
																				-- and when the first or only character in args.postscript is a dot
																				-- remove the author-date result trailing dot
																				-- the author-date result trailing dot will be replaced later with the content of args.postscript (usually a dot)
	if ('.' == result:sub(-1)) and ('.' == args.postscript:sub(1)) and ('' == args.page) and ('' == args.pages) and ('' == args.location) then
		result = result:gsub ('%.$', '');
	end
	
	if args.ref ~= 'none' then
		local anchor_id;
		if args.ref ~= '' then
			anchor_id = mw.uri.anchorEncode (args.ref);
			err_msg = target_check (anchor_id, args);
			result = table.concat ({'[[#', anchor_id, '|', result, ']]'});
		else
			anchor_id = mw.uri.anchorEncode (table.concat ({'CITEREF', args.P1, args.P2, args.P3, args.P4, args.P5}));
			err_msg = target_check (anchor_id, args);
			result = table.concat ({'[[#', anchor_id, '|', result, ']]'});
		end
	end

	if args.page ~= '' then
		result = table.concat ({result, args.page_sep, args.page});
	elseif args.pages ~= ''then
		result = table.concat ({result, args.pages_sep, args.pages});
	end      

	if args.location ~= '' then
		result = table.concat ({result, ', ', args.location});
	end

	result = table.concat ({args.bracket_left, result, args.bracket_right, args.postscript}):gsub ('%s+', ' ');		-- strip redundant spaces
	return result .. err_msg;
end


--[[--------------------------&lt; A R G S  _ F E T C H &gt;---------------------------------------------------------

Because all of the templates share a common set of parameters, a single common function to fetch those parameters
from frame and parent frame.

]]

local function args_fetch (frame, ps)
	local args = args_default;													-- create a copy of the default table
	local pframe = frame:getParent();											-- point to the template's parameter table

	for k, v in pairs (frame.args) do											-- override defaults with values provided in the #invoke: if any
		args[k] = v;	   
	end
	
	args.postscript = pframe.args.postscript or pframe.args.ps or ps;
	if 'none' == args.postscript then
		args.postscript = '';
	end
	args.page = pframe.args.p or pframe.args.page or '';
	args.pages = pframe.args.pp or pframe.args.pages or '';
	args.location = pframe.args.loc or '';
	args.ref = pframe.args.ref or pframe.args.Ref or '';
	args.ignore = ('yes' == pframe.args['ignore-false-positive']) or ('yes' == pframe.args['ignore-err']);
--	args.ignore = 'yes' == pframe.args['ignore-err'];
	
	for i, v in ipairs ({'P1', 'P2', 'P3', 'P4', 'P5'}) do						-- loop through the five positional parameters and trim if set else empty string
		args[v] = (pframe.args[i] and mw.text.trim (pframe.args[i])) or '';
	end

	return args;
end


--[[--------------------------&lt; H A R V A R D _ C I T A T I O N &gt;----------------------------------------------

common entry point for:
	{{harvard citation}} aka {{harv}}
	{{Harvard citation no brackets}} aka {{harvnb}}
	{{harvcol}}
	{{harvcolnb}}
	{{harvcoltxt}}
	{{Harvard citation text}} aka {{harvtxt}}
	{{Harvp}}

Distinguishing features (brackets and page separators) are specified in this module's {{#invoke}} in the respective templates.

]]

local function harvard_citation (frame)
	local args = args_fetch (frame, '');										-- get the template and invoke parameters; default postscript is empty string

	return core (args);
end


--[[--------------------------&lt; S T R I P _ U R L &gt;------------------------------------------------------------

used by sfn() and sfnm().  This function fixes an issue with reference tooltip gadget where the tooltip is not displayed
when an insource locator (|p=, |pp=, |loc=) has an external wikilink that contains a # character

strip uri-reserved characters from urls in |p=, |pp-, and |loc= parameters  The researved characters are:
	!#$&amp;'()*+,/:;=?@[]
	
]]

local function strip_url (pages)
	local escaped_uri;
	if not pages or ('' == pages) then
		return pages;
	end
	
	for uri in pages:gmatch ('%[(%a[%w%+%.%-]*://%S+)') do						-- for each external link get the uri
		escaped_uri = uri:gsub ("([%(%)%.%%%+%-%*%?%[%^%$%]])", "%%%1" );		-- save a copy with lua pattern characters escaped
		uri = uri:gsub ("[!#%$&amp;'%(%)%*%+,/:;=%?@%[%]%.%%]", '');				-- remove reserved characters and '%' because '%20' (space character) is a lua 'invalid capture index'
		pages = pages:gsub (escaped_uri, uri, 1);								-- replace original uri with the stripped version
	end
	
	return pages;
end


--[[--------------------------&lt; S F N &gt;------------------------------------------------------------------------

entry point for {{sfn}} and {{sfnp}}

]]

local function sfn (frame)
	local args = args_fetch (frame, '.');										-- get the template and invoke parameters; default postscript is a dot

	local result = core (args);													-- go make a CITEREF anchor
																				-- put it all together and then strip redundant spaces
	local name = table.concat ({'FOOTNOTE', args.P1, args.P2, args.P3, args.P4, args.P5, strip_url (args.page), strip_url (args.pages), strip_url (args.location)}):gsub ('%s+', ' ');

	return frame:extensionTag ({name='ref', args={name=name}, content=result});	

	
end


--[[--------------------------&lt; S F N M &gt;----------------------------------------------------------------------

common entry point for {{sfnm}} and {{sfnmp}}

Distinguishing features (brackets) are specified in this module's {{#invoke}} in the respective templates.

]]

local function sfnm (frame)
	local args = args_default;													-- create a copy of the default table
	local pframe = frame:getParent();											-- point to the template's parameter table
	
	local n = 1;																-- index of source; this is the 'n' in na1, ny, etc
	local first_pnum = 1;														-- first of a pair of positional parameters
	local second_pnum = 2;														-- second of a pair of positional parameters

	local last_ps = 0;															-- index of the last source with |nps= set
	local last_index = 0;														-- index of the last source; these used to determine which of |ps= or |nps= will terminate the whole rendering

	local out = {};																-- table to hold rendered sources
	local footnote = {'FOOTNOTE'};												-- all author, date, insource location stuff becomes part of the reference's footnote id; added as we go

	for k, v in pairs (frame.args) do											-- override defaults with values provided in the #invoke: if any
		args[k] = v;	   
	end
	
	while true do
		if not pframe.args[table.concat ({n, 'a1'})] and not pframe.args[first_pnum] then
			break;																-- no na1 or matching positional parameter so done
		end
		
		if pframe.args[table.concat ({n, 'a1'})] then							-- does this source use named parameters?
			for _, v in ipairs ({'P1', 'P2', 'P3', 'P4', 'P5'}) do				-- initialize for this source
				args[v] = '';
			end

			for i, v in ipairs ({'P1', 'P2', 'P3', 'P4', 'P5'}) do				-- extract author and year parameters for this source
				args[v] = pframe.args[table.concat ({n, 'a', i})] or '';		-- attempt to assign author name
				if '' == args[v] then											-- when there wasn't an author name
					args[v] = pframe.args[table.concat ({n, 'y'})] or '';		-- attempt to assign year
					break;														-- done with author/date for this source
				end
			end

		else																	-- this source uses positional parameters
			args.P1 = mw.text.trim (pframe.args[first_pnum]);					-- yes, only one author supported
			args.P2 = (pframe.args[second_pnum] and mw.text.trim (pframe.args[second_pnum])) or '';	-- when positional author, year must also be positional

			for _, v in ipairs ({'P3', 'P4', 'P5'}) do							-- blank the rest of these for this source
				args[v] = '';
			end

			first_pnum = first_pnum + 2;										-- source must use positional author and positional year
			second_pnum = first_pnum + 1;										-- bump these for possible next positional source
		end
		
		args.postscript = pframe.args[table.concat ({n, 'ps'})] or '';
		if 'none' == args.postscript then										-- this for compatibility with other footnote templates; does nothing
			args.postscript = '';
		end

		args.ref = pframe.args[table.concat ({n, 'ref'})] or '';				-- alternate reference for this source

		args.page = pframe.args[table.concat ({n, 'p'})] or '';					-- insource locations for this source
		args.pages = pframe.args[table.concat ({n, 'pp'})] or '';
		args.location = pframe.args[table.concat ({n, 'loc'})] or '';
		args.ignore = ('yes' == pframe.args[table.concat ({n, 'ignore-false-positive'})]) or ('yes' == pframe.args[table.concat ({n, 'ignore-err'})]);
--		args.ignore = 'yes' == pframe.args[table.concat ({n, 'ignore-err'})];

		table.insert (out, core (args));										-- save the rendering of this source
		
		for k, v in ipairs ({'P1', 'P2', 'P3', 'P4', 'P5'}) do					-- create the FOOTNOTE id
			if '' ~= args[v] then
				table.insert (footnote, args[v]);
			end
		end
		for k, v in ipairs ({'page', 'pages', 'location'}) do					-- these done separately so that we can strip uri-reserved characters from extlinked page numbers 
			if '' ~= args[v] then
				table.insert (footnote, strip_url (args[v]))
			end
		end
		
		last_index = n;															-- flags used to select terminal postscript from nps or from end_ps
		if '' ~= args.postscript then							
			last_ps = n;
		end
		
		n = n+1;																-- bump for the next one
	end
	
	local name = table.concat (footnote):gsub ('%s+', ' ');						-- put the footnote together and strip redundant space
	
	args.end_ps = pframe.args.postscript or pframe.args.ps or '.';				-- this is the postscript for the whole not for the individual sources
	if 'none' == args.end_ps then												-- not an original sfnm parameter value; added for compatibility with other footnote templates
		args.end_ps = '';
	end

	local result = table.concat ({table.concat (out, '; '), (last_index == last_ps) and '' or  args.end_ps});
	return frame:extensionTag ({name='ref', args={name=name}, content=result});
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {
	harvard_citation = harvard_citation,
	sfn = sfn,
	sfnm = sfnm,
	};</text>
      <sha1>1jd3c562g2w2ukmdrlxtivek4vei65a</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Footnotes/anchor id list</title>
    <ns>828</ns>
    <id>63248705</id>
    <revision>
      <id>954278318</id>
      <parentid>949627185</parentid>
      <timestamp>2020-05-01T15:58:37Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="36120" xml:space="preserve">require('Module:No globals');

local anchor_id_list = {};

local redirect_patterns_anchor = {
	 '{{%s*[Aa]nchor',
	 '{{%s*[Aa]nchor for redirect',
	 '{{%s*[Aa]nchors',
	 '{{%s*[Aa]nchro',
	 '{{%s*[Aa]ncor',
	}
local redirect_patterns_harvc = {
	'{{%s*[Hh]arvc',
	'{{%s*[Cc]itec',
	}
local redirect_patterns_sfn_whitelist = {
	'{{%s*[Ss]fn whitelist',
	'{{%s*[Hh]arv whitelist',
	}
local redirect_patterns_vcite = {
	'{{%s*[Vv]cite',
	'{{%s*[Vv]ancite',
--	'{{%s*[Cc]it ',																-- disabled 'cit journal &amp; cit paper' redirect to vcite journal but 'cit book', 'cit new', 'cit web' are cs1 redirects
	}
local redirects_citation = {
	['citation'] = true,
	['cite'] = true,
	['cite citation'] = true,
	['cite study'] = true,
	['cite technical standard'] = true,
	}
local redirects_date = {
	['date'] = true,
	['datetomos'] = true,
	['formatdate'] = true,
	['isotodmymdy'] = true,
	['isotomos'] = true,
	}
local redirects_harvc = {
	['harvc'] = true,
	['citec'] = true,
	}
local redirects_patent = {
	['cite patent'] = true,
	['citeref patent'] = true,
	['ref patent'] = true,
	}
local redirects_sfnref = {
	['sfnref'] = true,
	['harvid'] = true,
	}
local aliases_author = {														-- these use pseudo-patterns in the same way as cs1|2; '#' represents 1 or more enumerator digits
	'last#',
	'author#',
	'surname#',
	'author-last#',
	'author#-last',
	'subject#',
	'host#',
	}
local aliases_contributor = {
	'contributor#',
	'contributor-last#',
	'contributor#-last',
	'contributor-surname#',
	'contributor#-surname',
	}
local aliases_editor = {
	'editor#',
	'editor-last#',
	'editor#-last',
	'editor-surname#',
	'editor#-surname',
	}
local aliases_harvc_author = {
	'last#',
	'author#',
	}
local aliases_inventor = {														-- cite patent
	'inventor#',
	'inventor-last#',
	'inventor#-last',
	'inventor-surname#',
	'inventor#-surname',
	'invent#',
	'invent-#',
	}
local alias_patterns_date = {													-- normal lua patterns for most cs1|2-like templates
	'|%s*year%s*=%s*',
	'|%s*date%s*=%s*',
	'|%s*publication%-?date%s*=%s*',
	}
local alias_patterns_harvc_date = {												-- normal lua patterns for harvc template
	'|%s*anchor%-year%s*=%s*',
	'|%s*year%s*=%s*',
	}
local alias_patterns_patent_date = {											-- normal lua patterns for cite patent templates
	'|%s*issue%-date%s*=%s*',
	'|%s*gdate%s*=%s*',
	'|%s*publication%-date%s*=%s*',
	'|%s*pubdate%s*=%s*',
	}
local patterns_date = {															-- normal lua patterns
	'^(%d%d%d%d–%d%d%d%d%l?)$',													-- YYYY–YYYY four-digit year range; with or without dab
	'^(%d%d%d%d–%d%d%l?)$',														-- YYYY–YY two-digit year range; with or without dab
	'^(c%. %d%d%d%d?%l?)$',														-- three- or four-digit circa year; with or without dab
	'(%d%d%d%d?%l?)$',															-- three- or four-digit year at end of date (dmy or mdy); with or without dab
	'^(%d%d%d%d?%l?)',															-- three- or four-digit year at end of date (ymd or YYYY); with or without dab
	'^(n%.d%.%l?)$',															-- 'no date' with dots; with or without dab
	'^(nd%l?)$',																-- 'no date' without dots; with or without dab
	}
local template_skip = {
	['citation-attribution'] = true,
	}
local Article_content;

--[[--------------------------&lt; A R T I C L E _ C O N T E N T _ G E T &gt;----------------------------------------

get article content, remove templates inside nowiki tags and remove html comments

]]

local function article_content_get ()
	if not Article_content then
		Article_content = mw.title.getCurrentTitle():getContent() or '';		-- get the content of the article or ''; new pages edited w/ve do not have 'content' until saved; ve does not preview; phab:T221625
--		Article_content = Article_content:gsub ('&lt;nowiki&gt;%s*{{.-}}%s*&lt;/nowiki&gt;', '');	-- remove templates inside nowiki tags; too constrained?
		Article_content = Article_content:gsub ('&lt;nowiki&gt;.-&lt;/nowiki&gt;', '');		-- remove nowiki tags and their content; less constrained
		Article_content = Article_content:gsub ('&lt;!%-%-.-%-%-&gt;', '');			-- remove html comments and their content
	end
end


--[[--------------------------&lt; S F N R E F _ G E T &gt;----------------------------------------------------------

make an anchor id from the contents of {{sfnref}} or {{harvid}}.  this function assumes that {{sfnref}} and {{harvid}}
are correctly formed.

]]

local function sfnref_get (template)
	template = template:gsub ('{{%s*(.-)%s*}}', '%1');							-- strip bounding template markup and trim
	local parts = mw.text.split (template, '%s*|%s*');							-- split at the pipe and remove extraneous space characters
	local anchor_id = {};

	if redirects_sfnref[parts[1]:lower()] then
		anchor_id[1] = 'CITEREF';
	else
		return nil;																-- not an sfnref or harvid template
	end
	
	local i = 2;																-- indexer into parts{} table
	local j = 2;																-- indexer into anchor_id{} table which already has 'CITEREF' at [1]
	while parts[i] and 7 &gt; j do													-- loop through what should be just positional parameters for names and year (2-6 four names and a date)
		if not parts[i]:find ('=') then											-- look for equal sign (named paraneter in a template that doesn't support named parameters)
			anchor_id[j] = parts[i];												-- positional parameters are saved
			j = j+1;															-- bump the anchor_id{} indexer
		end
		i = i+ 1;																-- bump the parts{} indexer
	end

	return table.concat (anchor_id, '');
end


--[[--------------------------&lt; D A T E _ G E T &gt;--------------------------------------------------------------

extract year from one of |year=, |date=, |publicationdate=, or |publication-date in that order.  Does not error
check (that is left to the cs1|2 templates to do)

also gets date from |&lt;date alias&gt;={{date|...}}

]]

local function date_get (template, aliases)
	local date;
	local rvalue;

	for _, pattern in ipairs (aliases) do										-- spin through the date alias patterns
		rvalue = tostring(template):match (pattern);							-- is this |&lt;date alias&gt;= used (tostring() because something makes match() think template is a table)
		if rvalue then
			rvalue = tostring(template):match (pattern .. '(%b{})');			-- is rvalue a template?
			if rvalue then
				rvalue = rvalue:gsub ('{{%s*(.-)%s*}}', '%1');					-- strip bounding template markup and trim
				local parts = mw.text.split (rvalue, '%s*|%s*');				-- split at the pipe and remove extraneous space characters

				if redirects_date[parts[1]:lower()] then						-- if parts[1] names {{date}} or redirect
					rvalue = parts[2];											-- assume that date template is properly formed, first positional parameter is the date
				else
					return '';													-- |date= holds some other template than {{date}} or redirect
				end
			else
				rvalue = template:match (pattern .. '([^|}]+)');
				if rvalue then													-- if rvalue is something
					rvalue = mw.text.trim (rvalue);								-- trim it
				end
				
				if not rvalue or '' == rvalue then								-- if rvale was nothing or trimed to nothing
					rvalue = nil;												-- ensure that it is unset so we can try the next parameter in the list
				end
			end

			if rvalue then
				for _, pattern in ipairs (patterns_date) do						-- spin through the recognized date formats
					date = rvalue:match (pattern);								-- attempt to extract year portion according to the pattern
					if date then
						return date;											-- matched so return;
					end
				end
				break;															-- found a date but it was malformed so abandon
			end
		end
	end

	return '';																	-- no date param or date param doesn't hold a recognized date; empty string for concatenation
end

 
--[[--------------------------&lt; V N A M E S _ G E T &gt;----------------------------------------------------------

extract names from |vauthors= or |veditors=; there is no |vcontributors= parameter.

splits the v parameter value at the comma; correctly handles accept-as-witten markup when used to wrap a comma-
separated names (corporate)

]]

local function vnames_get (params, vparam)
	local vnames = {};															-- first four author or editor names go here
	local split = {};															-- temp table to assist in decoding accept-as-witten-markup

	if params[vparam] then														-- test for |vauthors= or |veditor=
		split = mw.text.split (params[vparam], '%s*,%s*');						-- this will separate portions of ((Black, Brown, White, an Co.))
	
		local i = 1;															-- an indexer
		
		while split[i] do
			if split[i]:match ('^%(%(.*[^%)][^%)]$') then						-- first segment of comma-separated accept-as-witten; this segment has the opening doubled parens
				local name = split[i];
				i=i+1;															-- bump indexer to next segment
				while split[i] do
					name = name .. ', ' .. split[i];							-- concatenate with previous segments
					if split[i]:match ('^.*%)%)$') then							-- if this table member has the closing doubled parens
						break;													-- and done reassembling so
					end
					i=i+1;														-- bump indexer
				end
				table.insert (vnames, name);									-- and add accept-as-witten name to the vnames table
	
			else
				table.insert (vnames, split[i]);								-- and add name to the vnames table
			end
		i=i+1;																	-- bump indexer
		if 5 == i then break; end												-- limit to four names
		end

		for i, vname in ipairs (vnames) do
			if not vname:match ('%(%(.-%)%)') then								-- without accept-this-value-as-written markup
				vnames[i] = vname:gsub ('(.-)%s+%u+$', '%1');					-- extract and save surname(s)
			end
		end
		for i, vname in ipairs (vnames) do										-- repeat, this time for accept-this-value-as-written markup
			vnames[i] = vname:gsub ('%(%((.-)%)%)', '%1');						-- remove markup if present and save the whole name
		end
	end

	return 0 ~= #vnames and table.concat (vnames) or nil						-- return a concatenation of the vnames; nil else
end


--[[--------------------------&lt; N A M E S _ G E T &gt;------------------------------------------------------------

cs1|2 makes anchor id from contributor, author, or editor name-lists in that order

get the names from the cs1|2 template;  if there are no contributor names, try author names, then try editor names.

returns concatenated names in enumeration order when successful; nil else

empty name (nameholding parameter n is present without value) and missing name (nameholding parameter n is not
present) are included as empty string with all other names

]]

local function names_get (params, aliases_list)
	local names = {};															-- first four author or editor names go here
	local enum_alias;															-- alias with '#' replaced with a digit

	for enum=1, 4 do															-- four names only
		for i, alias in ipairs (aliases_list) do
			if not names[enum] then												-- hanven't found a previous alias with this [enum]? see if we can find this alias with this enum
				enum_alias = alias:gsub ('#', enum);							-- replace '#' to make 'lastn'
	
				if 1 == enum then												-- because |last= and last1= are exact aliases
					if params[enum_alias] then									-- test |last1= first
						names[enum] = params[enum_alias];						-- found so save the value assigned to |last1=
						break;													-- next enum
					else
						enum_alias = alias:gsub ('#', '');						-- replace '#' to make 'last'
						if params[enum_alias] then
							names[enum] = params[enum_alias];					-- found so save the value assigned to |last=
							break;												-- next enum
						end
					end
				else															-- here for enum 2, 3, 4
					if params[enum_alias] then
						names[enum] = params[enum_alias];						-- found so save the value assigned to |lastn=
						break;													-- next enum
					end
				end
			end
		end
	end

	for enum=1, 4 do															-- spin through the names table and
		local name = names[enum];
		if not name then														-- when nameholding parameter n is not present (nil)
			name = '';															-- convert to empty string for concatenation
		end
		name = name:gsub('%(%((.-)%)%)', '%1');									-- remove accept-as-written markup if present
		names[enum] = name;														-- save the modified name
	end

	local name_str = table.concat (names);										-- concatenate the names
	return '' ~= name_str and name_str or nil;									-- return the concatenation if not empty string; nil else
end


--[[--------------------------&lt; T E M P L A T E _ S T R I P &gt;--------------------------------------------------

removes the citation or havrc template's {{ and }} markup then removes, in whole, any templates found inside the
citation or harvc template.

Templates are not allowed in parameters that are made part of COinS metadata; yet, they will appear.  cs1|2 does
not see the template markup but instead sees the result of the template as html.  cs1|2 strips the html which
leaves the displayed value for the anchor id.  We can't do that here so, because templates aren't allowed in
parameters, we simply discard any templates found in the cs1|2 template.

this may leave a |lastn= parameter empty which will be treated as if it were really empty as cs1|2 do (three authors,
|last2= empty -&gt; CITEREFLast1Last3YYYY (the harv and sfn render: 'Last1, &amp; Last3 YYYY' with CITEREFLast1Last3YYYY).

]]

local function template_strip (template)
	template = template:gsub ('^{{', ''):gsub ('}}$', '', 1);					-- remove outer {{ and }} (cs1|2 template delimiters)
	template = template:gsub ('%b{}', '');										-- remove any templates from the cs1|2 template
	return template;
end


--[[--------------------------&lt; E S C A P E _ L U A _ M A G I C _ C H A R S &gt;----------------------------------

Returns a string where all of lua's magic characters have been escaped.  This is important because functions like
string.gsub() treat their pattern and replace strings as patterns, not literal strings.
]]

local function escape_lua_magic_chars (argument)
	argument = argument:gsub("%%", "%%%%");										-- replace % with %%
	argument = argument:gsub("([%^%$%(%)%.%[%]%*%+%-%?])", "%%%1");				-- replace all other lua magic pattern characters
	return argument;
end


--[=[-------------------------&lt; W I K I L I N K _ S T R I P &gt;--------------------------------------------------

Wikilink markup does not belong in an anchor id and can / does confuse the code that parses apart citation and
harvc templates so here we remove any wiki markup:
	[[link|label]] -&gt; label
	[[link]] -&gt; link
	
]=]

local function wikilink_strip (template)
	for wikilink in template:gmatch ('%[%b[]%]') do								-- get a wikilink
		template = template:gsub ('%[%b[]%]', '__57r1P__', 1);					-- install a marker
		if wikilink:match ('%[%[.-|(.-)%]%]') then
			wikilink = wikilink:match ('%[%[.-|(.-)%]%]');						-- extract label from complex [[link|label]] wikilink
		else
			wikilink = wikilink:match ('%[%[(.-)%]%]');							-- extract link from simple [[link]] wikilinks
		end
		wikilink = escape_lua_magic_chars (wikilink);							-- in case there are lua magic characters in wikilink
		template = template:gsub ('__57r1P__', wikilink, 1);					-- replace the marker with the appropriate text
	end

	return template;
end


--[[--------------------------&lt; T E M P L A T E _ N A M E _ G E T &gt;--------------------------------------------

return the citation or harvc template's name; convert to lower case and trim leading and trailing whitespace;

when the template is a sandbox the subpage portion of the template name is omitted from the returned template name
	{{Cite book/new |...}} returns cite book

]]

local function template_name_get (template)
	local template_name = template:match ('{{%s*([^/|]+)');						-- get template name; ignore subpages ~/new, ~/sandbox
	if not template_name then
		return nil;																-- could not get template name from (possibly corrupt) template; extraneous opening { mid template can cause this;
	end;
	template_name = template_name:gsub ('%s*$', '');							-- trim whitespace
	template_name = template_name:lower();										-- and lowercase only
	return template_name;
end


--[[--------------------------&lt; T E M P L A T E _ P A R A M S _ G E T &gt;----------------------------------------

parse apart a template's parameters and store in the params table where key is the parameter's name and value is
the parameter's value; empty parameters are not saved

]]

local function template_params_get (template, params)
	template = wikilink_strip (template);										-- because piped wikilinks confuse code that builds params{} and because wikilinks not allowed in an anchor id
																				-- strip templates after getting |ref= value because |ref={{sfnref}} and |ref={{harvid}} are allowed
	template = template_strip (template);										-- because template markup can confuse code that builds params{} and because templates in name parameters are not allowed

	template = template:gsub ('|%s*|', '|');									-- when pipe follows pipe with or without white space, remove extraneous pipe

	for param, value in template:gmatch ('|%s*([^=]-)%s*=%s*([^|}]+)') do		-- build a table of template parameters and their values
		if value then															-- there must be a value but when
			if '' ~= value and not value:match ('^%s$') then					-- skip when value is empty string or only whitespace
				params[param] = mw.text.trim (value);							-- add trimmed value else
			end
		end
	end
end


--[[--------------------------&lt; C I T E R E F _ M A K E _ H A R V C &gt;------------------------------------------

makes anchor_id from {{harvc}} or redirects

]]

local function anchor_id_make_harvc (template)
	local date = date_get (template, alias_patterns_harvc_date);						-- get date; done here because might be in {{date}}; return date if valid; empty string else
	local anchor_id;
	local params = {};															-- table of harvc parameters
	local id;																	-- custom anchor id for this {{harvc}} template

	id = template:match ('|%s*id%s*=%s*(%b{})');								-- in case |id={{sfnref}}; done here because templates will be stripped

	template_params_get (template, params);										-- build a table of template parameters and their values; this strips wikilinks and templates

	if id then																	-- when set is {{sfnref}} or {{harvid}} template
		return sfnref_get (id);													-- returns content of {{sfnref}} or {{harvid}}; nil else
	end
	if params.id then															-- custom anchor for this {{harvc}} template (text)
		return params.id;														-- |id= value as written
	end
	
	anchor_id = names_get (params, aliases_harvc_author);							-- get the harvc contributor names

	if anchor_id then																-- if names were gotten
		return 'CITEREF' .. anchor_id .. date;
	end
	return nil;																	-- no names; no anchor_id
end


--[[--------------------------&lt; C I T E R E F _ M A K E &gt;------------------------------------------------------

inspect |ref= to decide what to do:
	|ref=										- empty or missing: get names and date from template parameters because all cs1|2 will soon create CITEREF anchor IDs
	|ref=harv									- get names and date from template parameters
	|ref={{SfnRef|name|name|name|name|year}}	- assemble an anchor id from {{sfnref}} positional parameters
	|ref={{Harvid|name|name|name|name|year}}	- assemble an anchor id from {{harvid}} positional parameters
	|ref=none									- skip; do nothing because an anchor id intentionally suppressed; TODO: keep with a type code of '0'?
	|ref=&lt;text&gt;									- save param value because may match an anchor id override value in {{harv}} template |ref= parameter or {{harvc}} |id= parameter

this no longer applies; all cs1|2 will soon create CITEREF anchor IDs
	|ref=										- empty or missing
													for cs1: skip
														if |mode=cs2: spoof |ref=harv
													for cs2: get names and date from template parameters
														if |mode=cs1: skip

]]

local function anchor_id_make (template)
	local ref;																	-- content of |ref=
	local template_name;														-- name of the template for cs2 detection
	local anchor_id;															-- the assembled anchor id from this template
	local date;
	local params = {};															-- table of cs1|2 parameters
	
	template_name = template_name_get (template);								-- get lowercase trimmed template name; ignore subpages ~/new, ~/sandbox
	if not template_name or template_skip[template_name] then
		return nil;																-- could not extract template name from (possibly corrupted) template (extraneous opening { in the template will cause this)
	end

	if redirects_patent[template_name] then
		date = date_get (template, alias_patterns_patent_date);						-- get date; done here because might be in {{date}} 
	else
		date = date_get (template, alias_patterns_date);
	end
	
	ref = template:match ('|%s*ref%s*=%s*(%b{})');								-- first look for |ref={{sfnref}} or |ref={{harvid}} because we will strip templates from the cs1|2 template
	if not ref then
		if template:match ('|%s*ref%s*=([^|}]+)') then							-- |ref={{template}} not found; if there is a |ref= param with an assigned value
			ref = template:match ('|%s*ref%s*=([^|}]+)');						-- get the value; whitespace is a 'value'
			if ref then															-- nil when |ref=|... or when |ref=}} (no spaces between assignment operator and pipe or closing brace)
				ref = mw.text.trim (ref);										-- something, could be just whitespace, so trim leading / trailing whitespace
				if '' == ref then												-- trimming a string of whitespace makes an empty string
					ref = nil;													-- make empty ref same as missing ref
				end
			end
		end

-- this disabled because all cs1|2 templates will create CITEREF anchor IDs after next cs1|2 module-suite update
--		if not ref then															-- here when |ref= missing or empty
--			if redirects_citation[template_name] then							-- could be cs2
--				if template:match ('|%s*mode%s*=%s*cs1') then
--					return nil;													-- |ref= missing or empty; citation template but |mode=cs1
--				else
--					ref = 'harv';												-- spoof to handle cs2 as if it were cs1 with |ref=harv
--				end
--			else																-- |ref= missing or empty; not a cs2 template
--				if template:match ('|%s*mode%s*=%s*cs2') then
--					ref = 'harv';												-- |ref= missing or empty; not a cs2 template; |mode=cs2; spoof as if it were cs1 with |ref=harv
--				end
--			end
--		end
	end

	template_params_get (template, params);										-- build a table of template parameters and their values

	if not ref then																-- |ref= not set, might be cite LSA which doesn't support |ref=
		if 'cite lsa' == template_name then
			return 'CITEREF' .. (params.last or '') .. (params.year or '');		-- cite LSA always creates an anchor id using only |last= and |year= (no aliases)
		end
-- all cs1|2 templates will create CITEREF anchor IDs after next cs1|2 module-suite update so keep going
--		return nil;																-- not cite LSA so done
	end

	if 'harv' == ref  or not ref then											-- |ref=harv specified or |ref= missing or empty (new cs1|2 default is not default for other templates handled here)
		if redirects_patent[template_name] then									-- if this is a cite patent template
			anchor_id = names_get (params, aliases_inventor);					-- inventor names only
		else																	-- cs1|2 template
			anchor_id = names_get (params, aliases_contributor) or				-- get contributor, author, or editor names
				names_get (params, aliases_author) or
				vnames_get (params, 'vauthors') or								-- |vauthors=
				names_get (params, aliases_editor) or
				vnames_get (params, 'veditors');								-- |veditors=
		end

		if anchor_id then														-- if names were gotten
			anchor_id = 'CITEREF' .. anchor_id .. date;
		end

	elseif ref:match ('%b{}') then												-- ref holds a template
		anchor_id = sfnref_get (ref);											-- returns content of {{sfnref}} or {{harvid}}; nil else

	elseif 'none' == ref and not redirects_patent[template_name] then			-- |ref=none; not supported by cite patent
		return nil;																-- anchor id expicitly suppressed
		
--	elseif '' ~= ref then	 -- ref is never empty string here					-- |ref=&lt;text&gt;
	else
		anchor_id = ref;														-- |ref=&lt;text&gt; may match an anchor id override value in {{harv}} template |ref= parameter
	end
	
	return anchor_id;															-- anchor_id text; nil else
end


--[[--------------------------&lt; L I S T _ A D D &gt;--------------------------------------------------------------

adds an item to the list table; for anchor IDs, the boolean encode argument must be set true; no return value

]]

local function list_add (item, list, encode)
	if item then																-- if there was an anchor id extracted
		if encode then															-- for anchor IDs ...
			item = mw.uri.anchorEncode (item);									-- encode to remove wikimarkup, convert spaces to underscores etc
		end
		
		if not list[item] then									-- if not already saved
			list[item] = 1;										-- save it 
		else																	-- here when this anchor id already saved
			list[item] = list[item] + 1;			-- to indicate that there are multiple same name/date citations
		end
	end
end


--[[--------------------------&lt; A N C H O R _ I D _ M A K E _ A N C H O R &gt;------------------------------------

make anchor IDs from {{anchor}}; there may be more than one because {{anchor}} is not limited to the number of
anchors it may hold.

]]

local function anchor_id_make_anchor (template, anchor_id_list)
	template = template:gsub ('^{{', ''):gsub ('}}$', '', 1);					-- remove outer {{ and }} (anchor template delimiters)
	template = template:gsub ('^[^|]+|', '');									-- remove template name and first pipe
	template = wikilink_strip (template);										-- strip any wikilink markup (there shouldn't be any but just in case)
	
	local params = {};
	local anchor_id;
	
	for param in template:gmatch ('%b{}') do									-- loop through the template; remove and save templates (presumed to sfnref or harvid)
		table.insert (params, param);											-- save it
		template = template:gsub ('%b{}', '', 1);								-- remove it from source template
	end
	
	for _, t in ipairs (params) do												-- spin through the templates in params
		anchor_id = sfnref_get (t);												-- attempt to decode {{sfnref}} and {{harvid}}
		if anchor_id then														-- nil when not {{sfnref}} and {{harvid}}
			list_add (anchor_id, anchor_id_list, true);							-- add anchor ID to the list
		end
	end
	
	template = template:gsub ('|%s*|', '|');									-- when pipe follows pipe with or without white space, remove extraneous pipe
	template = template:gsub ('^|', ''):gsub('|$', '');							-- remove extraneous leading and trailing pipes

	params = mw.text.split (template, '%s*|%s*');								-- split at the pipe and remove extraneous space characters
	
	for _, t in ipairs (params) do												-- spin through the anchor IDs
		anchor_id = mw.text.trim (t);											-- trim white space
		if '' ~= anchor_id then													-- should always have something
			list_add (anchor_id, anchor_id_list, true);							-- add anchor ID to the list
		end
	end
end


--[[--------------------------&lt; C I T E R E F _ L I S T _ M A K E &gt;--------------------------------------------

makes a list of anchor ids from cs1|2, cs1|2-like, vcite xxx, and harvc templates

Because cs1|2 wrapper templates can, and often do, hide |ref=, the author and date parameters inside the wrapper,
these parameters are not available in the article's wikisource so {{harv}}, {{sfn}}, and {{harvc}} templates that
link correctly to those wrapper templates will incorrectly show error messages.  Use |ignore-err=yes in the {{harv}},
{{sfn}}, and {{harvc}} templates to supress the error message.

]]

local function anchor_id_list_make ()
	article_content_get ();														-- attempt to get this article's content

	if '' == Article_content then												-- when there is no article content
		return '';																-- no point in continuing
	end
	
	local template;																-- place to hold the template that we found
	local anchor_id;															-- place to hold an anchor id as it is extracted / decoded
	local tstart, tend = Article_content:find ('{{%s*[Cc]it[ae]');				-- find the first cs1|2-like template

	while tstart do																-- nil when cs1|2 template not found
		template = Article_content:match ('%b{}', tstart);						-- get the whole template

		if template then														-- necessary?
			anchor_id = anchor_id_make (template);								-- extract an anchor id from this template
			list_add (anchor_id, anchor_id_list, true)
		end
		tstart = tend;															-- reset the search starting index
		tstart, tend = Article_content:find ('{{%s*[Cc]it[ae]', tstart);		-- search for another cs1|2 template
	end

	for _, pattern in ipairs (redirect_patterns_harvc) do
		tstart, tend = Article_content:find (pattern);							-- find the first harvc template
	
		while tstart do															-- nil when harvc template not found
			template = Article_content:match ('%b{}', tstart);					-- get the whole template
	
			if template then													-- necessary?
				anchor_id = anchor_id_make_harvc (template);					-- extract an anchor id from this template
				list_add (anchor_id, anchor_id_list, true);
			end
			tstart = tend;														-- reset the search starting index
			tstart, tend = Article_content:find (pattern, tstart);				-- search for another harvc template
		end
	end

	for _, pattern in ipairs (redirect_patterns_vcite) do						-- for each of the vcite family template base patterns
		tstart, tend = Article_content:find (pattern);							-- find the first vcite template
	
		while tstart do															-- nil when vcite template not found
			template = Article_content:match ('%b{}', tstart);					-- get the whole template
	
			if template then													-- necessary?
				local ref = template:match ('|%s*ref%s*=%s*(%b{})');			-- first look for |ref={{sfnref}} or |ref={{harvid}} because we will strip templates from the vcite template
				if ref then														-- |ref={{template}}
					anchor_id = sfnref_get (ref);									-- returns content of {{sfnref}} or {{harvid}}; nil else
					list_add (anchor_id, anchor_id_list, true);
				else
					local params = {};
					local template_name = template_name_get (template);			-- get lowercase trimmed template name; ignore subpages ~/new, ~/sandbox

					template_params_get (template, params);						-- build a table of template parameters and their values

					anchor_id = params['ref'];									-- when both set, vcite uses value from |ref=
					if not anchor_id and params['harvid'] then
						anchor_id = 'CITEREF' .. params['harvid'];				-- in vcite, |harvid= auto-adds 'CITEREF' prefix to the value in |harvid=
					end
					list_add (anchor_id, anchor_id_list, true);
				end
			end

			tstart = tend;														-- reset the search starting index
			tstart, tend = Article_content:find (pattern, tstart);				-- search for another vcite template
		end
	end
	
	tstart, tend = Article_content:find ('{{%s*[Ww]ikicite');					-- find the first {{wikicite}} template

	while tstart do																-- nil when cs1|2 template not found
		template = Article_content:match ('%b{}', tstart);						-- get the whole template

		if template then
			local ref = template:match ('|%s*ref%s*=%s*(%b{})');				-- first look for |ref={{sfnref}} or |ref={{harvid}}
			
			if ref then
				anchor_id = sfnref_get (ref);
	
			elseif template:match ('|%s*ref%s*=([^|}]+)') then
				anchor_id = template:match ('|%s*ref%s*=([^|}]+)');				-- plain-text
	
			elseif template:match ('|%s*id%s*=%s*(%b{})') then
				anchor_id = template:match ('|%s*id%s*=%s*(%b{})');
	
			elseif template:match ('|%s*id%s*=([^|}]+)') then
				anchor_id = 'Reference-' .. template:match ('|%s*id%s*=([^|}]+)');	-- plain-text

			else
				anchor_id = nil;												-- no matches, ensure that anchor_id has no value
			end
			
			if anchor_id then
				list_add (anchor_id, anchor_id_list, true);
			end
		end
		tstart = tend;															-- reset the search starting index
		tstart, tend = Article_content:find ('{{%s*[Ww]ikicite', tstart);		-- search for another cs1|2 template
	end
	
	for _, pattern in ipairs (redirect_patterns_anchor) do
		tstart, tend = Article_content:find (pattern);							-- find the first anchor template
	
		while tstart do															-- nil when anchor template not found
			template = Article_content:match ('%b{}', tstart);					-- get the whole template
	
			if template then													-- necessary?
				anchor_id_make_anchor (template, anchor_id_list);				-- extract anchor ids from this template if any
			end
			tstart = tend;														-- reset the search starting index
			tstart, tend = Article_content:find (pattern, tstart);				-- search for another anchor template
		end
	end


mw.logObject (anchor_id_list, 'anchor_id_list')
	return anchor_id_list;
end


--[[--------------------------&lt; T E M P L A T E _ L I S T _ M A K E &gt;------------------------------------------

makes a list of templates use in the article.

]]

local Lang_obj = mw.language.getContentLanguage();

local function template_list_make ()
	article_content_get ();														-- attempt to get this article's content

	if '' == Article_content then												-- when there is no article content
		return '';																-- no point in continuing
	end

	local template_list = {};
	
	for template in Article_content:gmatch ('{{%s*(.-)[|}]') do
		if template and not template:match ('^#') then							-- found a template or magic word; ignore magic words
			template=mw.text.trim (template);									-- trim whitespace
			template = Lang_obj:ucfirst (template);								-- first character in template name must be uppercase (same as canonical template name)
			list_add (template, template_list);									-- add to list with (unused) tally
		end
	end
	
mw.logObject (template_list, 'template_list')
	return template_list;
end


--[[--------------------------&lt; A R T I C L E _ L O C A L _ W H I T E L I S T _ M A K E &gt;----------------------

makes a list of templates use in the article.

]]

local function article_local_whitelist_make ()
	article_content_get ();														-- attempt to get this article's content

	if '' == Article_content then												-- when there is no article content
		return '';																-- no point in continuing
	end

	local article_whitelist = {};
	local tstart, tend;
	local template;
	
	for _, pattern in ipairs (redirect_patterns_sfn_whitelist) do
		tstart, tend = Article_content:find (pattern);							-- find the first whitelist template
	
		while tstart do															-- nil when whitelist template not found
			template = Article_content:match ('%b{}', tstart);					-- get the whole template
	
			if template then													-- necessary?
				template = template:gsub (pattern, ''):gsub ('}}$', '', 1);		-- remove outer {{ and }} and template name
				template = mw.text.trim (template, '%s|');						-- trim leading trailing white space and pipes
				template = mw.text.split (template, '%s*|%s*');					-- make a table of the template's parameters

				for _, anchor_id in ipairs (template) do						-- spin through this template's parameter
					if '' ~= anchor_id and not article_whitelist[anchor_id] then
						article_whitelist[anchor_id] = 1;						-- add to the whitelist
					end
				end
			end
			tstart = tend;														-- reset the search starting index
			tstart, tend = Article_content:find (pattern, tstart);				-- search for another whitelist template
		end
	end

mw.logObject (article_whitelist, 'article_whitelist')
	return article_whitelist;
end


--[[--------------------------&lt; E X P O R T E D _ T A B L E S &gt;------------------------------------------------
]]

return {
	anchor_id_list = anchor_id_list_make(),										-- table of anchor ids available in this article
	article_whitelist = article_local_whitelist_make(),							-- table of anchor ids with false-positive error message to be suppressed
	template_list = template_list_make(),										-- table of templates used in this article
	}</text>
      <sha1>iu4r50ro0xl6drrj55fln0czanpkvfd</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Footnotes/whitelist</title>
    <ns>828</ns>
    <id>63517642</id>
    <revision>
      <id>954481219</id>
      <parentid>954128975</parentid>
      <timestamp>2020-05-02T17:03:18Z</timestamp>
      <contributor>
        <username>Jonesey95</username>
        <id>9755426</id>
      </contributor>
      <comment>add Catholic Encyclopedia</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="48125" xml:space="preserve">--[[--------------------------&lt; T E M P L A T E _ N A M E S &gt;--------------------------------------------------

This table holds the names of templates and the names of their redirects.  Template names must be written exactly
as they are named at their templatespace page.  This same also applies to redirects.

The indexes in this table are not critical but should be short and concise.

]]

local template_names = {
	['al-Tabari'] = {'The History of al-Tabari', 'The History of Al-Tabari', 'The History of al-Ṭabarī'},
	['Butt_Stations'] = {'Butt-Stations', 'Butt-stations'},
	['Cam_Hist_Iran'] = {'Cambridge History of Iran', 'The Cambridge History of Iran'},
	['Catholic'] =  {'Catholic Encyclopedia', 'Catholic encyclopedia', '1913Catholic', 'CatholicEncyclopedia', 'CE1913', 'Catholic', 'CE13', 'Cite Catholic Encyclopedia', 'CathEncy', 'Cite Catholic Encyclopædia', 'Cite CE1913'},
	['DNB'] = {'Cite DNB', 'DNB', 'DNB Cite', 'Cite DNBSupp', 'DNBSupp', 'Cite DNB12', 'Cite DNBIE', 'DNB12', 'DNBIE'},
	['EB1911'] =  {'EB1911', 'Cite EB1911', '1911'},
	['ODLA'] = {'ODLA', 'Oxford Dictionary of Late Antiquity'}
	}


--[[--------------------------&lt; S P E C I A L _ P A T T E R N S &gt;----------------------------------------------

Lua patterns.  These are scanned sequentially which costs time and processing far and above the time and processing
needed to index into whitelist{}.  Do not create a pattern here if a normal whitelist entry or entries can be created.

]]

local special_patterns = {
	'CITEREFACAD%u%u%u?%u?%d+%u%u?',															-- {{Acad}} ID appears to be 2-4 letters, then 3 numbers, then 1-2 letters
	'CITEREFAHD%d+',															-- {{Cite AHD}}
	'CITEREFHistoric_England%d+',												-- {{National Heritage List for England}} &amp; {{PastScape}}
	'CITEREFHistoric_Environment_Scotland%u%u%u?%u?%d',							-- {{Historic Environment Scotland}} %u can be BTL, GLD, HMPA, LB, SM
	'CITEREFQHR%d+',															-- {{Cite QHR}}
	}


--[[--------------------------&lt; D N B _ S P E C I A L _ P A T T E R N S &gt;--------------------------------------

Lua patterns.  Note at special_patterns applies.  These for the DNB templates only; these will be tried only when
there is a DNB template in the article.

Pretty much any author name during the period 1885–1901 inclusive, and 1912.

The DNBIE was published in 1903, and Template:DNBIE says that its use is deprecated, but we do not fight that battle here.

]]

local DNB_special_patterns = {
	'CITEREF%a[%a%-_\']*188[5-9]',												-- 1885–1889
	'CITEREF%a[%a%-_\']*189%d',													-- 1890–1899
	'CITEREF%a[%a%-_\']*190[0-1]',												-- 1900–1901
	'CITEREF%a[%a%-_\']*1903',												-- 1903 IE
	'CITEREF%a[%a%-_\']*1912',													-- 1912 supplement
	}


--[[--------------------------&lt; W H I T E L I S T &gt;------------------------------------------------------------

This is a list of anchor IDs known to be associated with specific wrapper templates.  The anchor ID serves as an
index into the table.  The assigned value is another table that lists the associate template and any redirects.

Except for year disambiguators, anchor IDs must have the same form as the anchor creator makes; must be the
anchor-encoded form.  Remove the year disambiguator.

Template names must be written exactly as they are named at their templatespace page.  This same also applies to
redirects.  Module:Footnotes reads the template names left to right so most-commonly-used template or redirect name
should appear first.  When there are more than one name and when those templates have various anchor IDs the template
namelist should be added to the template_names{} table.

Note that references to Template:EB1911 are listed under "E" in the alphabetical list below to keep them organized.

]]

local whitelist = {
----------&lt; A &gt;----------
	['CITEREFA\'Becket1907'] = {'Cite CE1913'},
	['CITEREFAdamson1878'] = {'Cite EB9'},
	['CITEREFAGA_1884–1897'] = {'Schubert\'s compositions (references)'},
	['CITEREFAhrons1927'] = {'Book-Ahrons-British Steam Railway Locomotive'},
	['CITEREFAl-Imad2015'] = {'EI3'},
	['CITEREFAl-Tabari1985–2007'] = template_names['al-Tabari'],
	['CITEREFAlbert_Schumann1886'] = {'Cite ADB'},
	['CITEREFAldrich1969'] = {'Aldrich-LocosGER7'},
	['CITEREFAllenBoddyBrownFry1970'] = {'RCTS-LocosLNER-8A'},
	['CITEREFAllenBoddyBrownFry1971'] = {'RCTS-LocosLNER-8B'},
	['CITEREFAllenBoddyBrownFry1983'] = {'RCTS-LocosLNER-8A'},
	['CITEREFAmerican_Railway_Association1922'] = {'1922 Locomotive Cyclopedia'},
	['CITEREFATOC2009'] = {'ATOCConnectingCommunitiesReportS10'},
	['CITEREFAvdoyan2018'] = template_names['ODLA'],
	['CITEREFAwdry1990'] = {'Awdry-RailCo', 'Carnarvonshire Railway'},

----------&lt; B &gt;----------
	['CITEREFBabinger1978'] = {'Mehmed the Conqueror and His Time'},
	['CITEREFBabinger1992'] = {'Mehmed the Conqueror and His Time'},
	['CITEREFBaltzer1916'] = {'Baltzer-Kolonialbahnen'},
	['CITEREFBaxter1971'] = {'Baxter-BritishLocoCat1'},
	['CITEREFBaxter1977'] = {'Baxter-BritishLocoCat1'},
	['CITEREFBaxter1978'] = {'Baxter-BritishLocoCat2A'},
	['CITEREFBaxter1979'] = {'Baxter-BritishLocoCat2B'},
	['CITEREFBaxter1982'] = {'Baxter-BritishLocoCat3A', 'Baxter-BritishLocoCat3B'},
	['CITEREFBaxter1984'] = {'Baxter-BritishLocoCat4'},
	['CITEREFBaxter1986'] = {'Baxter-BritishLocoCat5A'},
	['CITEREFBaxter1988'] = {'Baxter-BritishLocoCat5B'},
	['CITEREFBaxter2012'] = {'Baxter-BritishLocoCat6'},
	['CITEREFBaynes1878'] = {'Cite EB9'},
	['CITEREFBennett2007'] = {'ODNB'},
	['CITEREFBezilla1980'] = {'Bezilla-PRR-Electric-Traction'},
	['CITEREFBivar1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFBlankinship1989'] = template_names['al-Tabari'],
	['CITEREFBlankinship1993'] = template_names['al-Tabari'],
	['CITEREFBlankinship1994'] = {'The End of the Jihâd State', 'The End of the Jihad State'},
	['CITEREFBock1978'] = {'Audie-bock-directors'},
	['CITEREFBoddyBrownFryHennigan1968'] = {'RCTS-LocosLNER-4'},
	['CITEREFBoddyBrownFryHennigan1975'] = {'RCTS-LocosLNER-2B'},
	['CITEREFBoddyBrownFryHennigan1977'] = {'RCTS-LocosLNER-9A', 'RCTS-LocosLNER-9B'},
	['CITEREFBoddyBrownFryHennigan1979'] = {'RCTS-LocosLNER-3A'},
	['CITEREFBoddyBrownHenniganHoole1984'] = {'RCTS-LocosLNER-6C'},
	['CITEREFBoddyBrownHenniganNeve1981'] = {'RCTS-LocosLNER-3B'},
	['CITEREFBoddyBrownNeveYeadon1983'] = {'RCTS-LocosLNER-6B'},
	['CITEREFBoddyFryHenniganHoole1990'] = {'RCTS-LocosLNER-10B'},
	['CITEREFBoddyFryHenniganProud1963'] = {'RCTS-LocosLNER-1'},
	['CITEREFBoddyNeveYeadon1973'] = {'RCTS-LocosLNER-2A'},
	['CITEREFBody1989'] = {'Body-Railways-Vol2'},
	['CITEREFBon1969'] = {'La Morée franque'},
	['CITEREFBonner2010'] = {'New Cambridge History of Islam'},
	['CITEREFBooth2000'] = {'Shakespeare sonnets bibliography'},
	['CITEREFBossert1914'] = {'Schaff-Herzog'},
	['CITEREFBosworth1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFBosworth1987'] = template_names['al-Tabari'],
	['CITEREFBosworth1989'] = template_names['al-Tabari'],
	['CITEREFBosworth1991'] = template_names['al-Tabari'],
	['CITEREFBosworth1999'] = template_names['al-Tabari'],
	['CITEREFBosworth2013'] = {'EI3'},
	['CITEREFBoyd1970'] = {'Boyd-MidWales'},
	['CITEREFBoyd1975'] = {'Boyd-FR1'},
	['CITEREFBoyd1985'] = {'Boyd-NCaerns2Penrhyn'},
	['CITEREFBoyd1986'] = {'Boyd-NCaerns3Dinorwic'},
	['CITEREFBoyd1988'] = {'Boyd-SCaerns1'},
	['CITEREFBoyd1989'] = {'Boyd-SCaerns2'},
	['CITEREFBoyd1990'] = {'Boyd-NCaerns1'},
	['CITEREFBradshaw1985'] = {'Bradshaw-1922July'},
	['CITEREFBradshaw1968'] = {'Bradshaw-1910April'},
	['CITEREFBradshaw2011'] = {'Bradshaw-1895December'},
	['CITEREFBradshaw2012'] = {'Bradshaw-1850March'},
	['CITEREFBrand1968'] = {'Byzantium Confronts the West'},
	['CITEREFBray2010'] = {'Bray-SDJR'},
	['CITEREFBrett2010'] = {'New Cambridge History of Islam'},
	['CITEREFBrinner1986'] = template_names['al-Tabari'],
	['CITEREFBrinner1991'] = template_names['al-Tabari'],
	['CITEREFBrock1908'] = {'Cite CE1913'},
	['CITEREFBrockett1997'] = template_names['al-Tabari'],
	['CITEREFBrunner1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFBrunner1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFBryan1886'] = {'Bryan (3rd edition)'},
	['CITEREFBunsen1878'] = {'Cite EB9'},
	['CITEREFBurch1911'] = {'Burch Electric Traction'},
	['CITEREFBurke1866'] = {'O\'Donnell family tree'},
	['CITEREFBurrowsWallace1999'] = {'Cite gotham'},
	['CITEREFButt1995'] = template_names['Butt_Stations'],


----------&lt; C &gt;----------
	['CITEREFCalifornia1988'] = {'CA-Rail Passenger Development Plan-1988'},
	['CITEREFCanepa2018'] = {'ODLA'},
	['CITEREFCanny2008'] = {'O\'Donnell family tree'},
	['CITEREFCaro1974'] = {'Cite Power Broker'},
	['CITEREFCasserley1968'] = {'Casserley-joint'},
	['CITEREFCasserleyJohnston1966'] = {'Casserley-LocoGrouping3'},
	['CITEREFCasserleyJohnston1974'] = {'Casserley-LocoGrouping3', 'Casserley-LocoGrouping2', '0-7110-0554-0'},
	['CITEREFCasway1984'] = {'O\'Donnell family tree'},
	['CITEREFChaléardChanson-JabeurBéranger2006'] = {'Chaléard-Le cdf en Afrique'},
	['CITEREFCheyneBlack1899'] = {'Cite Biblica'},
	['CITEREFCheyneBlack1901'] = {'Cite Biblica'},
	['CITEREFCheyneBlack1902'] = {'Cite Biblica'},
	['CITEREFCheyneBlack1903'] = {'Cite Biblica'},
	['CITEREFChurchman_&amp;amp;_Hurst2001'] = {'Churchman &amp; Hurst Railways of New Zealand'},
	['CITEREFChurella2013'] = {'Churella-PRR-1'},
	['CITEREFClementsMcMahon2008'] = {'ClementsMcMahon-GSR Locomotives'},
	['CITEREFClinker1978'] = {'Clinker-Stations'},
	['CITEREFClinker1988'] = {'Clinker-Stations'},
	['CITEREFClugnet1908'] = {'Cite CE1913'},
	['CITEREFCoates1990'] = {'Coates-Reading'},
	['CITEREFConolly1998'] = {'IanAllan-PreGroup-Atlas1998'},
	['CITEREFCoulthard-Clark2002'] = {'Australian Dictionary of Biography'},
	['CITEREFCousin1910'] = {'A Short Biographical Dictionary of English Literature', 'Cite SBDEL'},
	['CITEREFCox1967'] = {'Cox-Upper Darby'},
	['CITEREFCox2011'] = {'Cox-Dixie'},
	['CITEREFCrone1980'] = {'Slaves on Horses'},
	['CITEREFCroughtonKidnerYoung1982'] = {'Croughton-PrivateStations'},
	['CITEREFCudahy2002'] = {'Cudahy-Hudson'},
	['CITEREFCudahy2003'] = {'Cudahy-Subways'},


----------&lt; Catholic Encyclopedia &gt;----------

	['CITEREFArendzen1913'] = template_names['Catholic'],
	['CITEREFBacchus1913'] = template_names['Catholic'],
	['CITEREFBandelier1913'] = template_names['Catholic'],
	['CITEREFBechtel1910'] = template_names['Catholic'],
	['CITEREFBecket1913'] = template_names['Catholic'],
	['CITEREFBeecher1913'] = template_names['Catholic'],
	['CITEREFBenigni1909'] = template_names['Catholic'],
	['CITEREFBenigni1912'] = template_names['Catholic'],
	['CITEREFBesse1907'] = template_names['Catholic'],
	['CITEREFBoudinhon1910'] = template_names['Catholic'],
	['CITEREFBoudinhon1913'] = template_names['Catholic'],
	['CITEREFBraun1912'] = template_names['Catholic'],
	['CITEREFBurton1908'] = template_names['Catholic'],
	['CITEREFBurton1913'] = template_names['Catholic'],
	['CITEREFCabrol1911'] = template_names['Catholic'],
	['CITEREFCamm1908'] = template_names['Catholic'],
	['CITEREFChapman1909'] = template_names['Catholic'],
	['CITEREFClifford1907'] = template_names['Catholic'],
	['CITEREFCoghlan1913'] = template_names['Catholic'],
	['CITEREFColeman1907'] = template_names['Catholic'],
	['CITEREFD\'Alton1913'] = template_names['Catholic'],
	['CITEREFDelamarre1913'] = template_names['Catholic'],
	['CITEREFDevine1913'] = template_names['Catholic'],
	['CITEREFDinneen1909'] = template_names['Catholic'],
	['CITEREFDonovan1913'] = template_names['Catholic'],
	['CITEREFDorin1972'] = {'Dorin-North Western'},
	['CITEREFDrum1913'] = template_names['Catholic'],
	['CITEREFDégert1909'] = template_names['Catholic'],
	['CITEREFFalkiner1901'] = template_names['Catholic'],
	['CITEREFFallow1911'] = template_names['Catholic'],
	['CITEREFFanning1907'] = template_names['Catholic'],
	['CITEREFFanning1908'] = template_names['Catholic'],
	['CITEREFFenlon1910'] = template_names['Catholic'],
	['CITEREFFenlon1913'] = template_names['Catholic'],
	['CITEREFFord1912'] = template_names['Catholic'],
	['CITEREFForget1910'] = template_names['Catholic'],
	['CITEREFFortescue1908'] = template_names['Catholic'],
	['CITEREFFortescue1909'] = template_names['Catholic'],
	['CITEREFFortescue1912'] = template_names['Catholic'],
	['CITEREFGerard1913'] = template_names['Catholic'],
	['CITEREFGietmann1908'] = template_names['Catholic'],
	['CITEREFGildas1907'] = template_names['Catholic'],
	['CITEREFGruber1910'] = template_names['Catholic'],
	['CITEREFHealy1912'] = template_names['Catholic'],
	['CITEREFHenry1913'] = template_names['Catholic'],
	['CITEREFHerbermann1908'] = template_names['Catholic'],
	['CITEREFHerbermann1913'] = template_names['Catholic'],
	['CITEREFHind1913'] = template_names['Catholic'],
	['CITEREFHofmann1911'] = template_names['Catholic'],
	['CITEREFHogan1913'] = template_names['Catholic'],
	['CITEREFHughes1915'] = template_names['Catholic'],
	['CITEREFHunt1913'] = template_names['Catholic'],
	['CITEREFJenner1907'] = template_names['Catholic'],
	['CITEREFJenner1909'] = template_names['Catholic'],
	['CITEREFKellyOjetti1908'] = template_names['Catholic'],
	['CITEREFKennedy1913'] = template_names['Catholic'],
	['CITEREFKirsch1908'] = template_names['Catholic'],
	['CITEREFKirsch1911'] = template_names['Catholic'],
	['CITEREFLeclercq1910'] = template_names['Catholic'],
	['CITEREFLejay1913'] = template_names['Catholic'],
	['CITEREFLöffler1912'] = template_names['Catholic'],
	['CITEREFMann1909'] = template_names['Catholic'],
	['CITEREFMcMahon1913'] = template_names['Catholic'],
	['CITEREFMcNeill1911'] = template_names['Catholic'],
	['CITEREFMershman1912'] = template_names['Catholic'],
	['CITEREFMooney1913'] = template_names['Catholic'],
	['CITEREFMyers1910'] = template_names['Catholic'],
	['CITEREFOestreich1907'] = template_names['Catholic'],
	['CITEREFOtt1909'] = template_names['Catholic'],
	['CITEREFOtt1910'] = template_names['Catholic'],
	['CITEREFOtt1911'] = template_names['Catholic'],
	['CITEREFOtt1912'] = template_names['Catholic'],
	['CITEREFOtt1913'] = template_names['Catholic'],
	['CITEREFPlassmann1913'] = template_names['Catholic'],
	['CITEREFPolle1909'] = template_names['Catholic'],
	['CITEREFPétridès1910'] = template_names['Catholic'],
	['CITEREFPétridès1911'] = template_names['Catholic'],
	['CITEREFRemy1910'] = template_names['Catholic'],
	['CITEREFRobinson1910'] = template_names['Catholic'],
	['CITEREFRock1909'] = template_names['Catholic'],
	['CITEREFRudge1910'] = template_names['Catholic'],
	['CITEREFScannell1909'] = template_names['Catholic'],
	['CITEREFSchrantz1908'] = template_names['Catholic'],
	['CITEREFSchweitzer1913'] = template_names['Catholic'],
	['CITEREFSeroczynski1911'] = template_names['Catholic'],
	['CITEREFShahan1907'] = template_names['Catholic'],
	['CITEREFShahan1908'] = template_names['Catholic'],
	['CITEREFShahan1913'] = template_names['Catholic'],
	['CITEREFSicard1907'] = template_names['Catholic'],
	['CITEREFSinclair1911'] = template_names['Catholic'],
	['CITEREFSollier1907'] = template_names['Catholic'],
	['CITEREFSollier1908'] = template_names['Catholic'],
	['CITEREFSollier1913'] = template_names['Catholic'],
	['CITEREFSouvay1913'] = template_names['Catholic'],
	['CITEREFSpillane1913'] = template_names['Catholic'],
	['CITEREFThurston1908'] = template_names['Catholic'],
	['CITEREFTierney1909'] = template_names['Catholic'],
	['CITEREFTierney1913'] = template_names['Catholic'],
	['CITEREFVailhé1912'] = template_names['Catholic'],
	['CITEREFVenice:_Catholic_Encyclopedia'] = template_names['Catholic'],
	['CITEREFWainewright1910'] = template_names['Catholic'],
	['CITEREFWalsh1913'] = template_names['Catholic'],
	['CITEREFWeber1912'] = template_names['Catholic'],
	['CITEREFWeber1913'] = template_names['Catholic'],

----------&lt; D &gt;----------
	['CITEREFDaftary1990'] = {'Daftary-The Ismailis'},
	['CITEREFDaftary2007'] = {'Daftary-The Ismailis'},
	['CITEREFDanielsDench1963'] = {'Daniels-NoMore'},
	['CITEREFDanielsDench1973'] = {'Daniels-NoMore'},
	['CITEREFDaryaeeCanepa2018'] = {'ODLA'},
	['CITEREFDavies1997'] = {'Davies-NordLocoList'},
	['CITEREFDavies2001'] = {'Davies-EstLocoList3', 'Davies-ÉtatLocoList'},
	['CITEREFDavies2003'] = {'Davies-SNCFLocoList'},
	['CITEREFDaviesFirthLuckingThomas1966'] = {'RCTS-LocosGWR-10'},
	['CITEREFDBI'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFDeutsch1951'] = {'Schubert\'s compositions (references)'},
	['CITEREFDeutsch1978'] = {'Schubert\'s compositions (references)'},
	['CITEREFDewick2005'] = {'Dewick-Atlas'},
	['CITEREFDickens2018'] = template_names['ODLA'],
	['CITEREFDolkart1998'] = {'Cite morningside'},
	['CITEREFDonner1993'] = template_names['al-Tabari'],
	['CITEREFDonohue2003'] = {'The Buwayhid Dynasty in Iraq'},
	['CITEREFDow1962'] = {'Dow-GC2'},
	['CITEREFDow1965'] = {'Dow-GC3'},
	['CITEREFDow1985'] = {'Dow-GC1'},
	['CITEREFDowney2007'] = {'Downey-Chicago'},
	['CITEREFDrury1985'] = {'Drury Historical Guide 1985'},
	['CITEREFDrury1993'] = {'Drury-North American Steam'},
	['CITEREFDuke1995'] = {'Duke-Santa Fe-1'},
	['CITEREFDukeKeilty1990'] = {'Duke-RDC'},
	['CITEREFDunlop1895'] = {'O\'Donnell family tree'},
	['CITEREFDunn2013'] = {'Dunn-Comeng-5'},
	['CITEREFDurrant1972'] = {'Durrant-Steam Locos Eastern Europe'},
	['CITEREFDurrant1981'] = {'Durrant-Garratt-Rev'},
	['CITEREFDurrantLewisJorgensen1981'] = {'Durrant-SteamAfrica'},
	['CITEREFDurston2008'] = {'ODNB'},

----------&lt; DNB and Cite DNB &gt;----------

-- replaced by pattern search above --

----------&lt; E &gt;----------
	['CITEREFEl-Hibri2010'] = {'New Cambridge History of Islam'},
	['CITEREFEI3'] = {'Encyclopaedia of Islam, THREE', 'EI3'},
	['CITEREFEldredgeHorenstein2014'] = {'Cite concrete'},
	['CITEREFEuDalySchaferJessupBoyd2009'] = {'Complete Book of North American Railroading'},

----------&lt; EB1911 and EB 1922 &gt;----------
---- Please do not add CITEREFEB1911. It should be corrected instead, typically to Chisholm 1911. ----

	['CITEREFAbrahams1911'] = template_names['EB1911'],
	['CITEREFAdamsonMitchell1911'] = template_names['EB1911'],
	['CITEREFAlphandéry1911'] = template_names['EB1911'],
	['CITEREFAnchel1911'] = template_names['EB1911'],
	['CITEREFAnonymous1911'] = template_names['EB1911'],
	['CITEREFArcher1911'] = template_names['EB1911'],
	['CITEREFAshby1911'] = template_names['EB1911'],
	['CITEREFAtkinson1911'] = template_names['EB1911'],
	['CITEREFBain1911'] = template_names['EB1911'],
	['CITEREFBarclay1911'] = template_names['EB1911'],
	['CITEREFBarker1911'] = template_names['EB1911'],
	['CITEREFBarron1911'] = template_names['EB1911'],
	['CITEREFBateson1911'] = template_names['EB1911'],
	['CITEREFBealby1911'] = template_names['EB1911'],
	['CITEREFBeazley1911'] = template_names['EB1911'],
	['CITEREFBeck1911'] = template_names['EB1911'],
	['CITEREFBecke1911'] = template_names['EB1911'],
	['CITEREFBhownagree1911'] = template_names['EB1911'],
	['CITEREFBlunt1911'] = template_names['EB1911'],
	['CITEREFBourchier1911'] = template_names['EB1911'],
	['CITEREFBousset1911'] = template_names['EB1911'],
	['CITEREFBrandin1911'] = template_names['EB1911'],
	['CITEREFBraun1911'] = template_names['EB1911'],
	['CITEREFBryant1911'] = template_names['EB1911'],
	['CITEREFBunburyCaspariGardner1911'] = template_names['EB1911'],
	['CITEREFBury1911'] = template_names['EB1911'],
	['CITEREFButler1911'] = template_names['EB1911'],
	['CITEREFBémont1911'] = template_names['EB1911'],
	['CITEREFCana1911'] = template_names['EB1911'],
	['CITEREFCantor1911'] = template_names['EB1911'],
	['CITEREFCaspari1911'] = template_names['EB1911'],
	['CITEREFCastle1911'] = template_names['EB1911'],
	['CITEREFChadwick1911'] = template_names['EB1911'],
	['CITEREFChapman1911'] = template_names['EB1911'],
	['CITEREFCharles1911'] = template_names['EB1911'],
	['CITEREFChisholm1911'] = template_names['EB1911'],
	['CITEREFChurch1911'] = template_names['EB1911'],
	['CITEREFClerke1911'] = template_names['EB1911'],
	['CITEREFColvin1911'] = template_names['EB1911'],
	['CITEREFConway1911'] = template_names['EB1911'],
	['CITEREFConybeare1911'] = template_names['EB1911'],
	['CITEREFCoolidge1911'] = template_names['EB1911'],
	['CITEREFDarlow1911'] = template_names['EB1911'],
	['CITEREFDavis1911'] = template_names['EB1911'],
	['CITEREFDelehaye1911'] = template_names['EB1911'],
	['CITEREFDobson1911'] = template_names['EB1911'],
	['CITEREFDoughty1911'] = template_names['EB1911'],
	['CITEREFDumrath1911'] = template_names['EB1911'],
	['CITEREFErskine_Holland1911'] = template_names['EB1911'],
	['CITEREFEsmein1911'] = template_names['EB1911'],
	['CITEREFFilon1911'] = template_names['EB1911'],
	['CITEREFFitzmaurice-Kelly1911'] = template_names['EB1911'],
	['CITEREFFlett1911'] = template_names['EB1911'],
	['CITEREFFoster1911'] = template_names['EB1911'],
	['CITEREFFowlerMitchell1911'] = template_names['EB1911'],
	['CITEREFFrantz1911'] = template_names['EB1911'],
	['CITEREFFreese1911'] = template_names['EB1911'],
	['CITEREFGardner1911'] = template_names['EB1911'],
	['CITEREFGarnett1911'] = template_names['EB1911'],
	['CITEREFGaster1911'] = template_names['EB1911'],
	['CITEREFGeikie1911'] = template_names['EB1911'],
	['CITEREFGibson1911'] = template_names['EB1911'],
	['CITEREFGiles1911'] = template_names['EB1911'],
	['CITEREFGilrayMacfadyen1911'] = template_names['EB1911'],
	['CITEREFGordon1911'] = template_names['EB1911'],
	['CITEREFGosse1911'] = template_names['EB1911'],
	['CITEREFGriffith1911'] = template_names['EB1911'],
	['CITEREFHalphen1911'] = template_names['EB1911'],
	['CITEREFHannay1911'] = template_names['EB1911'],
	['CITEREFHashagen1911'] = template_names['EB1911'],
	['CITEREFHayes1911'] = template_names['EB1911'],
	['CITEREFHeadlam1911'] = template_names['EB1911'],
	['CITEREFHeath1911'] = template_names['EB1911'],
	['CITEREFHodgkin1911'] = template_names['EB1911'],
	['CITEREFHogarth1911'] = template_names['EB1911'],
	['CITEREFHogg1911'] = template_names['EB1911'],
	['CITEREFHoldich1911'] = template_names['EB1911'],
	['CITEREFHolland1911'] = template_names['EB1911'],
	['CITEREFHoughton1911'] = template_names['EB1911'],
	['CITEREFIngram1911'] = template_names['EB1911'],
	['CITEREFIsaac1911'] = template_names['EB1911'],
	['CITEREFJastrow1911'] = template_names['EB1911'],
	['CITEREFJones1911'] = template_names['EB1911'],
	['CITEREFKeltie1911'] = template_names['EB1911'],
	['CITEREFKingsford1911'] = template_names['EB1911'],
	['CITEREFKitchin1911'] = template_names['EB1911'],
	['CITEREFKnox1911'] = template_names['EB1911'],
	['CITEREFKropotkin1911'] = template_names['EB1911'],
	['CITEREFLake1911'] = template_names['EB1911'],
	['CITEREFLang1911'] = template_names['EB1911'],
	['CITEREFLankester1911'] = template_names['EB1911'],
	['CITEREFLaughton1911'] = template_names['EB1911'],
	['CITEREFLayard1911'] = template_names['EB1911'],
	['CITEREFLeach1911'] = template_names['EB1911'],
	['CITEREFLejay1911'] = template_names['EB1911'],
	['CITEREFLias1911'] = template_names['EB1911'],
	['CITEREFLow1911'] = template_names['EB1911'],
	['CITEREFLydekker1911'] = template_names['EB1911'],
	['CITEREFLöffler1911'] = template_names['EB1911'],
	['CITEREFMacfadyen1911'] = template_names['EB1911'],
	['CITEREFMarzials1911'] = template_names['EB1911'],
	['CITEREFMaude1911'] = template_names['EB1911'],
	['CITEREFMaus1911'] = template_names['EB1911'],
	['CITEREFMacneill1911'] = template_names['EB1911'],
	['CITEREFMcLean1911'] = template_names['EB1911'],
	['CITEREFMcNeill1911'] = template_names['EB1911'],
	['CITEREFMeyer1911'] = template_names['EB1911'],
	['CITEREFMijatovich1911'] = template_names['EB1911'],
	['CITEREFMinns1911'] = template_names['EB1911'],
	['CITEREFMirbt1911'] = template_names['EB1911'],
	['CITEREFMitchell1911'] = template_names['EB1911'],
	['CITEREFMorley1911'] = template_names['EB1911'],
	['CITEREFMullinger1911'] = template_names['EB1911'],
	['CITEREFNicholsonYule1911'] = template_names['EB1911'],
	['CITEREFNorthcote1911'] = template_names['EB1911'],
	['CITEREFOelsner1911'] = template_names['EB1911'],
	['CITEREFPeters1911'] = template_names['EB1911'],
	['CITEREFPhillimore1911'] = template_names['EB1911'],
	['CITEREFPhillip1911'] = template_names['EB1911'],
	['CITEREFPhillips1911'] = template_names['EB1911'],
	['CITEREFPhillipsAtkinson1911'] = template_names['EB1911'],
	['CITEREFPlummer1911'] = template_names['EB1911'],
	['CITEREFPollard1911'] = template_names['EB1911'],
	['CITEREFPostgate1911'] = template_names['EB1911'],
	['CITEREFPrestage1911'] = template_names['EB1911'],
	['CITEREFPrince1911'] = template_names['EB1911'],
	['CITEREFPrinet1911'] = template_names['EB1911'],
	['CITEREFRambaut1911'] = template_names['EB1911'],
	['CITEREFReid1911'] = template_names['EB1911'],
	['CITEREFRenton1911'] = template_names['EB1911'],
	['CITEREFRichardson1911'] = template_names['EB1911'],
	['CITEREFRobertson1911'] = template_names['EB1911'],
	['CITEREFRobertsonShotwell1911'] = template_names['EB1911'],
	['CITEREFRobinson1911'] = template_names['EB1911'],
	['CITEREFRockwell1911'] = template_names['EB1911'],
	['CITEREFRose1911'] = template_names['EB1911'],
	['CITEREFRossetti1911'] = template_names['EB1911'],
	['CITEREFRossettiJones1911'] = template_names['EB1911'],
	['CITEREFRound1911'] = template_names['EB1911'],
	['CITEREFRudler1911'] = template_names['EB1911'],
	['CITEREFSaintsbury1911'] = template_names['EB1911'],
	['CITEREFSandys1911'] = template_names['EB1911'],
	['CITEREFSchlesinger1911'] = template_names['EB1911'],
	['CITEREFScott1911'] = template_names['EB1911'],
	['CITEREFSeccombe1911'] = template_names['EB1911'],
	['CITEREFShedden-Ralston1911'] = template_names['EB1911'],
	['CITEREFSmith_Reid1911'] = template_names['EB1911'],
	['CITEREFSpencer1911'] = template_names['EB1911'],
	['CITEREFSpiers1911'] = template_names['EB1911'],
	['CITEREFSquire1911'] = template_names['EB1911'],
	['CITEREFStebbing1911'] = template_names['EB1911'],
	['CITEREFSteed1911'] = template_names['EB1911'],
	['CITEREFSturt1911'] = template_names['EB1911'],
	['CITEREFSwinburne1911'] = template_names['EB1911'],
	['CITEREFSymonds1911'] = template_names['EB1911'],
	['CITEREFTedder1911'] = template_names['EB1911'],
	['CITEREFThatcher1911'] = template_names['EB1911'],
	['CITEREFTilley1911'] = template_names['EB1911'],
	['CITEREFTod1911'] = template_names['EB1911'],
	['CITEREFTout1911'] = template_names['EB1911'],
	['CITEREFTozer1911'] = template_names['EB1911'],
	['CITEREFValois1911'] = template_names['EB1911'],
	['CITEREFVenables1911'] = template_names['EB1911'],
	['CITEREFViard1911'] = template_names['EB1911'],
	['CITEREFVillari1911'] = template_names['EB1911'],
	['CITEREFWalker1911'] = template_names['EB1911'],
	['CITEREFWallace1911'] = template_names['EB1911'],
	['CITEREFWalton1911'] = template_names['EB1911'],
	['CITEREFWard1911'] = template_names['EB1911'],
	['CITEREFWarren1911'] = template_names['EB1911'],
	['CITEREFWaugh1911'] = template_names['EB1911'],
	['CITEREFWebster1911'] = template_names['EB1911'],
	['CITEREFWestcott1911'] = template_names['EB1911'],
	['CITEREFWilliamson1911'] = template_names['EB1911'],
	['CITEREFWolff1911'] = template_names['EB1911'],
	['CITEREFWoodward1911'] = template_names['EB1911'],
	['CITEREFYork1911'] = template_names['EB1911'],
	['CITEREFYorke1911'] = template_names['EB1911'],
	['CITEREFvon_Hügel1911'] = template_names['EB1911'],

	['CITEREFChisholm1922'] = {'EB1922'},

----------&lt; EI2 (probably needs a pattern; valid years are [12][90][67890][012345678] ) &gt; ---------

	['CITEREFAl-Bakhit1995'] = {'EI2'},
	['CITEREFAnastassiadou2002'] = {'EI2'},
	['CITEREFBecker1960'] = {'EI2'},
	['CITEREFBianquis1997'] = {'EI2'},
	['CITEREFBianquis2002'] = {'EI2'},
	['CITEREFBosworth1965'] = {'EI2'},
	['CITEREFBosworth1993'] = {'EI2'},
	['CITEREFBosworth1995'] = {'EI2'},
	['CITEREFCanard1965'] = {'EI2'},
	['CITEREFCanard1971'] = {'EI2'},
	['CITEREFCarmona2002'] = {'EI2'},
	['CITEREFChristides2000'] = {'EI2'},
	['CITEREFCobb2000'] = {'EI2'},
	['CITEREFDella_Vida2000'] = {'EI2'},
	['CITEREFDella_VidaBosworth2000'] = {'EI2'},
	['CITEREFDietrich1971'] = {'EI2'},
	['CITEREFEI2'] = {'Encyclopaedia of Islam, New Edition', 'EI2', 'Cite EI2'},
	['CITEREFGabrieli1960'] = {'EI2'},
	['CITEREFGibb1960'] = {'EI2'},
	['CITEREFGrabar1986'] = {'EI2'},
	['CITEREFHartmannLewis1960'] = {'EI2'},
	['CITEREFHawting1995'] = {'EI2'},
	['CITEREFHawting2002'] = {'EI2'},
	['CITEREFHinds1991'] = {'EI2'},
	['CITEREFHinds1993'] = {'EI2'},
	['CITEREFKennedy1993'] = {'EI2'},
	['CITEREFKennedy2002'] = {'EI2'},
	['CITEREFLecker1997'] = {'EI2'},
	['CITEREFMolina2000'] = {'EI2'},
	['CITEREFMordtmann1986'] = {'EI2'},
	['CITEREFMorony1993'] = {'EI2'},
	['CITEREFMoscati1960'] = {'EI2'},
	['CITEREFRekaya1991'] = {'EI2'},
	['CITEREFRotter1991'] = {'EI2'},
	['CITEREFSavvides2000'] = {'EI2'},
	['CITEREFSourdel1965'] = {'EI2'},
	['CITEREFStern1960'] = {'EI2'},
	['CITEREFStreck1978'] = {'EI2'},
	['CITEREFStreckDuri1960'] = {'EI2'},
	['CITEREFWiet1960'] = {'EI2'},
	['CITEREFYerolimpos2000'] = {'EI2'},
	['CITEREFZaman2002'] = {'EI2'},
	['CITEREFZetterstéen1960'] = {'EI2'},
	['CITEREFZetterstéenBosworth1993'] = {'EI2'},
	['CITEREFZetterstéenGabrieli1960'] = {'EI2'},


----------&lt; F &gt;----------
	['CITEREFFields1987'] = template_names['al-Tabari'],
	['CITEREFFine1994'] = {'The Late Medieval Balkans'},
	['CITEREFFishbein1990'] = template_names['al-Tabari'],
	['CITEREFFishbein1992'] = template_names['al-Tabari'],
	['CITEREFFishbein1997'] = template_names['al-Tabari'],
	['CITEREFFletcher,_Great_Tank_Scandal'] = {'Book-Fletcher-Great Tank Scandal'},
	['CITEREFFletcher,_Universal_Tank'] = {'Book-Fletcher-Universal Tank'},
	['CITEREFFornaçon,_Siegfried1957'] = {'NDB'},
	['CITEREFForrestal1999'] = {'Forrestal-Wineries'},
	['CITEREFFoster1996'] = {'Foster-Field Guide'},
	['CITEREFFoss1991'] = {'ODB'},
	['CITEREFFrailey2010'] = {'Frailey-Twilight'},
	['CITEREFFriedmann1992'] = template_names['al-Tabari'],
	['CITEREFFry1964'] = {'RCTS-LocosLNER-7'},
	['CITEREFFry1966'] = {'RCTS-LocosLNER-5'},
	['CITEREFFrye1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFFluckMarshallWilson1996'] = {'FluMarWil-LocRailCR'},
	['CITEREFFultonHarris1991'] = {'Fulton-Harris'},

----------&lt; G &gt;----------
	['CITEREFGareyJohnson1979'] = {'Garey-Johnson'},
	['CITEREFGeanakoplos1959'] = {'Emperor Michael Palaeologus and the West'},
	['CITEREFGil1997'] = {'A History of Palestine, 634-1099'},
	['CITEREFGillham2001'] = {'Gillham-Waterloo-City'},
	['CITEREFGilliland1969'] = {'Gilliland'},
	['CITEREFGilliland1994'] = {'Pop Chronicles 40s'},
	['CITEREFGilmanPeckColby1905'] = {'New International Encyclopedia', 'NIE'},
	['CITEREFGilmanPeckColby1916'] = {'New International Encyclopedia', 'NIE'},
	['CITEREFGlischinski1997'] = {'Glischinski-Santa Fe'},
	['CITEREFGoldberg1981'] = {'Goldberg-Amtrak'},
	['CITEREFGordon2001'] = {'Gordon-The Breaking of a Thousand Swords'},
	['CITEREFGrant1994'] = {'Grant-Death'},
	['CITEREFGrant2010'] = {'Grant-Twilight'},
	['CITEREFGrant2017'] = {'Grant-RailCo'},
	['CITEREFGreenlaw2007'] = {'Greenlaw-Via Rail'},
	['CITEREFGregory1991'] = {'ODB'},
	['CITEREFGriffithsSmith1999'] = {'Griffiths-Sheds1'},
	['CITEREFGriffithsSmith2000'] = {'Griffiths-Sheds2'},
	['CITEREFGrothendieckDieudonné1960'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1961'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1963'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1964'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1965'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1966'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1966'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1967'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1971'] = {'EGA'},
	['CITEREFGroves2005'] = {'MSW3 Primates', 'MSW3 Groves'},
	['CITEREFGulino2005'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFGunzburg1984'] = {'Gunzburg-History WAGR Steam'},

----------&lt; H &gt;----------
	['CITEREFHalliday1985'] = {'Halliday-AustWineCompend'},
	['CITEREFHalliday2008'] = {'Halliday-JHWAtlasAust2008'},
	['CITEREFHalliday2009'] = {'Halliday-AustWineEncyc'},
	['CITEREFHartig1910'] = {'Cite CE1913'},
	['CITEREFHartshorne1977'] = {'Hartshorne AG'},
	['CITEREFHasumi2003'] = {'Hasumi-shiguehiko-ozu-2003'},
	['CITEREFHawting1989'] = template_names['al-Tabari'],
	['CITEREFHawting1996'] = template_names['al-Tabari'],
	['CITEREFHawting2000'] = {'The First Dynasty of Islam'},
	['CITEREFHenderson2004'] = {'ODNBweb'},
	['CITEREFHerr2000'] = {'Herr-LN'},
	['CITEREFHidyHidyScottHofsummer2004'] = {'Hidy-Great Northern'},
	['CITEREFHildHellenkemper1990'] = {'Tabula Imperii Byzantini'},
	['CITEREFHildRestle1981'] = {'Tabula Imperii Byzantini'},
	['CITEREFHillenbrand1989'] = template_names['al-Tabari'],
	['CITEREFHills,_Power_from_Steam'] = {'Book-Hills-Power from Steam'},
	['CITEREFHills1989'] = {'Book-Hills-Power from Steam'},
	['CITEREFHilton1980'] = {'Hilton-Amtrak'},
	['CITEREFHilton1990'] = {'Hilton Narrow Gauge'},
	['CITEREFHiltonDue1960'] = {'Hilton-Interurban'},
	['CITEREFHinds1990'] = template_names['al-Tabari'],
	['CITEREFHistoric_Environment_ScotlandLB33744'] = {'Historic Environment Scotland'},
	['CITEREFHistoric_Environment_ScotlandLB50114'] = {'Historic Environment Scotland'},
	['CITEREFHopley1983'] = {'Australian Dictionary of Biography'},
	['CITEREFHolland2001'] = {'Holland-Classic'},
	['CITEREFHollingsworth1980'] = {'Hollingsworth-Atlas-Rigby'},
	['CITEREFHollingsworth1991'] = {'ODB', 'Oxford Dictionary of Byzantium'},
	['CITEREFHollingsworthCutler1991'] = {'ODB', 'Oxford Dictionary of Byzantium'},
	['CITEREFHolmgren2003'] = {'EFloras'},
	['CITEREFHoltBiddle1986'] = {'Holt-NorthWest'},
	['CITEREFHolton1989'] = {'Holton-Reading-1'},
	['CITEREFHoward1990'] = template_names['al-Tabari'],
	['CITEREFHughes1990'] = {'Hughes-IndianLocos1'},
	['CITEREFHughes1994'] = {'Hughes-IndianLocos3'},
	['CITEREFHughes1996'] = {'Hughes-IndianLocos4'},
	['CITEREFHumphreys1990'] = template_names['al-Tabari'],

----------&lt; I &gt;----------
	['CITEREFIshino1998'] = {'Teishajo'},

----------&lt; J &gt;----------
	['CITEREFJackson1995'] = {'Cite enc-nyc'},
	['CITEREFJackson2010'] = {'Cite enc-nyc2'},
	['CITEREFJacobs1904'] = {'Cite Jewish Encyclopedia'},
	['CITEREFJacobs1904'] = {'Cite Jewish Encyclopedia'},
	['CITEREFJohnstonWelshSchafer2001'] = {'Johnston-Streamliner'},
	['CITEREFJordan2002'] = {'Jordan-WineWABest'},
	['CITEREFJoslen2003'] = {'Joslen-OOB'},
	['CITEREFJowett1989'] = {'Jowett-Atlas', 'Carnarvonshire Railway'},
	['CITEREFJowett2000'] = {'Jowett-Nationalised'},
	['CITEREFJuynboll1989'] = template_names['al-Tabari'],

----------&lt; K &gt;----------
	['CITEREFKadinsky2016'] = {'Cite Hidden Waters NYC'},
	['CITEREFKaegi1991'] = {'ODB'},
	['CITEREFKazhdan1991'] = {'ODB', 'Oxford Dictionary of Byzantium'},
	['CITEREFKazhdanCutler1991'] = {'ODB', 'Oxford Dictionary of Byzantium'},
	['CITEREFKazhdanŠevčenko1991'] = {'ODB'},
	['CITEREFKeane2004'] = {'ODNB'},
	['CITEREFKelsey2004'] = {'ODNB'},
	['CITEREFKennedy1990'] = template_names['al-Tabari'],
	['CITEREFKennedy2001'] = {'Kennedy-The Armies of the Caliphs'},
	['CITEREFKennedy2004'] = {'The Prophet and the Age of the Caliphates'},
	['CITEREFKennedy2007'] = {'Kennedy-The Great Arab Conquests'},
	['CITEREFKennedy2016'] = {'The Prophet and the Age of the Caliphates'},
	['CITEREFKerrigan1995'] = {'Shakespeare sonnets bibliography'},
	['CITEREFKlein2006'] = {'Klein-UP-2'},
	['CITEREFKoderHild1976'] = {'Tabula Imperii Byzantini'},
	['CITEREFKraemer1989'] = template_names['al-Tabari'],
	['CITEREFKratville1962'] = {'Kratville-SSL'},
	['CITEREFKube2009'] = {'Schubert\'s compositions (references)'},
	['CITEREFKülzer2008'] = {'Tabula Imperii Byzantini'},

----------&lt; L &gt;----------
	['CITEREFLadefogedMaddieson1996'] = {'SOWL'},
	['CITEREFLandau-Tasseron1998'] = template_names['al-Tabari'],
	['CITEREFLaërtius1925'] = {'Cite Lives of the Eminent Philosophers', 'Cite LotEP'},
	['CITEREFle_Fleming1953'] = {'RCTS-LocosGWR-8'},
	['CITEREFle_Fleming1960'] = {'RCTS-LocosGWR-8'},
 	['CITEREFLe_Strange1900'] = {'Baghdad During the Abbasid Caliphate'},
	['CITEREFLe_Strange1905'] = {'Lands of the Eastern Caliphate'},
	['CITEREFLee1903'] = {'Cite DNBIE'},
 	['CITEREFLewis1969'] = {'Setton-A History of the Crusades'},
	['CITEREFLewis1986'] = {'Lewis-Shortline-1986'},
	['CITEREFLewis1991'] = {'Lewis-Shortline-1991'},
	['CITEREFLewis1996'] = {'Lewis-Shortline-1996'},
 	['CITEREFLiederNet_Archive'] = {'Schubert\'s compositions (references)'},
	['CITEREFLighthouses_of_Australia_Inc'] = {'Cite loa'},
	['CITEREFLongnon1969'] = {'Setton-A History of the Crusades'},
	['CITEREFLynch2005'] = {'Lynch-New Haven passenger'},
	
----------&lt; M &gt;----------
	['CITEREFMadelung1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFMarshall2001'] = {'Marshall-INGSR'},
	['CITEREFMartindale1980'] = {'Prosopography of the Later Roman Empire', 'PLRE'},
	['CITEREFMartindale1992'] = {'Prosopography of the Later Roman Empire', 'PLRE'},
	['CITEREFMartindaleJonesMorris1971'] = {'Prosopography of the Later Roman Empire'},
	['CITEREFMarzolph2007'] = {'EI3'},
	['CITEREFMayGray2006'] = {'MayGray-WAGRPassCar'},
	['CITEREFMcCurdyRogers1902'] = {'Cite Jewish Encyclopedia'},
	['CITEREFMcAuliffe1995'] = template_names['al-Tabari'],
	['CITEREFMcDonald1987'] = template_names['al-Tabari'],
	['CITEREFMcDonnell2015'] = {'McDonnell-Locomotives-2nd'},
	['CITEREFMeints2005'] = {'Meints-Lines'},
	['CITEREFMiddleton1961'] = {'Middleton-Interurban'},
	['CITEREFMiddleton2001'] = {'Middleton-Electrified-2nd'},
	['CITEREFMiddletonSmerkDiehl2007'] = {'Encyclopedia of North American Railroads'},
	['CITEREFMillar2011'] = {'NZR Steam Locomotive'},
	['CITEREFMiller1908'] = {'The Latins in the Levant'},
	['CITEREFMiramar_Ship_Index'] = {'Csr', 'Cite ship register'},
	['CITEREFMittermeierKonstantHawkinsLouis2006'] = {'LoM2'},
	['CITEREFMittermeierLouisRichardsonSchwitzer2010'] = {'LoM3'},
	['CITEREFMittermeierTattersallKonstantMeyers1994'] = {'LoM1'},
	['CITEREFMorony1987'] = template_names['al-Tabari'],
	['CITEREFMottahedeh1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFMurray2006'] = {'Murray-Illinois Central'},

----------&lt; N &gt;----------
	['CITEREFNersessian2018'] = {'ODLA'},
	['CITEREFNicholsonCanepaDaryaee2018'] = {'ODLA'},
	['CITEREFNicol1988'] = {'Byzantium and Venice: A Study in Diplomatic and Cultural Relations'},
	['CITEREFNicol1993'] = {'The Last Centuries of Byzantium, 1261–1453', 'The Last Centuries of Byzantium'},
	['CITEREFNock1974'] = {'Nock-EustonGlasgow'},
	['CITEREFNSA_II,_15'] = {'Schubert\'s compositions (references)'},
	['CITEREFNSA_scores'] = {'Schubert\'s compositions (references)'},
	['CITEREFNSA_website'] = {'Schubert\'s compositions (references)'},

----------&lt; O &gt;----------
	['CITEREFO\'ConnorRobertson2000'] = {'MacTutor Biography', 'MacTutor'},
	['CITEREFODB'] = {'Oxford Dictionary of Byzantium'},
	['CITEREFODLA'] = template_names['ODLA'],
	['CITEREFOgorek2012'] = {'Ogorek-South Shore'},

----------&lt; P &gt;----------
	['CITEREFPalmer_&amp;amp;_Stewart1965'] = {'Palmer &amp; Stewart'},
	['CITEREFPerlmann1987'] = template_names['al-Tabari'],
	['CITEREFPinkepank1973'] = {'Pinkepank diesel spotters guide 2'},
	['CITEREFPlantlist2016'] = {'Plantlist'},
	['CITEREFPLP'] = {'Prosopographisches Lexikon der Palaiologenzeit', 'PLP'},
	['CITEREFPmbZ'] = {'Prosopographie der mittelbyzantinischen Zeit', 'PMBZ'},
	['CITEREFPoonawala1990'] = template_names['al-Tabari'],
	['CITEREFPopovkin2007'] = template_names['al-Tabari'],
	['CITEREFPowers1989'] = template_names['al-Tabari'],
	['CITEREFPrawer1985'] = {'Setton-A History of the Crusades'},
	['CITEREFProsopographie_der_mittelbyz._Zeit'] = {'Prosopographie der mittelbyzantinischen Zeit'},



----------&lt; Q &gt;----------
	['CITEREFQuick2009'] = {'Quick-Stations'},
	['CITEREFQuick2019'] = {'Quick-stations-5'},

----------&lt; R &gt;----------
	['CITEREFRamaer1974'] = {'Ramaer-SteamLocosEAR'},
	['CITEREFReed1953'] = {'RCTS-LocosGWR-2'},
	['CITEREFReed1975'] = {'Reed-Streamline era'},
	['CITEREFReed1997'] = {'Schubert\'s compositions (references)'},
	['CITEREFReynolds1921'] = {'Cite Collier\'s'},
	['CITEREFRines1920'] = {'Cite Americana'},
	['CITEREFRoltKichenside1982'] = {'Rolt-Red'},
	['CITEREFRosenthal1985'] = template_names['al-Tabari'],
	['CITEREFRosenthal1989'] = template_names['al-Tabari'],
	['CITEREFRosenzweigBlackmar1992'] = {'Cite Central Park history'},
	['CITEREFRowledge1975'] = {'Rowledge-Engines of the LMS'},
	['CITEREFRowledge1993'] = {'Rowledge-Irish Steam Register'},
	['CITEREFRowlett'] = {'Cite rowlett'},
	['CITEREFRowson1989'] = template_names['al-Tabari'],
	
----------&lt; S &gt;----------
	['CITEREFSaliba1985'] = template_names['al-Tabari'],
	['CITEREFSanders2003'] = {'Sanders-Indiana'},
	['CITEREFSanders2006'] = {'Sanders-Heartland'},
	['CITEREFSanders2007'] = {'Sanders-Akron'},
	['CITEREFSaunders2001'] = {'Saunders-Merging Lines'},
	['CITEREFSayce1878'] = {'Cite EB9'},
	['CITEREFSchafer1996'] = {'Schafer-Classic-Railroads-1'},
	['CITEREFSchafer2000'] = {'Schafer-More-Classic'},
	['CITEREFSchafer2003'] = {'Schafer-Classic-Railroads-3'},
	['CITEREFSchaferSolomon1997'] = {'Schafer-Pennsylvania'},
	['CITEREFSchaferWelsh1997'] = {'Schafer-Classic'},
	['CITEREFSchlitter2005'] = {'MSW3 Tubulidentata'},
	['CITEREFSchroeter1961'] = {'Schroeter-Eisenbahnen'},
	['CITEREFSchroeterRamaer1993'] = {'Schroeter-Ramaer-Eisenbahnen'},
	['CITEREFSchwieterman2001'] = {'Schwieterman-Leaves-Eastern'},
	['CITEREFScottNegus2011'] = {'Scott-Negus-Cellar Door'},
	['CITEREFScribbins1970'] = {'Scribbins-Hiawatha'},
	['CITEREFScribbins2008'] = {'Scribbins-400-2008', 'Scribbins-Remembered'},
	['CITEREFSearle'] = {'Cite sslidx'},
	['CITEREFSellwood1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFSemmensGoldfinch2000'] = {'Book-Semmens-Goldfinch-How Steam Locomotives Really Work'},
	['CITEREFSetton1976'] = {'The Papacy and the Levant'},
	['CITEREFSetton1978'] = {'The Papacy and the Levant'},
	['CITEREFShaughnessy1997'] = {'Shaughnessy-DH'},
	['CITEREFShaw1978'] = {'Shaw-RailroadAccidents'},
	['CITEREFShenton2015'] = {'ODNB'},
	['CITEREFShindo2004'] = {'Kaneto-shindo-shinario-jinsei'},
	['CITEREFSilke2006'] = {'O\'Donnell family tree'},
	['CITEREFSimon1966'] = {'Simon-Wines Australia'},
	['CITEREFSimonWarner2011'] = {'Amtrak By the Numbers'},
	['CITEREFSkoulatos1980'] = {'Les personnages byzantins de l\'Alexiade'},
	['CITEREFSmith1870'] = {'DGRBM'},
	['CITEREFSmith1878'] = {'Cite EB9'},
	['CITEREFSmith1994'] = template_names['al-Tabari'],
	['CITEREFSmith2010'] = {'Smith-Cruise Ships-2010'},
	['CITEREFSolomentsev2001'] = {'Springer', 'SpringerEOM'},
	['CITEREFSolomon2000'] = {'Solomon-American Diesel', 'Solomon-UP'},
	['CITEREFSolomon2003'] = {'Solomon-Masterpieces'},
	['CITEREFSolomon2004'] = {'Solomon-Amtrak'},
	['CITEREFSolomon2005'] = {'Solomon-SP-Passenger'},
	['CITEREFSolomon2006'] = {'Solomon-EMD Locomotives'},
	['CITEREFSolomon2011'] = {'Solomon-Modern Diesel'},
	['CITEREFSolomon2014'] = {'Solomon-GE and EMD'},

	['CITEREFSoustalKoder1981'] = {'Tabula Imperii Byzantini'},
	['CITEREFSpringirth2016'] = {'Springirth-Philadelphia'},
	['CITEREFStagner1993'] = {'Stagner-Transition'},
	['CITEREFStaunton1988'] = {'Australian Dictionary of Biography'},
	['CITEREFStauferPennypacker1962'] = {'Staufer-Pennsy'},
	['CITEREFStaufer1993'] = {'Staufer-Pennsy_III'},
	['CITEREFStewart1974'] = {'When Steam Was King'},
	['CITEREFStrickland1983'] = {'Strickland Locomotive Directory'},

----------&lt; T &gt;----------
	['CITEREFTaber1977'] = {'Taber-DLW-19th'},
	['CITEREFTaberTaber1980'] = {'Taber-DLW-20th-1'},
	['CITEREFTaberTaber1981'] = {'Taber-DLW-20th-2'},
	['CITEREFTalbot1991'] = {'ODB'},
	['CITEREFTer-Ghewondyan1976'] = {'The Arab Emirates in Bagratid Armenia'},
	['CITEREFThomas1971'] = {'Thomas-History-VI'},
	['CITEREFTonks1988'] = {'Tonks ironstone'},
	['CITEREFTonks1992'] = {'Tonks ironstone'},
	['CITEREFTopping1975'] = {'Setton-A History of the Crusades'},
	['CITEREFTourret1995'] = {'Tourret-Allied Military Locomotives'},
	['CITEREFTreadgold1988'] = {'The Byzantine Revival, 780–842'},
	['CITEREFTreadgold1997'] = {'A History of the Byzantine State and Society'},
	['CITEREFTurim1998'] = {'Turim-oshima'},
	['CITEREFTurner2013'] = {'EI3'},
	
----------&lt; U &gt;----------
	
----------&lt; V &gt;----------
	['CITEREFVan_Cleve1969'] = {'Setton-A History of the Crusades'},
	['CITEREFVan_Riemsdijk,_Compound_Locomotives'] = {'Book-Van Riemsdijk-Compound Locomotives'},
	['CITEREFVan_Tricht2011'] = {'The Latin Renovatio of Byzantium'},
	['CITEREFVarzos1984'] = {'Η Γενεαλογία των Κομνηνών', 'Varzos-Genealogy of the Komnenoi'},
	['CITEREFVolkmer1991'] = {'Volkmer-Pennsy-Electric'},

----------&lt; W &gt;----------
	['CITEREFWaines1992'] = template_names['al-Tabari'],
	['CITEREFWalker2011'] = {'EI3'},
	['CITEREFWattMcDonald1989'] = template_names['al-Tabari'],
	['CITEREFWayner1972'] = {'Wayner - Car names, numbers, consists'},
	['CITEREFWayner1973'] = {'Wayner-Spotter-2nd'},
	['CITEREFWegman2008'] = {'Wegman-Illustrated'},
	['CITEREFWeinrebHibbertKeayKeay2008'] = {'London encyclopedia'},
	['CITEREFWellhausen1927'] = {'The Arab Kingdom and its Fall'},
	['CITEREFWells1982'] = {'Accents of English'},
	['CITEREFWelsh2006'] = {'Welsh-Broadway'},
	['CITEREFWelsh2008'] = {'Welsh-UP'},
	['CITEREFWham1997'] = {'Wham-Ayrshire'},
	['CITEREFWhite1985'] = {'White-Passenger-1985'},
	['CITEREFWhitehurst1973'] = {'Whitehurst GW Engines from 1940'},
	['CITEREFWhiteWillenskyLeadon2010'] = {'Cite aia5'},
	['CITEREFWhittow1996'] = {'The Making of Byzantium, 600–1025'},
	['CITEREFWiesehöfer2018'] = template_names['ODLA'],
	['CITEREFWilliams1985'] = template_names['al-Tabari'],
	['CITEREFWilliams1998'] = {'Williams-Philadelphia'},
	['CITEREFWillis1750'] = {'Cite Notitia Parliamentaria'},
	['CITEREFWilson2017'] = {'Wilson-Guide'},
	['CITEREFWilsonFiske1891'] = {'Appletons\'', 'Cite Appletons\'', 'Appletons'},
	['CITEREFWilsonFiske1900'] = {'Appletons\'', 'Cite Appletons\'', 'Appletons'},
	['CITEREFWiltshire2000'] = {'Lloyd-Margaret River'},
	['CITEREFWolff1969'] = {'Setton-A History of the Crusades'},
	['CITEREFWood1907'] = {'Nuttall'},
	['CITEREFWozencraft2005'] = {'MSW3 Carnivora'},

----------&lt; X &gt;----------

----------&lt; Y &gt;----------
	['CITEREFYenne2005'] = {'Yenne-Chiefs'},
	['CITEREFYonge1994'] = {'Quail-5'},
	['CITEREFYonge2002'] = {'Quail-5'},
	['CITEREFYonge2008'] = {'Quail-5'},
	['CITEREFYonge2016'] = {'Quail-2-2016'},
	['CITEREFYonge1990'] = {'Quail-4'},
	['CITEREFYongePadgettSzwenk2013'] = {'Quail-4-Paper-3rdEd'},

----------&lt; Z &gt;----------
	['CITEREFZekulich2000'] = {'Zekulich-WineWA'},
	['CITEREFZimmermann2004'] = {'Zimmermann-Burlington'},
	['CITEREFZimmermann2007'] = {'Zimmermann-GrandLuxe'},
	

------- unsorted--------
	['CITEREFArrey_von_Dommer1875'] = {'Cite ADB'},
	['CITEREFBoddyNeveTeeYeadon1982'] = {'RCTS-LocosLNER-6A'},
	['CITEREFCarter2006'] = {'Carter-RailwaysMotivePowerArgentina'},
	['CITEREFFranz_Schnorr_von_Carolsfeld1883'] = {'Cite ADB'},
	['CITEREFFriedrich_Wilhelm_Bautz1975'] = {'BBKL'},
	['CITEREFFriedrich_Wilhelm_Bautz1990'] = {'BBKL'},
	['CITEREFGeorg_von_Dadelsen1953'] = {'NDB'},
	['CITEREFGrete_Schemann1957'] = {'NDB'},
	['CITEREFHans_Heinrich_Borcherdt1955'] = {'NDB'},
	['CITEREFHermann_Palm1876'] = {'Cite ADB'},
	['CITEREFKarl_Frohnmeyer1953'] = {'NDB'},
	['CITEREFKonrad_Ameln1985'] = {'NDB'},
	['CITEREFManfred_Knedlik2007'] = {'BBKL'},
	['CITEREFMartin_Persch1992'] = {'BBKL'},
	['CITEREFMartin_Persch1993'] = {'BBKL'},
	['CITEREFMartin_Persch1996'] = {'BBKL'},
	['CITEREFMüller,_Hans-Christian1966'] = {'NDB'},
	['CITEREFPalmer1875'] = {'Cite ADB'},
	['CITEREFReinhard_Tenberg1990'] = {'BBKL'},
	['CITEREFSolomonSchafer2007'] = {'Solomon-New York Central'},
	['CITEREFSusanne_Schurr1992'] = {'BBKL'},
	['CITEREFSusanne_Siebert1992'] = {'BBKL'},
	['CITEREFTodt1996'] = {'BBKL'},
	['CITEREFUwe_Eckardt2001'] = {'BBKL'},
	['CITEREFWerner_Raupp2001'] = {'BBKL'},
	['CITEREFWestermayer,_Georg1882'] = {'Cite ADB'},
	['CITEREFWinfieldLyon2004'] = {'Winfield'},
	['CITEREFunknown_author1881'] = {'Cite ADB'},
	['CITEREFunknown_author1882'] = {'Cite ADB'},

	}


--[[--------------------------&lt; E X P O R T E D   T A B L E S &gt;------------------------------------------------
]]

return {
	DNB_special_patterns = DNB_special_patterns,
	DNB_template_names = template_names['DNB'],
	special_patterns = special_patterns,
	whitelist = whitelist,
	}</text>
      <sha1>oyjjyl8eox4f6b66ja2yuea1uz01bzh</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Hatnote</title>
    <ns>828</ns>
    <id>42498502</id>
    <revision>
      <id>779487706</id>
      <parentid>726656423</parentid>
      <timestamp>2017-05-09T05:20:32Z</timestamp>
      <contributor>
        <username>JJMC89</username>
        <id>24812038</id>
      </contributor>
      <comment>Add navigation-not-searchable class per [[Special:Permalink/779475248#Add navigation-not-searchable class|request]] (also see [[phab:T164781|T164781]])</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6703" xml:space="preserve">--------------------------------------------------------------------------------
--                              Module:Hatnote                                --
--                                                                            --
-- This module produces hatnote links and links to related articles. It       --
-- implements the {{hatnote}} and {{format link}} meta-templates and includes --
-- helper functions for other Lua hatnote modules.                            --
--------------------------------------------------------------------------------

local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType
local mArguments -- lazily initialise [[Module:Arguments]]
local yesno -- lazily initialise [[Module:Yesno]]

local p = {}

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function getArgs(frame)
	-- Fetches the arguments from the parent frame. Whitespace is trimmed and
	-- blanks are removed.
	mArguments = require('Module:Arguments')
	return mArguments.getArgs(frame, {parentOnly = true})
end

local function removeInitialColon(s)
	-- Removes the initial colon from a string, if present.
	return s:match('^:?(.*)')
end

function p.findNamespaceId(link, removeColon)
	-- Finds the namespace id (namespace number) of a link or a pagename. This
	-- function will not work if the link is enclosed in double brackets. Colons
	-- are trimmed from the start of the link by default. To skip colon
	-- trimming, set the removeColon parameter to false.
	checkType('findNamespaceId', 1, link, 'string')
	checkType('findNamespaceId', 2, removeColon, 'boolean', true)
	if removeColon ~= false then
		link = removeInitialColon(link)
	end
	local namespace = link:match('^(.-):')
	if namespace then
		local nsTable = mw.site.namespaces[namespace]
		if nsTable then
			return nsTable.id
		end
	end
	return 0
end

function p.formatPages(...)
	-- Formats a list of pages using formatLink and returns it as an array. Nil
	-- values are not allowed.
	local pages = {...}
	local ret = {}
	for i, page in ipairs(pages) do
		ret[i] = p._formatLink(page)
	end
	return ret
end

function p.formatPageTables(...)
	-- Takes a list of page/display tables and returns it as a list of
	-- formatted links. Nil values are not allowed.
	local pages = {...}
	local links = {}
	for i, t in ipairs(pages) do
		checkType('formatPageTables', i, t, 'table')
		local link = t[1]
		local display = t[2]
		links[i] = p._formatLink(link, display)
	end
	return links
end

function p.makeWikitextError(msg, helpLink, addTrackingCategory, title)
	-- Formats an error message to be returned to wikitext. If
	-- addTrackingCategory is not false after being returned from
	-- [[Module:Yesno]], and if we are not on a talk page, a tracking category
	-- is added.
	checkType('makeWikitextError', 1, msg, 'string')
	checkType('makeWikitextError', 2, helpLink, 'string', true)
	yesno = require('Module:Yesno')
	title = title or mw.title.getCurrentTitle()
	-- Make the help link text.
	local helpText
	if helpLink then
		helpText = ' ([[' .. helpLink .. '|help]])'
	else
		helpText = ''
	end
	-- Make the category text.
	local category
	if not title.isTalkPage and yesno(addTrackingCategory) ~= false then
		category = 'Hatnote templates with errors'
		category = string.format(
			'[[%s:%s]]',
			mw.site.namespaces[14].name,
			category
		)
	else
		category = ''
	end
	return string.format(
		'&lt;strong class="error"&gt;Error: %s%s.&lt;/strong&gt;%s',
		msg,
		helpText,
		category
	)
end

function p.disambiguate(page, disambiguator)
	-- Formats a page title with a disambiguation parenthetical,
	-- i.e. "Example" → "Example (disambiguation)".
	checkType('disambiguate', 1, page, 'string')
	checkType('disambiguate', 2, disambiguator, 'string', true)
	disambiguator = disambiguator or 'disambiguation'
	return string.format('%s (%s)', page, disambiguator)
end

--------------------------------------------------------------------------------
-- Format link
--
-- Makes a wikilink from the given link and display values. Links are escaped
-- with colons if necessary, and links to sections are detected and displayed
-- with " § " as a separator rather than the standard MediaWiki "#". Used in
-- the {{format hatnote link}} template.
--------------------------------------------------------------------------------

function p.formatLink(frame)
	local args = getArgs(frame)
	local link = args[1]
	local display = args[2]
	if not link then
		return p.makeWikitextError(
			'no link specified',
			'Template:Format hatnote link#Errors',
			args.category
		)
	end
	return p._formatLink(link, display)
end

function p._formatLink(link, display)
	checkType('_formatLink', 1, link, 'string')
	checkType('_formatLink', 2, display, 'string', true)

	-- Remove the initial colon for links where it was specified manually.
	link = removeInitialColon(link)

	-- Find whether a faux display value has been added with the {{!}} magic
	-- word.
	if not display then
		local prePipe, postPipe = link:match('^(.-)|(.*)$')
		link = prePipe or link
		display = postPipe
	end

	-- Find the display value.
	if not display then
		local page, section = link:match('^(.-)#(.*)$')
		if page then
			display = page .. ' §&amp;nbsp;' .. section
		end
	end

	-- Assemble the link.
	if display then
		return string.format(
			'[[:%s|%s]]',
			string.gsub(link, '|(.*)$', ''), --display overwrites manual piping
			display
		)
	else
		return string.format('[[:%s]]', link)
	end
end

--------------------------------------------------------------------------------
-- Hatnote
--
-- Produces standard hatnote text. Implements the {{hatnote}} template.
--------------------------------------------------------------------------------

function p.hatnote(frame)
	local args = getArgs(frame)
	local s = args[1]
	local options = {}
	if not s then
		return p.makeWikitextError(
			'no text specified',
			'Template:Hatnote#Errors',
			args.category
		)
	end
	options.extraclasses = args.extraclasses
	options.selfref = args.selfref
	return p._hatnote(s, options)
end

function p._hatnote(s, options)
	checkType('_hatnote', 1, s, 'string')
	checkType('_hatnote', 2, options, 'table', true)
	options = options or {}
	local classes = {'hatnote', 'navigation-not-searchable'}
	local extraclasses = options.extraclasses
	local selfref = options.selfref
	if type(extraclasses) == 'string' then
		classes[#classes + 1] = extraclasses
	end
	if selfref then
		classes[#classes + 1] = 'selfref'
	end
	return string.format(
		'&lt;div role="note" class="%s"&gt;%s&lt;/div&gt;',
		table.concat(classes, ' '),
		s
	)
end

return p</text>
      <sha1>c5z31x97gktc3q7nnp8mf48t01l4qst</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Hatnote list</title>
    <ns>828</ns>
    <id>50085079</id>
    <revision>
      <id>833955078</id>
      <parentid>833954678</parentid>
      <timestamp>2018-04-03T05:19:54Z</timestamp>
      <contributor>
        <username>Galobtter</username>
        <id>19502780</id>
      </contributor>
      <comment>fix</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="7209" xml:space="preserve">--------------------------------------------------------------------------------
--                           Module:Hatnote list                              --
--                                                                            --
-- This module produces and formats lists for use in hatnotes. In particular, --
-- it implements the for-see list, i.e. lists of "For X, see Y" statements,   --
-- as used in {{about}}, {{redirect}}, and their variants. Also introduced    --
-- are andList &amp; orList helpers for formatting lists with those conjunctions. --
--------------------------------------------------------------------------------

local mArguments --initialize lazily
local mHatnote = require('Module:Hatnote')
local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType
local p = {}

--------------------------------------------------------------------------------
-- List stringification helper functions
--
-- These functions are used for stringifying lists, usually page lists inside
-- the "Y" portion of "For X, see Y" for-see items.
--------------------------------------------------------------------------------

--default options table used across the list stringification functions
local stringifyListDefaultOptions = {
	conjunction = "and",
	separator = ",",
	altSeparator = ";",
	space = " ",
	formatted = false
}

-- Stringifies a list generically; probably shouldn't be used directly
function stringifyList(list, options)
	-- Type-checks, defaults, and a shortcut
	checkType("stringifyList", 1, list, "table")
	if #list == 0 then return nil end
	checkType("stringifyList", 2, options, "table", true)
	options = options or {}
	for k, v in pairs(stringifyListDefaultOptions) do
		if options[k] == nil then options[k] = v end
	end
	local s = options.space
	-- Format the list if requested
	if options.formatted then list = mHatnote.formatPages(unpack(list)) end
	-- Set the separator; if any item contains it, use the alternate separator
	local separator = options.separator
	--searches display text only
	function searchDisp(t, f)
		return string.find(string.sub(t, (string.find(t, '|') or 0) + 1), f)
	end
	for k, v in pairs(list) do
		if searchDisp(v, separator) then
			separator = options.altSeparator
			break
		end
	end
	-- Set the conjunction, apply Oxford comma, and force a comma if #1 has "§"
	local conjunction = s .. options.conjunction .. s
	if #list == 2 and searchDisp(list[1], "§") or #list &gt; 2 then
		conjunction = separator .. conjunction
	end
	-- Return the formatted string
	return mw.text.listToText(list, separator .. s, conjunction)
end

--DRY function
function conjList (conj, list, fmt)
	return stringifyList(list, {conjunction = conj, formatted = fmt})
end

-- Stringifies lists with "and" or "or"
function p.andList (...) return conjList("and", ...) end
function p.orList (...) return conjList("or", ...) end

--------------------------------------------------------------------------------
-- For see
--
-- Makes a "For X, see [[Y]]." list from raw parameters. Intended for the
-- {{about}} and {{redirect}} templates and their variants.
--------------------------------------------------------------------------------

--default options table used across the forSee family of functions
local forSeeDefaultOptions = {
	andKeyword = 'and',
	title = mw.title.getCurrentTitle().text,
	otherText = 'other uses',
	forSeeForm = 'For %s, see %s.',
}

--Collapses duplicate punctuation
function punctuationCollapse (text)
	local replacements = {
		["%.%.$"] = ".",
		["%?%.$"] = "?",
		["%!%.$"] = "!",
		["%.%]%]%.$"] = ".]]",
		["%?%]%]%.$"] = "?]]",
		["%!%]%]%.$"] = "!]]"
	}
	for k, v in pairs(replacements) do text = string.gsub(text, k, v) end
	return text
end

-- Structures arguments into a table for stringification, &amp; options
function p.forSeeArgsToTable (args, from, options)
	-- Type-checks and defaults
	checkType("forSeeArgsToTable", 1, args, 'table')
	checkType("forSeeArgsToTable", 2, from, 'number', true)
	from = from or 1
	checkType("forSeeArgsToTable", 3, options, 'table', true)
	options = options or {}
	for k, v in pairs(forSeeDefaultOptions) do
		if options[k] == nil then options[k] = v end
	end
	-- maxArg's gotten manually because getArgs() and table.maxn aren't friends
	local maxArg = 0
	for k, v in pairs(args) do
		if type(k) == 'number' and k &gt; maxArg then maxArg = k end
	end
	-- Structure the data out from the parameter list:
	-- * forTable is the wrapper table, with forRow rows
	-- * Rows are tables of a "use" string &amp; a "pages" table of pagename strings
	-- * Blanks are left empty for defaulting elsewhere, but can terminate list
	local forTable = {}
	local i = from
	local terminated = false
	-- If there is extra text, and no arguments are given, give nil value
	-- to not produce default of "For other uses, see foo (disambiguation)"
	if options.extratext and i &gt; maxArg then return nil end
	-- Loop to generate rows
	repeat
		-- New empty row
		local forRow = {}
		-- On blank use, assume list's ended &amp; break at end of this loop
		forRow.use = args[i]
		if not args[i] then terminated = true end
		-- New empty list of pages
		forRow.pages = {}
		-- Insert first pages item if present
		table.insert(forRow.pages, args[i + 1])
		-- If the param after next is "and", do inner loop to collect params
		-- until the "and"'s stop. Blanks are ignored: "1|and||and|3" → {1, 3}
		while args[i + 2] == options.andKeyword do
			if args[i + 3] then 
				table.insert(forRow.pages, args[i + 3])
			end
			-- Increment to next "and"
			i = i + 2
		end
		-- Increment to next use
		i = i + 2
		-- Append the row
		table.insert(forTable, forRow)
	until terminated or i &gt; maxArg
	
	return forTable
end

-- Stringifies a table as formatted by forSeeArgsToTable
function p.forSeeTableToString (forSeeTable, options)
	-- Type-checks and defaults
	checkType("forSeeTableToString", 1, forSeeTable, "table", true)
	checkType("forSeeTableToString", 2, options, "table", true)
	options = options or {}
	for k, v in pairs(forSeeDefaultOptions) do
		if options[k] == nil then options[k] = v end
	end
	-- Stringify each for-see item into a list
	local strList = {}
	if forSeeTable then
		for k, v in pairs(forSeeTable) do
			local useStr = v.use or options.otherText
			local pagesStr = p.andList(v.pages, true) or mHatnote._formatLink(mHatnote.disambiguate(options.title))
			local forSeeStr = string.format(options.forSeeForm, useStr, pagesStr)
			forSeeStr = punctuationCollapse(forSeeStr)
			table.insert(strList, forSeeStr)
		end
	end
	if options.extratext then table.insert(strList, punctuationCollapse(options.extratext..'.')) end
	-- Return the concatenated list
	return table.concat(strList, ' ')
end

-- Produces a "For X, see [[Y]]" string from arguments. Expects index gaps
-- but not blank/whitespace values. Ignores named args and args &lt; "from".
function p._forSee (args, from, options)
	local forSeeTable = p.forSeeArgsToTable(args, from, options)
	return p.forSeeTableToString(forSeeTable, options)
end

-- As _forSee, but uses the frame.
function p.forSee (frame, from, options)
	mArguments = require('Module:Arguments')
	return p._forSee(mArguments.getArgs(frame), from, options)
end

return p</text>
      <sha1>2hmyydi47hep0hexbh8sw7ybxc07m5k</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Infobox</title>
    <ns>828</ns>
    <id>38808424</id>
    <revision>
      <id>906075621</id>
      <parentid>906073835</parentid>
      <timestamp>2019-07-13T13:05:36Z</timestamp>
      <contributor>
        <username>Gonnym</username>
        <id>14984434</id>
      </contributor>
      <comment>Undid revision 906073835 by [[Special:Contributions/Gonnym|Gonnym]] ([[User talk:Gonnym|talk]]) errors in code were reported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="15874" xml:space="preserve">--
-- This module implements {{Infobox}}
--

local p = {}

local navbar = require('Module:Navbar')._navbar

local args = {}
local origArgs
local root

local function notempty( s ) return s and s:match( '%S' ) end

local function fixChildBoxes(sval, tt)
	if notempty(sval) then
		local marker = '&lt;span class=special_infobox_marker&gt;'
		local s = sval
		s = mw.ustring.gsub(s, '(&lt;%s*[Tt][Rr])', marker .. '%1')
		s = mw.ustring.gsub(s, '(&lt;/[Tt][Rr]%s*&gt;)', '%1' .. marker)
		if s:match(marker) then
			s = mw.ustring.gsub(s, marker .. '%s*' .. marker, '')
			s = mw.ustring.gsub(s, '([\r\n]|-[^\r\n]*[\r\n])%s*' .. marker, '%1')
			s = mw.ustring.gsub(s, marker .. '%s*([\r\n]|-)', '%1')
			s = mw.ustring.gsub(s, '(&lt;/[Cc][Aa][Pp][Tt][Ii][Oo][Nn]%s*&gt;%s*)' .. marker, '%1')
			s = mw.ustring.gsub(s, '(&lt;%s*[Tt][Aa][Bb][Ll][Ee][^&lt;&gt;]*&gt;%s*)' .. marker, '%1')
			s = mw.ustring.gsub(s, '^(%{|[^\r\n]*[\r\n]%s*)' .. marker, '%1')
			s = mw.ustring.gsub(s, '([\r\n]%{|[^\r\n]*[\r\n]%s*)' .. marker, '%1')
			s = mw.ustring.gsub(s,  marker .. '(%s*&lt;/[Tt][Aa][Bb][Ll][Ee]%s*&gt;)', '%1')
			s = mw.ustring.gsub(s,  marker .. '(%s*\n|%})', '%1')
		end
		if s:match(marker) then
			local subcells = mw.text.split(s, marker)
			s = ''
			for k = 1, #subcells do
				if k == 1 then
					s = s .. subcells[k] .. '&lt;/' .. tt .. '&gt;&lt;/tr&gt;'
				elseif k == #subcells then
					local rowstyle = ' style="display:none"'
					if notempty(subcells[k]) then rowstyle = ''	end
					s = s .. '&lt;tr' .. rowstyle ..'&gt;&lt;' .. tt .. ' colspan=2&gt;\n' .. subcells[k]
				elseif notempty(subcells[k]) then
					if (k % 2) == 0 then
						s = s .. subcells[k]
					else
						s = s .. '&lt;tr&gt;&lt;' .. tt .. ' colspan=2&gt;\n' .. subcells[k] .. '&lt;/' .. tt .. '&gt;&lt;/tr&gt;'
					end
				end
			end
		end
		-- the next two lines add a newline at the end of lists for the PHP parser
		-- https://en.wikipedia.org/w/index.php?title=Template_talk:Infobox_musical_artist&amp;oldid=849054481
		-- remove when [[:phab:T191516]] is fixed or OBE
		s = mw.ustring.gsub(s, '([\r\n][%*#;:][^\r\n]*)$', '%1\n')
		s = mw.ustring.gsub(s, '^([%*#;:][^\r\n]*)$', '%1\n')
		s = mw.ustring.gsub(s, '^([%*#;:])', '\n%1')
		s = mw.ustring.gsub(s, '^(%{%|)', '\n%1')
		return s
	else
		return sval
	end
end

local function union(t1, t2)
    -- Returns the union of the values of two tables, as a sequence.
    local vals = {}
    for k, v in pairs(t1) do
        vals[v] = true
    end
    for k, v in pairs(t2) do
        vals[v] = true
    end
    local ret = {}
    for k, v in pairs(vals) do
        table.insert(ret, k)
    end
    return ret
end

local function getArgNums(prefix)
    -- Returns a table containing the numbers of the arguments that exist
    -- for the specified prefix. For example, if the prefix was 'data', and
    -- 'data1', 'data2', and 'data5' exist, it would return {1, 2, 5}.
    local nums = {}
    for k, v in pairs(args) do
        local num = tostring(k):match('^' .. prefix .. '([1-9]%d*)$')
        if num then table.insert(nums, tonumber(num)) end
    end
    table.sort(nums)
    return nums
end

local function addRow(rowArgs)
    -- Adds a row to the infobox, with either a header cell
    -- or a label/data cell combination.
    if rowArgs.header then
        root
            :tag('tr')
                :addClass(rowArgs.rowclass)
                :cssText(rowArgs.rowstyle)
                :attr('id', rowArgs.rowid)
                :tag('th')
                    :attr('colspan', 2)
                    :attr('id', rowArgs.headerid)
                    :addClass(rowArgs.class)
                    :addClass(args.headerclass)
                    :css('text-align', 'center')
                    :cssText(args.headerstyle)
                    :cssText(rowArgs.rowcellstyle)
                    :wikitext(fixChildBoxes(rowArgs.header, 'th'))
    elseif rowArgs.data then
        local row = root:tag('tr')
        row:addClass(rowArgs.rowclass)
        row:cssText(rowArgs.rowstyle)
        row:attr('id', rowArgs.rowid)
        if rowArgs.label then
            row
                :tag('th')
                    :attr('scope', 'row')
                    :attr('id', rowArgs.labelid)
                    :cssText(args.labelstyle)
                    :cssText(rowArgs.rowcellstyle)
                    :wikitext(rowArgs.label)
                    :done()
        end
        
        local dataCell = row:tag('td')
        if not rowArgs.label then 
            dataCell
                :attr('colspan', 2)
                :css('text-align', 'center') 
        end
        dataCell
            :attr('id', rowArgs.dataid)
            :addClass(rowArgs.class)
            :cssText(rowArgs.datastyle)
            :cssText(rowArgs.rowcellstyle)
            :wikitext(fixChildBoxes(rowArgs.data, 'td'))
    end
end

local function renderTitle()
    if not args.title then return end

    root
        :tag('caption')
            :addClass(args.titleclass)
            :cssText(args.titlestyle)
            :wikitext(args.title)
end

local function renderAboveRow()
    if not args.above then return end
    
    root
        :tag('tr')
            :tag('th')
                :attr('colspan', 2)
                :addClass(args.aboveclass)
                :css('text-align', 'center')
                :css('font-size', '125%')
                :css('font-weight', 'bold')
                :cssText(args.abovestyle)
                :wikitext(fixChildBoxes(args.above,'th'))
end

local function renderBelowRow()
    if not args.below then return end
    
    root
        :tag('tr')
            :tag('td')
                :attr('colspan', '2')
                :addClass(args.belowclass)
                :css('text-align', 'center')
                :cssText(args.belowstyle)
                :wikitext(fixChildBoxes(args.below,'td'))
end

local function renderSubheaders()
    if args.subheader then
        args.subheader1 = args.subheader
    end
    if args.subheaderrowclass then
        args.subheaderrowclass1 = args.subheaderrowclass
    end
    local subheadernums = getArgNums('subheader')
    for k, num in ipairs(subheadernums) do
        addRow({
            data = args['subheader' .. tostring(num)],
            datastyle = args.subheaderstyle,
            rowcellstyle = args['subheaderstyle' .. tostring(num)],
            class = args.subheaderclass,
            rowclass = args['subheaderrowclass' .. tostring(num)]
        })
    end
end

local function renderImages()
    if args.image then
        args.image1 = args.image
    end
    if args.caption then
        args.caption1 = args.caption
    end
    local imagenums = getArgNums('image')
    for k, num in ipairs(imagenums) do
        local caption = args['caption' .. tostring(num)]
        local data = mw.html.create():wikitext(args['image' .. tostring(num)])
        if caption then
            data
                :tag('div')
                    :cssText(args.captionstyle)
                    :wikitext(caption)
        end
        addRow({
            data = tostring(data),
            datastyle = args.imagestyle,
            class = args.imageclass,
            rowclass = args['imagerowclass' .. tostring(num)]
        })
    end
end

local function renderRows()
    -- Gets the union of the header and data argument numbers,
    -- and renders them all in order using addRow.
    local rownums = union(getArgNums('header'), getArgNums('data'))
    table.sort(rownums)
    for k, num in ipairs(rownums) do
        addRow({
            header = args['header' .. tostring(num)],
            label = args['label' .. tostring(num)],
            data = args['data' .. tostring(num)],
            datastyle = args.datastyle,
            class = args['class' .. tostring(num)],
            rowclass = args['rowclass' .. tostring(num)],
            rowstyle = args['rowstyle' .. tostring(num)],
            rowcellstyle = args['rowcellstyle' .. tostring(num)],
            dataid = args['dataid' .. tostring(num)],
            labelid = args['labelid' .. tostring(num)],
            headerid = args['headerid' .. tostring(num)],
            rowid = args['rowid' .. tostring(num)]
        })
    end
end

local function renderNavBar()
    if not args.name then return end
    
    root
        :tag('tr')
            :tag('td')
                :attr('colspan', '2')
                :css('text-align', 'right')
                :wikitext(navbar{
                    args.name,
                    mini = 1,
                })
end

local function renderItalicTitle()
    local italicTitle = args['italic title'] and mw.ustring.lower(args['italic title'])
    if italicTitle == '' or italicTitle == 'force' or italicTitle == 'yes' then
        root:wikitext(mw.getCurrentFrame():expandTemplate({title = 'italic title'}))
    end
end

local function renderTrackingCategories()
    if args.decat ~= 'yes' then
    	if args.child == 'yes' then
        	if args.title then
            	root:wikitext('[[Category:Pages which use embedded infobox templates with the title parameter]]')
        	end
        elseif #(getArgNums('data')) == 0 and mw.title.getCurrentTitle().namespace == 0 then
            root:wikitext('[[Category:Articles which use infobox templates with no data rows]]')
        end
    end
end

local function _infobox()
    -- Specify the overall layout of the infobox, with special settings
    -- if the infobox is used as a 'child' inside another infobox.
    if args.child ~= 'yes' then
        root = mw.html.create('table')
        
        root
            :addClass((args.subbox ~= 'yes') and 'infobox' or nil)
            :addClass(args.bodyclass)
            
            if args.subbox == 'yes' then
                root
                    :css('padding', '0')
                    :css('border', 'none')
                    :css('margin', '-3px')
                    :css('width', 'auto')
                    :css('min-width', '100%')
                    :css('font-size', '100%')
                    :css('clear', 'none')
                    :css('float', 'none')
                    :css('background-color', 'transparent')
            else
                root
                    :css('width', '22em')
            end
        root
            :cssText(args.bodystyle)
    
        renderTitle()
        renderAboveRow()
    else
        root = mw.html.create()
        
        root
            :wikitext(args.title)
    end

    renderSubheaders()
    renderImages() 
    renderRows() 
    renderBelowRow()  
    renderNavBar()
    renderItalicTitle()
    renderTrackingCategories()
    
    return tostring(root)
end

local function preprocessSingleArg(argName)
    -- If the argument exists and isn't blank, add it to the argument table.
    -- Blank arguments are treated as nil to match the behaviour of ParserFunctions.
    if origArgs[argName] and origArgs[argName] ~= '' then
        args[argName] = origArgs[argName]
    end
end

local function preprocessArgs(prefixTable, step)
    -- Assign the parameters with the given prefixes to the args table, in order, in batches
    -- of the step size specified. This is to prevent references etc. from appearing in the
    -- wrong order. The prefixTable should be an array containing tables, each of which has
    -- two possible fields, a "prefix" string and a "depend" table. The function always parses
    -- parameters containing the "prefix" string, but only parses parameters in the "depend"
    -- table if the prefix parameter is present and non-blank.
    if type(prefixTable) ~= 'table' then
        error("Non-table value detected for the prefix table", 2)
    end
    if type(step) ~= 'number' then
        error("Invalid step value detected", 2)
    end
    
    -- Get arguments without a number suffix, and check for bad input.
    for i,v in ipairs(prefixTable) do
        if type(v) ~= 'table' or type(v.prefix) ~= "string" or (v.depend and type(v.depend) ~= 'table') then
            error('Invalid input detected to preprocessArgs prefix table', 2)
        end
        preprocessSingleArg(v.prefix)
        -- Only parse the depend parameter if the prefix parameter is present and not blank.
        if args[v.prefix] and v.depend then
            for j, dependValue in ipairs(v.depend) do
                if type(dependValue) ~= 'string' then
                    error('Invalid "depend" parameter value detected in preprocessArgs')
                end
                preprocessSingleArg(dependValue)
            end
        end
    end

    -- Get arguments with number suffixes.
    local a = 1 -- Counter variable.
    local moreArgumentsExist = true
    while moreArgumentsExist == true do
        moreArgumentsExist = false
        for i = a, a + step - 1 do
            for j,v in ipairs(prefixTable) do
                local prefixArgName = v.prefix .. tostring(i)
                if origArgs[prefixArgName] then
                    moreArgumentsExist = true -- Do another loop if any arguments are found, even blank ones.
                    preprocessSingleArg(prefixArgName)
                end
                -- Process the depend table if the prefix argument is present and not blank, or
                -- we are processing "prefix1" and "prefix" is present and not blank, and
                -- if the depend table is present.
                if v.depend and (args[prefixArgName] or (i == 1 and args[v.prefix])) then
                    for j,dependValue in ipairs(v.depend) do
                        local dependArgName = dependValue .. tostring(i)
                        preprocessSingleArg(dependArgName)
                    end
                end
            end
        end
        a = a + step
    end
end
 
function p.infobox(frame)
    -- If called via #invoke, use the args passed into the invoking template.
    -- Otherwise, for testing purposes, assume args are being passed directly in.
    if frame == mw.getCurrentFrame() then
        origArgs = frame:getParent().args
    else
        origArgs = frame
    end
    
    -- Parse the data parameters in the same order that the old {{infobox}} did, so that
    -- references etc. will display in the expected places. Parameters that depend on
    -- another parameter are only processed if that parameter is present, to avoid
    -- phantom references appearing in article reference lists.
    preprocessSingleArg('child')
    preprocessSingleArg('bodyclass')
    preprocessSingleArg('subbox')
    preprocessSingleArg('bodystyle')
    preprocessSingleArg('title')
    preprocessSingleArg('titleclass')
    preprocessSingleArg('titlestyle')
    preprocessSingleArg('above')
    preprocessSingleArg('aboveclass')
    preprocessSingleArg('abovestyle')
    preprocessArgs({
        {prefix = 'subheader', depend = {'subheaderstyle', 'subheaderrowclass'}}
    }, 10)
    preprocessSingleArg('subheaderstyle')
    preprocessSingleArg('subheaderclass')
    preprocessArgs({
        {prefix = 'image', depend = {'caption', 'imagerowclass'}}
    }, 10)
    preprocessSingleArg('captionstyle')
    preprocessSingleArg('imagestyle')
    preprocessSingleArg('imageclass')
    preprocessArgs({
        {prefix = 'header'},
        {prefix = 'data', depend = {'label'}},
        {prefix = 'rowclass'},
        {prefix = 'rowstyle'},
        {prefix = 'rowcellstyle'},
        {prefix = 'class'},
        {prefix = 'dataid'},
        {prefix = 'labelid'},
        {prefix = 'headerid'},
        {prefix = 'rowid'}
    }, 50)
    preprocessSingleArg('headerclass')
    preprocessSingleArg('headerstyle')
    preprocessSingleArg('labelstyle')
    preprocessSingleArg('datastyle')
    preprocessSingleArg('below')
    preprocessSingleArg('belowclass')
    preprocessSingleArg('belowstyle')
    preprocessSingleArg('name')
    args['italic title'] = origArgs['italic title'] -- different behaviour if blank or absent
    preprocessSingleArg('decat')
 
    return _infobox()
end
 
return p</text>
      <sha1>fqwlmnh999j8i9ezhfasls5wwtsbxv1</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Labelled list hatnote</title>
    <ns>828</ns>
    <id>50971703</id>
    <revision>
      <id>763259375</id>
      <parentid>745988142</parentid>
      <timestamp>2017-02-02T05:26:53Z</timestamp>
      <contributor>
        <username>Nihiltres</username>
        <id>236191</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Module:Labelled list hatnote]]": [[WP:High-risk templates|Highly visible template]] ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3083" xml:space="preserve">--------------------------------------------------------------------------------
--                               Labelled list                                --
--                                                                            --
-- This module does the core work of creating a hatnote composed of a list    --
-- prefixed by a colon-terminated label, i.e. "LABEL: [andList of pages]",    --
-- for {{see also}} and similar templates.                                    --
--------------------------------------------------------------------------------

local mHatnote = require('Module:Hatnote')
local mHatlist = require('Module:Hatnote list')
local mArguments --initialize lazily
local p = {}

-- Defaults global to this module
local defaults = {
	label = 'See also', --Final fallback for label argument
	labelForm = '%s: %s',
	prefixes = {'label', 'label ', 'l'},
	template = 'Module:Labelled list hatnote'
}

-- Helper function that pre-combines display parameters into page arguments.
-- Also compresses sparse arrays, as a desirable side-effect.
function p.preprocessDisplays (args, prefixes)
	-- Prefixes specify which parameters, in order, to check for display options
	-- They each have numbers auto-appended, e.g. 'label1', 'label 1', &amp; 'l1'
	prefixes = prefixes or defaults.prefixes
	local pages = {}
	for k, v in pairs(args) do
		if type(k) == 'number' then
			local display
			for i = 1, #prefixes do
				display = args[prefixes[i] .. k]
				if display then break end
			end
			local page = display and
				string.format('%s|%s', string.gsub(v, '|.*$', ''), display) or v
			pages[#pages + 1] = page
		end
	end
	return pages
end

-- Produces a labelled pages-list hatnote.
-- The main frame (template definition) takes 1 or 2 arguments, for a singular
-- and (optionally) plural label respectively:
-- * {{#invoke:Labelled list hatnote|labelledList|Singular label|Plural label}}
-- The resulting template takes pagename &amp; label parameters normally.
function p.labelledList (frame)
	mArguments = require('Module:Arguments')
	local labels = {frame.args[1] or defaults.label}
	labels[2] = frame.args[2] or labels[1]
	local template = frame:getParent():getTitle()
	local args = mArguments.getArgs(frame, {parentOnly = true})
	local pages = p.preprocessDisplays(args)
	local options = {
		extraclasses = frame.args.extraclasses,
		category = args.category,
		selfref = frame.args.selfref or args.selfref,
		template = template
	}
	return p._labelledList(pages, labels, options)
end

function p._labelledList (pages, labels, options)
	labels = labels or {}
	if #pages == 0 then
		return mHatnote.makeWikitextError(
			'no page names specified',
			(options.template or defaults.template) .. '#Errors',
			options.category
		)
	end
	label = (#pages == 1 and labels[1] or labels[2]) or defaults.label
	local text = string.format(
		options.labelForm or defaults.labelForm,
		label,
		mHatlist.andList(pages, true)
	)
	local hnOptions = {
		extraclasses = options.extraclasses,
		selfref = options.selfref
	}
	return mHatnote._hatnote(text, hnOptions)
end

return p</text>
      <sha1>932zychfwl5xu5castj2k9j5qs6lzif</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Main</title>
    <ns>828</ns>
    <id>42570919</id>
    <revision>
      <id>923207673</id>
      <parentid>727437646</parentid>
      <timestamp>2019-10-27T02:18:55Z</timestamp>
      <contributor>
        <username>Black Falcon</username>
        <id>348521</id>
      </contributor>
      <comment>changing link from [[Wikipedia:Categorization]] (for editors) to [[Help:Categories]] (for readers)</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2221" xml:space="preserve">--[[
-- This module produces a link to a main article or articles. It implements the
-- template {{main}}.
-- 
-- If the module is used in category or category talk space, it produces "The
-- main article for this category is xxx". Otherwise, it produces
-- "Main article: xxx".
--]]

local mHatnote = require('Module:Hatnote')
local mHatlist = require('Module:Hatnote list')
local mArguments -- lazily initialise
local p = {}

function p.main(frame)
	mArguments = require('Module:Arguments')
	local args = mArguments.getArgs(frame, {parentOnly = true})
	local pages = {}
	for k, v in pairs(args) do
		if type(k) == 'number' then
			local display = args['label ' .. k] or args['l' .. k]
			local page = display and
				string.format('%s|%s', string.gsub(v, '|.*$', ''), display) or v
			pages[#pages + 1] = page
		end
	end
	if #pages == 0 and mw.title.getCurrentTitle().namespace == 0 then
		return mHatnote.makeWikitextError(
			'no page names specified',
			'Template:Main#Errors',
			args.category
		)
	end
	local options = {
		selfref = args.selfref
	}
	return p._main(pages, options)
end

function p._main(args, options)
	-- Get the list of pages. If no first page was specified we use the current
	-- page name.
	local currentTitle = mw.title.getCurrentTitle()
	if #args == 0 then args = {currentTitle.text} end
	local firstPage = string.gsub(args[1], '|.*$', '')
	-- Find the pagetype.
	local pageType = mHatnote.findNamespaceId(firstPage) == 0 and 'article' or 'page'
	-- Make the formatted link text
	list = mHatlist.andList(args, true)
	-- Build the text.
	local isPlural = #args &gt; 1
	local mainForm
	local curNs = currentTitle.namespace
	if (curNs == 14) or (curNs == 15) then --category/talk namespaces
		mainForm = isPlural and
			'The main %ss for this [[Help:Categories|category]] are %s'
			or
			'The main %s for this [[Help:Categories|category]] is %s'
	else
		mainForm = isPlural and 'Main %ss: %s' or 'Main %s: %s'
	end
	local text = string.format(mainForm, pageType, list)
	-- Process the options and pass the text to the _rellink function in
	-- [[Module:Hatnote]].
	options = options or {}
	local hnOptions = {
		selfref = options.selfref
	}
	return mHatnote._hatnote(text, hnOptions)
end

return p</text>
      <sha1>351nwvb1b2lqqeaim7uj9w4zpojq8rr</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Message box</title>
    <ns>828</ns>
    <id>40574910</id>
    <revision>
      <id>948472512</id>
      <parentid>948472510</parentid>
      <timestamp>2020-04-01T06:12:44Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="17776" xml:space="preserve">-- This is a meta-module for producing message box templates, including
-- {{mbox}}, {{ambox}}, {{imbox}}, {{tmbox}}, {{ombox}}, {{cmbox}} and {{fmbox}}.

-- Load necessary modules.
require('Module:No globals')
local getArgs
local yesno = require('Module:Yesno')

-- Get a language object for formatDate and ucfirst.
local lang = mw.language.getContentLanguage()

-- Define constants
local CONFIG_MODULE = 'Module:Message box/configuration'
local DEMOSPACES = {talk = 'tmbox', image = 'imbox', file = 'imbox', category = 'cmbox', article = 'ambox', main = 'ambox'}

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function getTitleObject(...)
	-- Get the title object, passing the function through pcall
	-- in case we are over the expensive function count limit.
	local success, title = pcall(mw.title.new, ...)
	if success then
		return title
	end
end

local function union(t1, t2)
	-- Returns the union of two arrays.
	local vals = {}
	for i, v in ipairs(t1) do
		vals[v] = true
	end
	for i, v in ipairs(t2) do
		vals[v] = true
	end
	local ret = {}
	for k in pairs(vals) do
		table.insert(ret, k)
	end
	table.sort(ret)
	return ret
end

local function getArgNums(args, prefix)
	local nums = {}
	for k, v in pairs(args) do
		local num = mw.ustring.match(tostring(k), '^' .. prefix .. '([1-9]%d*)$')
		if num then
			table.insert(nums, tonumber(num))
		end
	end
	table.sort(nums)
	return nums
end

--------------------------------------------------------------------------------
-- Box class definition
--------------------------------------------------------------------------------

local MessageBox = {}
MessageBox.__index = MessageBox

function MessageBox.new(boxType, args, cfg)
	args = args or {}
	local obj = {}

	-- Set the title object and the namespace.
	obj.title = getTitleObject(args.page) or mw.title.getCurrentTitle()

	-- Set the config for our box type.
	obj.cfg = cfg[boxType]
	if not obj.cfg then
		local ns = obj.title.namespace
		-- boxType is "mbox" or invalid input
		if args.demospace and args.demospace ~= '' then
			-- implement demospace parameter of mbox
			local demospace = string.lower(args.demospace)
			if DEMOSPACES[demospace] then
				-- use template from DEMOSPACES
				obj.cfg = cfg[DEMOSPACES[demospace]]
			elseif string.find( demospace, 'talk' ) then
				-- demo as a talk page
				obj.cfg = cfg.tmbox
			else
				-- default to ombox
				obj.cfg = cfg.ombox
			end
		elseif ns == 0 then
			obj.cfg = cfg.ambox -- main namespace
		elseif ns == 6 then
			obj.cfg = cfg.imbox -- file namespace
		elseif ns == 14 then
			obj.cfg = cfg.cmbox -- category namespace
		else
			local nsTable = mw.site.namespaces[ns]
			if nsTable and nsTable.isTalk then
				obj.cfg = cfg.tmbox -- any talk namespace
			else
				obj.cfg = cfg.ombox -- other namespaces or invalid input
			end
		end
	end

	-- Set the arguments, and remove all blank arguments except for the ones
	-- listed in cfg.allowBlankParams.
	do
		local newArgs = {}
		for k, v in pairs(args) do
			if v ~= '' then
				newArgs[k] = v
			end
		end
		for i, param in ipairs(obj.cfg.allowBlankParams or {}) do
			newArgs[param] = args[param]
		end
		obj.args = newArgs
	end

	-- Define internal data structure.
	obj.categories = {}
	obj.classes = {}
	-- For lazy loading of [[Module:Category handler]].
	obj.hasCategories = false

	return setmetatable(obj, MessageBox)
end

function MessageBox:addCat(ns, cat, sort)
	if not cat then
		return nil
	end
	if sort then
		cat = string.format('[[Category:%s|%s]]', cat, sort)
	else
		cat = string.format('[[Category:%s]]', cat)
	end
	self.hasCategories = true
	self.categories[ns] = self.categories[ns] or {}
	table.insert(self.categories[ns], cat)
end

function MessageBox:addClass(class)
	if not class then
		return nil
	end
	table.insert(self.classes, class)
end

function MessageBox:setParameters()
	local args = self.args
	local cfg = self.cfg

	-- Get type data.
	self.type = args.type
	local typeData = cfg.types[self.type]
	self.invalidTypeError = cfg.showInvalidTypeError
		and self.type
		and not typeData
	typeData = typeData or cfg.types[cfg.default]
	self.typeClass = typeData.class
	self.typeImage = typeData.image

	-- Find if the box has been wrongly substituted.
	self.isSubstituted = cfg.substCheck and args.subst == 'SUBST'

	-- Find whether we are using a small message box.
	self.isSmall = cfg.allowSmall and (
		cfg.smallParam and args.small == cfg.smallParam
		or not cfg.smallParam and yesno(args.small)
	)

	-- Add attributes, classes and styles.
	self.id = args.id
	self.name = args.name
	if self.name then
		self:addClass('box-' .. string.gsub(self.name,' ','_'))
	end
	if yesno(args.plainlinks) ~= false then
		self:addClass('plainlinks')
	end
	for _, class in ipairs(cfg.classes or {}) do
		self:addClass(class)
	end
	if self.isSmall then
		self:addClass(cfg.smallClass or 'mbox-small')
	end
	self:addClass(self.typeClass)
	self:addClass(args.class)
	self.style = args.style
	self.attrs = args.attrs

	-- Set text style.
	self.textstyle = args.textstyle

	-- Find if we are on the template page or not. This functionality is only
	-- used if useCollapsibleTextFields is set, or if both cfg.templateCategory
	-- and cfg.templateCategoryRequireName are set.
	self.useCollapsibleTextFields = cfg.useCollapsibleTextFields
	if self.useCollapsibleTextFields
		or cfg.templateCategory
		and cfg.templateCategoryRequireName
	then
		if self.name then
			local templateName = mw.ustring.match(
				self.name,
				'^[tT][eE][mM][pP][lL][aA][tT][eE][%s_]*:[%s_]*(.*)$'
			) or self.name
			templateName = 'Template:' .. templateName
			self.templateTitle = getTitleObject(templateName)
		end
		self.isTemplatePage = self.templateTitle
			and mw.title.equals(self.title, self.templateTitle)
	end
	
	-- Process data for collapsible text fields. At the moment these are only
	-- used in {{ambox}}.
	if self.useCollapsibleTextFields then
		-- Get the self.issue value.
		if self.isSmall and args.smalltext then
			self.issue = args.smalltext
		else
			local sect
			if args.sect == '' then
				sect = 'This ' .. (cfg.sectionDefault or 'page')
			elseif type(args.sect) == 'string' then
				sect = 'This ' .. args.sect
			end
			local issue = args.issue
			issue = type(issue) == 'string' and issue ~= '' and issue or nil
			local text = args.text
			text = type(text) == 'string' and text or nil
			local issues = {}
			table.insert(issues, sect)
			table.insert(issues, issue)
			table.insert(issues, text)
			self.issue = table.concat(issues, ' ')
		end

		-- Get the self.talk value.
		local talk = args.talk
		-- Show talk links on the template page or template subpages if the talk
		-- parameter is blank.
		if talk == ''
			and self.templateTitle
			and (
				mw.title.equals(self.templateTitle, self.title)
				or self.title:isSubpageOf(self.templateTitle)
			)
		then
			talk = '#'
		elseif talk == '' then
			talk = nil
		end
		if talk then
			-- If the talk value is a talk page, make a link to that page. Else
			-- assume that it's a section heading, and make a link to the talk
			-- page of the current page with that section heading.
			local talkTitle = getTitleObject(talk)
			local talkArgIsTalkPage = true
			if not talkTitle or not talkTitle.isTalkPage then
				talkArgIsTalkPage = false
				talkTitle = getTitleObject(
					self.title.text,
					mw.site.namespaces[self.title.namespace].talk.id
				)
			end
			if talkTitle and talkTitle.exists then
				local talkText = 'Relevant discussion may be found on'
				if talkArgIsTalkPage then
					talkText = string.format(
						'%s [[%s|%s]].',
						talkText,
						talk,
						talkTitle.prefixedText
					)
				else
					talkText = string.format(
						'%s the [[%s#%s|talk page]].',
						talkText,
						talkTitle.prefixedText,
						talk
					)
				end
				self.talk = talkText
			end
		end

		-- Get other values.
		self.fix = args.fix ~= '' and args.fix or nil
		local date
		if args.date and args.date ~= '' then
			date = args.date
		elseif args.date == '' and self.isTemplatePage then
			date = lang:formatDate('F Y')
		end
		if date then
			self.date = string.format(" &lt;small class='date-container'&gt;''(&lt;span class='date'&gt;%s&lt;/span&gt;)''&lt;/small&gt;", date)
		end
		self.info = args.info
		if yesno(args.removalnotice) then
			self.removalNotice = cfg.removalNotice
		end
	end

	-- Set the non-collapsible text field. At the moment this is used by all box
	-- types other than ambox, and also by ambox when small=yes.
	if self.isSmall then
		self.text = args.smalltext or args.text
	else
		self.text = args.text
	end

	-- Set the below row.
	self.below = cfg.below and args.below

	-- General image settings.
	self.imageCellDiv = not self.isSmall and cfg.imageCellDiv
	self.imageEmptyCell = cfg.imageEmptyCell
	if cfg.imageEmptyCellStyle then
		self.imageEmptyCellStyle = 'border:none;padding:0px;width:1px'
	end

	-- Left image settings.
	local imageLeft = self.isSmall and args.smallimage or args.image
	if cfg.imageCheckBlank and imageLeft ~= 'blank' and imageLeft ~= 'none'
		or not cfg.imageCheckBlank and imageLeft ~= 'none'
	then
		self.imageLeft = imageLeft
		if not imageLeft then
			local imageSize = self.isSmall
				and (cfg.imageSmallSize or '30x30px')
				or '40x40px'
			self.imageLeft = string.format('[[File:%s|%s|link=|alt=]]', self.typeImage
				or 'Imbox notice.png', imageSize)
		end
	end

	-- Right image settings.
	local imageRight = self.isSmall and args.smallimageright or args.imageright
	if not (cfg.imageRightNone and imageRight == 'none') then
		self.imageRight = imageRight
	end
end

function MessageBox:setMainspaceCategories()
	local args = self.args
	local cfg = self.cfg

	if not cfg.allowMainspaceCategories then
		return nil
	end

	local nums = {}
	for _, prefix in ipairs{'cat', 'category', 'all'} do
		args[prefix .. '1'] = args[prefix]
		nums = union(nums, getArgNums(args, prefix))
	end

	-- The following is roughly equivalent to the old {{Ambox/category}}.
	local date = args.date
	date = type(date) == 'string' and date
	local preposition = 'from'
	for _, num in ipairs(nums) do
		local mainCat = args['cat' .. tostring(num)]
			or args['category' .. tostring(num)]
		local allCat = args['all' .. tostring(num)]
		mainCat = type(mainCat) == 'string' and mainCat
		allCat = type(allCat) == 'string' and allCat
		if mainCat and date and date ~= '' then
			local catTitle = string.format('%s %s %s', mainCat, preposition, date)
			self:addCat(0, catTitle)
			catTitle = getTitleObject('Category:' .. catTitle)
			if not catTitle or not catTitle.exists then
				self:addCat(0, 'Articles with invalid date parameter in template')
			end
		elseif mainCat and (not date or date == '') then
			self:addCat(0, mainCat)
		end
		if allCat then
			self:addCat(0, allCat)
		end
	end
end

function MessageBox:setTemplateCategories()
	local args = self.args
	local cfg = self.cfg

	-- Add template categories.
	if cfg.templateCategory then
		if cfg.templateCategoryRequireName then
			if self.isTemplatePage then
				self:addCat(10, cfg.templateCategory)
			end
		elseif not self.title.isSubpage then
			self:addCat(10, cfg.templateCategory)
		end
	end

	-- Add template error categories.
	if cfg.templateErrorCategory then
		local templateErrorCategory = cfg.templateErrorCategory
		local templateCat, templateSort
		if not self.name and not self.title.isSubpage then
			templateCat = templateErrorCategory
		elseif self.isTemplatePage then
			local paramsToCheck = cfg.templateErrorParamsToCheck or {}
			local count = 0
			for i, param in ipairs(paramsToCheck) do
				if not args[param] then
					count = count + 1
				end
			end
			if count &gt; 0 then
				templateCat = templateErrorCategory
				templateSort = tostring(count)
			end
			if self.categoryNums and #self.categoryNums &gt; 0 then
				templateCat = templateErrorCategory
				templateSort = 'C'
			end
		end
		self:addCat(10, templateCat, templateSort)
	end
end

function MessageBox:setAllNamespaceCategories()
	-- Set categories for all namespaces.
	if self.invalidTypeError then
		local allSort = (self.title.namespace == 0 and 'Main:' or '') .. self.title.prefixedText
		self:addCat('all', 'Wikipedia message box parameter needs fixing', allSort)
	end
	if self.isSubstituted then
		self:addCat('all', 'Pages with incorrectly substituted templates')
	end
end

function MessageBox:setCategories()
	if self.title.namespace == 0 then
		self:setMainspaceCategories()
	elseif self.title.namespace == 10 then
		self:setTemplateCategories()
	end
	self:setAllNamespaceCategories()
end

function MessageBox:renderCategories()
	if not self.hasCategories then
		-- No categories added, no need to pass them to Category handler so,
		-- if it was invoked, it would return the empty string.
		-- So we shortcut and return the empty string.
		return ""
	end
	-- Convert category tables to strings and pass them through
	-- [[Module:Category handler]].
	return require('Module:Category handler')._main{
		main = table.concat(self.categories[0] or {}),
		template = table.concat(self.categories[10] or {}),
		all = table.concat(self.categories.all or {}),
		nocat = self.args.nocat,
		page = self.args.page
	}
end

function MessageBox:export()
	local root = mw.html.create()

	-- Add the subst check error.
	if self.isSubstituted and self.name then
		root:tag('b')
			:addClass('error')
			:wikitext(string.format(
				'Template &lt;code&gt;%s[[Template:%s|%s]]%s&lt;/code&gt; has been incorrectly substituted.',
				mw.text.nowiki('{{'), self.name, self.name, mw.text.nowiki('}}')
			))
	end

	-- Create the box table.
	local boxTable = root:tag('table')
	boxTable:attr('id', self.id or nil)
	for i, class in ipairs(self.classes or {}) do
		boxTable:addClass(class or nil)
	end
	boxTable
		:cssText(self.style or nil)
		:attr('role', 'presentation')

	if self.attrs then
		boxTable:attr(self.attrs)
	end

	-- Add the left-hand image.
	local row = boxTable:tag('tr')
	if self.imageLeft then
		local imageLeftCell = row:tag('td'):addClass('mbox-image')
		if self.imageCellDiv then
			-- If we are using a div, redefine imageLeftCell so that the image
			-- is inside it. Divs use style="width: 52px;", which limits the
			-- image width to 52px. If any images in a div are wider than that,
			-- they may overlap with the text or cause other display problems.
			imageLeftCell = imageLeftCell:tag('div'):css('width', '52px')
		end
		imageLeftCell:wikitext(self.imageLeft or nil)
	elseif self.imageEmptyCell then
		-- Some message boxes define an empty cell if no image is specified, and
		-- some don't. The old template code in templates where empty cells are
		-- specified gives the following hint: "No image. Cell with some width
		-- or padding necessary for text cell to have 100% width."
		row:tag('td')
			:addClass('mbox-empty-cell')
			:cssText(self.imageEmptyCellStyle or nil)
	end

	-- Add the text.
	local textCell = row:tag('td'):addClass('mbox-text')
	if self.useCollapsibleTextFields then
		-- The message box uses advanced text parameters that allow things to be
		-- collapsible. At the moment, only ambox uses this.
		textCell:cssText(self.textstyle or nil)
		local textCellDiv = textCell:tag('div')
		textCellDiv
			:addClass('mbox-text-span')
			:wikitext(self.issue or nil)
		if (self.talk or self.fix) and not self.isSmall then
			textCellDiv:tag('span')
				:addClass('hide-when-compact')
				:wikitext(self.talk and (' ' .. self.talk) or nil)
				:wikitext(self.fix and (' ' .. self.fix) or nil)
		end
		textCellDiv:wikitext(self.date and (' ' .. self.date) or nil)
		if self.info and not self.isSmall then
			textCellDiv
				:tag('span')
				:addClass('hide-when-compact')
				:wikitext(self.info and (' ' .. self.info) or nil)
		end
		if self.removalNotice then
			textCellDiv:tag('small')
				:addClass('hide-when-compact')
				:tag('i')
					:wikitext(string.format(" (%s)", self.removalNotice))
		end
	else
		-- Default text formatting - anything goes.
		textCell
			:cssText(self.textstyle or nil)
			:wikitext(self.text or nil)
	end

	-- Add the right-hand image.
	if self.imageRight then
		local imageRightCell = row:tag('td'):addClass('mbox-imageright')
		if self.imageCellDiv then
			-- If we are using a div, redefine imageRightCell so that the image
			-- is inside it.
			imageRightCell = imageRightCell:tag('div'):css('width', '52px')
		end
		imageRightCell
			:wikitext(self.imageRight or nil)
	end

	-- Add the below row.
	if self.below then
		boxTable:tag('tr')
			:tag('td')
				:attr('colspan', self.imageRight and '3' or '2')
				:addClass('mbox-text')
				:cssText(self.textstyle or nil)
				:wikitext(self.below or nil)
	end

	-- Add error message for invalid type parameters.
	if self.invalidTypeError then
		root:tag('div')
			:css('text-align', 'center')
			:wikitext(string.format(
				'This message box is using an invalid "type=%s" parameter and needs fixing.',
				self.type or ''
			))
	end

	-- Add categories.
	root:wikitext(self:renderCategories() or nil)

	return tostring(root)
end

--------------------------------------------------------------------------------
-- Exports
--------------------------------------------------------------------------------

local p, mt = {}, {}

function p._exportClasses()
	-- For testing.
	return {
		MessageBox = MessageBox
	}
end

function p.main(boxType, args, cfgTables)
	local box = MessageBox.new(boxType, args, cfgTables or mw.loadData(CONFIG_MODULE))
	box:setParameters()
	box:setCategories()
	return box:export()
end

function mt.__index(t, k)
	return function (frame)
		if not getArgs then
			getArgs = require('Module:Arguments').getArgs
		end
		return t.main(k, getArgs(frame, {trim = false, removeBlanks = false}))
	end
end

return setmetatable(p, mt)</text>
      <sha1>jxxabz8imuheyjlrvf8pyk1zbhdiz42</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Message box/configuration</title>
    <ns>828</ns>
    <id>40627038</id>
    <revision>
      <id>948472514</id>
      <parentid>948472513</parentid>
      <timestamp>2020-04-01T06:12:44Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6141" xml:space="preserve">--------------------------------------------------------------------------------
--                          Message box configuration                         --
--                                                                            --
-- This module contains configuration data for [[Module:Message box]].        --
--------------------------------------------------------------------------------

return {
	ambox = {
		types = {
			speedy = {
				class = 'ambox-speedy',
				image = 'Ambox warning pn.svg'
			},
			delete = {
				class = 'ambox-delete',
				image = 'Ambox warning pn.svg'
			},
			content = {
				class = 'ambox-content',
				image = 'Ambox important.svg'
			},
			style = {
				class = 'ambox-style',
				image = 'Edit-clear.svg'
			},
			move = {
				class = 'ambox-move',
				image = 'Merge-split-transwiki default.svg'
			},
			protection = {
				class = 'ambox-protection',
				image = 'Semi-protection-shackle-keyhole.svg'
			},
			notice = {
				class = 'ambox-notice',
				image = 'Information icon4.svg'
			}
		},
		default                     = 'notice',
		allowBlankParams            = {'talk', 'sect', 'date', 'issue', 'fix', 'subst', 'hidden'},
		allowSmall                  = true,
		smallParam                  = 'left',
		smallClass                  = 'mbox-small-left',
		substCheck                  = true,
		classes                     = {'metadata', 'ambox'},
		imageEmptyCell              = true,
		imageCheckBlank             = true,
		imageSmallSize              = '20x20px',
		imageCellDiv                = true,
		useCollapsibleTextFields    = true,
		imageRightNone              = true,
		sectionDefault              = 'article',
		allowMainspaceCategories    = true,
		templateCategory            = 'Article message templates',
	        templateCategoryRequireName = true,
		templateErrorCategory       = 'Article message templates with missing parameters',
		templateErrorParamsToCheck  = {'issue', 'fix', 'subst'},
		removalNotice               = '[[Help:Maintenance template removal|Learn how and when to remove this template message]]'
	},
	
	cmbox = {
		types = {
			speedy = {
				class = 'cmbox-speedy',
				image = 'Ambox warning pn.svg'
			},
			delete = {
				class = 'cmbox-delete',
				image = 'Ambox warning pn.svg'
			},
			content = {
				class = 'cmbox-content',
				image = 'Ambox important.svg'
			},
			style = {
				class = 'cmbox-style',
				image = 'Edit-clear.svg'
			},
			move = {
				class = 'cmbox-move',
				image = 'Merge-split-transwiki default.svg'
			},
			protection = {
				class = 'cmbox-protection',
				image = 'Semi-protection-shackle-keyhole.svg'
			},
			notice = {
				class = 'cmbox-notice',
				image = 'Information icon4.svg'
			}
		},
		default              = 'notice',
		showInvalidTypeError = true,
		classes              = {'cmbox'},
		imageEmptyCell       = true
	},
	
	fmbox = {
		types = {
			warning = {
				class = 'fmbox-warning',
				image = 'Ambox warning pn.svg'
			},
			editnotice = {
				class = 'fmbox-editnotice',
				image = 'Information icon4.svg'
			},
			system = {
				class = 'fmbox-system',
				image = 'Information icon4.svg'
			}
		},
		default              = 'system',
		showInvalidTypeError = true,
		classes              = {'fmbox'},
		imageEmptyCell       = false,
		imageRightNone       = false
	},
	
	imbox = {
		types = {
			speedy = {
				class = 'imbox-speedy',
				image = 'Ambox warning pn.svg'
			},
			delete = {
				class = 'imbox-delete',
				image = 'Ambox warning pn.svg'
			},
			content = {
				class = 'imbox-content',
				image = 'Ambox important.svg'
			},
			style = {
				class = 'imbox-style',
				image = 'Edit-clear.svg'
			},
			move = {
				class = 'imbox-move',
				image = 'Merge-split-transwiki default.svg'
			},
			protection = {
				class = 'imbox-protection',
				image = 'Semi-protection-shackle-keyhole.svg'
			},
			license = {
				class = 'imbox-license licensetpl',
				image = 'Imbox license.png' -- @todo We need an SVG version of this
			},
			featured = {
				class = 'imbox-featured',
				image = 'Cscr-featured.svg'
			},
			notice = {
				class = 'imbox-notice',
				image = 'Information icon4.svg'
			}
		},
		default              = 'notice',
		showInvalidTypeError = true,
		classes              = {'imbox'},
		imageEmptyCell       = true,
		below                = true,
		templateCategory     = 'File message boxes'
	},
	
	ombox = {
		types = {
			speedy = {
				class = 'ombox-speedy',
				image = 'Ambox warning pn.svg'
			},
			delete = {
				class = 'ombox-delete',
				image = 'Ambox warning pn.svg'
			},
			content = {
				class = 'ombox-content',
				image = 'Ambox important.svg'
			},
			style = {
				class = 'ombox-style',
				image = 'Edit-clear.svg'
			},
			move = {
				class = 'ombox-move',
				image = 'Merge-split-transwiki default.svg'
			},
			protection = {
				class = 'ombox-protection',
				image = 'Semi-protection-shackle-keyhole.svg'
			},
			notice = {
				class = 'ombox-notice',
				image = 'Information icon4.svg'
			}
		},
		default              = 'notice',
		showInvalidTypeError = true,
		classes              = {'ombox'},
		allowSmall           = true,
		imageEmptyCell       = true,
		imageRightNone       = true
	},
	
	tmbox = {
		types = {
			speedy = {
				class = 'tmbox-speedy',
				image = 'Ambox warning pn.svg'
			},
			delete = {
				class = 'tmbox-delete',
				image = 'Ambox warning pn.svg'
			},
			content = {
				class = 'tmbox-content',
				image = 'Ambox important.svg'
			},
			style = {
				class = 'tmbox-style',
				image = 'Edit-clear.svg'
			},
			move = {
				class = 'tmbox-move',
				image = 'Merge-split-transwiki default.svg'
			},
			protection = {
				class = 'tmbox-protection',
				image = 'Semi-protection-shackle-keyhole.svg'
			},
			notice = {
				class = 'tmbox-notice',
				image = 'Information icon4.svg'
			}
		},
		default              = 'notice',
		showInvalidTypeError = true,
		classes              = {'tmbox'},
		allowSmall           = true,
		imageRightNone       = true,
		imageEmptyCell       = true,
		imageEmptyCellStyle  = true,
		templateCategory     = 'Talk message boxes'
	}
}</text>
      <sha1>rz63o9789otb966y0k5pcntqf0bl6te</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Namespace detect</title>
    <ns>828</ns>
    <id>39762919</id>
    <revision>
      <id>602886406</id>
      <parentid>601020017</parentid>
      <timestamp>2014-04-05T17:01:23Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>use demopage instead of page as the main "page" parameter</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5992" xml:space="preserve">--[[
--------------------------------------------------------------------------------
--                                                                            --
--                            NAMESPACE DETECT                                --
--                                                                            --
-- This module implements the {{namespace detect}} template in Lua, with a    --
-- few improvements: all namespaces and all namespace aliases are supported,  --
-- and namespace names are detected automatically for the local wiki. The     --
-- module can also use the corresponding subject namespace value if it is     --
-- used on a talk page. Parameter names can be configured for different wikis --
-- by altering the values in the "cfg" table in                               --
-- Module:Namespace detect/config.                                            --
--                                                                            --
--------------------------------------------------------------------------------
--]]

local data = mw.loadData('Module:Namespace detect/data')
local argKeys = data.argKeys
local cfg = data.cfg
local mappings = data.mappings

local yesno = require('Module:Yesno')
local mArguments -- Lazily initialise Module:Arguments
local mTableTools -- Lazily initilalise Module:TableTools
local ustringLower = mw.ustring.lower

local p = {}

local function fetchValue(t1, t2)
	-- Fetches a value from the table t1 for the first key in array t2 where
	-- a non-nil value of t1 exists.
	for i, key in ipairs(t2) do
		local value = t1[key]
		if value ~= nil then
			return value
		end
	end
	return nil
end

local function equalsArrayValue(t, value)
	-- Returns true if value equals a value in the array t. Otherwise
	-- returns false.
	for i, arrayValue in ipairs(t) do
		if value == arrayValue then
			return true
		end
	end
	return false
end

function p.getPageObject(page)
	-- Get the page object, passing the function through pcall in case of
	-- errors, e.g. being over the expensive function count limit.
	if page then
		local success, pageObject = pcall(mw.title.new, page)
		if success then
			return pageObject
		else
			return nil
		end
	else
		return mw.title.getCurrentTitle()
	end
end

-- Provided for backward compatibility with other modules
function p.getParamMappings()
	return mappings
end

local function getNamespace(args)
	-- This function gets the namespace name from the page object.
	local page = fetchValue(args, argKeys.demopage)
	if page == '' then
		page = nil
	end
	local demospace = fetchValue(args, argKeys.demospace)
	if demospace == '' then
		demospace = nil
	end
	local subjectns = fetchValue(args, argKeys.subjectns)
	local ret
	if demospace then
		-- Handle "demospace = main" properly.
		if equalsArrayValue(argKeys.main, ustringLower(demospace)) then
			ret = mw.site.namespaces[0].name
		else
			ret = demospace
		end
	else
		local pageObject = p.getPageObject(page)
		if pageObject then
			if pageObject.isTalkPage then
				-- Get the subject namespace if the option is set,
				-- otherwise use "talk".
				if yesno(subjectns) then
					ret = mw.site.namespaces[pageObject.namespace].subject.name
				else
					ret = 'talk'
				end
			else
				ret = pageObject.nsText
			end
		else
			return nil -- return nil if the page object doesn't exist.
		end
	end
	ret = ret:gsub('_', ' ')
	return ustringLower(ret)
end

function p._main(args)
	-- Check the parameters stored in the mappings table for any matches.
	local namespace = getNamespace(args) or 'other' -- "other" avoids nil table keys
	local params = mappings[namespace] or {}
	local ret = fetchValue(args, params)
	--[[
	-- If there were no matches, return parameters for other namespaces.
	-- This happens if there was no text specified for the namespace that
	-- was detected or if the demospace parameter is not a valid
	-- namespace. Note that the parameter for the detected namespace must be
	-- completely absent for this to happen, not merely blank.
	--]]
	if ret == nil then
		ret = fetchValue(args, argKeys.other)
	end
	return ret
end

function p.main(frame)
	mArguments = require('Module:Arguments')
	local args = mArguments.getArgs(frame, {removeBlanks = false})
	local ret = p._main(args)
	return ret or ''
end

function p.table(frame)
	--[[
	-- Create a wikitable of all subject namespace parameters, for
	-- documentation purposes. The talk parameter is optional, in case it
	-- needs to be excluded in the documentation.
	--]]
	
	-- Load modules and initialise variables.
	mTableTools = require('Module:TableTools')
	local namespaces = mw.site.namespaces
	local cfg = data.cfg
	local useTalk = type(frame) == 'table' 
		and type(frame.args) == 'table' 
		and yesno(frame.args.talk) -- Whether to use the talk parameter.
	
	-- Get the header names.
	local function checkValue(value, default)
		if type(value) == 'string' then
			return value
		else
			return default
		end
	end
	local nsHeader = checkValue(cfg.wikitableNamespaceHeader, 'Namespace')
	local aliasesHeader = checkValue(cfg.wikitableAliasesHeader, 'Aliases')

	-- Put the namespaces in order.
	local mappingsOrdered = {}
	for nsname, params in pairs(mappings) do
		if useTalk or nsname ~= 'talk' then
			local nsid = namespaces[nsname].id
			-- Add 1, as the array must start with 1; nsid 0 would be lost otherwise.
			nsid = nsid + 1 
			mappingsOrdered[nsid] = params
		end
	end
	mappingsOrdered = mTableTools.compressSparseArray(mappingsOrdered)

	-- Build the table.
	local ret = '{| class="wikitable"'
		.. '\n|-'
		.. '\n! ' .. nsHeader
		.. '\n! ' .. aliasesHeader
	for i, params in ipairs(mappingsOrdered) do
		for j, param in ipairs(params) do
			if j == 1 then
				ret = ret .. '\n|-'
					.. '\n| &lt;code&gt;' .. param .. '&lt;/code&gt;'
					.. '\n| '
			elseif j == 2 then
				ret = ret .. '&lt;code&gt;' .. param .. '&lt;/code&gt;'
			else
				ret = ret .. ', &lt;code&gt;' .. param .. '&lt;/code&gt;'
			end
		end
	end
	ret = ret .. '\n|-'
		.. '\n|}'
	return ret
end

return p</text>
      <sha1>j7kygz1y56jpz4doq0m2c6x1td5d8ar</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Namespace detect/config</title>
    <ns>828</ns>
    <id>42256703</id>
    <revision>
      <id>948472518</id>
      <parentid>948472515</parentid>
      <timestamp>2020-04-01T06:12:44Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3545" xml:space="preserve">--------------------------------------------------------------------------------
--                    Namespace detect configuration data                     --
--                                                                            --
-- This module stores configuration data for Module:Namespace detect. Here    --
-- you can localise the module to your wiki's language.                       --
--                                                                            --
-- To activate a configuration item, you need to uncomment it. This means     --
-- that you need to remove the text "-- " at the start of the line.           --
--------------------------------------------------------------------------------

local cfg = {} -- Don't edit this line.

--------------------------------------------------------------------------------
--                              Parameter names                               --
-- These configuration items specify custom parameter names. Values added     --
-- here will work in addition to the default English parameter names.         --
-- To add one extra name, you can use this format:                            --
--                                                                            --
-- cfg.foo = 'parameter name'                                                 --
--                                                                            --
-- To add multiple names, you can use this format:                            --
--                                                                            --
-- cfg.foo = {'parameter name 1', 'parameter name 2', 'parameter name 3'}     --
--------------------------------------------------------------------------------

---- This parameter displays content for the main namespace:
-- cfg.main = 'main'

---- This parameter displays in talk namespaces:
-- cfg.talk = 'talk'

---- This parameter displays content for "other" namespaces (namespaces for which
---- parameters have not been specified):
-- cfg.other = 'other'

---- This parameter makes talk pages behave as though they are the corresponding
---- subject namespace. Note that this parameter is used with [[Module:Yesno]].
---- Edit that module to change the default values of "yes", "no", etc.
-- cfg.subjectns = 'subjectns'

---- This parameter sets a demonstration namespace:
-- cfg.demospace = 'demospace'

---- This parameter sets a specific page to compare:
cfg.demopage = 'page'

--------------------------------------------------------------------------------
--                           Table configuration                              --
-- These configuration items allow customisation of the "table" function,     --
-- used to generate a table of possible parameters in the module              --
-- documentation.                                                             --
--------------------------------------------------------------------------------

---- The header for the namespace column in the wikitable containing the list of
---- possible subject-space parameters.
-- cfg.wikitableNamespaceHeader = 'Namespace'

---- The header for the wikitable containing the list of possible subject-space
---- parameters.
-- cfg.wikitableAliasesHeader = 'Aliases'

--------------------------------------------------------------------------------
--                        End of configuration data                           --
--------------------------------------------------------------------------------

return cfg -- Don't edit this line.</text>
      <sha1>1o6ozz56i8q0xgyl6xa41n2v7kelhli</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Namespace detect/data</title>
    <ns>828</ns>
    <id>42257476</id>
    <revision>
      <id>948472520</id>
      <parentid>948472519</parentid>
      <timestamp>2020-04-01T06:12:45Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2569" xml:space="preserve">--------------------------------------------------------------------------------
--                          Namespace detect data                             --
-- This module holds data for [[Module:Namespace detect]] to be loaded per    --
-- page, rather than per #invoke, for performance reasons.                    --
--------------------------------------------------------------------------------

local cfg = require('Module:Namespace detect/config')

local function addKey(t, key, defaultKey)
	if key ~= defaultKey then
		t[#t + 1] = key
	end
end

-- Get a table of parameters to query for each default parameter name.
-- This allows wikis to customise parameter names in the cfg table while
-- ensuring that default parameter names will always work. The cfg table
-- values can be added as a string, or as an array of strings.

local defaultKeys = {
	'main',
	'talk',
	'other',
	'subjectns',
	'demospace',
	'demopage'
}

local argKeys = {}
for i, defaultKey in ipairs(defaultKeys) do
	argKeys[defaultKey] = {defaultKey}
end

for defaultKey, t in pairs(argKeys) do
	local cfgValue = cfg[defaultKey]
	local cfgValueType = type(cfgValue)
	if cfgValueType == 'string' then
		addKey(t, cfgValue, defaultKey)
	elseif cfgValueType == 'table' then
		for i, key in ipairs(cfgValue) do
			addKey(t, key, defaultKey)
		end
	end
	cfg[defaultKey] = nil -- Free the cfg value as we don't need it any more.
end

local function getParamMappings()
	--[[
	-- Returns a table of how parameter names map to namespace names. The keys
	-- are the actual namespace names, in lower case, and the values are the
	-- possible parameter names for that namespace, also in lower case. The
	-- table entries are structured like this:
	-- {
	--   [''] = {'main'},
	--   ['wikipedia'] = {'wikipedia', 'project', 'wp'},
	--   ...
	-- }
	--]]
	local mappings = {}
	local mainNsName = mw.site.subjectNamespaces[0].name
	mainNsName = mw.ustring.lower(mainNsName)
	mappings[mainNsName] = mw.clone(argKeys.main)
	mappings['talk'] = mw.clone(argKeys.talk)
	for nsid, ns in pairs(mw.site.subjectNamespaces) do
		if nsid ~= 0 then -- Exclude main namespace.
			local nsname = mw.ustring.lower(ns.name)
			local canonicalName = mw.ustring.lower(ns.canonicalName)
			mappings[nsname] = {nsname}
			if canonicalName ~= nsname then
				table.insert(mappings[nsname], canonicalName)
			end
			for _, alias in ipairs(ns.aliases) do
				table.insert(mappings[nsname], mw.ustring.lower(alias))
			end
		end
	end
	return mappings
end

return {
	argKeys = argKeys,
	cfg = cfg,
	mappings = getParamMappings()
}</text>
      <sha1>ojp6d3pc8mql5nufaqdg576c9so3479</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbar</title>
    <ns>828</ns>
    <id>38827227</id>
    <revision>
      <id>948473991</id>
      <parentid>948472522</parentid>
      <timestamp>2020-04-01T06:30:21Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <comment>Undid revision 948472521 by [[Special:Contributions/w&gt;MusikAnimal|w&gt;MusikAnimal]] ([[User talk:w&gt;MusikAnimal|talk]])</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3091" xml:space="preserve">local p = {}

local getArgs
local ul

function p.addItem (mini, full, link, descrip, args, url)
	local l
	if url then
		l = {'[', '', ']'}
	else
		l = {'[[', '|', ']]'}
	end
	ul:tag('li')
		:addClass('nv-'..full)
		:wikitext(l[1] .. link .. l[2])
		:tag(args.mini and 'abbr' or 'span')
			:attr('title', descrip..' this template')
			:cssText(args.fontstyle)
			:wikitext(args.mini and mini or full)
			:done()
		:wikitext(l[3])
end

function p.brackets (position, c, args, div)
	if args.brackets then
		div
			:tag('span')
				:css('margin-'..position, '-0.125em')
				:cssText(args.fontstyle)
				:wikitext(c)
	end
end

function p._navbar(args)
	local show = {true, true, true, false, false, false}
	local titleArg = 1
	
	if args.collapsible then
		titleArg = 2
		if not args.plain then args.mini = 1 end
		if args.fontcolor then
			args.fontstyle = 'color:' .. args.fontcolor .. ';'
		end
		args.style = 'float:left; text-align:left'
	end
	
	if args.template then
		titleArg = 'template'
		show = {true, false, false, false, false, false}
		local index = {t = 2, d = 2, e = 3, h = 4, m = 5, w = 6, talk = 2, edit = 3, hist = 4, move = 5, watch = 6}
		for k,v in ipairs(require ('Module:TableTools').compressSparseArray(args)) do
			local num = index[v]
			if num then show[num] = true end
		end
	end
	
	if args.noedit then show[3] = false end
	
	local titleText = args[titleArg] or (':' .. mw.getCurrentFrame():getParent():getTitle())
	local title = mw.title.new(mw.text.trim(titleText), 'Template')
	if not title then
		error('Invalid title ' .. titleText)
	end
	local talkpage = title.talkPageTitle and title.talkPageTitle.fullText or ''
	
	local div = mw.html.create():tag('div')
	div
		:addClass('plainlinks')
		:addClass('hlist')
		:addClass('navbar')
		:cssText(args.style)

	if args.mini then div:addClass('mini') end

	if not (args.mini or args.plain) then
		div
			:tag('span')
				:css('word-spacing', 0)
				:cssText(args.fontstyle)
				:wikitext(args.text or 'This box:')
				:wikitext(' ')
	end
	
	p.brackets('right', '&amp;#91; ', args, div)
	
	ul = div:tag('ul')
	if show[1] then p.addItem('v', 'view', title.fullText, 'View', args) end
	if show[2] then p.addItem('t', 'talk', talkpage, 'Discuss', args) end
	if show[3] then p.addItem('e', 'edit', title:fullUrl('action=edit'), 'Edit', args, true) end
	if show[4] then p.addItem('h', 'hist', title:fullUrl('action=history'), 'History of', args, true) end
	if show[5] then
		local move = mw.title.new ('Special:Movepage')
		p.addItem('m', 'move', move:fullUrl('target='..title.fullText), 'Move', args, true) end
	if show[6] then p.addItem('w', 'watch', title:fullUrl('action=watch'), 'Watch', args, true) end
	
	p.brackets('left', ' &amp;#93;', args, div)
	
	if args.collapsible then
		div
			:done()
		:tag('div')
			:css('font-size', '114%')
			:css('margin', args.mini and '0 4em' or '0 7em')
			:cssText(args.fontstyle)
			:wikitext(args[1])
	end

	return tostring(div:done())
end

function p.navbar(frame)
	if not getArgs then
		getArgs = require('Module:Arguments').getArgs
	end
	return p._navbar(getArgs(frame))
end

return p</text>
      <sha1>0kto9e56pycr6rz0vadnqvghkpm06x9</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbox</title>
    <ns>828</ns>
    <id>38634746</id>
    <revision>
      <id>948473914</id>
      <parentid>948472524</parentid>
      <timestamp>2020-04-01T06:29:21Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <comment>Undid revision 948472523 by [[Special:Contributions/w&gt;MusikAnimal|w&gt;MusikAnimal]] ([[User talk:w&gt;MusikAnimal|talk]])</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="12969" xml:space="preserve">--
-- This module implements {{Navbox}}
--

local p = {}

local navbar = require('Module:Navbar')._navbar
local getArgs -- lazily initialized

local args
local border
local listnums
local ODD_EVEN_MARKER = '\127_ODDEVEN_\127'
local RESTART_MARKER = '\127_ODDEVEN0_\127'
local REGEX_MARKER = '\127_ODDEVEN(%d?)_\127'

local function striped(wikitext)
	-- Return wikitext with markers replaced for odd/even striping.
	-- Child (subgroup) navboxes are flagged with a category that is removed
	-- by parent navboxes. The result is that the category shows all pages
	-- where a child navbox is not contained in a parent navbox.
	local orphanCat = '[[Category:Navbox orphans]]'
	if border == 'subgroup' and args.orphan ~= 'yes' then
		-- No change; striping occurs in outermost navbox.
		return wikitext .. orphanCat
	end
	local first, second = 'odd', 'even'
	if args.evenodd then
		if args.evenodd == 'swap' then
			first, second = second, first
		else
			first = args.evenodd
			second = first
		end
	end
	local changer
	if first == second then
		changer = first
	else
		local index = 0
		changer = function (code)
			if code == '0' then
				-- Current occurrence is for a group before a nested table.
				-- Set it to first as a valid although pointless class.
				-- The next occurrence will be the first row after a title
				-- in a subgroup and will also be first.
				index = 0
				return first
			end
			index = index + 1
			return index % 2 == 1 and first or second
		end
	end
	local regex = orphanCat:gsub('([%[%]])', '%%%1')
	return (wikitext:gsub(regex, ''):gsub(REGEX_MARKER, changer))  -- () omits gsub count
end

local function processItem(item, nowrapitems)
	if item:sub(1, 2) == '{|' then
		-- Applying nowrap to lines in a table does not make sense.
		-- Add newlines to compensate for trim of x in |parm=x in a template.
		return '\n' .. item ..'\n'
	end
	if nowrapitems == 'yes' then
		local lines = {}
		for line in (item .. '\n'):gmatch('([^\n]*)\n') do
			local prefix, content = line:match('^([*:;#]+)%s*(.*)')
			if prefix and not content:match('^&lt;span class="nowrap"&gt;') then
				line = prefix .. '&lt;span class="nowrap"&gt;' .. content .. '&lt;/span&gt;'
			end
			table.insert(lines, line)
		end
		item = table.concat(lines, '\n')
	end
	if item:match('^[*:;#]') then
		return '\n' .. item ..'\n'
	end
	return item
end

local function renderNavBar(titleCell)

	if args.navbar ~= 'off' and args.navbar ~= 'plain' and not (not args.name and mw.getCurrentFrame():getParent():getTitle():gsub('/sandbox$', '') == 'Template:Navbox') then
		titleCell:wikitext(navbar{
			args.name,
			mini = 1,
			fontstyle = (args.basestyle or '') .. ';' .. (args.titlestyle or '') .. ';background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;'
		})
	end

end

--
--   Title row
--
local function renderTitleRow(tbl)
	if not args.title then return end

	local titleRow = tbl:tag('tr')

	if args.titlegroup then
		titleRow
			:tag('th')
				:attr('scope', 'row')
				:addClass('navbox-group')
				:addClass(args.titlegroupclass)
				:cssText(args.basestyle)
				:cssText(args.groupstyle)
				:cssText(args.titlegroupstyle)
				:wikitext(args.titlegroup)
	end

	local titleCell = titleRow:tag('th'):attr('scope', 'col')

	if args.titlegroup then
		titleCell
			:css('border-left', '2px solid #fdfdfd')
			:css('width', '100%')
	end

	local titleColspan = 2
	if args.imageleft then titleColspan = titleColspan + 1 end
	if args.image then titleColspan = titleColspan + 1 end
	if args.titlegroup then titleColspan = titleColspan - 1 end

	titleCell
		:cssText(args.basestyle)
		:cssText(args.titlestyle)
		:addClass('navbox-title')
		:attr('colspan', titleColspan)

	renderNavBar(titleCell)

	titleCell
		:tag('div')
			-- id for aria-labelledby attribute
			:attr('id', mw.uri.anchorEncode(args.title))
			:addClass(args.titleclass)
			:css('font-size', '114%')
			:css('margin', '0 4em')
			:wikitext(processItem(args.title))
end

--
--   Above/Below rows
--

local function getAboveBelowColspan()
	local ret = 2
	if args.imageleft then ret = ret + 1 end
	if args.image then ret = ret + 1 end
	return ret
end

local function renderAboveRow(tbl)
	if not args.above then return end

	tbl:tag('tr')
		:tag('td')
			:addClass('navbox-abovebelow')
			:addClass(args.aboveclass)
			:cssText(args.basestyle)
			:cssText(args.abovestyle)
			:attr('colspan', getAboveBelowColspan())
			:tag('div')
				-- id for aria-labelledby attribute, if no title
				:attr('id', args.title and nil or mw.uri.anchorEncode(args.above))
				:wikitext(processItem(args.above, args.nowrapitems))
end

local function renderBelowRow(tbl)
	if not args.below then return end

	tbl:tag('tr')
		:tag('td')
			:addClass('navbox-abovebelow')
			:addClass(args.belowclass)
			:cssText(args.basestyle)
			:cssText(args.belowstyle)
			:attr('colspan', getAboveBelowColspan())
			:tag('div')
				:wikitext(processItem(args.below, args.nowrapitems))
end

--
--   List rows
--
local function renderListRow(tbl, index, listnum)
	local row = tbl:tag('tr')

	if index == 1 and args.imageleft then
		row
			:tag('td')
				:addClass('navbox-image')
				:addClass(args.imageclass)
				:css('width', '1px')               -- Minimize width
				:css('padding', '0px 2px 0px 0px')
				:cssText(args.imageleftstyle)
				:attr('rowspan', #listnums)
				:tag('div')
					:wikitext(processItem(args.imageleft))
	end

	if args['group' .. listnum] then
		local groupCell = row:tag('th')

		-- id for aria-labelledby attribute, if lone group with no title or above
		if listnum == 1 and not (args.title or args.above or args.group2) then
			groupCell
				:attr('id', mw.uri.anchorEncode(args.group1))
		end

		groupCell
			:attr('scope', 'row')
			:addClass('navbox-group')
			:addClass(args.groupclass)
			:cssText(args.basestyle)
			:css('width', args.groupwidth or '1%') -- If groupwidth not specified, minimize width

		groupCell
			:cssText(args.groupstyle)
			:cssText(args['group' .. listnum .. 'style'])
			:wikitext(args['group' .. listnum])
	end

	local listCell = row:tag('td')

	if args['group' .. listnum] then
		listCell
			:css('text-align', 'left')
			:css('border-left-width', '2px')
			:css('border-left-style', 'solid')
	else
		listCell:attr('colspan', 2)
	end

	if not args.groupwidth then
		listCell:css('width', '100%')
	end

	local rowstyle  -- usually nil so cssText(rowstyle) usually adds nothing
	if index % 2 == 1 then
		rowstyle = args.oddstyle
	else
		rowstyle = args.evenstyle
	end

	local listText = args['list' .. listnum]
	local oddEven = ODD_EVEN_MARKER
	if listText:sub(1, 12) == '&lt;/div&gt;&lt;table' then
		-- Assume list text is for a subgroup navbox so no automatic striping for this row.
		oddEven = listText:find('&lt;th[^&gt;]*"navbox%-title"') and RESTART_MARKER or 'odd'
	end
	listCell
		:css('padding', '0px')
		:cssText(args.liststyle)
		:cssText(rowstyle)
		:cssText(args['list' .. listnum .. 'style'])
		:addClass('navbox-list')
		:addClass('navbox-' .. oddEven)
		:addClass(args.listclass)
		:addClass(args['list' .. listnum .. 'class'])
		:tag('div')
			:css('padding', (index == 1 and args.list1padding) or args.listpadding or '0em 0.25em')
			:wikitext(processItem(listText, args.nowrapitems))

	if index == 1 and args.image then
		row
			:tag('td')
				:addClass('navbox-image')
				:addClass(args.imageclass)
				:css('width', '1px')               -- Minimize width
				:css('padding', '0px 0px 0px 2px')
				:cssText(args.imagestyle)
				:attr('rowspan', #listnums)
				:tag('div')
					:wikitext(processItem(args.image))
	end
end


--
--   Tracking categories
--

local function needsHorizontalLists()
	if border == 'subgroup' or args.tracking == 'no' then
		return false
	end
	local listClasses = {
		['plainlist'] = true, ['hlist'] = true, ['hlist hnum'] = true,
		['hlist hwrap'] = true, ['hlist vcard'] = true, ['vcard hlist'] = true,
		['hlist vevent'] = true,
	}
	return not (listClasses[args.listclass] or listClasses[args.bodyclass])
end

local function hasBackgroundColors()
	for _, key in ipairs({'titlestyle', 'groupstyle', 'basestyle', 'abovestyle', 'belowstyle'}) do
		if tostring(args[key]):find('background', 1, true) then
			return true
		end
	end
end

local function hasBorders()
	for _, key in ipairs({'groupstyle', 'basestyle', 'abovestyle', 'belowstyle'}) do
		if tostring(args[key]):find('border', 1, true) then
			return true
		end
	end
end

local function isIllegible()
	local styleratio = require('Module:Color contrast')._styleratio

	for key, style in pairs(args) do
		if tostring(key):match("style$") then
			if styleratio{mw.text.unstripNoWiki(style)} &lt; 4.5 then
				return true
			end
		end
	end
	return false
end

local function getTrackingCategories()
	local cats = {}
	if needsHorizontalLists() then table.insert(cats, 'Navigational boxes without horizontal lists') end
	if hasBackgroundColors() then table.insert(cats, 'Navboxes using background colours') end
	if isIllegible() then table.insert(cats, 'Potentially illegible navboxes') end
	if hasBorders() then table.insert(cats, 'Navboxes using borders') end
	return cats
end

local function renderTrackingCategories(builder)
	local title = mw.title.getCurrentTitle()
	if title.namespace ~= 10 then return end -- not in template space
	local subpage = title.subpageText
	if subpage == 'doc' or subpage == 'sandbox' or subpage == 'testcases' then return end

	for _, cat in ipairs(getTrackingCategories()) do
		builder:wikitext('[[Category:' .. cat .. ']]')
	end
end

--
--   Main navbox tables
--
local function renderMainTable()
	local tbl = mw.html.create('table')
		:addClass('nowraplinks')
		:addClass(args.bodyclass)

	if args.title and (args.state ~= 'plain' and args.state ~= 'off') then
		if args.state == 'collapsed' then args.state = 'mw-collapsed' end
		tbl
			:addClass('mw-collapsible')
			:addClass(args.state or 'autocollapse')
	end

	tbl:css('border-spacing', 0)
	if border == 'subgroup' or border == 'none' then
		tbl
			:addClass('navbox-subgroup')
			:cssText(args.bodystyle)
			:cssText(args.style)
	else  -- regular navbox - bodystyle and style will be applied to the wrapper table
		tbl
			:addClass('navbox-inner')
			:css('background', 'transparent')
			:css('color', 'inherit')
	end
	tbl:cssText(args.innerstyle)

	renderTitleRow(tbl)
	renderAboveRow(tbl)
	for i, listnum in ipairs(listnums) do
		renderListRow(tbl, i, listnum)
	end
	renderBelowRow(tbl)

	return tbl
end

function p._navbox(navboxArgs)
	args = navboxArgs
	listnums = {}

	for k, _ in pairs(args) do
		if type(k) == 'string' then
			local listnum = k:match('^list(%d+)$')
			if listnum then table.insert(listnums, tonumber(listnum)) end
		end
	end
	table.sort(listnums)

	border = mw.text.trim(args.border or args[1] or '')
	if border == 'child' then
		border = 'subgroup'
	end

	-- render the main body of the navbox
	local tbl = renderMainTable()

	-- render the appropriate wrapper around the navbox, depending on the border param
	local res = mw.html.create()
	if border == 'none' then
		local nav = res:tag('div')
			:attr('role', 'navigation')
			:node(tbl)
		-- aria-labelledby title, otherwise above, otherwise lone group
		if args.title or args.above or (args.group1 and not args.group2) then
			nav:attr('aria-labelledby', mw.uri.anchorEncode(args.title or args.above or args.group1))
		else
			nav:attr('aria-label', 'Navbox')
		end
	elseif border == 'subgroup' then
		-- We assume that this navbox is being rendered in a list cell of a parent navbox, and is
		-- therefore inside a div with padding:0em 0.25em. We start with a &lt;/div&gt; to avoid the
		-- padding being applied, and at the end add a &lt;div&gt; to balance out the parent's &lt;/div&gt;
		res
			:wikitext('&lt;/div&gt;')
			:node(tbl)
			:wikitext('&lt;div&gt;')
	else
		local nav = res:tag('div')
			:attr('role', 'navigation')
			:addClass('navbox')
			:addClass(args.navboxclass)
			:cssText(args.bodystyle)
			:cssText(args.style)
			:css('padding', '3px')
			:node(tbl)
		-- aria-labelledby title, otherwise above, otherwise lone group
		if args.title or args.above or (args.group1 and not args.group2) then
			nav:attr('aria-labelledby', mw.uri.anchorEncode(args.title or args.above or args.group1))
		else
			nav:attr('aria-label', 'Navbox')
		end
	end

	if (args.nocat or 'false'):lower() == 'false' then
		renderTrackingCategories(res)
	end
	return striped(tostring(res))
end

function p.navbox(frame)
	if not getArgs then
		getArgs = require('Module:Arguments').getArgs
	end
	args = getArgs(frame, {wrappers = {'Template:Navbox', 'Template:Navbox subgroup'}})
	if frame.args.border then
		-- This allows Template:Navbox_subgroup to use {{#invoke:Navbox|navbox|border=...}}.
		args.border = frame.args.border
	end

	-- Read the arguments in the order they'll be output in, to make references number in the right order.
	local _
	_ = args.title
	_ = args.above
	for i = 1, 20 do
		_ = args["group" .. tostring(i)]
		_ = args["list" .. tostring(i)]
	end
	_ = args.below

	return p._navbox(args)
end

return p</text>
      <sha1>msqtiqdgm245sn6a5v8eu1ia0vtr1o1</sha1>
    </revision>
  </page>
  <page>
    <title>Module:No globals</title>
    <ns>828</ns>
    <id>42567026</id>
    <revision>
      <id>948473889</id>
      <parentid>948472526</parentid>
      <timestamp>2020-04-01T06:28:55Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <comment>Undid revision 948472525 by [[Special:Contributions/w&gt;DiBabelYurikBot|w&gt;DiBabelYurikBot]] ([[User talk:w&gt;DiBabelYurikBot|talk]])</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="307" xml:space="preserve">local mt = getmetatable(_G) or {}
function mt.__index (t, k)
	if k ~= 'arg' then
		error('Tried to read nil global ' .. tostring(k), 2)
	end
	return nil
end
function mt.__newindex(t, k, v)
	if k ~= 'arg' then
		error('Tried to write global ' .. tostring(k), 2)
	end
	rawset(t, k, v)
end
setmetatable(_G, mt)</text>
      <sha1>gggsv54pq7f94l3up48hr91qtxnskdm</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Ns has subpages</title>
    <ns>828</ns>
    <id>44657407</id>
    <revision>
      <id>637438142</id>
      <parentid>637436476</parentid>
      <timestamp>2014-12-10T06:37:29Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <minor/>
      <comment>Protected Module:Ns has subpages: [[WP:High-risk templates|High-risk Lua module]] ([Edit=Allow only template editors and admins] (indefinite) [Move=Allow only template editors and admins] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1678" xml:space="preserve">-- This module implements [[Template:Ns has subpages]].
-- While the template is fairly simple, this information is made available to
-- Lua directly, so using a module means that we don't have to update the
-- template as new namespaces are added.

local p = {}

function p._main(ns, frame)
	-- Get the current namespace if we were not passed one.
	if not ns then
		ns = mw.title.getCurrentTitle().namespace
	end

	-- Look up the namespace table from mw.site.namespaces. This should work
	-- for a majority of cases.
	local nsTable = mw.site.namespaces[ns]

	-- Try using string matching to get the namespace from page names.
	-- Do a quick and dirty bad title check to try and make sure we do the same
	-- thing as {{NAMESPACE}} in most cases.
	if not nsTable and type(ns) == 'string' and not ns:find('[&lt;&gt;|%[%]{}]') then
		local nsStripped = ns:gsub('^[_%s]*:', '')
		nsStripped = nsStripped:gsub(':.*$', '')
		nsTable = mw.site.namespaces[nsStripped]
	end

	-- If we still have no match then try the {{NAMESPACE}} parser function,
	-- which should catch the remainder of cases. Don't use a mw.title object,
	-- as this would increment the expensive function count for each new page
	-- tested.
	if not nsTable then
		frame = frame or mw.getCurrentFrame()
		local nsProcessed = frame:callParserFunction('NAMESPACE', ns)
		nsTable = nsProcessed and mw.site.namespaces[nsProcessed]
	end
	
	return nsTable and nsTable.hasSubpages
end

function p.main(frame)
	local ns = frame:getParent().args[1]
	if ns then
		ns = ns:match('^%s*(.-)%s*$') -- trim whitespace
		ns = tonumber(ns) or ns
	end
	local hasSubpages = p._main(ns, frame)
	return hasSubpages and 'yes' or ''
end

return p</text>
      <sha1>qb0b1z2vff7kifnw21v205d791esbiz</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Other uses</title>
    <ns>828</ns>
    <id>50049066</id>
    <revision>
      <id>902477439</id>
      <parentid>767935439</parentid>
      <timestamp>2019-06-19T03:17:25Z</timestamp>
      <contributor>
        <username>DannyS712</username>
        <id>34581532</id>
      </contributor>
      <comment>merging [[Module:Other uses2]], per tfd</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2016" xml:space="preserve">local mHatnote = require('Module:Hatnote')
local mHatlist = require('Module:Hatnote list')
local mArguments --initialize lazily
local mTableTools --initialize lazily
local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType
local p = {}

-- Produces standard {{other uses}} implementation
function p.otheruses(frame)
	mArguments = require('Module:Arguments')
	mTableTools = require('Module:TableTools')
	local args = mTableTools.compressSparseArray(mArguments.getArgs(frame))
	local title = mw.title.getCurrentTitle().prefixedText
	return p._otheruses(args, {title=title})
end

-- Produces standard {{other uses2}} implementation
function p.otheruses2(frame)
	return p._otheruses({}, {title = (frame:getParent().args[1] or mw.title.getCurrentTitle().prefixedText)})
end

--Implements "other [x]" templates with otherText supplied at invocation
function p.otherX(frame)
	mArguments = require('Module:Arguments')
	mTableTools = require('Module:TableTools')
	local x = frame.args[1]
	local args = mTableTools.compressSparseArray(
		mArguments.getArgs(frame, {parentOnly = true})
	)
	local options = {
		title = mw.title.getCurrentTitle().prefixedText,
		otherText = x
	}
	return p._otheruses(args, options)
end

-- Main generator
function p._otheruses(args, options)
	--Type-checks and defaults
	checkType('_otheruses', 1, args, 'table', true)
	args = args or {}
	checkType('_otheruses', 2, options, 'table')
	if not (options.defaultPage or options.title) then
		error('No default title data provided in "_otheruses" options table', 2)
	end
	local emptyArgs = true
	for k, v in pairs(args) do
		if type(k) == 'number' then emptyArgs = false break end
	end
	if emptyArgs then
		args = {
			options.defaultPage or
			mHatnote.disambiguate(options.title, options.disambiguator)
		}
	end
	--Generate and return hatnote
	local text = mHatlist.forSeeTableToString({{
		use = options.otherText and "other " .. options.otherText or nil,
		pages = args
	}})
	return mHatnote._hatnote(text)
end

return p</text>
      <sha1>84x5jhetrd6pyz99cb4507hr43tiv02</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Pagetype</title>
    <ns>828</ns>
    <id>40875383</id>
    <revision>
      <id>879659113</id>
      <parentid>602685322</parentid>
      <timestamp>2019-01-22T16:51:09Z</timestamp>
      <contributor>
        <username>Galobtter</username>
        <id>19502780</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Module:Pagetype]]": Nearly 8 million transclusions, only template used in WPBannerMeta not to be fully protected ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6396" xml:space="preserve">--------------------------------------------------------------------------------
--                                                                            --
--                                PAGETYPE                                    --
--                                                                            --
--      This is a meta-module intended to replace {{pagetype}} and similar    --
--      templates. It automatically detects namespaces, and allows for a      --
--      great deal of customisation. It can easily be ported to other         --
--      wikis by changing the values in the [[Module:Pagetype/config]].       --
--                                                                            --
--------------------------------------------------------------------------------

-- Load config.
local cfg = mw.loadData('Module:Pagetype/config')

-- Load required modules.
local getArgs = require('Module:Arguments').getArgs
local yesno = require('Module:Yesno')
local nsDetectModule = require('Module:Namespace detect')
local nsDetect = nsDetectModule._main
local getParamMappings = nsDetectModule.getParamMappings
local getPageObject = nsDetectModule.getPageObject

local p = {}

local function shallowCopy(t)
	-- Makes a shallow copy of a table.
	local ret = {}
	for k, v in pairs(t) do
		ret[k] = v
	end
	return ret
end

local function checkPagetypeInput(namespace, val)
	-- Checks to see whether we need the default value for the given namespace,
	-- and if so gets it from the pagetypes table.
	-- The yesno function returns true/false for "yes", "no", etc., and returns
	-- val for other input.
	local ret = yesno(val, val)
	if ret and type(ret) ~= 'string' then
		ret = cfg.pagetypes[namespace]
	end
	return ret
end

local function getPagetypeFromClass(class, param, aliasTable, default)
	-- Gets the pagetype from a class specified from the first positional
	-- parameter.
	param = yesno(param, param)
	if param ~= false then -- No check if specifically disallowed.
		for _, alias in ipairs(aliasTable) do
			if class == alias then
				if type(param) == 'string' then
					return param
				else
					return default
				end
			end
		end
	end
end

local function getNsDetectValue(args)
	-- Builds the arguments to pass to [[Module:Namespace detect]] and returns
	-- the result.

	-- Get the default values.
	local ndArgs = {}
	local defaultns = args[cfg.defaultns]
	if defaultns == cfg.defaultnsAll then
		ndArgs = shallowCopy(cfg.pagetypes)
	else
		local defaultnsArray
		if defaultns == cfg.defaultnsExtended then
			defaultnsArray = cfg.extendedNamespaces
		elseif defaultns == cfg.defaultnsNone then
			defaultnsArray = {}
		else
			defaultnsArray = cfg.defaultNamespaces
		end
		for _, namespace in ipairs(defaultnsArray) do
			ndArgs[namespace] = cfg.pagetypes[namespace]
		end
	end

	--[[
	-- Add custom values passed in from the arguments. These overwrite the
	-- defaults. The possible argument names are fetched from
	-- Module:Namespace detect automatically in case new namespaces are
	-- added. Although we accept namespace aliases as parameters, we only pass
	-- the local namespace name as a parameter to Module:Namespace detect.
	-- This means that the "image" parameter can overwrite defaults for the
	-- File: namespace, which wouldn't work if we passed the parameters through
	-- separately.
	--]]
	local mappings = getParamMappings()
	for ns, paramAliases in pairs(mappings) do
		-- Copy the aliases table, as # doesn't work with tables returned from
		-- mw.loadData.
		paramAliases = shallowCopy(paramAliases)
		local paramName = paramAliases[1]
		-- Iterate backwards along the array so that any values for the local
		-- namespace names overwrite those for namespace aliases.
		for i = #paramAliases, 1, -1 do
			local paramAlias = paramAliases[i]
			local ndArg = checkPagetypeInput(paramAlias, args[paramAlias])
			if ndArg == false then
				-- If any arguments are false, convert them to nil to protect
				-- against breakage by future changes to
				-- [[Module:Namespace detect]].
				ndArgs[paramName] = nil
			elseif ndArg then
				ndArgs[paramName] = ndArg
			end
		end
	end
	-- Check for disambiguation-class and N/A-class pages in mainspace.
	if ndArgs.main then
		local class = args[1]
		if type(class) == 'string' then
			-- Put in lower case so e.g. "Dab" and "dab" will both match.
			class = mw.ustring.lower(class)
		end
		local dab = getPagetypeFromClass(
			class,
			args[cfg.dab],
			cfg.dabAliases,
			cfg.dabDefault
		)
		if dab then
			ndArgs.main = dab
		else
			local na = getPagetypeFromClass(
				class,
				args[cfg.na],
				cfg.naAliases,
				cfg.naDefault
			)
			if na then
				ndArgs.main = na
			end
		end
	end
	-- If there is no talk value specified, use the corresponding subject 
	-- namespace for talk pages.
	if not ndArgs.talk then
		ndArgs.subjectns = true
	end
	-- Add the fallback value. This can also be customised, but it cannot be
	-- disabled.
	local other = args[cfg.other]
	-- We will ignore true/false/nil results from yesno here, but using it
	-- anyway for consistency.
	other = yesno(other, other)
	if type(other) == 'string' then
		ndArgs.other = other
	else
		ndArgs.other = cfg.otherDefault
	end
	-- Allow custom page values.
	ndArgs.page = args.page
	return nsDetect(ndArgs)
end

local function detectRedirects(args)
	local redirect = args[cfg.redirect]
	-- The yesno function returns true/false for "yes", "no", etc., and returns
	-- redirect for other input.
	redirect = yesno(redirect, redirect)
	if redirect == false then
		-- Detect redirects unless they have been explicitly disallowed with
		-- "redirect=no" or similar.
		return
	end
	local pageObject = getPageObject(args.page)
	-- If we are using subject namespaces elsewhere, do so here as well.
	if pageObject
		and not yesno(args.talk, true)
		and args[cfg.defaultns] ~= cfg.defaultnsAll
	then
		pageObject = getPageObject(
			pageObject.subjectNsText .. ':' .. pageObject.text
		)
	end
	-- Allow custom values for redirects.
	if pageObject and pageObject.isRedirect then
		if type(redirect) == 'string' then
			return redirect
		else
			return cfg.redirectDefault
		end
	end
end

function p._main(args)
	local redirect = detectRedirects(args)
	if redirect then
		return redirect
	else
		return getNsDetectValue(args)
	end
end

function p.main(frame)
	local args = getArgs(frame)
	return p._main(args)
end

return p</text>
      <sha1>95yj90zj7nf2doh38om166uuyivtaoq</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Pagetype/config</title>
    <ns>828</ns>
    <id>42396800</id>
    <revision>
      <id>893668182</id>
      <parentid>683099161</parentid>
      <timestamp>2019-04-22T21:09:58Z</timestamp>
      <contributor>
        <username>El C</username>
        <id>92203</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Module:Pagetype/config]]": [[WP:High-risk templates|High-risk Lua module]] ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3776" xml:space="preserve">--------------------------------------------------------------------------------
--                  Module:Pagetype configuration data                        --
-- This page holds localisation and configuration data for Module:Pagetype.   --
--------------------------------------------------------------------------------

local cfg = {} -- Don't edit this line.

--------------------------------------------------------------------------------
--                        Start configuration data                            --
--------------------------------------------------------------------------------

-- This table holds the values to use for "main=true", "user=true", etc. Keys to
-- this table should be namespace parameters that can be used with
-- [[Module:Namespace detect]]. 
cfg.pagetypes = {
	['main']              = 'article',
	['user']              = 'user page',
	['project']           = 'project page',
	['wikipedia']         = 'project page',
	['wp']                = 'project page',
	['file']              = 'file',
	['image']             = 'file',
	['mediawiki']         = 'interface page',
	['template']          = 'template',
	['help']              = 'help page',
	['category']          = 'category',
	['portal']            = 'portal',
	['book']              = 'book',
	['draft']             = 'draft',
	['education program'] = 'education program page',
	['timedtext']         = 'Timed Text page',
	['module']            = 'module',
	['topic']             = 'topic',
	['gadget']            = 'gadget',
	['gadget definition'] = 'gadget definition',
	['talk']              = 'talk page',
	['special']           = 'special page',
	['media']             = 'file',
}

-- This table holds the names of the namespaces to be looked up from
-- cfg.pagetypes by default.
cfg.defaultNamespaces = {
	'main',
	'file',
	'template',
	'category',
	'module',
	'book'
}

-- This table holds the names of the namespaces to be looked up from
-- cfg.pagetypes if cfg.defaultnsExtended is set.
cfg.extendedNamespaces = {
	'main',
	'user',
	'project',
	'file',
	'mediawiki',
	'template',
	'category',
	'help',
	'portal',
	'module',
	'book',
	'draft'
}

-- The parameter name to set which default namespace values to be looked up from
-- cfg.pagetypes.
cfg.defaultns = 'defaultns'

-- The value of cfg.defaultns to set all namespaces, including talk.
cfg.defaultnsAll = 'all'

-- The value of cfg.defaultns to set the namespaces listed in
-- cfg.extendedNamespaces
cfg.defaultnsExtended = 'extended'

-- The value of cfg.defaultns to set no default namespaces.
cfg.defaultnsNone = 'none'

-- The parameter name to use for disambiguation pages page.
cfg.dab = 'dab'

-- This table holds the different possible aliases for disambiguation-class
-- pages. These should be lower-case.
cfg.dabAliases = {
	'disambiguation',
	'disambig',
	'disamb',
	'dab'
}

-- The default value for disambiguation pages.
cfg.dabDefault = 'page'

-- The parameter name to use for N/A-class page.
cfg.na = 'na'

-- This table holds the different possible aliases for N/A-class pages. These
-- should be lower-case.
cfg.naAliases = {'na', 'n/a'}

-- The default value for N/A-class pages.
cfg.naDefault = 'page'

-- The parameter name to use for redirects.
cfg.redirect = 'redirect'

-- The default value to use for redirects.
cfg.redirectDefault = 'redirect'

-- The parameter name for undefined namespaces.
cfg.other = 'other'

-- The value used if the module detects an undefined namespace.
cfg.otherDefault = 'page'

--------------------------------------------------------------------------------
--                        End configuration data                              --
--------------------------------------------------------------------------------

return cfg -- Don't edit this line</text>
      <sha1>nsjvdnxzxja6ehw5fddooj4hmniipbh</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Pp-move-indef</title>
    <ns>828</ns>
    <id>43852218</id>
    <revision>
      <id>626024599</id>
      <parentid>626023280</parentid>
      <timestamp>2014-09-18T01:37:33Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>make fixes for when we are called from #invoke - the title parameter becomes a frame object</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1325" xml:space="preserve">-- This module implements [[Template:Pp-move-indef]].

local p = {}

function p.main(title)
	if type(title) == 'string' then
		title = mw.title.new(title)
	elseif type(title) ~= 'table' or not title.text or not title.getContent then
		-- The title parameter is absent or not a title object. It could be a
		-- frame object if we are being called from #invoke.
		title = mw.title.getCurrentTitle()
	end
	
	local level = title
		and title.protectionLevels
		and title.protectionLevels.move
		and title.protectionLevels.move[1]
	local namespace = title and title.namespace

	local category
	if level == 'sysop' or level == 'templateeditor' then
		if namespace == 2 or namespace == 3 then
			category = 'Wikipedia move-protected user and user talk pages'
		elseif namespace == 4 or namepace == 12 then
			category = 'Wikipedia move-protected project pages'
		elseif namespace == 100 then
			category = 'Wikipedia move-protected portals'
		elseif title.isTalkPage then
			category = 'Wikipedia move-protected talk pages'
		else
			category = 'Wikipedia indefinitely move-protected pages'
		end
	else
		category = 'Wikipedia pages with incorrect protection templates'
	end

	return string.format(
		'[[%s:%s|%s]]',
		mw.site.namespaces[14].name, -- "Category"
		category,
		title.text -- equivalent of {{PAGENAME}}
	)
end

return p</text>
      <sha1>atx7059h6idmnrzpafno6seeehksu5k</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Protection banner</title>
    <ns>828</ns>
    <id>42040984</id>
    <revision>
      <id>948472529</id>
      <parentid>948472527</parentid>
      <timestamp>2020-04-01T06:12:46Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="25486" xml:space="preserve">-- This module implements {{pp-meta}} and its daughter templates such as
-- {{pp-dispute}}, {{pp-vandalism}} and {{pp-sock}}.

-- Initialise necessary modules.
require('Module:No globals')
local makeFileLink = require('Module:File link')._main
local effectiveProtectionLevel = require('Module:Effective protection level')._main
local effectiveProtectionExpiry = require('Module:Effective protection expiry')._main
local yesno = require('Module:Yesno')

-- Lazily initialise modules and objects we don't always need.
local getArgs, makeMessageBox, lang

-- Set constants.
local CONFIG_MODULE = 'Module:Protection banner/config'

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function makeCategoryLink(cat, sort)
	if cat then
		return string.format(
			'[[%s:%s|%s]]',
			mw.site.namespaces[14].name,
			cat,
			sort
		)
	end
end

-- Validation function for the expiry and the protection date
local function validateDate(dateString, dateType)
	if not lang then
		lang = mw.language.getContentLanguage()
	end
	local success, result = pcall(lang.formatDate, lang, 'U', dateString)
	if success then
		result = tonumber(result)
		if result then
			return result
		end
	end
	error(string.format(
		'invalid %s: %s',
		dateType,
		tostring(dateString)
	), 4)
end

local function makeFullUrl(page, query, display)
	return string.format(
		'[%s %s]',
		tostring(mw.uri.fullUrl(page, query)),
		display
	)
end

-- Given a directed graph formatted as node -&gt; table of direct successors,
-- get a table of all nodes reachable from a given node (though always
-- including the given node).
local function getReachableNodes(graph, start)
	local toWalk, retval = {[start] = true}, {}
	while true do
		-- Can't use pairs() since we're adding and removing things as we're iterating
		local k = next(toWalk) -- This always gets the "first" key
		if k == nil then
			return retval
		end
		toWalk[k] = nil
		retval[k] = true
		for _,v in ipairs(graph[k]) do
			if not retval[v] then
				toWalk[v] = true
			end
		end
	end
end

--------------------------------------------------------------------------------
-- Protection class
--------------------------------------------------------------------------------

local Protection = {}
Protection.__index = Protection

Protection.supportedActions = {
	edit = true,
	move = true,
	autoreview = true,
	upload = true
}

Protection.bannerConfigFields = {
	'text',
	'explanation',
	'tooltip',
	'alt',
	'link',
	'image'
}

function Protection.new(args, cfg, title)
	local obj = {}
	obj._cfg = cfg
	obj.title = title or mw.title.getCurrentTitle()

	-- Set action
	if not args.action then
		obj.action = 'edit'
	elseif Protection.supportedActions[args.action] then
		obj.action = args.action
	else
		error(string.format(
			'invalid action: %s',
			tostring(args.action)
		), 3)
	end

	-- Set level
	obj.level = args.demolevel or effectiveProtectionLevel(obj.action, obj.title)
	if not obj.level or (obj.action == 'move' and obj.level == 'autoconfirmed') then
		-- Users need to be autoconfirmed to move pages anyway, so treat
		-- semi-move-protected pages as unprotected.
		obj.level = '*'
	end

	-- Set expiry
	local effectiveExpiry = effectiveProtectionExpiry(obj.action, obj.title)
	if effectiveExpiry == 'infinity' then
		obj.expiry = 'indef'
	elseif effectiveExpiry ~= 'unknown' then
		obj.expiry = validateDate(effectiveExpiry, 'expiry date')
	end

	-- Set reason
	if args[1] then
		obj.reason = mw.ustring.lower(args[1])
		if obj.reason:find('|') then
			error('reasons cannot contain the pipe character ("|")', 3)
		end
	end

	-- Set protection date
	if args.date then
		obj.protectionDate = validateDate(args.date, 'protection date')
	end
	
	-- Set banner config
	do
		obj.bannerConfig = {}
		local configTables = {}
		if cfg.banners[obj.action] then
			configTables[#configTables + 1] = cfg.banners[obj.action][obj.reason]
		end
		if cfg.defaultBanners[obj.action] then
			configTables[#configTables + 1] = cfg.defaultBanners[obj.action][obj.level]
			configTables[#configTables + 1] = cfg.defaultBanners[obj.action].default
		end
		configTables[#configTables + 1] = cfg.masterBanner
		for i, field in ipairs(Protection.bannerConfigFields) do
			for j, t in ipairs(configTables) do
				if t[field] then
					obj.bannerConfig[field] = t[field]
					break
				end
			end
		end
	end
	return setmetatable(obj, Protection)
end

function Protection:isProtected()
	return self.level ~= '*'
end

function Protection:isTemporary()
	return type(self.expiry) == 'number'
end

function Protection:makeProtectionCategory()
	local cfg = self._cfg
	local title = self.title
	
	-- Exit if the page is not protected.
	if not self:isProtected() then
		return ''
	end
	
	-- Get the expiry key fragment.
	local expiryFragment
	if self.expiry == 'indef' then
		expiryFragment = self.expiry
	elseif type(self.expiry) == 'number' then
		expiryFragment = 'temp'
	end

	-- Get the namespace key fragment.
	local namespaceFragment = cfg.categoryNamespaceKeys[title.namespace]
	if not namespaceFragment and title.namespace % 2 == 1 then
			namespaceFragment = 'talk'
	end
 
	-- Define the order that key fragments are tested in. This is done with an
	-- array of tables containing the value to be tested, along with its
	-- position in the cfg.protectionCategories table.
	local order = {
		{val = expiryFragment,    keypos = 1},
		{val = namespaceFragment, keypos = 2},
		{val = self.reason,       keypos = 3},
		{val = self.level,        keypos = 4},
		{val = self.action,       keypos = 5}
	}

	--[[
	-- The old protection templates used an ad-hoc protection category system,
	-- with some templates prioritising namespaces in their categories, and
	-- others prioritising the protection reason. To emulate this in this module
	-- we use the config table cfg.reasonsWithNamespacePriority to set the
	-- reasons for which namespaces have priority over protection reason.
	-- If we are dealing with one of those reasons, move the namespace table to
	-- the end of the order table, i.e. give it highest priority. If not, the
	-- reason should have highest priority, so move that to the end of the table
	-- instead.
	--]]
	table.insert(order, table.remove(order, self.reason and cfg.reasonsWithNamespacePriority[self.reason] and 2 or 3))
 
	--[[
	-- Define the attempt order. Inactive subtables (subtables with nil "value"
	-- fields) are moved to the end, where they will later be given the key
	-- "all". This is to cut down on the number of table lookups in
	-- cfg.protectionCategories, which grows exponentially with the number of
	-- non-nil keys. We keep track of the number of active subtables with the
	-- noActive parameter.
	--]]
	local noActive, attemptOrder
	do
		local active, inactive = {}, {}
		for i, t in ipairs(order) do
			if t.val then
				active[#active + 1] = t
			else
				inactive[#inactive + 1] = t
			end
		end
		noActive = #active
		attemptOrder = active
		for i, t in ipairs(inactive) do
			attemptOrder[#attemptOrder + 1] = t
		end
	end
 
	--[[
	-- Check increasingly generic key combinations until we find a match. If a
	-- specific category exists for the combination of key fragments we are
	-- given, that match will be found first. If not, we keep trying different
	-- key fragment combinations until we match using the key
	-- "all-all-all-all-all".
	--
	-- To generate the keys, we index the key subtables using a binary matrix
	-- with indexes i and j. j is only calculated up to the number of active
	-- subtables. For example, if there were three active subtables, the matrix
	-- would look like this, with 0 corresponding to the key fragment "all", and
	-- 1 corresponding to other key fragments.
	-- 
	--   j 1  2  3
	-- i  
	-- 1   1  1  1
	-- 2   0  1  1
	-- 3   1  0  1
	-- 4   0  0  1
	-- 5   1  1  0
	-- 6   0  1  0
	-- 7   1  0  0
	-- 8   0  0  0
	-- 
	-- Values of j higher than the number of active subtables are set
	-- to the string "all".
	--
	-- A key for cfg.protectionCategories is constructed for each value of i.
	-- The position of the value in the key is determined by the keypos field in
	-- each subtable.
	--]]
	local cats = cfg.protectionCategories
	for i = 1, 2^noActive do
		local key = {}
		for j, t in ipairs(attemptOrder) do
			if j &gt; noActive then
				key[t.keypos] = 'all'
			else
				local quotient = i / 2 ^ (j - 1)
				quotient = math.ceil(quotient)
				if quotient % 2 == 1 then
					key[t.keypos] = t.val
				else
					key[t.keypos] = 'all'
				end
			end
		end
		key = table.concat(key, '|')
		local attempt = cats[key]
		if attempt then
			return makeCategoryLink(attempt, title.text)
		end
	end
	return ''
end

function Protection:isIncorrect()
	local expiry = self.expiry
	return not self:isProtected()
		or type(expiry) == 'number' and expiry &lt; os.time()
end

function Protection:isTemplateProtectedNonTemplate()
	local action, namespace = self.action, self.title.namespace
	return self.level == 'templateeditor'
		and (
			(action ~= 'edit' and action ~= 'move')
			or (namespace ~= 10 and namespace ~= 828)
		)
end

function Protection:makeCategoryLinks()
	local msg = self._cfg.msg
	local ret = { self:makeProtectionCategory() }
	if self:isIncorrect() then
		ret[#ret + 1] = makeCategoryLink(
			msg['tracking-category-incorrect'],
			self.title.text
		)
	end
	if self:isTemplateProtectedNonTemplate() then
		ret[#ret + 1] = makeCategoryLink(
			msg['tracking-category-template'],
			self.title.text
		)
	end
	return table.concat(ret)
end

--------------------------------------------------------------------------------
-- Blurb class
--------------------------------------------------------------------------------

local Blurb = {}
Blurb.__index = Blurb

Blurb.bannerTextFields = {
	text = true,
	explanation = true,
	tooltip = true,
	alt = true,
	link = true
}

function Blurb.new(protectionObj, args, cfg)
	return setmetatable({
		_cfg = cfg,
		_protectionObj = protectionObj,
		_args = args
	}, Blurb)
end

-- Private methods --

function Blurb:_formatDate(num)
	-- Formats a Unix timestamp into dd Month, YYYY format.
	lang = lang or mw.language.getContentLanguage()
	local success, date = pcall(
		lang.formatDate,
		lang,
		self._cfg.msg['expiry-date-format'] or 'j F Y',
		'@' .. tostring(num)
	)
	if success then
		return date
	end
end

function Blurb:_getExpandedMessage(msgKey)
	return self:_substituteParameters(self._cfg.msg[msgKey])
end

function Blurb:_substituteParameters(msg)
	if not self._params then
		local parameterFuncs = {}

		parameterFuncs.CURRENTVERSION     = self._makeCurrentVersionParameter
		parameterFuncs.EDITREQUEST        = self._makeEditRequestParameter
		parameterFuncs.EXPIRY             = self._makeExpiryParameter
		parameterFuncs.EXPLANATIONBLURB   = self._makeExplanationBlurbParameter
		parameterFuncs.IMAGELINK          = self._makeImageLinkParameter
		parameterFuncs.INTROBLURB         = self._makeIntroBlurbParameter
		parameterFuncs.INTROFRAGMENT      = self._makeIntroFragmentParameter
		parameterFuncs.PAGETYPE           = self._makePagetypeParameter
		parameterFuncs.PROTECTIONBLURB    = self._makeProtectionBlurbParameter
		parameterFuncs.PROTECTIONDATE     = self._makeProtectionDateParameter
		parameterFuncs.PROTECTIONLEVEL    = self._makeProtectionLevelParameter
		parameterFuncs.PROTECTIONLOG      = self._makeProtectionLogParameter
		parameterFuncs.TALKPAGE           = self._makeTalkPageParameter
		parameterFuncs.TOOLTIPBLURB       = self._makeTooltipBlurbParameter
		parameterFuncs.TOOLTIPFRAGMENT    = self._makeTooltipFragmentParameter
		parameterFuncs.VANDAL             = self._makeVandalTemplateParameter
		
		self._params = setmetatable({}, {
			__index = function (t, k)
				local param
				if parameterFuncs[k] then
					param = parameterFuncs[k](self)
				end
				param = param or ''
				t[k] = param
				return param
			end
		})
	end
	
	msg = msg:gsub('${(%u+)}', self._params)
	return msg
end

function Blurb:_makeCurrentVersionParameter()
	-- A link to the page history or the move log, depending on the kind of
	-- protection.
	local pagename = self._protectionObj.title.prefixedText
	if self._protectionObj.action == 'move' then
		-- We need the move log link.
		return makeFullUrl(
			'Special:Log',
			{type = 'move', page = pagename},
			self:_getExpandedMessage('current-version-move-display')
		)
	else
		-- We need the history link.
		return makeFullUrl(
			pagename,
			{action = 'history'},
			self:_getExpandedMessage('current-version-edit-display')
		)
	end
end

function Blurb:_makeEditRequestParameter()
	local mEditRequest = require('Module:Submit an edit request')
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	
	-- Get the edit request type.
	local requestType
	if action == 'edit' then
		if level == 'autoconfirmed' then
			requestType = 'semi'
		elseif level == 'extendedconfirmed' then
			requestType = 'extended'
		elseif level == 'templateeditor' then
			requestType = 'template'
		end
	end
	requestType = requestType or 'full'
	
	-- Get the display value.
	local display = self:_getExpandedMessage('edit-request-display')

	return mEditRequest._link{type = requestType, display = display}
end

function Blurb:_makeExpiryParameter()
	local expiry = self._protectionObj.expiry
	if type(expiry) == 'number' then
		return self:_formatDate(expiry)
	else
		return expiry
	end
end

function Blurb:_makeExplanationBlurbParameter()
	-- Cover special cases first.
	if self._protectionObj.title.namespace == 8 then
		-- MediaWiki namespace
		return self:_getExpandedMessage('explanation-blurb-nounprotect')
	end

	-- Get explanation blurb table keys
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	local talkKey = self._protectionObj.title.isTalkPage and 'talk' or 'subject'

	-- Find the message in the explanation blurb table and substitute any
	-- parameters.
	local explanations = self._cfg.explanationBlurbs
	local msg
	if explanations[action][level] and explanations[action][level][talkKey] then
		msg = explanations[action][level][talkKey]
	elseif explanations[action][level] and explanations[action][level].default then
		msg = explanations[action][level].default
	elseif explanations[action].default and explanations[action].default[talkKey] then
		msg = explanations[action].default[talkKey]
	elseif explanations[action].default and explanations[action].default.default then
		msg = explanations[action].default.default
	else
		error(string.format(
			'could not find explanation blurb for action "%s", level "%s" and talk key "%s"',
			action,
			level,
			talkKey
		), 8)
	end
	return self:_substituteParameters(msg)
end

function Blurb:_makeImageLinkParameter()
	local imageLinks = self._cfg.imageLinks
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	local msg
	if imageLinks[action][level] then
		msg = imageLinks[action][level]
	elseif imageLinks[action].default then
		msg = imageLinks[action].default
	else
		msg = imageLinks.edit.default
	end
	return self:_substituteParameters(msg)
end

function Blurb:_makeIntroBlurbParameter()
	if self._protectionObj:isTemporary() then
		return self:_getExpandedMessage('intro-blurb-expiry')
	else
		return self:_getExpandedMessage('intro-blurb-noexpiry')
	end
end

function Blurb:_makeIntroFragmentParameter()
	if self._protectionObj:isTemporary() then
		return self:_getExpandedMessage('intro-fragment-expiry')
	else
		return self:_getExpandedMessage('intro-fragment-noexpiry')
	end
end

function Blurb:_makePagetypeParameter()
	local pagetypes = self._cfg.pagetypes
	return pagetypes[self._protectionObj.title.namespace]
		or pagetypes.default
		or error('no default pagetype defined', 8)
end

function Blurb:_makeProtectionBlurbParameter()
	local protectionBlurbs = self._cfg.protectionBlurbs
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	local msg
	if protectionBlurbs[action][level] then
		msg = protectionBlurbs[action][level]
	elseif protectionBlurbs[action].default then
		msg = protectionBlurbs[action].default
	elseif protectionBlurbs.edit.default then
		msg = protectionBlurbs.edit.default
	else
		error('no protection blurb defined for protectionBlurbs.edit.default', 8)
	end
	return self:_substituteParameters(msg)
end

function Blurb:_makeProtectionDateParameter()
	local protectionDate = self._protectionObj.protectionDate
	if type(protectionDate) == 'number' then
		return self:_formatDate(protectionDate)
	else
		return protectionDate
	end
end

function Blurb:_makeProtectionLevelParameter()
	local protectionLevels = self._cfg.protectionLevels
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	local msg
	if protectionLevels[action][level] then
		msg = protectionLevels[action][level]
	elseif protectionLevels[action].default then
		msg = protectionLevels[action].default
	elseif protectionLevels.edit.default then
		msg = protectionLevels.edit.default
	else
		error('no protection level defined for protectionLevels.edit.default', 8)
	end
	return self:_substituteParameters(msg)
end

function Blurb:_makeProtectionLogParameter()
	local pagename = self._protectionObj.title.prefixedText
	if self._protectionObj.action == 'autoreview' then
		-- We need the pending changes log.
		return makeFullUrl(
			'Special:Log',
			{type = 'stable', page = pagename},
			self:_getExpandedMessage('pc-log-display')
		)
	else
		-- We need the protection log.
		return makeFullUrl(
			'Special:Log',
			{type = 'protect', page = pagename},
			self:_getExpandedMessage('protection-log-display')
		)
	end
end

function Blurb:_makeTalkPageParameter()
	return string.format(
		'[[%s:%s#%s|%s]]',
		mw.site.namespaces[self._protectionObj.title.namespace].talk.name,
		self._protectionObj.title.text,
		self._args.section or 'top',
		self:_getExpandedMessage('talk-page-link-display')
	)
end

function Blurb:_makeTooltipBlurbParameter()
	if self._protectionObj:isTemporary() then
		return self:_getExpandedMessage('tooltip-blurb-expiry')
	else
		return self:_getExpandedMessage('tooltip-blurb-noexpiry')
	end
end

function Blurb:_makeTooltipFragmentParameter()
	if self._protectionObj:isTemporary() then
		return self:_getExpandedMessage('tooltip-fragment-expiry')
	else
		return self:_getExpandedMessage('tooltip-fragment-noexpiry')
	end
end

function Blurb:_makeVandalTemplateParameter()
	return require('Module:Vandal-m')._main{
		self._args.user or self._protectionObj.title.baseText
	}
end

-- Public methods --

function Blurb:makeBannerText(key)
	-- Validate input.
	if not key or not Blurb.bannerTextFields[key] then
		error(string.format(
			'"%s" is not a valid banner config field',
			tostring(key)
		), 2)
	end

	-- Generate the text.
	local msg = self._protectionObj.bannerConfig[key]
	if type(msg) == 'string' then
		return self:_substituteParameters(msg)
	elseif type(msg) == 'function' then
		msg = msg(self._protectionObj, self._args)
		if type(msg) ~= 'string' then
			error(string.format(
				'bad output from banner config function with key "%s"'
					.. ' (expected string, got %s)',
				tostring(key),
				type(msg)
			), 4)
		end
		return self:_substituteParameters(msg)
	end
end

--------------------------------------------------------------------------------
-- BannerTemplate class
--------------------------------------------------------------------------------

local BannerTemplate = {}
BannerTemplate.__index = BannerTemplate

function BannerTemplate.new(protectionObj, cfg)
	local obj = {}
	obj._cfg = cfg

	-- Set the image filename.
	local imageFilename = protectionObj.bannerConfig.image
	if imageFilename then
		obj._imageFilename = imageFilename
	else
		-- If an image filename isn't specified explicitly in the banner config,
		-- generate it from the protection status and the namespace.
		local action = protectionObj.action
		local level = protectionObj.level
		local namespace = protectionObj.title.namespace
		local reason = protectionObj.reason
		
		-- Deal with special cases first.
		if (
			namespace == 10
			or namespace == 828
			or reason and obj._cfg.indefImageReasons[reason]
			)
			and action == 'edit'
			and level == 'sysop'
			and not protectionObj:isTemporary()
		then
			-- Fully protected modules and templates get the special red "indef"
			-- padlock.
			obj._imageFilename = obj._cfg.msg['image-filename-indef']
		else
			-- Deal with regular protection types.
			local images = obj._cfg.images
			if images[action] then
				if images[action][level] then
					obj._imageFilename = images[action][level]
				elseif images[action].default then
					obj._imageFilename = images[action].default
				end
			end
		end
	end
	return setmetatable(obj, BannerTemplate)
end

function BannerTemplate:renderImage()
	local filename = self._imageFilename
		or self._cfg.msg['image-filename-default']
		or 'Transparent.gif'
	return makeFileLink{
		file = filename,
		size = (self.imageWidth or 20) .. 'px',
		alt = self._imageAlt,
		link = self._imageLink,
		caption = self.imageCaption
	}
end

--------------------------------------------------------------------------------
-- Banner class
--------------------------------------------------------------------------------

local Banner = setmetatable({}, BannerTemplate)
Banner.__index = Banner

function Banner.new(protectionObj, blurbObj, cfg)
	local obj = BannerTemplate.new(protectionObj, cfg) -- This doesn't need the blurb.
	obj.imageWidth = 40
	obj.imageCaption = blurbObj:makeBannerText('alt') -- Large banners use the alt text for the tooltip.
	obj._reasonText = blurbObj:makeBannerText('text')
	obj._explanationText = blurbObj:makeBannerText('explanation')
	obj._page = protectionObj.title.prefixedText -- Only makes a difference in testing.
	return setmetatable(obj, Banner)
end

function Banner:__tostring()
	-- Renders the banner.
	makeMessageBox = makeMessageBox or require('Module:Message box').main
	local reasonText = self._reasonText or error('no reason text set', 2)
	local explanationText = self._explanationText
	local mbargs = {
		page = self._page,
		type = 'protection',
		image = self:renderImage(),
		text = string.format(
			"'''%s'''%s",
			reasonText,
			explanationText and '&lt;br /&gt;' .. explanationText or ''
		)
	}
	return makeMessageBox('mbox', mbargs)
end

--------------------------------------------------------------------------------
-- Padlock class
--------------------------------------------------------------------------------

local Padlock = setmetatable({}, BannerTemplate)
Padlock.__index = Padlock

function Padlock.new(protectionObj, blurbObj, cfg)
	local obj = BannerTemplate.new(protectionObj, cfg) -- This doesn't need the blurb.
	obj.imageWidth = 20
	obj.imageCaption = blurbObj:makeBannerText('tooltip')
	obj._imageAlt = blurbObj:makeBannerText('alt')
	obj._imageLink = blurbObj:makeBannerText('link')
	obj._indicatorName = cfg.padlockIndicatorNames[protectionObj.action]
		or cfg.padlockIndicatorNames.default
		or 'pp-default'
	return setmetatable(obj, Padlock)
end

function Padlock:__tostring()
	local frame = mw.getCurrentFrame()
	-- The nowiki tag helps prevent whitespace at the top of articles.
	return frame:extensionTag{name = 'nowiki'} .. frame:extensionTag{
		name = 'indicator',
		args = {name = self._indicatorName},
		content = self:renderImage()
	}
end

--------------------------------------------------------------------------------
-- Exports
--------------------------------------------------------------------------------

local p = {}

function p._exportClasses()
	-- This is used for testing purposes.
	return {
		Protection = Protection,
		Blurb = Blurb,
		BannerTemplate = BannerTemplate,
		Banner = Banner,
		Padlock = Padlock,
	}
end

function p._main(args, cfg, title)
	args = args or {}
	cfg = cfg or require(CONFIG_MODULE)

	local protectionObj = Protection.new(args, cfg, title)

	local ret = {}

	-- If a page's edit protection is equally or more restrictive than its
	-- protection from some other action, then don't bother displaying anything
	-- for the other action (except categories).
	if protectionObj.action == 'edit' or
		args.demolevel or
		not getReachableNodes(
			cfg.hierarchy,
			protectionObj.level
		)[effectiveProtectionLevel('edit', protectionObj.title)]
	then
		-- Initialise the blurb object
		local blurbObj = Blurb.new(protectionObj, args, cfg)
	
		-- Render the banner
		if protectionObj:isProtected() then
			ret[#ret + 1] = tostring(
				(yesno(args.small) and Padlock or Banner)
				.new(protectionObj, blurbObj, cfg)
			)
		end
	end

	-- Render the categories
	if yesno(args.category) ~= false then
		ret[#ret + 1] = protectionObj:makeCategoryLinks()
	end
	
	return table.concat(ret)	
end

function p.main(frame, cfg)
	cfg = cfg or require(CONFIG_MODULE)

	-- Find default args, if any.
	local parent = frame.getParent and frame:getParent()
	local defaultArgs = parent and cfg.wrappers[parent:getTitle():gsub('/sandbox$', '')]

	-- Find user args, and use the parent frame if we are being called from a
	-- wrapper template.
	getArgs = getArgs or require('Module:Arguments').getArgs
	local userArgs = getArgs(frame, {
		parentOnly = defaultArgs,
		frameOnly = not defaultArgs
	})

	-- Build the args table. User-specified args overwrite default args.
	local args = {}
	for k, v in pairs(defaultArgs or {}) do
		args[k] = v
	end
	for k, v in pairs(userArgs) do
		args[k] = v
	end
	return p._main(args, cfg)
end

return p</text>
      <sha1>ice162y8kua930ie41kredxjaxhzy3y</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Protection banner/config</title>
    <ns>828</ns>
    <id>42982788</id>
    <revision>
      <id>948472532</id>
      <parentid>939889955</parentid>
      <timestamp>2020-04-01T06:12:47Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="45682" xml:space="preserve">-- This module provides configuration data for [[Module:Protection banner]].

return {

--------------------------------------------------------------------------------
--
--                                BANNER DATA
--
--------------------------------------------------------------------------------

--[[
-- Banner data consists of six fields:
-- * text - the main protection text that appears at the top of protection
--   banners.
-- * explanation - the text that appears below the main protection text, used
--   to explain the details of the protection.
-- * tooltip - the tooltip text you see when you move the mouse over a small
--   padlock icon.
-- * link - the page that the small padlock icon links to.
-- * alt - the alt text for the small padlock icon. This is also used as tooltip
--   text for the large protection banners.
-- * image - the padlock image used in both protection banners and small padlock
--   icons.
--
-- The module checks in three separate tables to find a value for each field.
-- First it checks the banners table, which has values specific to the reason
-- for the page being protected. Then the module checks the defaultBanners
-- table, which has values specific to each protection level. Finally, the
-- module checks the masterBanner table, which holds data for protection
-- templates to use if no data has been found in the previous two tables.
--
-- The values in the banner data can take parameters. These are specified
-- using ${TEXTLIKETHIS} (a dollar sign preceding a parameter name
-- enclosed in curly braces).
--
--                          Available parameters:
--
-- ${CURRENTVERSION} - a link to the page history or the move log, with the
-- display message "current-version-edit-display" or
-- "current-version-move-display".
--
-- ${EDITREQUEST} - a link to create an edit request for the current page.
--
-- ${EXPLANATIONBLURB} - an explanation blurb, e.g. "Please discuss any changes
-- on the talk page; you may submit a request to ask an administrator to make
-- an edit if it is minor or supported by consensus."
--
-- ${IMAGELINK} - a link to set the image to, depending on the protection
-- action and protection level.
--
-- ${INTROBLURB} - the PROTECTIONBLURB parameter, plus the expiry if an expiry
-- is set. E.g. "Editing of this page by new or unregistered users is currently 
-- disabled until dd Month YYYY."
--
-- ${INTROFRAGMENT} - the same as ${INTROBLURB}, but without final punctuation
-- so that it can be used in run-on sentences.
--
-- ${PAGETYPE} - the type of the page, e.g. "article" or "template".
-- Defined in the cfg.pagetypes table.
--
-- ${PROTECTIONBLURB} - a blurb explaining the protection level of the page, e.g.
-- "Editing of this page by new or unregistered users is currently disabled"
--
-- ${PROTECTIONDATE} - the protection date, if it has been supplied to the
-- template.
--
-- ${PROTECTIONLEVEL} - the protection level, e.g. "fully protected" or
-- "semi-protected".
--
-- ${PROTECTIONLOG} - a link to the protection log or the pending changes log,
-- depending on the protection action.
--
-- ${TALKPAGE} - a link to the talk page. If a section is specified, links
-- straight to that talk page section.
--
-- ${TOOLTIPBLURB} - uses the PAGETYPE, PROTECTIONTYPE and EXPIRY parameters to
-- create a blurb like "This template is semi-protected", or "This article is
-- move-protected until DD Month YYYY".
--
-- ${VANDAL} - links for the specified username (or the root page name)
-- using Module:Vandal-m.
--
--                                 Functions
--
-- For advanced users, it is possible to use Lua functions instead of strings
-- in the banner config tables. Using functions gives flexibility that is not
-- possible just by using parameters. Functions take two arguments, the
-- protection object and the template arguments, and they must output a string.
--
-- For example:
--
-- text = function (protectionObj, args)
--     if protectionObj.level == 'autoconfirmed' then
--         return 'foo'
--     else
--         return 'bar'
--     end
-- end
--
-- Some protection object properties and methods that may be useful:
-- protectionObj.action - the protection action
-- protectionObj.level - the protection level
-- protectionObj.reason - the protection reason
-- protectionObj.expiry - the expiry. Nil if unset, the string "indef" if set
--     to indefinite, and the protection time in unix time if temporary.
-- protectionObj.protectionDate - the protection date in unix time, or nil if
--     unspecified.
-- protectionObj.bannerConfig - the banner config found by the module. Beware
--     of editing the config field used by the function, as it could create an
--     infinite loop.
-- protectionObj:isProtected - returns a boolean showing whether the page is
--     protected.
-- protectionObj:isTemporary - returns a boolean showing whether the expiry is
--     temporary.
-- protectionObj:isIncorrect - returns a boolean showing whether the protection
--     template is incorrect.
--]]

-- The master banner data, used if no values have been found in banners or
-- defaultBanners.
masterBanner = {
	text = '${INTROBLURB}',
	explanation = '${EXPLANATIONBLURB}',
	tooltip = '${TOOLTIPBLURB}',
	link = '${IMAGELINK}',
	alt = 'Page ${PROTECTIONLEVEL}'
},

-- The default banner data. This holds banner data for different protection
-- levels.
-- *required* - this table needs edit, move, autoreview and upload subtables.
defaultBanners = {
	edit = {},
	move = {},
	autoreview = {
		default = {
			alt = 'Page protected with pending changes',
			tooltip = 'All edits by unregistered and new users are subject to review prior to becoming visible to unregistered users',
			image = 'Pending-protection-shackle.svg'
		}
	},
	upload = {}
},

-- The banner data. This holds banner data for different protection reasons.
-- In fact, the reasons specified in this table control which reasons are
-- valid inputs to the first positional parameter.
--
-- There is also a non-standard "description" field that can be used for items
-- in this table. This is a description of the protection reason for use in the
-- module documentation.
--
-- *required* - this table needs edit, move, autoreview and upload subtables.
banners = {
	edit = {
		blp = {
			description = 'For pages protected to promote compliance with the'
				.. ' [[Wikipedia:Biographies of living persons'
				.. '|biographies of living persons]] policy',
			text = '${INTROFRAGMENT} to promote compliance with'
				.. ' [[Wikipedia:Biographies of living persons'
				.. "|Wikipedia's&amp;nbsp;policy on&amp;nbsp;the&amp;nbsp;biographies"
				.. ' of&amp;nbsp;living&amp;nbsp;people]].',
			tooltip = '${TOOLTIPFRAGMENT} to promote compliance with the policy on'
				.. ' biographies of living persons',
		},
		dmca = {
			description = 'For pages protected by the Wikimedia Foundation'
				.. ' due to [[Digital Millennium Copyright Act]] takedown requests',
			explanation = function (protectionObj, args)
				local ret = 'Pursuant to a rights owner notice under the Digital'
					.. ' Millennium Copyright Act (DMCA) regarding some content'
					.. ' in this article, the Wikimedia Foundation acted under'
					.. ' applicable law and took down and restricted the content'
					.. ' in question.'
				if args.notice then
					ret = ret .. ' A copy of the received notice can be found here: '
						.. args.notice .. '.'
				end
				ret = ret .. ' For more information, including websites discussing'
					.. ' how to file a counter-notice, please see'
					.. " [[Wikipedia:Office actions]] and the article's ${TALKPAGE}."
					.. "'''Do not remove this template from the article until the"
					.. " restrictions are withdrawn'''."
				return ret
			end,
			image = 'Office-protection-shackle.svg',
		},
		dispute = {
			description = 'For pages protected due to editing disputes',
			text = function (protectionObj, args)
				-- Find the value of "disputes".
				local display = 'disputes'
				local disputes
				if args.section then
					disputes = string.format(
						'[[%s:%s#%s|%s]]',
						mw.site.namespaces[protectionObj.title.namespace].talk.name,
						protectionObj.title.text,
						args.section,
						display
					)
				else
					disputes = display
				end

				-- Make the blurb, depending on the expiry.
				local msg
				if type(protectionObj.expiry) == 'number' then
					msg = '${INTROFRAGMENT} or until editing %s have been resolved.'
				else
					msg = '${INTROFRAGMENT} until editing %s have been resolved.'
				end
				return string.format(msg, disputes)
			end,
			explanation = "This protection is '''not''' an endorsement of the"
				.. ' ${CURRENTVERSION}. ${EXPLANATIONBLURB}',
			tooltip = '${TOOLTIPFRAGMENT} due to editing disputes',
		},
		ecp = {
			description = 'For articles in topic areas authorized by'
				.. ' [[Wikipedia:Arbitration Committee|ArbCom]] or'
				.. ' meets the criteria for community use',
			tooltip = 'This ${PAGETYPE} is extended-confirmed protected',
			alt = 'Extended-protected ${PAGETYPE}',
		},
		mainpage = {
			description = 'For pages protected for being displayed on the [[Main Page]]',
			text = 'This file is currently'
				.. ' [[Wikipedia:This page is protected|protected]] from'
				.. ' editing because it is currently or will soon be displayed'
				.. ' on the [[Main Page]].',
			explanation = 'Images on the Main Page are protected due to their high'
				.. ' visibility. Please discuss any necessary changes on the ${TALKPAGE}.'
				.. '&lt;br /&gt;&lt;span style="font-size:90%;"&gt;'
				.. "'''Administrators:''' Once this image is definitely off the Main Page,"
				.. ' please unprotect this file, or reduce to semi-protection,'
				.. ' as appropriate.&lt;/span&gt;',
		},
		office = {
			description = 'For pages protected by the Wikimedia Foundation',
			text = function (protectionObj, args)
				local ret = 'This ${PAGETYPE} is currently under the'
					.. ' scrutiny of the'
					.. ' [[Wikipedia:Office actions|Wikimedia Foundation Office]]'
					.. ' and is protected.'
				if protectionObj.protectionDate then
					ret = ret .. ' It has been protected since ${PROTECTIONDATE}.'
				end
				return ret
			end,
			explanation = "If you can edit this page, please discuss all changes and"
				.. " additions on the ${TALKPAGE} first. '''Do not remove protection from this"
				.. " page unless you are authorized by the Wikimedia Foundation to do"
				.. " so.'''",
			image = 'Office-protection-shackle.svg',
		},
		reset = {
			description = 'For pages protected by the Wikimedia Foundation and'
				.. ' "reset" to a bare-bones version',
 			text = 'This ${PAGETYPE} is currently under the'
					.. ' scrutiny of the'
					.. ' [[Wikipedia:Office actions|Wikimedia Foundation Office]]'
					.. ' and is protected.',
			explanation = function (protectionObj, args)
				local ret = ''
				if protectionObj.protectionDate then
					ret = ret .. 'On ${PROTECTIONDATE} this ${PAGETYPE} was'
				else
					ret = ret .. 'This ${PAGETYPE} has been'
				end
				ret = ret .. ' reduced to a'
				.. ' simplified, "bare bones" version so that it may be completely'
				.. ' rewritten to ensure it meets the policies of'
				.. ' [[WP:NPOV|Neutral Point of View]] and [[WP:V|Verifiability]].'
				.. ' Standard Wikipedia policies will apply to its rewriting—which'
				.. ' will eventually be open to all editors—and will be strictly'
				.. ' enforced. The ${PAGETYPE} has been ${PROTECTIONLEVEL} while'
				.. ' it is being rebuilt.\n\n'
				.. 'Any insertion of material directly from'
				.. ' pre-protection revisions of the ${PAGETYPE} will be removed, as'
				.. ' will any material added to the ${PAGETYPE} that is not properly'
				.. ' sourced. The associated talk page(s) were also cleared on the'
				.. " same date.\n\n"
				.. "If you can edit this page, please discuss all changes and"
				.. " additions on the ${TALKPAGE} first. '''Do not override"
				.. " this action, and do not remove protection from this page,"
				.. " unless you are authorized by the Wikimedia Foundation"
				.. " to do so. No editor may remove this notice.'''"

				return ret
			end,
			image = 'Office-protection-shackle.svg',
		},
		sock = {
			description = 'For pages protected due to'
				.. ' [[Wikipedia:Sock puppetry|sock puppetry]]',
			text = '${INTROFRAGMENT} to prevent [[Wikipedia:Sock puppetry|sock puppets]] of'
				.. ' [[Wikipedia:Blocking policy|blocked]] or'
				.. ' [[Wikipedia:Banning policy|banned users]]'
				.. ' from editing it.',
			tooltip = '${TOOLTIPFRAGMENT} to prevent sock puppets of blocked or banned users from'
				.. ' editing it',
		},
		template = {
			description = 'For [[Wikipedia:High-risk templates|high-risk]]'
				.. ' templates and Lua modules',
			text = 'This is a permanently [[Help:Protection|protected]] ${PAGETYPE},'
				.. ' as it is [[Wikipedia:High-risk templates|high-risk]].',
			explanation = 'Please discuss any changes on the ${TALKPAGE}; you may'
				.. ' ${EDITREQUEST} to ask an'
				.. ' [[Wikipedia:Administrators|administrator]] or'
				.. ' [[Wikipedia:Template editor|template editor]] to make an edit if'
				.. ' it is [[Help:Minor edit#When to mark an edit as a minor edit'
				.. '|uncontroversial]] or supported by'
				.. ' [[Wikipedia:Consensus|consensus]]. You can also'
				.. ' [[Wikipedia:Requests for page protection|request]] that the page be'
				.. ' unprotected.',
			tooltip = 'This high-risk ${PAGETYPE} is permanently ${PROTECTIONLEVEL}'
				.. ' to prevent vandalism',
			alt = 'Permanently protected ${PAGETYPE}',
		},
		usertalk = {
			description = 'For pages protected against disruptive edits by a'
				.. ' particular user',
			text = '${INTROFRAGMENT} to prevent ${VANDAL} from using it to make disruptive edits,'
				.. ' such as abusing the'
				.. ' &amp;#123;&amp;#123;[[Template:unblock|unblock]]&amp;#125;&amp;#125; template.',
			explanation = 'If you cannot edit this user talk page and you need to'
				.. ' make a change or leave a message, you can'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for edits to a protected page'
				.. '|request an edit]],'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for reduction in protection level'
				.. '|request unprotection]],'
				.. ' [[Special:Userlogin|log in]],'
				.. ' or [[Special:UserLogin/signup|create an account]].',
		},
		vandalism = {
			description = 'For pages protected against'
				.. ' [[Wikipedia:Vandalism|vandalism]]',
			text = '${INTROFRAGMENT} due to [[Wikipedia:Vandalism|vandalism]].',
			explanation = function (protectionObj, args)
				local ret = ''
				if protectionObj.level == 'sysop' then
					ret = ret .. "This protection is '''not''' an endorsement of the"
						.. ' ${CURRENTVERSION}. '
				end
				return ret .. '${EXPLANATIONBLURB}'
			end,
			tooltip = '${TOOLTIPFRAGMENT} due to vandalism',
		}
	},
	move = {
		dispute = {
			description = 'For pages protected against page moves due to'
				.. ' disputes over the page title',
			explanation = "This protection is '''not''' an endorsement of the"
				.. ' ${CURRENTVERSION}. ${EXPLANATIONBLURB}',
			image = 'Move-protection-shackle.svg'
		},
		vandalism = {
			description = 'For pages protected against'
				.. ' [[Wikipedia:Vandalism#Page-move vandalism'
				.. ' |page-move vandalism]]'
		}
	},
	autoreview = {},
	upload = {}
},

--------------------------------------------------------------------------------
--
--                            GENERAL DATA TABLES
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Protection blurbs
--------------------------------------------------------------------------------

-- This table produces the protection blurbs available with the
-- ${PROTECTIONBLURB} parameter. It is sorted by protection action and
-- protection level, and is checked by the module in the following order:
-- 1. page's protection action, page's protection level
-- 2. page's protection action, default protection level
-- 3. "edit" protection action, default protection level
--
-- It is possible to use banner parameters inside this table.
-- *required* - this table needs edit, move, autoreview and upload subtables.
protectionBlurbs = {
	edit = {
		default = 'This ${PAGETYPE} is currently [[Help:Protection|'
			.. 'protected]] from editing',
		autoconfirmed = 'Editing of this ${PAGETYPE} by [[Wikipedia:User access'
			.. ' levels#New users|new]] or [[Wikipedia:User access levels#Unregistered'
			.. ' users|unregistered]] users is currently [[Help:Protection|disabled]]',
		extendedconfirmed = 'This ${PAGETYPE} is currently under extended confirmed protection',
	},
	move = {
		default = 'This ${PAGETYPE} is currently [[Help:Protection|protected]]'
			.. ' from [[Help:Moving a page|page moves]]'
	},
	autoreview = {
		default = 'All edits made to this ${PAGETYPE} by'
			.. ' [[Wikipedia:User access levels#New users|new]] or'
			.. ' [[Wikipedia:User access levels#Unregistered users|unregistered]]'
			.. ' users are currently'
			.. ' [[Wikipedia:Pending changes|subject to review]]'
	},
	upload = {
		default = 'Uploading new versions of this ${PAGETYPE} is currently disabled'
	}
},


--------------------------------------------------------------------------------
-- Explanation blurbs
--------------------------------------------------------------------------------

-- This table produces the explanation blurbs available with the
-- ${EXPLANATIONBLURB} parameter. It is sorted by protection action,
-- protection level, and whether the page is a talk page or not. If the page is
-- a talk page it will have a talk key of "talk"; otherwise it will have a talk
-- key of "subject". The table is checked in the following order:
-- 1. page's protection action, page's protection level, page's talk key
-- 2. page's protection action, page's protection level, default talk key
-- 3. page's protection action, default protection level, page's talk key
-- 4. page's protection action, default protection level, default talk key
--
-- It is possible to use banner parameters inside this table.
-- *required* - this table needs edit, move, autoreview and upload subtables.
explanationBlurbs = {
	edit = {
		autoconfirmed = {
			subject = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details. If you'
				.. ' cannot edit this ${PAGETYPE} and you wish to make a change, you can'
				.. ' ${EDITREQUEST}, discuss changes on the ${TALKPAGE},'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for reduction in protection level'
				.. '|request unprotection]], [[Special:Userlogin|log in]], or'
				.. ' [[Special:UserLogin/signup|create an account]].',
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details. If you'
				.. ' cannot edit this ${PAGETYPE} and you wish to make a change, you can'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for reduction in protection level'
				.. '|request unprotection]], [[Special:Userlogin|log in]], or'
				.. ' [[Special:UserLogin/signup|create an account]].',
		},
		extendedconfirmed = {
			default = 'Extended confirmed protection prevents edits from all unregistered editors'
				.. ' and registered users with fewer than 30 days tenure and 500 edits.'
				.. ' The [[Wikipedia:Protection policy#extended|policy on community use]]'
				.. ' specifies that extended confirmed protection can be applied to combat'
				.. ' disruption, if semi-protection has proven to be ineffective.'
				.. ' Extended confirmed protection may also be applied to enforce'
				.. ' [[Wikipedia:Arbitration Committee|arbitration sanctions]].'
				.. ' Please discuss any changes on the ${TALKPAGE}; you may'
				.. ' ${EDITREQUEST} to ask for uncontroversial changes supported by'
				.. ' [[Wikipedia:Consensus|consensus]].'
		},
		default = {
			subject = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' Please discuss any changes on the ${TALKPAGE}; you'
				.. ' may ${EDITREQUEST} to ask an'
				.. ' [[Wikipedia:Administrators|administrator]] to make an edit if it'
				.. ' is [[Help:Minor edit#When to mark an edit as a minor edit'
				.. '|uncontroversial]] or supported by [[Wikipedia:Consensus'
				.. '|consensus]]. You may also [[Wikipedia:Requests for'
				.. ' page protection#Current requests for reduction in protection level'
				.. '|request]] that this page be unprotected.',
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' You may [[Wikipedia:Requests for page'
				.. ' protection#Current requests for edits to a protected page|request an'
				.. ' edit]] to this page, or [[Wikipedia:Requests for'
				.. ' page protection#Current requests for reduction in protection level'
				.. '|ask]] for it to be unprotected.'
		}
	},
	move = {
		default = {
			subject = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' The page may still be edited but cannot be moved'
				.. ' until unprotected. Please discuss any suggested moves on the'
				.. ' ${TALKPAGE} or at [[Wikipedia:Requested moves]]. You can also'
				.. ' [[Wikipedia:Requests for page protection|request]] that the page be'
				.. ' unprotected.',
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' The page may still be edited but cannot be moved'
				.. ' until unprotected. Please discuss any suggested moves at'
				.. ' [[Wikipedia:Requested moves]]. You can also'
				.. ' [[Wikipedia:Requests for page protection|request]] that the page be'
				.. ' unprotected.'
		}
	},
	autoreview = {
		default = {
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' Edits to this ${PAGETYPE} by new and unregistered users'
				.. ' will not be visible to readers until they are accepted by'
				.. ' a reviewer. To avoid the need for your edits to be'
				.. ' reviewed, you may'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for reduction in protection level'
				.. '|request unprotection]], [[Special:Userlogin|log in]], or'
				.. ' [[Special:UserLogin/signup|create an account]].'
		},
	},
	upload = {
		default = {
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' The page may still be edited but new versions of the file'
				.. ' cannot be uploaded until it is unprotected. You can'
				.. ' request that a new version be uploaded by using a'
				.. ' [[Wikipedia:Edit requests|protected edit request]], or you'
				.. ' can  [[Wikipedia:Requests for page protection|request]]'
				.. ' that the file be unprotected.'
		}
	}
},

--------------------------------------------------------------------------------
-- Protection levels
--------------------------------------------------------------------------------

-- This table provides the data for the ${PROTECTIONLEVEL} parameter, which
-- produces a short label for different protection levels. It is sorted by
-- protection action and protection level, and is checked in the following
-- order:
-- 1. page's protection action, page's protection level
-- 2. page's protection action, default protection level
-- 3. "edit" protection action, default protection level
--
-- It is possible to use banner parameters inside this table.
-- *required* - this table needs edit, move, autoreview and upload subtables.
protectionLevels = {
	edit = {
		default = 'protected',
		templateeditor = 'template-protected',
		extendedconfirmed = 'extended-protected',
		autoconfirmed = 'semi-protected',
	},
	move = {
		default = 'move-protected'
	},
	autoreview = {
	},
	upload = {
		default = 'upload-protected'
	}
},

--------------------------------------------------------------------------------
-- Images
--------------------------------------------------------------------------------

-- This table lists different padlock images for each protection action and
-- protection level. It is used if an image is not specified in any of the
-- banner data tables, and if the page does not satisfy the conditions for using
-- the ['image-filename-indef'] image. It is checked in the following order:
-- 1. page's protection action, page's protection level
-- 2. page's protection action, default protection level
images = {
	edit = {
		default = 'Full-protection-shackle.svg',
		templateeditor = 'Template-protection-shackle.svg',
		extendedconfirmed = 'Extended-protection-shackle.svg',
		autoconfirmed = 'Semi-protection-shackle.svg'
	},
	move = {
		default = 'Move-protection-shackle.svg',
	},
	autoreview = {
		default = 'Pending-protection-shackle.svg'
	},
	upload = {
		default = 'Upload-protection-shackle.svg'
	}
},

-- Pages with a reason specified in this table will show the special "indef"
-- padlock, defined in the 'image-filename-indef' message, if no expiry is set.
indefImageReasons = {
	template = true
},

--------------------------------------------------------------------------------
-- Image links
--------------------------------------------------------------------------------

-- This table provides the data for the ${IMAGELINK} parameter, which gets
-- the image link for small padlock icons based on the page's protection action
-- and protection level. It is checked in the following order:
-- 1. page's protection action, page's protection level
-- 2. page's protection action, default protection level
-- 3. "edit" protection action, default protection level
--
-- It is possible to use banner parameters inside this table.
-- *required* - this table needs edit, move, autoreview and upload subtables.
imageLinks = {
	edit = {
		default = 'Wikipedia:Protection policy#full',
		templateeditor = 'Wikipedia:Protection policy#template',
		extendedconfirmed = 'Wikipedia:Protection policy#extended',
		autoconfirmed = 'Wikipedia:Protection policy#semi'
	},
	move = {
		default = 'Wikipedia:Protection policy#move'
	},
	autoreview = {
		default = 'Wikipedia:Protection policy#pending'
	},
	upload = {
		default = 'Wikipedia:Protection policy#upload'
	}
},

--------------------------------------------------------------------------------
-- Padlock indicator names
--------------------------------------------------------------------------------

-- This table provides the "name" attribute for the &lt;indicator&gt; extension tag
-- with which small padlock icons are generated. All indicator tags on a page
-- are displayed in alphabetical order based on this attribute, and with
-- indicator tags with duplicate names, the last tag on the page wins.
-- The attribute is chosen based on the protection action; table keys must be a
-- protection action name or the string "default".
padlockIndicatorNames = {
	autoreview = 'pp-autoreview',
	default = 'pp-default'
},

--------------------------------------------------------------------------------
-- Protection categories
--------------------------------------------------------------------------------

--[[
-- The protection categories are stored in the protectionCategories table.
-- Keys to this table are made up of the following strings:
--
-- 1. the expiry date
-- 2. the namespace
-- 3. the protection reason (e.g. "dispute" or "vandalism")
-- 4. the protection level (e.g. "sysop" or "autoconfirmed")
-- 5. the action (e.g. "edit" or "move")
-- 
-- When the module looks up a category in the table, first it will will check to
-- see a key exists that corresponds to all five parameters. For example, a
-- user page semi-protected from vandalism for two weeks would have the key
-- "temp-user-vandalism-autoconfirmed-edit". If no match is found, the module
-- changes the first part of the key to "all" and checks the table again. It
-- keeps checking increasingly generic key combinations until it finds the
-- field, or until it reaches the key "all-all-all-all-all".
--
-- The module uses a binary matrix to determine the order in which to search.
-- This is best demonstrated by a table. In this table, the "0" values
-- represent "all", and the "1" values represent the original data (e.g.
-- "indef" or "file" or "vandalism").
--
--        expiry    namespace reason   level     action
-- order
-- 1      1         1         1        1         1
-- 2      0         1         1        1         1
-- 3      1         0         1        1         1
-- 4      0         0         1        1         1
-- 5      1         1         0        1         1
-- 6      0         1         0        1         1
-- 7      1         0         0        1         1
-- 8      0         0         0        1         1
-- 9      1         1         1        0         1
-- 10     0         1         1        0         1
-- 11     1         0         1        0         1
-- 12     0         0         1        0         1
-- 13     1         1         0        0         1
-- 14     0         1         0        0         1
-- 15     1         0         0        0         1
-- 16     0         0         0        0         1
-- 17     1         1         1        1         0
-- 18     0         1         1        1         0
-- 19     1         0         1        1         0
-- 20     0         0         1        1         0
-- 21     1         1         0        1         0
-- 22     0         1         0        1         0
-- 23     1         0         0        1         0
-- 24     0         0         0        1         0
-- 25     1         1         1        0         0
-- 26     0         1         1        0         0
-- 27     1         0         1        0         0
-- 28     0         0         1        0         0
-- 29     1         1         0        0         0
-- 30     0         1         0        0         0
-- 31     1         0         0        0         0
-- 32     0         0         0        0         0
--
-- In this scheme the action has the highest priority, as it is the last
-- to change, and the expiry has the least priority, as it changes the most.
-- The priorities of the expiry, the protection level and the action are
-- fixed, but the priorities of the reason and the namespace can be swapped
-- through the use of the cfg.bannerDataNamespaceHasPriority table.
--]]

-- If the reason specified to the template is listed in this table,
-- namespace data will take priority over reason data in the protectionCategories
-- table.
reasonsWithNamespacePriority = {
	vandalism = true,
},

-- The string to use as a namespace key for the protectionCategories table for each
-- namespace number.
categoryNamespaceKeys = {
	[  2] = 'user',
	[  3] = 'user',
	[  4] = 'project',
	[  6] = 'file',
	[  8] = 'mediawiki',
	[ 10] = 'template',
	[ 12] = 'project',
	[ 14] = 'category',
	[100] = 'portal',
	[828] = 'module',
},

protectionCategories = {
	['all|all|all|all|all']                  = 'Wikipedia fully protected pages',
	['all|all|office|all|all']               = 'Wikipedia Office-protected pages',
	['all|all|reset|all|all']                = 'Wikipedia Office-protected pages',
	['all|all|dmca|all|all']                 = 'Wikipedia Office-protected pages',
	['all|all|mainpage|all|all']             = 'Wikipedia fully-protected main page files',
	['all|all|all|extendedconfirmed|all']    = 'Wikipedia extended-confirmed-protected pages',
	['all|all|ecp|extendedconfirmed|all']    = 'Wikipedia extended-confirmed-protected pages',
	['all|template|all|all|edit']            = 'Wikipedia fully protected templates',
	['all|all|all|autoconfirmed|edit']       = 'Wikipedia semi-protected pages',
	['indef|all|all|autoconfirmed|edit']     = 'Wikipedia indefinitely semi-protected pages',
	['all|all|blp|autoconfirmed|edit']       = 'Wikipedia indefinitely semi-protected biographies of living people',
	['temp|all|blp|autoconfirmed|edit']      = 'Wikipedia temporarily semi-protected biographies of living people',
	['all|all|dispute|autoconfirmed|edit']   = 'Wikipedia pages semi-protected due to dispute',
	['all|all|sock|autoconfirmed|edit']      = 'Wikipedia pages semi-protected from banned users',
	['all|all|vandalism|autoconfirmed|edit'] = 'Wikipedia pages semi-protected against vandalism',
	['all|category|all|autoconfirmed|edit']  = 'Wikipedia semi-protected categories',
	['all|file|all|autoconfirmed|edit']      = 'Wikipedia semi-protected files',
	['all|portal|all|autoconfirmed|edit']    = 'Wikipedia semi-protected portals',
	['all|project|all|autoconfirmed|edit']   = 'Wikipedia semi-protected project pages',
	['all|talk|all|autoconfirmed|edit']      = 'Wikipedia semi-protected talk pages',
	['all|template|all|autoconfirmed|edit']  = 'Wikipedia semi-protected templates',
	['all|user|all|autoconfirmed|edit']      = 'Wikipedia semi-protected user and user talk pages',
	['all|template|all|templateeditor|edit'] = 'Wikipedia template-protected templates',
	['all|all|blp|sysop|edit']               = 'Wikipedia indefinitely protected biographies of living people',
	['temp|all|blp|sysop|edit']              = 'Wikipedia temporarily protected biographies of living people',
	['all|all|dispute|sysop|edit']           = 'Wikipedia pages protected due to dispute',
	['all|all|sock|sysop|edit']              = 'Wikipedia pages protected from banned users',
	['all|all|vandalism|sysop|edit']         = 'Wikipedia pages protected against vandalism',
	['all|category|all|sysop|edit']          = 'Wikipedia fully protected categories',
	['all|file|all|sysop|edit']              = 'Wikipedia fully-protected files',
	['all|project|all|sysop|edit']           = 'Wikipedia fully-protected project pages',
	['all|talk|all|sysop|edit']              = 'Wikipedia fully-protected talk pages',
	['all|template|all|sysop|edit']          = 'Wikipedia fully protected templates',
	['all|user|all|sysop|edit']              = 'Wikipedia fully protected user and user talk pages',
	['all|module|all|all|edit']              = 'Wikipedia fully-protected modules',
	['all|module|all|templateeditor|edit']   = 'Wikipedia template-protected modules',
	['all|module|all|autoconfirmed|edit']    = 'Wikipedia semi-protected modules',
	['all|all|all|sysop|move']               = 'Wikipedia move-protected pages',
	['indef|all|all|sysop|move']             = 'Wikipedia indefinitely move-protected pages',
	['all|all|dispute|sysop|move']           = 'Wikipedia pages move-protected due to dispute',
	['all|all|vandalism|sysop|move']         = 'Wikipedia pages move-protected due to vandalism',
	['all|portal|all|sysop|move']            = 'Wikipedia move-protected portals',
	['all|portal|all|sysop|move']            = 'Wikipedia move-protected portals',
	['all|project|all|sysop|move']           = 'Wikipedia move-protected project pages',
	['all|talk|all|sysop|move']              = 'Wikipedia move-protected talk pages',
	['all|template|all|sysop|move']          = 'Wikipedia move-protected templates',
	['all|user|all|sysop|move']              = 'Wikipedia move-protected user and user talk pages',
	['all|all|all|autoconfirmed|autoreview'] = 'Wikipedia pending changes protected pages',
	['all|file|all|all|upload']              = 'Wikipedia upload-protected files',
},

--------------------------------------------------------------------------------
-- Expiry category config
--------------------------------------------------------------------------------

-- This table configures the expiry category behaviour for each protection
-- action.
-- * If set to true, setting that action will always categorise the page if
--   an expiry parameter is not set.
-- * If set to false, setting that action will never categorise the page.
-- * If set to nil, the module will categorise the page if:
--   1) an expiry parameter is not set, and
--   2) a reason is provided, and
--   3) the specified reason is not blacklisted in the reasonsWithoutExpiryCheck
--      table.

expiryCheckActions = {
	edit = nil,
	move = false,
	autoreview = true,
	upload = false
},

reasonsWithoutExpiryCheck = {
	blp = true,
	template = true,
},

--------------------------------------------------------------------------------
-- Pagetypes
--------------------------------------------------------------------------------

-- This table produces the page types available with the ${PAGETYPE} parameter.
-- Keys are namespace numbers, or the string "default" for the default value.
pagetypes = {
	[0] = 'article',
	[6] = 'file',
	[10] = 'template',
	[14] = 'category',
	[828] = 'module',
	default = 'page'
},

--------------------------------------------------------------------------------
-- Strings marking indefinite protection
--------------------------------------------------------------------------------

-- This table contains values passed to the expiry parameter that mean the page
-- is protected indefinitely.
indefStrings = {
	['indef'] = true,
	['indefinite'] = true,
	['indefinitely'] = true,
	['infinite'] = true,
},

--------------------------------------------------------------------------------
-- Group hierarchy
--------------------------------------------------------------------------------

-- This table maps each group to all groups that have a superset of the original
-- group's page editing permissions.
hierarchy = {
	sysop = {},
	reviewer = {'sysop'},
	filemover = {'sysop'},
	templateeditor = {'sysop'},
	extendedconfirmed = {'sysop'},
	autoconfirmed = {'reviewer', 'filemover', 'templateeditor', 'extendedconfirmed'},
	user = {'autoconfirmed'},
	['*'] = {'user'}
},

--------------------------------------------------------------------------------
-- Wrapper templates and their default arguments
--------------------------------------------------------------------------------

-- This table contains wrapper templates used with the module, and their
-- default arguments. Templates specified in this table should contain the
-- following invocation, and no other template content:
--
-- {{#invoke:Protection banner|main}}
--
-- If other content is desired, it can be added between
-- &lt;noinclude&gt;...&lt;/noinclude&gt; tags.
--
-- When a user calls one of these wrapper templates, they will use the
-- default arguments automatically. However, users can override any of the
-- arguments.
wrappers = {
	['Template:Pp']                         = {},
	['Template:Pp-extended']                = {'ecp'},
	['Template:Pp-blp']                     = {'blp'},
	-- we don't need Template:Pp-create
	['Template:Pp-dispute']                 = {'dispute'},
	['Template:Pp-main-page']               = {'mainpage'},
	['Template:Pp-move']                    = {action = 'move'},
	['Template:Pp-move-dispute']            = {'dispute', action = 'move'},
	-- we don't need Template:Pp-move-indef
	['Template:Pp-move-vandalism']          = {'vandalism', action = 'move'},
	['Template:Pp-office']                  = {'office'},
	['Template:Pp-office-dmca']             = {'dmca'},
	['Template:Pp-pc']                      = {action = 'autoreview', small = true},
	['Template:Pp-pc1']                     = {action = 'autoreview', small = true},
	['Template:Pp-reset']                   = {'reset'},
	['Template:Pp-semi-indef']              = {small = true},
	['Template:Pp-sock']                    = {'sock'},
	['Template:Pp-template']                = {'template', small = true},
	['Template:Pp-upload']                  = {action = 'upload'},
	['Template:Pp-usertalk']                = {'usertalk'},
	['Template:Pp-vandalism']               = {'vandalism'},
},

--------------------------------------------------------------------------------
-- 
--                                 MESSAGES
-- 
--------------------------------------------------------------------------------

msg = {

--------------------------------------------------------------------------------
-- Intro blurb and intro fragment
--------------------------------------------------------------------------------

-- These messages specify what is produced by the ${INTROBLURB} and
-- ${INTROFRAGMENT} parameters. If the protection is temporary they use the
-- intro-blurb-expiry or intro-fragment-expiry, and if not they use
-- intro-blurb-noexpiry or intro-fragment-noexpiry.
-- It is possible to use banner parameters in these messages.
['intro-blurb-expiry'] = '${PROTECTIONBLURB} until ${EXPIRY}.',
['intro-blurb-noexpiry'] = '${PROTECTIONBLURB}.',
['intro-fragment-expiry'] = '${PROTECTIONBLURB} until ${EXPIRY},',
['intro-fragment-noexpiry'] = '${PROTECTIONBLURB}',

--------------------------------------------------------------------------------
-- Tooltip blurb
--------------------------------------------------------------------------------

-- These messages specify what is produced by the ${TOOLTIPBLURB} parameter.
-- If the protection is temporary the tooltip-blurb-expiry message is used, and
-- if not the tooltip-blurb-noexpiry message is used.
-- It is possible to use banner parameters in these messages.
['tooltip-blurb-expiry'] = 'This ${PAGETYPE} is ${PROTECTIONLEVEL} until ${EXPIRY}.',
['tooltip-blurb-noexpiry'] = 'This ${PAGETYPE} is ${PROTECTIONLEVEL}.',
['tooltip-fragment-expiry'] = 'This ${PAGETYPE} is ${PROTECTIONLEVEL} until ${EXPIRY},',
['tooltip-fragment-noexpiry'] = 'This ${PAGETYPE} is ${PROTECTIONLEVEL}',

--------------------------------------------------------------------------------
-- Special explanation blurb
--------------------------------------------------------------------------------

-- An explanation blurb for pages that cannot be unprotected, e.g. for pages
-- in the MediaWiki namespace.
-- It is possible to use banner parameters in this message.
['explanation-blurb-nounprotect'] = 'See the [[Wikipedia:Protection policy|'
	.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
	.. ' Please discuss any changes on the ${TALKPAGE}; you'
	.. ' may ${EDITREQUEST} to ask an'
	.. ' [[Wikipedia:Administrators|administrator]] to make an edit if it'
	.. ' is [[Help:Minor edit#When to mark an edit as a minor edit'
	.. '|uncontroversial]] or supported by [[Wikipedia:Consensus'
	.. '|consensus]].',

--------------------------------------------------------------------------------
-- Protection log display values
--------------------------------------------------------------------------------

-- These messages determine the display values for the protection log link
-- or the pending changes log link produced by the ${PROTECTIONLOG} parameter.
-- It is possible to use banner parameters in these messages.
['protection-log-display'] = 'protection log',
['pc-log-display'] = 'pending changes log',

--------------------------------------------------------------------------------
-- Current version display values
--------------------------------------------------------------------------------

-- These messages determine the display values for the page history link
-- or the move log link produced by the ${CURRENTVERSION} parameter.
-- It is possible to use banner parameters in these messages.
['current-version-move-display'] = 'current title',
['current-version-edit-display'] = 'current version',

--------------------------------------------------------------------------------
-- Talk page
--------------------------------------------------------------------------------

-- This message determines the display value of the talk page link produced
-- with the ${TALKPAGE} parameter.
-- It is possible to use banner parameters in this message.
['talk-page-link-display'] = 'talk page',

--------------------------------------------------------------------------------
-- Edit requests
--------------------------------------------------------------------------------

-- This message determines the display value of the edit request link produced
-- with the ${EDITREQUEST} parameter.
-- It is possible to use banner parameters in this message.
['edit-request-display'] = 'submit an edit request',

--------------------------------------------------------------------------------
-- Expiry date format
--------------------------------------------------------------------------------

-- This is the format for the blurb expiry date. It should be valid input for
-- the first parameter of the #time parser function.
['expiry-date-format'] = 'F j, Y "at" H:i e',

--------------------------------------------------------------------------------
-- Tracking categories
--------------------------------------------------------------------------------

-- These messages determine which tracking categories the module outputs.
['tracking-category-incorrect'] = 'Wikipedia pages with incorrect protection templates',
['tracking-category-template'] = 'Wikipedia template-protected pages other than templates and modules',

--------------------------------------------------------------------------------
-- Images
--------------------------------------------------------------------------------

-- These are images that are not defined by their protection action and protection level.
['image-filename-indef'] = 'Full-protection-shackle.svg',
['image-filename-default'] = 'Transparent.gif',

--------------------------------------------------------------------------------
-- End messages
--------------------------------------------------------------------------------
}

--------------------------------------------------------------------------------
-- End configuration
--------------------------------------------------------------------------------
}</text>
      <sha1>scj9exx3uf3stq00uy4gpnlbwru3gox</sha1>
    </revision>
  </page>
  <page>
    <title>Module:ResolveEntityId</title>
    <ns>828</ns>
    <id>56477902</id>
    <revision>
      <id>862468996</id>
      <parentid>862467062</parentid>
      <timestamp>2018-10-04T15:37:31Z</timestamp>
      <contributor>
        <username>Ahecht</username>
        <id>2016996</id>
      </contributor>
      <comment>-- backwards compatibility for deprecated _entityid function</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1133" xml:space="preserve">local p = {}

function p._entityid(_,id,alt)
	-- backwards compatibility for deprecated _entityid function
	return p._id(id,alt)
end

function p._id(id,alt)
	if type(id) == 'string' then
		id = mw.ustring.upper(mw.ustring.sub(id,1,1))..mw.ustring.sub(id,2)
		if mw.ustring.match(id,'^Q%d+$') then
			-- id is in the proper format for a Wikidata entity
			if mw.wikibase.isValidEntityId(id) then
				-- id is valid
				id = mw.wikibase.getEntity(id)
				if id then
					-- entity exists
					return id.id
				end
			end
		else
			id = mw.wikibase.getEntityIdForTitle(id)
			if id then
				-- id is a title that matches a Wikidata entity
				local instanceOf = mw.wikibase.getBestStatements(id, 'P31')[1] --instance of
				if instanceOf and instanceOf.mainsnak.datavalue.value.id ~= 'Q4167410' then
					-- not disambiguation
					return mw.wikibase.getEntity(id).id
				elseif instanceOf == nil then
					-- id is a title, but is missing an instance-of value
					return mw.wikibase.getEntity(id).id
				end
			end
		end
	end
	return alt or nil
end

function p.entityid(frame)
	return p._id(frame.args[1], frame.args[2])
end

return p</text>
      <sha1>dli4n6qadyck5v1020efiabil2x2mhz</sha1>
    </revision>
  </page>
  <page>
    <title>Module:String</title>
    <ns>828</ns>
    <id>38569505</id>
    <revision>
      <id>924313232</id>
      <parentid>903742087</parentid>
      <timestamp>2019-11-03T02:30:49Z</timestamp>
      <contributor>
        <username>RexxS</username>
        <id>6112901</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Module:String]]": Cascade-protected from main page, so no point in enabling TE ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="16668" xml:space="preserve">--[[

This module is intended to provide access to basic string functions.

Most of the functions provided here can be invoked with named parameters,
unnamed parameters, or a mixture.  If named parameters are used, Mediawiki will
automatically remove any leading or trailing whitespace from the parameter.
Depending on the intended use, it may be advantageous to either preserve or
remove such whitespace.

Global options
    ignore_errors: If set to 'true' or 1, any error condition will result in
        an empty string being returned rather than an error message.

    error_category: If an error occurs, specifies the name of a category to
        include with the error message.  The default category is
        [Category:Errors reported by Module String].

    no_category: If set to 'true' or 1, no category will be added if an error
        is generated.

Unit tests for this module are available at Module:String/tests.
]]

local str = {}

--[[
len

This function returns the length of the target string.

Usage:
{{#invoke:String|len|target_string|}}
OR
{{#invoke:String|len|s=target_string}}

Parameters
    s: The string whose length to report

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from the target string.
]]
function str.len( frame )
	local new_args = str._getParameters( frame.args, {'s'} )
	local s = new_args['s'] or ''
	return mw.ustring.len( s )
end

--[[
sub

This function returns a substring of the target string at specified indices.

Usage:
{{#invoke:String|sub|target_string|start_index|end_index}}
OR
{{#invoke:String|sub|s=target_string|i=start_index|j=end_index}}

Parameters
    s: The string to return a subset of
    i: The fist index of the substring to return, defaults to 1.
    j: The last index of the string to return, defaults to the last character.

The first character of the string is assigned an index of 1.  If either i or j
is a negative value, it is interpreted the same as selecting a character by
counting from the end of the string.  Hence, a value of -1 is the same as
selecting the last character of the string.

If the requested indices are out of range for the given string, an error is
reported.
]]
function str.sub( frame )
	local new_args = str._getParameters( frame.args, { 's', 'i', 'j' } )
	local s = new_args['s'] or ''
	local i = tonumber( new_args['i'] ) or 1
	local j = tonumber( new_args['j'] ) or -1

	local len = mw.ustring.len( s )

	-- Convert negatives for range checking
	if i &lt; 0 then
		i = len + i + 1
	end
	if j &lt; 0 then
		j = len + j + 1
	end

	if i &gt; len or j &gt; len or i &lt; 1 or j &lt; 1 then
		return str._error( 'String subset index out of range' )
	end
	if j &lt; i then
		return str._error( 'String subset indices out of order' )
	end

	return mw.ustring.sub( s, i, j )
end

--[[
This function implements that features of {{str sub old}} and is kept in order
to maintain these older templates.
]]
function str.sublength( frame )
	local i = tonumber( frame.args.i ) or 0
	local len = tonumber( frame.args.len )
	return mw.ustring.sub( frame.args.s, i + 1, len and ( i + len ) )
end

--[[
match

This function returns a substring from the source string that matches a
specified pattern.

Usage:
{{#invoke:String|match|source_string|pattern_string|start_index|match_number|plain_flag|nomatch_output}}
OR
{{#invoke:String|match|s=source_string|pattern=pattern_string|start=start_index
    |match=match_number|plain=plain_flag|nomatch=nomatch_output}}

Parameters
    s: The string to search
    pattern: The pattern or string to find within the string
    start: The index within the source string to start the search.  The first
        character of the string has index 1.  Defaults to 1.
    match: In some cases it may be possible to make multiple matches on a single
        string.  This specifies which match to return, where the first match is
        match= 1.  If a negative number is specified then a match is returned
        counting from the last match.  Hence match = -1 is the same as requesting
        the last match.  Defaults to 1.
    plain: A flag indicating that the pattern should be understood as plain
        text.  Defaults to false.
    nomatch: If no match is found, output the "nomatch" value rather than an error.

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from each string.  In some circumstances this is desirable, in
other cases one may want to preserve the whitespace.

If the match_number or start_index are out of range for the string being queried, then
this function generates an error.  An error is also generated if no match is found.
If one adds the parameter ignore_errors=true, then the error will be suppressed and
an empty string will be returned on any failure.

For information on constructing Lua patterns, a form of [regular expression], see:

* http://www.lua.org/manual/5.1/manual.html#5.4.1
* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Patterns
* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Ustring_patterns

]]
-- This sub-routine is exported for use in other modules
function str._match( s, pattern, start, match_index, plain_flag, nomatch )
	if s == '' then
		return str._error( 'Target string is empty' )
	end
	if pattern == '' then
		return str._error( 'Pattern string is empty' )
	end
	start = tonumber(start) or 1
	if math.abs(start) &lt; 1 or math.abs(start) &gt; mw.ustring.len( s ) then
		return str._error( 'Requested start is out of range' )
	end
	if match_index == 0 then
		return str._error( 'Match index is out of range' )
	end
	if plain_flag then
		pattern = str._escapePattern( pattern )
	end

	local result
	if match_index == 1 then
		-- Find first match is simple case
		result = mw.ustring.match( s, pattern, start )
	else
		if start &gt; 1 then
			s = mw.ustring.sub( s, start )
		end

		local iterator = mw.ustring.gmatch(s, pattern)
		if match_index &gt; 0 then
			-- Forward search
			for w in iterator do
				match_index = match_index - 1
				if match_index == 0 then
					result = w
					break
				end
			end
		else
			-- Reverse search
			local result_table = {}
			local count = 1
			for w in iterator do
				result_table[count] = w
				count = count + 1
			end

			result = result_table[ count + match_index ]
		end
	end

	if result == nil then
		if nomatch == nil then
			return str._error( 'Match not found' )
		else
			return nomatch
		end
	else
		return result
	end
end
-- This is the entry point for #invoke:String|match
function str.match( frame )
	local new_args = str._getParameters( frame.args, {'s', 'pattern', 'start', 'match', 'plain', 'nomatch'} )
	local s = new_args['s'] or ''
	local start = tonumber( new_args['start'] ) or 1
	local plain_flag = str._getBoolean( new_args['plain'] or false )
	local pattern = new_args['pattern'] or ''
	local match_index = math.floor( tonumber(new_args['match']) or 1 )
	local nomatch = new_args['nomatch']

	return str._match( s, pattern, start, match_index, plain_flag, nomatch )
end

--[[
pos

This function returns a single character from the target string at position pos.

Usage:
{{#invoke:String|pos|target_string|index_value}}
OR
{{#invoke:String|pos|target=target_string|pos=index_value}}

Parameters
    target: The string to search
    pos: The index for the character to return

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from the target string.  In some circumstances this is desirable, in
other cases one may want to preserve the whitespace.

The first character has an index value of 1.

If one requests a negative value, this function will select a character by counting backwards
from the end of the string.  In other words pos = -1 is the same as asking for the last character.

A requested value of zero, or a value greater than the length of the string returns an error.
]]
function str.pos( frame )
	local new_args = str._getParameters( frame.args, {'target', 'pos'} )
	local target_str = new_args['target'] or ''
	local pos = tonumber( new_args['pos'] ) or 0

	if pos == 0 or math.abs(pos) &gt; mw.ustring.len( target_str ) then
		return str._error( 'String index out of range' )
	end

	return mw.ustring.sub( target_str, pos, pos )
end

--[[
str_find

This function duplicates the behavior of {{str_find}}, including all of its quirks.
This is provided in order to support existing templates, but is NOT RECOMMENDED for
new code and templates.  New code is recommended to use the "find" function instead.

Returns the first index in "source" that is a match to "target".  Indexing is 1-based,
and the function returns -1 if the "target" string is not present in "source".

Important Note: If the "target" string is empty / missing, this function returns a
value of "1", which is generally unexpected behavior, and must be accounted for
separatetly.
]]
function str.str_find( frame )
	local new_args = str._getParameters( frame.args, {'source', 'target'} )
	local source_str = new_args['source'] or ''
	local target_str = new_args['target'] or ''

	if target_str == '' then
		return 1
	end

	local start = mw.ustring.find( source_str, target_str, 1, true )
	if start == nil then
		start = -1
	end

	return start
end

--[[
find

This function allows one to search for a target string or pattern within another
string.

Usage:
{{#invoke:String|find|source_str|target_string|start_index|plain_flag}}
OR
{{#invoke:String|find|source=source_str|target=target_str|start=start_index|plain=plain_flag}}

Parameters
    source: The string to search
    target: The string or pattern to find within source
    start: The index within the source string to start the search, defaults to 1
    plain: Boolean flag indicating that target should be understood as plain
        text and not as a Lua style regular expression, defaults to true

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from the parameter.  In some circumstances this is desirable, in
other cases one may want to preserve the whitespace.

This function returns the first index &gt;= "start" where "target" can be found
within "source".  Indices are 1-based.  If "target" is not found, then this
function returns 0.  If either "source" or "target" are missing / empty, this
function also returns 0.

This function should be safe for UTF-8 strings.
]]
function str.find( frame )
	local new_args = str._getParameters( frame.args, {'source', 'target', 'start', 'plain' } )
	local source_str = new_args['source'] or ''
	local pattern = new_args['target'] or ''
	local start_pos = tonumber(new_args['start']) or 1
	local plain = new_args['plain'] or true

	if source_str == '' or pattern == '' then
		return 0
	end

	plain = str._getBoolean( plain )

	local start = mw.ustring.find( source_str, pattern, start_pos, plain )
	if start == nil then
		start = 0
	end

	return start
end

--[[
replace

This function allows one to replace a target string or pattern within another
string.

Usage:
{{#invoke:String|replace|source_str|pattern_string|replace_string|replacement_count|plain_flag}}
OR
{{#invoke:String|replace|source=source_string|pattern=pattern_string|replace=replace_string|
   count=replacement_count|plain=plain_flag}}

Parameters
    source: The string to search
    pattern: The string or pattern to find within source
    replace: The replacement text
    count: The number of occurences to replace, defaults to all.
    plain: Boolean flag indicating that pattern should be understood as plain
        text and not as a Lua style regular expression, defaults to true
]]
function str.replace( frame )
	local new_args = str._getParameters( frame.args, {'source', 'pattern', 'replace', 'count', 'plain' } )
	local source_str = new_args['source'] or ''
	local pattern = new_args['pattern'] or ''
	local replace = new_args['replace'] or ''
	local count = tonumber( new_args['count'] )
	local plain = new_args['plain'] or true

	if source_str == '' or pattern == '' then
		return source_str
	end
	plain = str._getBoolean( plain )

	if plain then
		pattern = str._escapePattern( pattern )
		replace = mw.ustring.gsub( replace, "%%", "%%%%" ) --Only need to escape replacement sequences.
	end

	local result

	if count ~= nil then
		result = mw.ustring.gsub( source_str, pattern, replace, count )
	else
		result = mw.ustring.gsub( source_str, pattern, replace )
	end

	return result
end

--[[
    simple function to pipe string.rep to templates.
]]
function str.rep( frame )
	local repetitions = tonumber( frame.args[2] )
	if not repetitions then
		return str._error( 'function rep expects a number as second parameter, received "' .. ( frame.args[2] or '' ) .. '"' )
	end
	return string.rep( frame.args[1] or '', repetitions )
end

--[[
escapePattern

This function escapes special characters from a Lua string pattern. See [1]
for details on how patterns work.

[1] https://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Patterns

Usage:
{{#invoke:String|escapePattern|pattern_string}}

Parameters
    pattern_string: The pattern string to escape.
]]
function str.escapePattern( frame )
	local pattern_str = frame.args[1]
	if not pattern_str then
		return str._error( 'No pattern string specified' )
	end
	local result = str._escapePattern( pattern_str )
	return result
end

--[[
count
This function counts the number of occurrences of one string in another.
]]
function str.count(frame)
	local args = str._getParameters(frame.args, {'source', 'pattern', 'plain'})
	local source = args.source or ''
	local pattern = args.pattern or ''
	local plain = str._getBoolean(args.plain or true)
	if plain then
		pattern = str._escapePattern(pattern)
	end
	local _, count = mw.ustring.gsub(source, pattern, '')
	return count
end

--[[
endswith
This function determines whether a string ends with another string.
]]
function str.endswith(frame)
	local args = str._getParameters(frame.args, {'source', 'pattern'})
	local source = args.source or ''
	local pattern = args.pattern or ''
	if pattern == '' then
		-- All strings end with the empty string.
		return "yes"
	end
	if mw.ustring.sub(source, -mw.ustring.len(pattern), -1) == pattern then
		return "yes"
	else
		return ""
	end
end

--[[
join

Join all non empty arguments together; the first argument is the separator.
Usage:
{{#invoke:String|join|sep|one|two|three}}
]]
function str.join(frame)
	local args = {}
	local sep
	for _, v in ipairs( frame.args ) do
		if sep then
			if v ~= '' then
				table.insert(args, v)
			end
		else
			sep = v
		end
	end
	return table.concat( args, sep or '' )
end

--[[
Helper function that populates the argument list given that user may need to use a mix of
named and unnamed parameters.  This is relevant because named parameters are not
identical to unnamed parameters due to string trimming, and when dealing with strings
we sometimes want to either preserve or remove that whitespace depending on the application.
]]
function str._getParameters( frame_args, arg_list )
	local new_args = {}
	local index = 1
	local value

	for _, arg in ipairs( arg_list ) do
		value = frame_args[arg]
		if value == nil then
			value = frame_args[index]
			index = index + 1
		end
		new_args[arg] = value
	end

	return new_args
end

--[[
Helper function to handle error messages.
]]
function str._error( error_str )
	local frame = mw.getCurrentFrame()
	local error_category = frame.args.error_category or 'Errors reported by Module String'
	local ignore_errors = frame.args.ignore_errors or false
	local no_category = frame.args.no_category or false

	if str._getBoolean(ignore_errors) then
		return ''
	end

	local error_str = '&lt;strong class="error"&gt;String Module Error: ' .. error_str .. '&lt;/strong&gt;'
	if error_category ~= '' and not str._getBoolean( no_category ) then
		error_str = '[[Category:' .. error_category .. ']]' .. error_str
	end

	return error_str
end

--[[
Helper Function to interpret boolean strings
]]
function str._getBoolean( boolean_str )
	local boolean_value

	if type( boolean_str ) == 'string' then
		boolean_str = boolean_str:lower()
		if boolean_str == 'false' or boolean_str == 'no' or boolean_str == '0'
				or boolean_str == '' then
			boolean_value = false
		else
			boolean_value = true
		end
	elseif type( boolean_str ) == 'boolean' then
		boolean_value = boolean_str
	else
		error( 'No boolean value found' )
	end
	return boolean_value
end

--[[
Helper function that escapes all pattern characters so that they will be treated
as plain text.
]]
function str._escapePattern( pattern_str )
	return mw.ustring.gsub( pattern_str, "([%(%)%.%%%+%-%*%?%[%^%$%]])", "%%%1" )
end

return str</text>
      <sha1>g9myztjccfeamhqorwvd1gwnwhtk4kx</sha1>
    </revision>
  </page>
  <page>
    <title>Module:TableTools</title>
    <ns>828</ns>
    <id>41371028</id>
    <revision>
      <id>931776054</id>
      <parentid>887403551</parentid>
      <timestamp>2019-12-21T03:39:49Z</timestamp>
      <contributor>
        <username>Pppery</username>
        <id>28032115</id>
      </contributor>
      <comment>Finally getting around to merging in [[Module:Array length]] (originally written by Mr. Stradivarius) over six months after writing the merged code, also minor code simplify per Dinoguy1000 on talk page</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="12655" xml:space="preserve">--[[
------------------------------------------------------------------------------------
--                               TableTools                                       --
--                                                                                --
-- This module includes a number of functions for dealing with Lua tables.        --
-- It is a meta-module, meant to be called from other Lua modules, and should     --
-- not be called directly from #invoke.                                           --
------------------------------------------------------------------------------------
--]]

local libraryUtil = require('libraryUtil')

local p = {}

-- Define often-used variables and functions.
local floor = math.floor
local infinity = math.huge
local checkType = libraryUtil.checkType
local checkTypeMulti = libraryUtil.checkTypeMulti

--[[
------------------------------------------------------------------------------------
-- isPositiveInteger
--
-- This function returns true if the given value is a positive integer, and false
-- if not. Although it doesn't operate on tables, it is included here as it is
-- useful for determining whether a given table key is in the array part or the
-- hash part of a table.
------------------------------------------------------------------------------------
--]]
function p.isPositiveInteger(v)
	return type(v) == 'number' and v &gt;= 1 and floor(v) == v and v &lt; infinity
end

--[[
------------------------------------------------------------------------------------
-- isNan
--
-- This function returns true if the given number is a NaN value, and false
-- if not. Although it doesn't operate on tables, it is included here as it is
-- useful for determining whether a value can be a valid table key. Lua will
-- generate an error if a NaN is used as a table key.
------------------------------------------------------------------------------------
--]]
function p.isNan(v)
	return type(v) == 'number' and tostring(v) == '-nan'
end

--[[
------------------------------------------------------------------------------------
-- shallowClone
--
-- This returns a clone of a table. The value returned is a new table, but all
-- subtables and functions are shared. Metamethods are respected, but the returned
-- table will have no metatable of its own.
------------------------------------------------------------------------------------
--]]
function p.shallowClone(t)
	local ret = {}
	for k, v in pairs(t) do
		ret[k] = v
	end
	return ret
end

--[[
------------------------------------------------------------------------------------
-- removeDuplicates
--
-- This removes duplicate values from an array. Non-positive-integer keys are
-- ignored. The earliest value is kept, and all subsequent duplicate values are
-- removed, but otherwise the array order is unchanged.
------------------------------------------------------------------------------------
--]]
function p.removeDuplicates(t)
	checkType('removeDuplicates', 1, t, 'table')
	local isNan = p.isNan
	local ret, exists = {}, {}
	for i, v in ipairs(t) do
		if isNan(v) then
			-- NaNs can't be table keys, and they are also unique, so we don't need to check existence.
			ret[#ret + 1] = v
		else
			if not exists[v] then
				ret[#ret + 1] = v
				exists[v] = true
			end
		end	
	end
	return ret
end			

--[[
------------------------------------------------------------------------------------
-- numKeys
--
-- This takes a table and returns an array containing the numbers of any numerical
-- keys that have non-nil values, sorted in numerical order.
------------------------------------------------------------------------------------
--]]
function p.numKeys(t)
	checkType('numKeys', 1, t, 'table')
	local isPositiveInteger = p.isPositiveInteger
	local nums = {}
	for k, v in pairs(t) do
		if isPositiveInteger(k) then
			nums[#nums + 1] = k
		end
	end
	table.sort(nums)
	return nums
end

--[[
------------------------------------------------------------------------------------
-- affixNums
--
-- This takes a table and returns an array containing the numbers of keys with the
-- specified prefix and suffix. For example, for the table
-- {a1 = 'foo', a3 = 'bar', a6 = 'baz'} and the prefix "a", affixNums will
-- return {1, 3, 6}.
------------------------------------------------------------------------------------
--]]
function p.affixNums(t, prefix, suffix)
	checkType('affixNums', 1, t, 'table')
	checkType('affixNums', 2, prefix, 'string', true)
	checkType('affixNums', 3, suffix, 'string', true)

	local function cleanPattern(s)
		-- Cleans a pattern so that the magic characters ()%.[]*+-?^$ are interpreted literally.
		s = s:gsub('([%(%)%%%.%[%]%*%+%-%?%^%$])', '%%%1')
		return s
	end

	prefix = prefix or ''
	suffix = suffix or ''
	prefix = cleanPattern(prefix)
	suffix = cleanPattern(suffix)
	local pattern = '^' .. prefix .. '([1-9]%d*)' .. suffix .. '$'

	local nums = {}
	for k, v in pairs(t) do
		if type(k) == 'string' then			
			local num = mw.ustring.match(k, pattern)
			if num then
				nums[#nums + 1] = tonumber(num)
			end
		end
	end
	table.sort(nums)
	return nums
end

--[[
------------------------------------------------------------------------------------
-- numData
--
-- Given a table with keys like ("foo1", "bar1", "foo2", "baz2"), returns a table
-- of subtables in the format 
-- { [1] = {foo = 'text', bar = 'text'}, [2] = {foo = 'text', baz = 'text'} }
-- Keys that don't end with an integer are stored in a subtable named "other".
-- The compress option compresses the table so that it can be iterated over with
-- ipairs.
------------------------------------------------------------------------------------
--]]
function p.numData(t, compress)
	checkType('numData', 1, t, 'table')
	checkType('numData', 2, compress, 'boolean', true)
	local ret = {}
	for k, v in pairs(t) do
		local prefix, num = mw.ustring.match(tostring(k), '^([^0-9]*)([1-9][0-9]*)$')
		if num then
			num = tonumber(num)
			local subtable = ret[num] or {}
			if prefix == '' then
				-- Positional parameters match the blank string; put them at the start of the subtable instead.
				prefix = 1
			end
			subtable[prefix] = v
			ret[num] = subtable
		else
			local subtable = ret.other or {}
			subtable[k] = v
			ret.other = subtable
		end
	end
	if compress then
		local other = ret.other
		ret = p.compressSparseArray(ret)
		ret.other = other
	end
	return ret
end

--[[
------------------------------------------------------------------------------------
-- compressSparseArray
--
-- This takes an array with one or more nil values, and removes the nil values
-- while preserving the order, so that the array can be safely traversed with
-- ipairs.
------------------------------------------------------------------------------------
--]]
function p.compressSparseArray(t)
	checkType('compressSparseArray', 1, t, 'table')
	local ret = {}
	local nums = p.numKeys(t)
	for _, num in ipairs(nums) do
		ret[#ret + 1] = t[num]
	end
	return ret
end

--[[
------------------------------------------------------------------------------------
-- sparseIpairs
--
-- This is an iterator for sparse arrays. It can be used like ipairs, but can
-- handle nil values.
------------------------------------------------------------------------------------
--]]
function p.sparseIpairs(t)
	checkType('sparseIpairs', 1, t, 'table')
	local nums = p.numKeys(t)
	local i = 0
	local lim = #nums
	return function ()
		i = i + 1
		if i &lt;= lim then
			local key = nums[i]
			return key, t[key]
		else
			return nil, nil
		end
	end
end

--[[
------------------------------------------------------------------------------------
-- size
--
-- This returns the size of a key/value pair table. It will also work on arrays,
-- but for arrays it is more efficient to use the # operator.
------------------------------------------------------------------------------------
--]]

function p.size(t)
	checkType('size', 1, t, 'table')
	local i = 0
	for k in pairs(t) do
		i = i + 1
	end
	return i
end


local function defaultKeySort(item1, item2)
	-- "number" &lt; "string", so numbers will be sorted before strings.
	local type1, type2 = type(item1), type(item2)
	if type1 ~= type2 then
		return type1 &lt; type2
	else -- This will fail with table, boolean, function.
		return item1 &lt; item2
	end
end

--[[
	Returns a list of the keys in a table, sorted using either a default
	comparison function or a custom keySort function.
]]
function p.keysToList(t, keySort, checked)
	if not checked then
		checkType('keysToList', 1, t, 'table')
		checkTypeMulti('keysToList', 2, keySort, { 'function', 'boolean', 'nil' })
	end
	
	local list = {}
	local index = 1
	for key, value in pairs(t) do
		list[index] = key
		index = index + 1
	end
	
	if keySort ~= false then
		keySort = type(keySort) == 'function' and keySort or defaultKeySort
		
		table.sort(list, keySort)
	end
	
	return list
end

--[[
	Iterates through a table, with the keys sorted using the keysToList function.
	If there are only numerical keys, sparseIpairs is probably more efficient.
]]
function p.sortedPairs(t, keySort)
	checkType('sortedPairs', 1, t, 'table')
	checkType('sortedPairs', 2, keySort, 'function', true)
	
	local list = p.keysToList(t, keySort, true)
	
	local i = 0
	return function()
		i = i + 1
		local key = list[i]
		if key ~= nil then
			return key, t[key]
		else
			return nil, nil
		end
	end
end

--[[
	Returns true if all keys in the table are consecutive integers starting at 1.
--]]
function p.isArray(t)
	checkType("isArray", 1, t, "table")
	
	local i = 0
	for k, v in pairs(t) do
		i = i + 1
		if t[i] == nil then
			return false
		end
	end
	return true
end

-- { "a", "b", "c" } -&gt; { a = 1, b = 2, c = 3 }
function p.invert(array)
	checkType("invert", 1, array, "table")
	
	local map = {}
	for i, v in ipairs(array) do
		map[v] = i
	end
	
	return map
end

--[[
	{ "a", "b", "c" } -&gt; { ["a"] = true, ["b"] = true, ["c"] = true }
--]]
function p.listToSet(t)
	checkType("listToSet", 1, t, "table")
	
	local set = {}
	for _, item in ipairs(t) do
		set[item] = true
	end
	
	return set
end

--[[
	Recursive deep copy function.
	Preserves identities of subtables.
	
]]
local function _deepCopy(orig, includeMetatable, already_seen)
	-- Stores copies of tables indexed by the original table.
	already_seen = already_seen or {}
	
	local copy = already_seen[orig]
	if copy ~= nil then
		return copy
	end
	
	if type(orig) == 'table' then
		copy = {}
		for orig_key, orig_value in pairs(orig) do
			copy[deepcopy(orig_key, includeMetatable, already_seen)] = deepcopy(orig_value, includeMetatable, already_seen)
		end
		already_seen[orig] = copy
		
		if includeMetatable then
			local mt = getmetatable(orig)
			if mt ~= nil then
				local mt_copy = deepcopy(mt, includeMetatable, already_seen)
				setmetatable(copy, mt_copy)
				already_seen[mt] = mt_copy
			end
		end
	else -- number, string, boolean, etc
		copy = orig
	end
	return copy
end

function p.deepCopy(orig, noMetatable, already_seen)
	checkType("deepCopy", 3, already_seen, "table", true)
	
	return _deepCopy(orig, not noMetatable, already_seen)
end

--[[
	Concatenates all values in the table that are indexed by a number, in order.
	sparseConcat{ a, nil, c, d }  =&gt;  "acd"
	sparseConcat{ nil, b, c, d }  =&gt;  "bcd"
]]
function p.sparseConcat(t, sep, i, j)
	local list = {}
	
	local list_i = 0
	for _, v in p.sparseIpairs(t) do
		list_i = list_i + 1
		list[list_i] = v
	end
	
	return table.concat(list, sep, i, j)
end

--[[
-- Finds the length of an array, or of a quasi-array with keys such
-- as "data1", "data2", etc., using an exponental search algorithm. 
-- It is similar to the operator #, but may return
-- a different value when there are gaps in the array portion of the table.
-- Intended to be used on data loaded with mw.loadData. For other tables, use #.
-- Note: #frame.args in frame object always be set to 0, regardless of 
-- the number of unnamed template parameters, so use this function for
-- frame.args.
--]]

function p.length(t, prefix)
	-- requiring module inline so that [[Module:Exponental search]]
	-- which is only needed by this one function
	-- doesn't get millions of transclusions
	local expSearch = require("Module:Exponential search")
	checkType('length', 1, t, 'table')
	checkType('length', 2, prefix, 'string', true)
	return expSearch(function(i)
		local key
		if prefix then
			key = prefix .. tostring(i)
		else
			key = i
		end
		return t[key] ~= nil
	end) or 0
end
function p.inArray(arr, valueToFind)
	checkType("inArray", 1, arr, "table")
	
	-- if valueToFind is nil, error?
	
	for _, v in ipairs(arr) do
		if v == valueToFind then
			return true
		end
	end
	
	return false
end

return p</text>
      <sha1>1ysve6f0f2ibqmdnd97k710ph63wifq</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Unsubst</title>
    <ns>828</ns>
    <id>40945493</id>
    <revision>
      <id>872090768</id>
      <parentid>784254967</parentid>
      <timestamp>2018-12-05T02:49:39Z</timestamp>
      <contributor>
        <username>Amorymeltzer</username>
        <id>141948</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Module:Unsubst]]": [[WP:High-risk templates|High-risk Lua module]]: Bump to full protection, over 3.5M transclusions, including some very critical templates ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3688" xml:space="preserve">local checkType = require('libraryUtil').checkType

local p = {}

local BODY_PARAM = '$B'

local specialParams = {
	['$params'] = 'parameter list',
	['$aliases'] = 'parameter aliases',
	['$flags'] = 'flags',
	['$B'] = 'template content'
}

function p.main(frame, body)
	-- If we are substing, this function returns a template invocation, and if
	-- not, it returns the template body. The template body can be specified in
	-- the body parameter, or in the template parameter defined in the
	-- BODY_PARAM variable. This function can be called from Lua or from
	-- #invoke.

	-- Return the template body if we aren't substing.
	if not mw.isSubsting() then
		if body ~= nil then
			return body
		elseif frame.args[BODY_PARAM] ~= nil then
			return frame.args[BODY_PARAM]
		else
			error(string.format(
				"no template content specified (use parameter '%s' from #invoke)",
				BODY_PARAM
			), 2)
		end
	end

	-- Sanity check for the frame object.
	if type(frame) ~= 'table'
		or type(frame.getParent) ~= 'function'
		or not frame:getParent()
	then
		error(
			"argument #1 to 'main' must be a frame object with a parent " ..
			"frame available",
			2
		)
	end

	-- Find the invocation name.
	local mTemplateInvocation = require('Module:Template invocation')
	local name = mTemplateInvocation.name(frame:getParent():getTitle())

	-- Combine passed args with passed defaults
	local args = {}
	if string.find( ','..(frame.args['$flags'] or '')..',', ',%s*override%s*,' ) then
		for k, v in pairs( frame:getParent().args ) do
			args[k] = v
		end
		for k, v in pairs( frame.args ) do
			if not specialParams[k] then
				if v == '__DATE__' then
					v = mw.getContentLanguage():formatDate( 'F Y' )
				end
				args[k] = v
			end
		end
	else
		for k, v in pairs( frame.args ) do
			if not specialParams[k] then
				if v == '__DATE__' then
					v = mw.getContentLanguage():formatDate( 'F Y' )
				end
				args[k] = v
			end
		end
		for k, v in pairs( frame:getParent().args ) do
			args[k] = v
		end
	end

	-- Trim parameters, if not specified otherwise
	if not string.find( ','..(frame.args['$flags'] or '')..',', ',%s*keep%-whitespace%s*,' ) then
		for k, v in pairs( args ) do args[k] = mw.ustring.match(v, '^%s*(.*)%s*$') or '' end
	end

	-- Pull information from parameter aliases
	local aliases = {}
	if frame.args['$aliases'] then
		local list = mw.text.split( frame.args['$aliases'], '%s*,%s*' )
		for k, v in ipairs( list ) do
			local tmp = mw.text.split( v, '%s*&gt;%s*' )
			aliases[tonumber(mw.ustring.match(tmp[1], '^[1-9][0-9]*$')) or tmp[1]] = ((tonumber(mw.ustring.match(tmp[2], '^[1-9][0-9]*$'))) or tmp[2])
		end
	end
	for k, v in pairs( aliases ) do
		if args[k] and ( not args[v] or args[v] == '' ) then
			args[v] = args[k]
		end
		args[k] = nil
	end

	-- Remove empty parameters, if specified
	if string.find( ','..(frame.args['$flags'] or '')..',', ',%s*remove%-empty%s*,' ) then
		local tmp = 0
		for k, v in ipairs( args ) do
			if v ~= '' or ( args[k+1] and args[k+1] ~= '' ) or ( args[k+2] and args[k+2] ~= '' ) then
				tmp = k
			else
				break
			end
		end
		for k, v in pairs( args ) do
			if v == '' then
				if not (type(k) == 'number' and k &lt; tmp) then args[k] = nil end
			end
		end
	end

	-- Order parameters
	if frame.args['$params'] then
		local params, tmp = mw.text.split( frame.args['$params'], '%s*,%s*' ), {}
		for k, v in ipairs(params) do
			v = tonumber(mw.ustring.match(v, '^[1-9][0-9]*$')) or v
			if args[v] then tmp[v], args[v] = args[v], nil end
		end
		for k, v in pairs(args) do tmp[k], args[k] = args[k], nil end
		args = tmp
	end

	return mTemplateInvocation.invocation(name, args)
end

p[''] = p.main -- For backwards compatibility

return p</text>
      <sha1>dnfbu3ol9y1rn4f58ap519pwafevpgq</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Webarchive</title>
    <ns>828</ns>
    <id>51937454</id>
    <revision>
      <id>879514430</id>
      <parentid>863835221</parentid>
      <timestamp>2019-01-21T18:59:39Z</timestamp>
      <contributor>
        <username>GreenC</username>
        <id>8931761</id>
      </contributor>
      <comment>deprecate default trailing period for Wayback URLs</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="37938" xml:space="preserve">--[[ ----------------------------------

Lua module implementing the {{webarchive}} template. 

A merger of the functionality of three templates: {{wayback}}, {{webcite}} and {{cite archives}}
	
]]


--[[--------------------------&lt; D E P E N D E N C I E S &gt;------------------------------------------------------
]]

require('Module:No globals');
local getArgs = require ('Module:Arguments').getArgs;


--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local categories = {};															-- category names
local config = {};																-- global configuration settings
local digits = {};																-- for i18n; table that translates local-wiki digits to western digits
local err_warn_msgs = {};														-- error and warning messages
local excepted_pages = {};
local month_num = {};															-- for i18n; table that translates local-wiki month names to western digits
local prefixes = {};															-- service provider tail string prefixes
local services = {};															-- archive service provider data from
local s_text = {};																-- table of static text strings used to build final rendering
local uncategorized_namespaces = {};											-- list of namespaces that we should not categorize
local uncategorized_subpages = {};												-- list of subpages that should not be categorized


--[[--------------------------&lt; P A G E   S C O P E   I D E N T I F I E R S &gt;----------------------------------
]]

local non_western_digits;														-- boolean flag set true when data.digits.enable is true
local this_page = mw.title.getCurrentTitle();

local track = {};																-- Associative array to hold tracking categories
local ulx = {};																	-- Associative array to hold template data 


--[[--------------------------&lt; S U B S T I T U T E &gt;----------------------------------------------------------

Populates numbered arguments in a message string using an argument table.

]]

local function substitute (msg, args)
	return args and mw.message.newRawMessage (msg, args):plain() or msg;
end


--[[--------------------------&lt; tableLength &gt;-----------------------

Given a 1-D table, return number of elements

]]

local function tableLength(T)
	local count = 0
	for _ in pairs(T) do count = count + 1 end
	return count
end


--[=[-------------------------&lt; M A K E _ W I K I L I N K &gt;----------------------------------------------------

Makes a wikilink; when both link and display text is provided, returns a wikilink in the form [[L|D]]; if only
link is provided, returns a wikilink in the form [[L]]; if neither are provided or link is omitted, returns an
empty string.

]=]

local function make_wikilink (link, display, no_link)
	if nil == no_link then
		if link and ('' ~= link) then
			if display and ('' ~= display) then
				return table.concat ({'[[', link, '|', display, ']]'});
			else
				return table.concat ({'[[', link, ']]'});
			end
		end
		return display or '';													-- link not set so return the display text

	else																		-- no_link
		if display and ('' ~= display) then										-- if there is display text
			return display;														-- return that
		else
			return link or '';													-- return the target article name or empty string
		end
	end
end


--[[--------------------------&lt; createTracking &gt;-----------------------

Return data in track[] ie. tracking categories

]]

local function createTracking()
	if not excepted_pages[this_page.fullText] then								-- namespace:title/fragment is allowed to be categorized (typically this module's / template's testcases page(s))
		if uncategorized_namespaces[this_page.nsText] then
			return '';															-- this page not to be categorized so return empty string
		end
		for _,v in ipairs (uncategorized_subpages) do							-- cycle through page name patterns
			if this_page.text:match (v) then									-- test page name against each pattern
				return '';														-- this subpage type not to be categorized so return empty string
			end
		end
	end

	local out = {};
	if tableLength(track) &gt; 0 then
		for key, _ in pairs(track) do											-- loop through table
			table.insert (out, make_wikilink (key));							-- and convert category names to links
		end
	end
	return table.concat (out);													-- concat into one big string; empty string if table is empty

end


--[[--------------------------&lt; inlineError &gt;-----------------------

Critical error. Render output completely in red. Add to tracking category.

This function called as the last thing before abandoning this module

]]

local function inlineError (msg, args)
	track[categories.error] = 1
	return table.concat ({
		'&lt;span style="font-size:100%" class="error citation-comment"&gt;Error in ',	-- open the error message span
		config.tname,															-- insert the local language template name
		' template: ',
		substitute (msg, args),													-- insert the formatted error message
		'.&lt;/span&gt;',																-- close the span
		createTracking()														-- add the category
		})
end


--[[--------------------------&lt; inlineRed &gt;-----------------------

Render a text fragment in red, such as a warning as part of the final output.
Add tracking category.

 ]]

local function inlineRed(msg, trackmsg)
	if trackmsg == "warning" then
		track[categories.warning] = 1;
	elseif trackmsg == "error" then
		track[categories.error] = 1;
	end

	return '&lt;span style="font-size:100%" class="error citation-comment"&gt;' .. msg .. '&lt;/span&gt;'
end


--[[--------------------------&lt; base62 &gt;-----------------------

Convert base-62 to base-10
Credit: https://de.wikipedia.org/wiki/Modul:Expr 

]]

local function base62( value )
	local r = 1																	-- default return value is input value is malformed

	if value:match ('%W') then													-- value must only be in the set [0-9a-zA-Z]
		return;																	-- nil return when value contains extraneous characters
	end

	local n = #value															-- number of characters in value
	local k = 1
	local c
	r = 0
	for i = n, 1, -1 do															-- loop through all characters in value from ls digit to ms digit
		c = value:byte( i, i )
		if c &gt;= 48 and c &lt;= 57 then												-- character is digit 0-9
			c = c - 48
		elseif c &gt;= 65 and c &lt;= 90 then											-- character is ascii a-z
			c = c - 55
		else																	-- must be ascii A-Z
			c = c - 61
		end
		r = r + c * k															-- accumulate this base62 character's value
		k = k * 62																-- bump for next
	end -- for i

	return r
end 


--[[--------------------------&lt; D E C O D E _ D A T E &gt;--------------------------------------------------------

Given a date string, return it in iso format along with an indicator of the date's format.  Except that month names
must be recognizable as legitimate month names with proper capitalization, and that the date string must match one
of the recognized date formats, no error checking is done here; return nil else

]]

local function decode_date (date_str)
	local patterns = {
		['dmy'] = {'^(%d%d?) +([^%s%d]+) +(%d%d%d%d)$', 'd', 'm', 'y'},			-- %a does not recognize unicode combining characters used by some languages
		['mdy'] = {'^([^%s%d]+) (%d%d?), +(%d%d%d%d)$', 'm', 'd', 'y'},
		['ymd'] = {'^(%d%d%d%d) +([^%s%d]+) (%d%d?)$', 'y', 'm', 'd'},			-- not mos compliant at en.wiki but may be acceptible at other wikis
		};
	
	local t = {};

	if non_western_digits then													-- this wiki uses non-western digits?
		date_str = mw.ustring.gsub (date_str, '%d', digits);					-- convert this wiki's non-western digits to western digits
	end

	if date_str:match ('^%d%d%d%d%-%d%d%-%d%d$') then							-- already an iso format date, return western digits form
		return date_str, 'iso';
	end
	
	for k, v in pairs (patterns) do
		local c1, c2, c3 = mw.ustring.match (date_str, patterns[k][1]);			-- c1 .. c3 are captured but we don't know what they hold
		
		if c1 then																-- set on match
			t = {																-- translate unspecified captures to y, m, and d
				[patterns[k][2]] = c1,											-- fill the table of captures with the captures
				[patterns[k][3]] = c2,											-- take index names from src_pattern table and assign sequential captures
				[patterns[k][4]] = c3,
				};
			if month_num[t.m] then												-- when month not already a number
				t.m = month_num[t.m];											-- replace valid month name with a number
			else
				return nil, 'iso';												-- not a valid date form because month not valid
			end

			return mw.ustring.format ('%.4d-%.2d-%.2d', t.y, t.m, t.d), k;		-- return date in iso format
		end
	end
	return nil, 'iso';															-- date could not be decoded; return nil and default iso date
end

	
--[[--------------------------&lt; makeDate &gt;-----------------------

Given year, month, day numbers, (zero-padded or not) return a full date in df format
where df may be one of:
	mdy, dmy, iso, ymd

on entry, year, month, day are presumed to be correct for the date that they represent; all are required

in this module, makeDate() is sometimes given an iso-format date in year:
	makeDate (2018-09-20, nil, nil, df)
this works because table.concat() sees only one table member

]]

local function makeDate (year, month, day, df)
	local format = {
		['dmy'] = 'j F Y',
		['mdy'] = 'F j, Y',
		['ymd'] = 'Y F j',
		['iso'] = 'Y-m-d',
		};

	local date = table.concat ({year, month, day}, '-');						-- assemble year-initial numeric-format date (zero padding not required here)

	if non_western_digits then													--this wiki uses non-western digits?
		date = mw.ustring.gsub (date, '%d', digits);							-- convert this wiki's non-western digits to western digits
	end

	return mw.getContentLanguage():formatDate (format[df], date);
end


--[[--------------------------&lt; I S _ V A L I D _ D A T E &gt;----------------------------------------------------

Returns true if date is after 31 December 1899 (why is 1900 the min year? shouldn't the internet's date-of-birth
be min year?), not after today's date, and represents a valid date (29 February 2017 is not a valid date).  Applies
Gregorian leapyear rules.

all arguments are required

]]

local function is_valid_date (year, month, day)
	local days_in_month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	local month_length;
	local y, m, d;
	local today = os.date ('*t');												-- fetch a table of current date parts

	if not year or '' == year or not month or '' == month or not day or '' == day then
		return false;															-- something missing
	end
	
	y = tonumber (year);
	m = tonumber (month);
	d = tonumber (day);

	if 1900 &gt; y or today.year &lt; y or 1 &gt; m or 12 &lt; m then						-- year and month are within bounds	TODO: 1900?
		return false;
	end

	if (2==m) then																-- if February
		month_length = 28;														-- then 28 days unless
		if (0==(y%4) and (0~=(y%100) or 0==(y%400))) then						-- is a leap year?
			month_length = 29;													-- if leap year then 29 days in February
		end
	else
		month_length=days_in_month[m];
	end

	if 1 &gt; d or month_length &lt; d then											-- day is within bounds
		return false;
	end
																					-- here when date parts represent a valid date
	return os.time({['year']=y, ['month']=m, ['day']=d, ['hour']=0}) &lt;= os.time();	-- date at midnight must be less than or equal to current date/time
end


--[[--------------------------&lt; decodeWebciteDate &gt;-----------------------

Given a URI-path to Webcite (eg. /67xHmVFWP) return the encoded date in df format

returns date string in df format - webcite date is a unix timestamp encoded as bae62
or the string 'query'

]]

local function decodeWebciteDate(path, df)

	local dt = {};
	local decode;

	dt = mw.text.split(path, "/")

	-- valid URL formats that are not base62

	-- http://www.webcitation.org/query?id=1138911916587475
	-- http://www.webcitation.org/query?url=http..&amp;date=2012-06-01+21:40:03
	-- http://www.webcitation.org/1138911916587475
	-- http://www.webcitation.org/cache/73e53dd1f16cf8c5da298418d2a6e452870cf50e
	-- http://www.webcitation.org/getfile.php?fileid=1c46e791d68e89e12d0c2532cc3cf629b8bc8c8e

	if dt[2]:find ('query', 1, true) or 
		dt[2]:find ('cache', 1, true) or
		dt[2]:find ('getfile', 1, true) or
		tonumber(dt[2]) then
			return 'query';
	end

	decode = base62(dt[2]);														-- base62 string -&gt; exponential number
	if not decode then
		return nil;																-- nil return when dt[2] contains characters not in %w
	end
	dt = os.date('*t', string.format("%d", decode):sub(1,10))					-- exponential number -&gt; text -&gt; first 10 characters (a unix timestamp) -&gt; a table of date parts

	decode = makeDate (dt.year, dt.month, dt.day, 'iso');						-- date comparisons are all done in iso format with western digits
	if non_western_digits then													--this wiki uses non-western digits?
		decode = mw.ustring.gsub (decode, '%d', digits);						-- convert this wiki's non-western digits to western digits
	end

	return decode;
end


--[[--------------------------&lt; decodeWaybackDate &gt;-----------------------

Given a URI-path to Wayback (eg. /web/20160901010101/http://example.com )
or Library of Congress Web Archives (/all/20160901010101/http://example.com)
return the formatted date eg. "September 1, 2016" in df format 
Handle non-digits in snapshot ID such as "re_" and "-" and "*"

returns two values:
	first value is one of these:
		valid date string in df format - wayback date is valid (including the text string 'index' when date is '/*/')
		empty string - wayback date is malformed (less than 8 digits, not a valid date)
		nil - wayback date is '/save/' or otherwise not a number
	
	second return value is an appropriate 'message' may or may not be formatted

]]

local function decodeWaybackDate(path, df)

	local msg, snapdate;

	snapdate = path:gsub ('^/all/', ''):gsub ('^/web/', ''):gsub ('^/', '');	-- remove leading '/all/', leading '/web/' or leading '/'
	snapdate = snapdate:match ('^[^/]+');										-- get timestamp
	if snapdate == "*" then														-- eg. /web/*/http.. or /all/*/http..
		return 'index';															-- return indicator that this url has an index date
	end

	snapdate = snapdate:gsub ('%a%a_%d?$', ''):gsub ('%-', '');					-- from date, remove any trailing "re_", dashes

	msg = '';
	if snapdate:match ('%*$') then												-- a trailing '*' causes calendar display at archive .org
		snapdate = snapdate:gsub ('%*$', '');									-- remove so not part of length calc later
		msg = inlineRed (err_warn_msgs.ts_cal, 'warning');						-- make a message
	end

	if not tonumber(snapdate) then
		return nil, 'ts_nan';													-- return nil (fatal error flag) and message selector
	end

	local dlen = snapdate:len();
	if dlen &lt; 8 then															-- we need 8 digits TODO: but shouldn't this be testing for 14 digits?
		return '', inlineRed (err_warn_msgs.ts_short, 'error');					-- return empty string and error message
	end

	local year, month, day = snapdate:match ('(%d%d%d%d)(%d%d)(%d%d)');			-- no need for snapdatelong here

	if not is_valid_date (year, month, day) then
		return '', inlineRed (err_warn_msgs.ts_date, 'error');					-- return empty string and error message
	end

	snapdate = table.concat ({year, month, day}, '-');							-- date comparisons are all done in iso format
	if 14 == dlen then
		return snapdate, msg;													-- return date with message if any
	else
		return snapdate, msg .. inlineRed (err_warn_msgs.ts_len, 'warning');	-- return date with warning message(s)
	end
end


--[[--------------------------&lt; decodeArchiveisDate &gt;-----------------------

Given an Archive.is "long link" URI-path (e.g. /2016.08.28-144552/http://example.com)
return the date in df format (e.g. if df = dmy, return 28 August 2016)
Handles "." and "-" in snapshot date, so 2016.08.28-144552 is same as 20160828144552

returns two values:
	first value is one of these:
		valid date string in df format - archive.is date is valid (including the text string 'short link' when url is the short form)
		empty string - wayback date is malformed (not a number, less than 8 digits, not a valid date)
		nil - wayback date is '/save/'
	
	second return value is an appropriate 'message' may or may not be formatted

]]

local function decodeArchiveisDate(path, df)
	local snapdate

	if path:match ('^/%w+$') then												-- short form url path is '/' followed by some number of base 62 digits and nothing else
		return "short link"														-- e.g. http://archive.is/hD1qz
	end

	snapdate = mw.text.split (path, '/')[2]:gsub('[%.%-]', '');					-- get snapshot date, e.g. 2016.08.28-144552; remove periods and hyphens

	local dlen = string.len(snapdate)
	if dlen &lt; 8 then															-- we need 8 digits TODO: but shouldn't this be testing for 14 digits?
		return '', inlineRed (err_warn_msgs.ts_short, 'error');					-- return empty string and error message
	end

	local year, month, day = snapdate:match ('(%d%d%d%d)(%d%d)(%d%d)');			-- no need for snapdatelong here

	if not is_valid_date (year, month, day) then
		return '', inlineRed (err_warn_msgs.ts_date, 'error');					-- return empty string and error message
	end

	snapdate = table.concat ({year, month, day}, '-');							-- date comparisons are all done in iso format
	if 14 == dlen then
		return snapdate;														-- return date
	else
		return snapdate, inlineRed (err_warn_msgs.ts_len, 'warning');			-- return date with warning message
	end
 end


--[[--------------------------&lt; serviceName &gt;-----------------------

Given a domain extracted by mw.uri.new() (eg. web.archive.org) set tail string and service ID

]]

local function serviceName(host, no_link)
	local tracking;
	local index;
	
	host = host:lower():gsub ('^web%.(.+)', '%1'):gsub ('^www%.(.+)', '%1');	-- lowercase, remove web. and www. subdomains

	if services[host] then
		index = host;
	else
		for k, _ in pairs (services) do
			if host:find ('%f[%a]'..k:gsub ('([%.%-])', '%%%1')) then
				index = k;
				break;
			end
		end
	end
	
	if index then
		local out = {''};														-- empty string in [1] so that concatenated result has leading single space
		ulx.url1.service = services[index][4] or 'other';
		tracking = services[index][5] or categories.other;
																				-- build tail string
		if false == services[index][1] then										-- select prefix
			table.insert (out, prefixes.at);
		elseif true == services[index][1] then
			table.insert (out, prefixes.atthe);
		else
			table.insert (out, services[index][1]);
		end
		
		table.insert (out, make_wikilink (services[index][2], services[index][3], no_link));	-- add article wikilink
		if services[index][6] then												-- add tail postfix if it exists
			table.insert (out, services[index][6]);
		end
		
		ulx.url1.tail = table.concat (out, ' ');								-- put it all together; result has leading space character

	else																		-- here when unknown archive
		ulx.url1.service = 'other';
		tracking = categories.unknown;
		ulx.url1.tail = table.concat ({'', prefixes.at, host, inlineRed (err_warn_msgs.unknown_url, error)}, ' ');
	end
	
	track[tracking] = 1
end


--[[--------------------------&lt; parseExtraArgs &gt;-----------------------

Parse numbered arguments starting at 2, such as url2..url10, date2..date10, title2..title10
	For example: {{webarchive |url=.. |url4=.. |url7=..}}
		Three url arguments not in numeric sequence (1..4..7). 
			Function only processes arguments numbered 2 or greater (in this case 4 and 7)
				It creates numeric sequenced table entries like:
				urlx.url2.url = &lt;argument value for url4&gt;
				urlx.url3.url = &lt;argument value for url7&gt;
			Returns the number of URL arguments found numbered 2 or greater (in this case returns "2")

 ]]

local function parseExtraArgs(args)

	local i, j, argurl, argurl2, argdate, argtitle

	j = 2
	for i = 2, config.maxurls do
		argurl = "url" .. i
		if args[argurl] then
			argurl2 = "url" .. j
			ulx[argurl2] = {}
			ulx[argurl2]["url"] = args[argurl]
			argdate = "date" .. j
			if args[argdate] then
				ulx[argurl2]["date"] = args[argdate]
			else
				ulx[argurl2]["date"] = inlineRed (err_warn_msgs.date_miss, 'warning');
			end
	
			argtitle = "title" .. j
			if args[argtitle] then
				ulx[argurl2]["title"] = args[argtitle]
			else
				ulx[argurl2]["title"] = nil
			end
			j = j + 1
		end
	end

	if j == 2 then
		return 0
	else
		return j - 2
	end
end


--[[--------------------------&lt; comma &gt;-----------------------

Given a date string, return "," if it's MDY 

]]

local function comma(date)
	return (date and date:match ('%a+ +%d%d?(,) +%d%d%d%d')) or '';
end


--[[--------------------------&lt; createRendering &gt;-----------------------

Return a rendering of the data in ulx[][]

]]

local function createRendering()

	local displayfield
	local out = {};
	
	local index_date, msg = ulx.url1.date:match ('(index)(.*)');				-- when ulx.url1.date extract 'index' text and message text (if there is a message)
	ulx.url1.date = ulx.url1.date:gsub ('index.*', 'index');					-- remove message

	if 'none' == ulx.url1.format then											-- For {{wayback}}, {{webcite}}
		table.insert (out, '[');												-- open extlink markup
		table.insert (out, ulx.url1.url);										-- add url

		if ulx.url1.title then
			table.insert (out, ' ')												-- the required space
			table.insert (out, ulx.url1.title)									-- the title
			table.insert (out, ']');											-- close extlink markup
			table.insert (out, ulx.url1.tail);									-- tail text
			if ulx.url1.date then
				table.insert (out, '&amp;#32;(');									-- open date text; TODO: why the html entity? replace with regular space?
				table.insert (out, 'index' == ulx.url1.date and s_text.archive or s_text.archived);	-- add text
				table.insert (out, ' ');										-- insert a space
				table.insert (out, ulx.url1.date);								-- add date
				table.insert (out, ')');										-- close date text
			end
		else																	-- no title
			if index_date then													-- when url date is 'index' 
				table.insert (out, table.concat ({' ', s_text.Archive_index, ']'}));	-- add the index link label
				table.insert (out, msg or '');									-- add date mismatch message when url date is /*/ and |date= has valid date
			else
				table.insert (out, table.concat ({' ', s_text.Archived, '] '}));	-- add link label for url has timestamp date (will include mismatch message if there is one)
			end
			if ulx.url1.date then
				if 'index' ~= ulx.url1.date then
					table.insert (out, ulx.url1.date);							-- add date when data is not 'index'
				end
				table.insert (out, comma(ulx.url1.date));						-- add ',' if date format is mdy
				table.insert (out, ulx.url1.tail);								-- add tail text
			else																-- no date
				table.insert (out, ulx.url1.tail);								-- add tail text
			end
		end

		if 0 &lt; ulx.url1.extraurls then											-- For multiple archive URLs
			local tot = ulx.url1.extraurls + 1
			table.insert (out, '.')												-- terminate first url
			table.insert (out, table.concat ({' ', s_text.addlarchives, ': '}));	-- add header text

			for i=2, tot do														-- loop through the additionals
				local index = table.concat ({'url', i});						-- make an index
				displayfield = ulx[index]['title'] and 'title' or 'date';		-- choose display text
				table.insert (out, '[');										-- open extlink markup
				table.insert (out, ulx[index]['url']);							-- add the url
				table.insert (out, ' ');										-- the required space
				table.insert (out, ulx[index][displayfield]);					-- add the label
				table.insert (out, ']');										-- close extlink markup
				table.insert (out, i==tot and '.' or ', ');						-- add terminator
			end
		end
		return table.concat (out);												-- make a big string and done

	else																		-- For {{cite archives}}																	
		if 'addlarchives' == ulx.url1.format then								-- Multiple archive services 
			table.insert (out, table.concat ({s_text.addlarchives, ': '}));		-- add header text
		else																	-- Multiple pages from the same archive 
			table.insert (out, table.concat ({s_text.addlpages, ' '}));			-- add header text
			table.insert (out, ulx.url1.date);									-- add date to header text
			table.insert (out, ': ');											-- close header text
		end

		local tot = ulx.url1.extraurls + 1;
		for i=1, tot do															-- loop through the additionals
			local index = table.concat ({'url', i});							-- make an index
			table.insert (out, '[');											-- open extlink markup
			table.insert (out, ulx[index]['url']);								-- add url
			table.insert (out, ' ');											-- add required space

			displayfield = ulx[index]['title'];
			if 'addlarchives' == ulx.url1.format then
				if not displayfield then 
					displayfield = ulx[index]['date']
				end
			else																-- must be addlpages
				if not displayfield then 
					displayfield = table.concat ({s_text.Page, ' ', i});
				end
			end
			table.insert (out, displayfield);									-- add title, date, page label text
			table.insert (out, ']');											-- close extlink markup
			table.insert (out, (i==tot and '.' or ', '));							-- add terminator
		end
		return table.concat (out);												-- make a big string and done
	end
end


--[[--------------------------&lt; P A R A M E T E R _ N A M E _ X L A T E &gt;--------------------------------------

for internaltionalization, translate local-language parameter names to their English equivalents

TODO: return error message if multiple aliases of the same canonical parameter name are found?

returns two tables:
	new_args - holds canonical form parameters and their values either from translation or because the parameter was already in canonical form
	origin - maps canonical-form parameter names to their untranslated (local language) form for error messaging in the local language

unrecognized parameters are ignored

]]

local function parameter_name_xlate (args, params, enum_params)
	local name;																	-- holds modifiable name of the parameter name during evaluation
	local enum;																	-- for enumerated parameters, holds the enumerator during evaluation
	local found = false;														-- flag used to break out of nested for loops
	local new_args = {};														-- a table that holds canonical and translated parameter k/v pairs
	local origin = {};															-- a table that maps original (local language) parameter names to their canonical name for local language error messaging
	local unnamed_params;														-- set true when unsupported positional parameters are detected
	
	for k, v in pairs (args) do													-- loop through all of the arguments in the args table
		name = k;																-- copy of original parameter name

		if 'string' == type (k) then
			if non_western_digits then											-- true when non-western digits supported at this wiki
				name = mw.ustring.gsub (name, '%d', digits);					-- convert this wiki's non-western digits to western digits
			end
			
			enum = name:match ('%d+$');											-- get parameter enumerator if it exists; nil else
			
			if not enum then													-- no enumerator so looking for non-enumnerated parameters
				-- TODO: insert shortcut here? if params[name] then name holds the canonical parameter name; no need to search further
				for pname, aliases in pairs (params) do							-- loop through each parameter the params table
					for _, alias in ipairs (aliases) do							-- loop through each alias in the parameter's aliases table
						if name == alias then
							new_args[pname] = v;								-- create a new entry in the new_args table
							origin [pname] = k;									-- create an entry to make canonical parameter name to original local language parameter name
							found = true;										-- flag so that we can break out of these nested for loops
							break;												-- no need to search the rest of the aliases table for name so go on to the next k, v pair
						end
					end
	
					if found then												-- true when we found an alias that matched name
						found = false;											-- reset the flag
						break;													-- go do next args k/v pair
					end
				end
			else																-- enumerated parameters
				name = name:gsub ('%d$', '#');									-- replace enumeration digits with place holder for table search
				-- TODO: insert shortcut here? if num_params[name] then name holds the canonical parameter name; no need to search further
				for pname, aliases in pairs (enum_params) do					-- loop through each parameter the num_params table
					for _, alias in ipairs (aliases) do							-- loop through each alias in the parameter's aliases table
						if name == alias then
							pname = pname:gsub ('#$', enum);					-- replace the '#' place holder with the actual enumerator
							new_args[pname] = v;								-- create a new entry in the new_args table
							origin [pname] = k;									-- create an entry to make canonical parameter name to original local language parameter name
							found = true;										-- flag so that we can break out of these nested for loops
							break;												-- no need to search the rest of the aliases table for name so go on to the next k, v pair
						end
					end
	
					if found then												-- true when we found an alias that matched name
						found = false;											-- reset the flag
						break;													-- go do next args k/v pair
					end
				end
			end
		else
			unnamed_params = true;												-- flag for unsupported positional parameters
		end
	end																			-- for k, v
	return new_args, origin, unnamed_params;
end


--[[--------------------------&lt; W E B A R C H I V E &gt;----------------------------------------------------------

template entry point

]]

local function webarchive(frame)
	local args = getArgs (frame);

	local data = mw.loadData (table.concat ({									-- make a data module name; sandbox or live
		'Module:Webarchive/data',
		frame:getTitle():find('sandbox', 1, true) and '/sandbox' or ''			-- this instance is ./sandbox then append /sandbox
		}));
	categories = data.categories;												-- fill in the forward declarations
	config = data.config;
	if data.digits.enable then
		digits = data.digits;													-- for i18n; table of digits in the local wiki's language
		non_western_digits = true;												-- use_non_western_digits
	end
	err_warn_msgs = data.err_warn_msgs;
	excepted_pages = data.excepted_pages;
	month_num = data.month_num;													-- for i18n; table of month names in the local wiki's language
	prefixes = data.prefixes;
	services = data.services;
	s_text = data.s_text;
	uncategorized_namespaces = data.uncategorized_namespaces;
	uncategorized_subpages = data.uncategorized_subpages;

	local origin = {};															-- holds a map of English to local language parameter names used in the current template; not currently used
	local unnamed_params;														-- boolean set to true when template call has unnamed parameters
	args, origin, unnamed_params = parameter_name_xlate (args, data.params, data.enum_params);	-- translate parameter names in args to English

	local date, format, msg, udate, uri, url;
	local ldf = 'iso';															-- when there is no |date= parameter, render url dates in iso format
	
	if args.url and args.url1 then												-- URL argument (first)
		return inlineError (data.crit_err_msgs.conflicting, {origin.url, origin.url1});
	end
	
	url = args.url or args.url1;
	
	if not url then
		return inlineError (data.crit_err_msgs.empty);
	end
																				-- these iabot bugs perportedly fixed; removing these causes lua script error
--[[																				-- at Template:Webarchive/testcases/Production; resolve that before deleting these tests
	if mw.ustring.find( url, "https://web.http", 1, true ) then					-- track bug - TODO: IAbot bug; not known if the bug has been fixed; deferred
		track[categories.error] = 1;
		return inlineError (data.crit_err_msgs.iabot1);
	end 
	if url == "https://web.archive.org/http:/" then								 -- track bug - TODO: IAbot bug; not known if the bug has been fixed; deferred
		track[categories.error] = 1;
		return inlineError (data.crit_err_msgs.iabot2);
	end
]]

	if not (url:lower():find ('^http') or url:find ('^//')) then
		return inlineError (data.crit_err_msgs.invalid_url );
	end

	ulx.url1 = {}
	ulx.url1.url = url

	ulx.url1.extraurls = parseExtraArgs(args)

	local good = false;
	good, uri = pcall (mw.uri.new, ulx.url1.url);								-- get a table of uri parts from this url; protected mode to prevent lua error when ulx.url1.url is malformed
	
	if not good or nil == uri.host then											-- abandon when ulx.url1.url is malformed
		return inlineError (data.crit_err_msgs.invalid_url);
	end
	
	serviceName(uri.host, args.nolink)

	if args.date and args.date1 then											-- Date argument
		return inlineError (data.crit_err_msgs.conflicting, {origin.date, origin.date1});
	end
	
	date = args.date or args.date1;
	date = date and date:gsub (' +', ' ');										-- replace multiple spaces with a single space

	if date and config.verifydates then
		if '*' == date then
			date = 'index';
			ldf = 'iso';														-- set to default format
		else
			date, ldf = decode_date (date);										-- get an iso format date from date and get date's original format
		end
	end

	if 'wayback' == ulx.url1.service or 'locwebarchives' == ulx.url1.service then
		if date then
			if config.verifydates then
				if ldf then
					udate, msg = decodeWaybackDate (uri.path);					-- get the url date in iso format and format of date in |date=; 'index' when wayback url date is *
					if not udate then											-- this is the only 'fatal' error return
						return inlineError (data.crit_err_msgs[msg]);
					end

					if udate ~= date then										-- date comparison using iso format dates
						date = udate;
						msg = table.concat ({
							inlineRed (err_warn_msgs.mismatch, 'warning'),		-- add warning message
							msg,												-- add message if there is one
						});
					end
				end
			end
		else																	-- no |date=
			udate, msg = decodeWaybackDate (uri.path);

			if not udate then													-- this is the only 'fatal' error return
				return inlineError (data.crit_err_msgs[msg]);
			end

			if '' == udate then 
				date = nil;														-- unset
			else
				date = udate;
			end
		end

	elseif 'webcite' == ulx.url1.service then
		if date then
			if config.verifydates then
				if ldf then
					udate = decodeWebciteDate (uri.path);						-- get the url date in iso format
					if 'query' ~= udate then									-- skip if query
						if udate ~= date then									-- date comparison using iso format dates
							date = udate;
							msg = table.concat ({
								inlineRed (err_warn_msgs.mismatch, 'warning'),
								});
						end
					end
				end
			end
		else
			date = decodeWebciteDate( uri.path, "iso" )
			if date == "query" then
				date = nil;														-- unset
				msg = inlineRed (err_warn_msgs.date_miss, 'warning');
			elseif not date then												-- invalid base62 string
				date = inlineRed (err_warn_msgs.date1, 'error');
			end
		end

	elseif 'archiveis' == ulx.url1.service then
		if date then
			if config.verifydates then
				if ldf then
					udate, msg = decodeArchiveisDate (uri.path)					-- get the url date in iso format
					if 'short link' ~= udate then								-- skip if short link
						if udate ~= date then									-- date comparison using iso format dates
							date = udate;
							msg = table.concat ({
								inlineRed (err_warn_msgs.mismatch, 'warning'),	-- add warning message
								msg,											-- add message if there is one
							});
						end
					end
				end
			end
		else																	-- no |date=
			udate, msg = decodeArchiveisDate( uri.path, "iso" )
			if udate == "short link" then
				date = nil;														-- unset
				msg = inlineRed (err_warn_msgs.date_miss, 'warning');
			elseif '' == udate then
				date = nil;														-- unset
			else
				date = udate;
			end
		end
		
	else																		-- some other service
		if not date then
			msg = inlineRed (err_warn_msgs.date_miss, 'warning');
		end
	end

	if 'index' == date then
		ulx.url1.date = date .. (msg or '');									-- create index + message (if there is one)
	elseif date then
		ulx.url1.date = makeDate (date, nil, nil, ldf) .. (msg or '');			-- create a date in the wiki's local language + message (if there is one)
	else
		ulx.url1.date = msg;
	end
		
	format = args.format;														-- Format argument 

	if not format then
		format = "none"
	else
		for k, v in pairs (data.format_vals) do									-- |format= accepts two specific values loop through a table of those values
			local found;														-- declare a nil flag
			for _, p in ipairs (v) do											-- loop through local language variants
				if format == p then												-- when |format= value matches 
					format = k;													-- use name from table key
					found = true;												-- declare found so that we can break out of outer for loop
					break;														-- break out of inner for loop
				end
			end
			
			if found then
				break;
			end
		end

		if format == "addlpages" then
			if not ulx.url1.date then
				format = "none"
			end
		elseif format == "addlarchives" then
			format = "addlarchives"
		else
			format = "none"
		end
	end
	ulx.url1.format = format

	if args.title and args.title1 then											-- Title argument
		return inlineError (data.crit_err_msgs.conflicting, {origin.title, origin.title1});
	end

	ulx.url1.title = args.title or args.title1;

	local rend = createRendering()
	if not rend then
		return inlineError (data.crit_err_msgs.unknown);
	end

	return rend .. ((unnamed_params and inlineRed (err_warn_msgs.unnamed_params, 'warning')) or '') .. createTracking();

end


--[[--------------------------&lt; E X P O R T E D 	 F U N C T I O N S &gt;------------------------------------------
]]

return {webarchive = webarchive};</text>
      <sha1>bs72n4jqbfrg7h4j8ti2gs0v0rt5nly</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Webarchive/data</title>
    <ns>828</ns>
    <id>58440631</id>
    <revision>
      <id>876951147</id>
      <parentid>863694780</parentid>
      <timestamp>2019-01-05T15:54:19Z</timestamp>
      <contributor>
        <username>GreenC</username>
        <id>8931761</id>
      </contributor>
      <comment>add new .MD, .PH and .VN .. change target article to .TODAY (wiki article rename in progress) .. sort alpha</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="10861" xml:space="preserve">--[[--------------------------&lt; C O N F I G U R A T I O N &gt;----------------------------------------------------

global configuration settings

]]

local config = {
	maxurls = 10,																-- Max number of URLs allowed. 
	tname = 'Webarchive',														-- name of calling template. Change if template rename.
	verifydates = true,															-- See documentation. Set false to disable.
	}


--[[--------------------------&lt; U N C A T E G O R I Z E D _ N A M E S P A C E S &gt;------------------------------

List of namespaces that should not be included in citation error categories.

Note: Namespace names should use underscores instead of spaces.

]]

local uncategorized_namespaces = {												-- same list as specified at [[Module:Citation/CS1/Configuration]]
	['User']=true, ['Talk']=true, ['User_talk']=true, ['Wikipedia_talk']=true, ['File_talk']=true,
	['Template_talk']=true, ['Help_talk']=true, ['Category_talk']=true, ['Portal_talk']=true,
	['Book_talk']=true, ['Draft_talk']=true, ['Education_Program_talk']=true, ['Module_talk']=true,
	['MediaWiki_talk']=true,
	}

local uncategorized_subpages = {'/[Ss]andbox', '/[Tt]estcases'};				-- list of Lua patterns found in page names of pages we should not categorize

local excepted_pages = {														-- these pages will be categorized if set true; set to nil to disable
	['Module talk:Webarchive/testcases'] = true,								-- test cases pages used during development
	['Template:Webarchive/testcases/Production'] = true,
	}


--[[--------------------------&lt; C A T E G O R I E S &gt;----------------------------------------------------------

this is a table of all categories supported by Module:Webarchive

]]

local categories = {
	archiveis = 'Category:Webarchive template archiveis links',
	error = 'Category:Webarchive template errors',
	other = 'Category:Webarchive template other archives',
	unknown = 'Category:Webarchive template unknown archives',
	warning = 'Category:Webarchive template warnings',
	wayback = 'Category:Webarchive template wayback links',
	webcite = 'Category:Webarchive template webcite links',
	}


--[[--------------------------&lt; P R E F I X E S &gt;--------------------------------------------------------------

used only with serviceName(), this table holds the two generic tail-text prefixes specified by services['&lt;service name&gt;'][1]

]]

local prefixes = {
	at = 'at',
	atthe = 'at the',
	}


--[=[-------------------------&lt; S E R V I C E S &gt;--------------------------------------------------------------

this is a table of tables for archive services.  Each service table has:
	[1]=prefix; may be boolean true or false, or text string where:
		true indicates that the prefix is taken from prefixes.atthe
		false indicates that the prefix is taken from prefixes.at
		'text string' is used in lieu of the typical 'at' or 'at the' prefix
	[2]=wikilink target article that describes the service; set to nil if not used
	[3]=wikilink label; the label in [[target|label]]; set to nil if not used; when there is not article ([2] is nil) use this to name the service; see wikiwix in the table
	[4]=service ID; set to nil if not used
	[5]=tracking category key from the categories table; set to nil if not used
	[6]=postfix; text string to be appended at the end of the tail string - see webarchive.loc.gov in the table

]=]

local services = {
	['archive.ec'] = {false, 'Archive.today', nil, 'archiveis', categories.archiveis},
	['archive.fo'] = {false, 'Archive.today', nil, 'archiveis', categories.archiveis},
	['archive.is'] = {false, 'Archive.today', nil, 'archiveis', categories.archiveis},
	['archive.li'] = {false, 'Archive.today', nil, 'archiveis', categories.archiveis},
	['archive.md'] = {false, 'Archive.today', nil, 'archiveis', categories.archiveis},
	['archive.org'] = {true, 'Wayback Machine', nil, 'wayback', categories.wayback},
	['archive.ph'] = {false, 'Archive.today', nil, 'archiveis', categories.archiveis},
	['archive.today'] = {false, 'Archive.today', nil, 'archiveis', categories.archiveis},
	['archive.vn'] = {false, 'Archive.today', nil, 'archiveis', categories.archiveis},
	['archive-it.org'] = {false, 'Archive-It', nil, 'archiveit'},
	['arquivo.pt'] = {true, nil, 'Portuguese Web Archive'},
	['bibalex.org'] = {false, 'Bibliotheca Alexandrina#Internet Archive partnership', 'Bibliotheca Alexandrina'},
	['collectionscanada'] = {true, 'Canadian Government Web Archive'},
	['europarchive.org'] = {true, 'National Library of Ireland'},
	['freezepage.com'] = {false, nil, 'Freezepage'},
	['haw.nsk'] = {true, 'Croatian Web Archive (HAW)'},
	['langzeitarchivierung.bib-bvb.de'] = {false, 'Bavarian State Library'},
	['loc.gov'] = {true, 'Library of Congress'},
	['nationalarchives.gov.uk'] = {true, 'UK Government Web Archive'},
	['nlb.gov.sg'] = {false, 'Web Archive Singapore'},
	['pandora.nla.gov.au'] = {false, 'Pandora Archive'},
	['parliament.uk'] = {true, 'UK Parliament\'s Web Archive'},
	['perma.cc'] = {false, 'Perma.cc'},
	['perma-archives.cc'] = {false, 'Perma.cc'},
	['proni.gov'] = {true, 'Public Record Office of Northern Ireland'},
	['screenshots.com'] = {false, nil, 'Screenshots'},
	['stanford.edu'] = {true, 'Stanford University Libraries', 'Stanford Web Archive'},
	['timetravel.mementoweb.org'] = {false, 'Memento Project'},
	['uni-lj.si'] = {true, nil, 'Slovenian Web Archive'},
	['veebiarhiiv.digar.ee'] = {true, nil, 'Estonian Web Archive'},
	['vefsafn.is'] = {true, 'National and University Library of Iceland'},
	['webarchive.bac-lac.gc.ca'] = {false, 'Library and Archives Canada'},
	['webarchive.loc.gov'] = {true, 'Library of Congress', nil, 'locwebarchives', nil, 'Web Archives'},
	['webarchive.org.uk'] = {true, 'UK Web Archive'},
	['webcache.googleusercontent.com'] = {false, nil, 'Google Cache'},
	['webcitation.org'] = {false, 'WebCite', nil, 'webcite', categories.webcite},
	['webharvest.gov'] = {true, 'National Archives and Records Administration'},
	['webrecorder.io'] = {false, 'webrecorder.io'},
	['wikiwix.com'] = {false, nil, 'Wikiwix'},
	['yorku.ca'] = {false, 'York University Libraries', 'York University Digital Library'},
	}


--[[--------------------------&lt; S T A T I C   T E X T &gt;--------------------------------------------------------

for internationalzation

]]

local s_text = {
	addlarchives = 'Additional archives',
	addlpages = 'Additional pages archived&amp;nbsp;on',							-- TODO why the &amp;nbsp; there? replace with regular space?
	Archive_index = 'Archive index',
	Archived = 'Archived',
	archived = 'archived',
	archive = 'archive',
	Page = 'Page',
	}


--[[--------------------------&lt; E R R _ W A R N _ M S G S &gt;----------------------------------------------------

these tables hold error and warning message text

]]

local err_warn_msgs = {
	date_err = '[Date error]',													-- decodeWebciteDate, decodeWaybackDate, decodeArchiveisDate
	date_miss = '[Date missing]',												-- parseExtraArgs
	ts_short = '[Timestamp date length]',										-- decodeWaybackDate timestamp less than 8 digits
	ts_date = '[Timestamp date invalid]',										-- decodeWaybackDate timestamp not a valid date
	unknown_url = '[Error: unknown archive URL]',								-- serviceName
	unnamed_params = '[Positional parameters ignored]',

--warnings
	mismatch = '&lt;sup&gt;[Date mismatch]&lt;/sup&gt;',									-- webarchive
	ts_len = '&lt;sup&gt;[Timestamp length]&lt;/sup&gt;',									-- decodeWaybackDate, decodeArchiveisDate timestamp not 14 digits
	ts_cal = '&lt;sup&gt;[Calendar]&lt;/sup&gt;',											-- decodeWaybackDate timestamp has trailing splat
	}


local crit_err_msgs = {															-- critical error messages
	conflicting = 'Conflicting |$1= and |$2=',
	empty = 'Empty url',
--	iabot1 = 'https://web.http',												-- TODO: these iabot bugs perportedly fixed; removing these causes lua script error
--	iabot2 = 'Invalid URL',														-- at Template:Webarchive/testcases/Production; resolve that before deleting these messages
	invalid_url = 'Invalid URL',
	ts_nan = 'Timestamp not a number',
	unknown = 'Unknown problem. Please report on template talk page',
	}



--[[--------------------------&lt; D A T E   I N T E R N A T I O N A L I Z A T I O N &gt;----------------------------

these tables hold data that is used when converting date formats from non-English languages (because mw.language.getContentLanguage:formatDate()
doesn't understand non-English month names)

]]

local month_num = {																-- retain English language names even though they may not be strictly required on the local wiki
	['January'] = 1, ['February'] = 2, ['March'] = 3, ['April'] = 4, ['May'] = 5, ['June'] = 6, ['July'] = 7, ['August'] = 8, ['September'] = 9, ['October'] = 10, ['November'] = 11, ['December'] = 12,
	['Jan'] = 1, ['Feb'] = 2, ['Mar'] = 3, ['Apr'] = 4, ['May'] = 5, ['Jun'] = 6, ['Jul'] = 7, ['Aug'] = 8, ['Sep'] = 9, ['Oct'] = 10, ['Nov'] = 11, ['Dec'] = 12,
-- add local wiki month-names to number translation here
--	[''] = 1, [''] = 2, [''] = 3, [''] = 4, [''] = 5, [''] = 6, [''] = 7, [''] = 8, [''] = 9, [''] = 10, [''] = 11, [''] = 12,
	};

																				-- when the local wiki uses non-western digits in dates, local wiki digits must be
																				-- translated to western digits; lua only understands western digits
local digits = {																-- use this table to aid translation
--	[''] = 0, [''] = 1, [''] = 2, [''] = 3, [''] = 4, [''] = 5, [''] = 6, [''] = 7, [''] = 8, [''] = 9,	-- fill these table indexes with local digits
	enable = false																-- set to true to enable local-digit to western-digit translation
	};


--[[--------------------------&lt; P A R A M E T E R   I N T E R N A T I O N A L I Z A T I O N &gt;------------------

this table holds tables of parameter names and their non-English aliases.  In the enum_params table '#' is a single
character placeholder for 1 or more digit characters

parameter names in this table shall be lowercase
]]

local params = {
	['url'] = {'url'},
	['date'] = {'date', 'datum'},
	['title'] = {'title', 'titel'},
	['nolink'] = {'nolink'},
	['format'] = {'format'}
	}

local enum_params = {
	['url#'] = {'url#'},
	['date#'] = {'date#', 'datum#'},
	['title#'] = {'title#', 'titel#'},
	}

local format_vals = {															-- |format= accepts two values; add local language variants here
	['addlpages'] = {'addlpages'},
	['addlarchives'] = {'addlarchives'},
	}


--[[--------------------------&lt; E X P O R T E D   T A B L E S &gt;------------------------------------------------
]]

return {
	categories = categories,
	config = config,
	crit_err_msgs = crit_err_msgs,
	digits = digits,
	enum_params = enum_params,
	err_warn_msgs = err_warn_msgs,
	excepted_pages = excepted_pages,
	format_vals = format_vals,
	month_num = month_num,
	params = params,
	prefixes = prefixes,
	services = services,
	s_text = s_text,
	uncategorized_namespaces = uncategorized_namespaces,
	uncategorized_subpages = uncategorized_subpages,
	}</text>
      <sha1>lzmbn7x5jyx332clrzmk4m5jwsp53yj</sha1>
    </revision>
  </page>
  <page>
    <title>Module:WikidataIB</title>
    <ns>828</ns>
    <id>50557571</id>
    <revision>
      <id>953913873</id>
      <parentid>953881365</parentid>
      <timestamp>2020-04-29T18:24:21Z</timestamp>
      <contributor>
        <username>Uzume</username>
        <id>51070</id>
      </contributor>
      <comment>some minor fixes</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="133969" xml:space="preserve">-- Module to implement use of a blacklist and whitelist for infobox fields
-- Can take a named parameter |qid which is the Wikidata ID for the article
-- if not supplied, it will use the Wikidata ID associated with the current page.
-- Fields in blacklist are never to be displayed, i.e. module must return nil in all circumstances
-- Fields in whitelist return local value if it exists or the Wikidata value otherwise
-- The name of the field that this function is called from is passed in named parameter |name
-- The name is compulsory when blacklist or whitelist is used,
-- so the module returns nil if it is not supplied.
-- blacklist is passed in named parameter |suppressfields (or |spf)
-- whitelist is passed in named parameter |fetchwikidata (or |fwd)

local p = {}

local cdate -- initialise as nil and only load _complex_date function if needed
-- [[Module:Complex date]] is loaded lazily and has the following dependencies:
-- Module:I18n/complex date, Module:ISOdate, Module:DateI18n (alternative for Module:Date),
-- Module:Formatnum, Module:I18n/date, Module:Yesno, Module:Linguistic, Module:Calendar
-- The following, taken from https://www.mediawiki.org/wiki/Wikibase/DataModel#Dates_and_times,
-- is needed to use Module:Complex date which seemingly requires date precision as a string.
-- It would work better if only the authors of the mediawiki page could spell 'millennium'.
local dp = {
	[6] = "millennium",
	[7] = "century",
	[8] = "decade",
	[9] = "year",
	[10] = "month",
	[11] = "day",
}

local i18n =
{
	["errors"] =
	{
		["property-not-found"] = "Property not found.",
		["No property supplied"] = "No property supplied",
		["entity-not-found"] = "Wikidata entity not found.",
		["unknown-claim-type"] = "Unknown claim type.",
		["unknown-entity-type"] = "Unknown entity type.",
		["qualifier-not-found"] = "Qualifier not found.",
		["site-not-found"] = "Wikimedia project not found.",
		["labels-not-found"] = "No labels found.",
		["descriptions-not-found"] = "No descriptions found.",
		["aliases-not-found"] = "No aliases found.",
		["unknown-datetime-format"] = "Unknown datetime format.",
		["local-article-not-found"] = "Article is available on Wikidata, but not on Wikipedia",
		["dab-page"] = " (dab)",
	},
	["months"] =
	{
		"January", "February", "March", "April", "May", "June",
		"July", "August", "September", "October", "November", "December"
	},
	["century"] = "century",
	["BC"] = "BC",
	["BCE"] = "BCE",
	["ordinal"] =
	{
		[1] = "st",
		[2] = "nd",
		[3] = "rd",
		["default"] = "th"
	},
	["filespace"] = "File",
	["Unknown"] = "Unknown",
	["NaN"] = "Not a number",
	-- set the following to the name of a tracking category,
	-- e.g. "[[Category:Articles with missing Wikidata information]]", or "" to disable:
	["missinginfocat"] = "[[Category:Articles with missing Wikidata information]]",
	["editonwikidata"] = "Edit this on Wikidata",
	["latestdatequalifier"] = function (date) return "before " .. date end,
	-- some languages, e.g. Bosnian use a period as a suffix after each number in a date
	["datenumbersuffix"] = "",
	["list separator"] = ", ",
	["multipliers"] = {
		[0]  = "",
		[3]  = " thousand",
		[6]  = " million",
		[9]  = " billion",
		[12] = " trillion",
	}
}
-- This allows an internationisation module to override the above table
if 'en' ~= mw.getContentLanguage():getCode() then
	require("Module:i18n").loadI18n("Module:WikidataIB/i18n", i18n)
end

-- This piece of html implements a collapsible container. Check the classes exist on your wiki.
local collapsediv = '&lt;div class="mw-collapsible mw-collapsed" style="width:100%; overflow:auto;" data-expandtext="{{int:show}}" data-collapsetext="{{int:hide}}"&gt;'

-- Some items should not be linked.
-- Each wiki can create a list of those in Module:WikidataIB/nolinks
-- It should return a table called itemsindex, containing true for each item not to be linked
local donotlink = {}
local nolinks_exists, nolinks = pcall(mw.loadData, "Module:WikidataIB/nolinks")
if nolinks_exists then
	donotlink = nolinks.itemsindex
end

-- To satisfy Wikipedia:Manual of Style/Titles, certain types of items are italicised, and others are quoted.
-- The submodule [[Module:WikidataIB/titleformats]] lists the entity-ids used in 'instance of' (P31),
-- which allows this module to identify the values that should be formatted.
-- WikidataIB/titleformats exports a table p.formats, which is indexed by entity-id, and contains the value " or ''
local formats = {}
local titleformats_exists, titleformats = pcall(mw.loadData, "Module:WikidataIB/titleformats")
if titleformats_exists then
	formats = titleformats.formats
end

-------------------------------------------------------------------------------
-- Private functions
-------------------------------------------------------------------------------
--
-------------------------------------------------------------------------------
-- makeOrdinal needs to be internationalised along with the above:
-- takes cardinal number as a numeric and returns the ordinal as a string
-- we need three exceptions in English for 1st, 2nd, 3rd, 21st, .. 31st, etc.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local makeOrdinal = function(cardinal)
	local ordsuffix = i18n.ordinal.default
	if cardinal % 10 == 1 then
		ordsuffix = i18n.ordinal[1]
	elseif cardinal % 10 == 2 then
		ordsuffix = i18n.ordinal[2]
	elseif cardinal % 10 == 3 then
		ordsuffix = i18n.ordinal[3]
	end
	-- In English, 1, 21, 31, etc. use 'st', but 11, 111, etc. use 'th'
	-- similarly for 12 and 13, etc.
	if (cardinal % 100 == 11) or (cardinal % 100 == 12) or (cardinal % 100 == 13) then
		ordsuffix = i18n.ordinal.default
	end
	return tostring(cardinal) .. ordsuffix
end


-------------------------------------------------------------------------------
-- findLang takes a "langcode" parameter if supplied and valid
-- otherwise it tries to create it from the user's set language ({{int:lang}})
-- failing that it uses the wiki's content language.
-- It returns a language object
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local findLang = function(langcode)
	local langobj
	langcode = mw.text.trim(langcode or "")
	if mw.language.isKnownLanguageTag(langcode) then
		langobj = mw.language.new( langcode )
	else
		langcode = mw.getCurrentFrame():preprocess( '{{int:lang}}' )
		if mw.language.isKnownLanguageTag(langcode) then
			langobj = mw.language.new( langcode )
		else
			langobj = mw.language.getContentLanguage()
		end
	end
	return langobj
end


-------------------------------------------------------------------------------
-- _getItemLangCode takes a qid parameter (using the current page's qid if blank)
-- If the item for that qid has property country (P17) it looks at the first preferred value
-- If the country has an official language (P37), it looks at the first preferred value
-- If that official language has a language code (P424), it returns the first preferred value
-- Otherwise it returns nothing.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local _getItemLangCode = function(qid)
	qid = mw.text.trim(qid or ""):upper()
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return end
	local prop17 = mw.wikibase.getBestStatements(qid, "P17")[1]
	if not prop17 or prop17.mainsnak.snaktype ~= "value" then return end
	local qid17 = prop17.mainsnak.datavalue.value.id
	local prop37 = mw.wikibase.getBestStatements(qid17, "P37")[1]
	if not prop37 or prop37.mainsnak.snaktype ~= "value" then return end
	local qid37 = prop37.mainsnak.datavalue.value.id
	local prop424 = mw.wikibase.getBestStatements(qid37, "P424")[1]
	if not prop424 or prop424.mainsnak.snaktype ~= "value" then return end
	return prop424.mainsnak.datavalue.value
end


-------------------------------------------------------------------------------
-- roundto takes a number (x)
-- and returns it rounded to (sf) significant figures
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local roundto = function(x, sf)
	if x == 0 then return 0 end
	local s = 1
	if x &lt; 0 then
		x = -x
		s = -1
	end
	if sf &lt; 1 then sf = 1 end
	local p = 10 ^ (math.floor(math.log10(x)) - sf + 1)
	x = math.floor(x / p + 0.5) * p * s
	-- if it's integral, cast to an integer:
	if x == math.floor(x) then x = math.floor(x) end
	return x
end


-------------------------------------------------------------------------------
-- decimalToDMS takes a decimal degrees (x) with precision (p)
-- and returns degrees/minutes/seconds according to the precision
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local decimalToDMS = function(x, p)
	-- if p is not supplied, use a precision around 0.1 seconds
	if not tonumber(p) then p = 1e-4 end
	local d = math.floor(x)
	local ms = (x - d) * 60
	if p &gt; 0.5 then -- precision is &gt; 1/2 a degree
		if ms &gt; 30 then d = d + 1 end
		ms = 0
	end
	local m = math.floor(ms)
	local s = (ms - m) * 60
	if p &gt; 0.008 then -- precision is &gt; 1/2 a minute
		if s &gt; 30 then m = m +1 end
		s = 0
	elseif p &gt; 0.00014 then -- precision is &gt; 1/2 a second
		s = math.floor(s + 0.5)
	elseif p &gt; 0.000014 then -- precision is &gt; 1/20 second
		s = math.floor(10 * s + 0.5) / 10
	elseif p &gt; 0.0000014 then -- precision is &gt; 1/200 second
		s = math.floor(100 * s + 0.5) / 100
	else -- cap it at 3 dec places for now
		s = math.floor(1000 * s + 0.5) / 1000
	end
	return d, m, s
end


-------------------------------------------------------------------------------
-- decimalPrecision takes a decimal (x) with precision (p)
-- and returns x rounded approximately to the given precision
-- precision should be between 1 and 1e-6, preferably a power of 10.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local decimalPrecision = function(x, p)
	local s = 1
	if x &lt; 0 then
		x = -x
		s = -1
	end
	-- if p is not supplied, pick an arbitrary precision
	if not tonumber(p) then p = 1e-4
	elseif p &gt; 1 then p = 1
	elseif p &lt; 1e-6 then p = 1e-6
	else p = 10 ^ math.floor(math.log10(p))
	end
	x = math.floor(x / p + 0.5) * p * s
	-- if it's integral, cast to an integer:
	if  x == math.floor(x) then x = math.floor(x) end
	-- if it's less than 1e-4, it will be in exponent form, so return a string with 6dp
	-- 9e-5 becomes 0.000090
	if math.abs(x) &lt; 1e-4 then x = string.format("%f", x) end
	return x
end


-------------------------------------------------------------------------------
-- formatDate takes a datetime of the usual format from mw.wikibase.entity:formatPropertyValues
-- like "1 August 30 BCE" as parameter 1
-- and formats it according to the df (date format) and bc parameters
-- df = ["dmy" / "mdy" / "y"] default will be "dmy"
-- bc = ["BC" / "BCE"] default will be "BCE"
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local format_Date = function(datetime, dateformat, bc)
	local datetime = datetime or "1 August 30 BCE" -- in case of nil value
	-- chop off multiple vales and/or any hours, mins, etc.
	-- keep anything before punctuation - we just want a single date:
	local dateval = string.match( datetime, "[%w ]+")

	local dateformat = string.lower(dateformat or "dmy") -- default to dmy

	local bc = string.upper(bc or "") -- can't use nil for bc
	-- we only want to accept two possibilities: BC or default to BCE
	if bc == "BC" then
		bc = "&amp;nbsp;" .. i18n["BC"] -- prepend a non-breaking space.
	else
		bc = "&amp;nbsp;" .. i18n["BCE"]
	end

	local postchrist = true -- start by assuming no BCE
	local dateparts = {}
	for word in string.gmatch(dateval, "%w+") do
		if word == "BCE" or word == "BC" then -- *** internationalise later ***
			postchrist = false
		else
			-- we'll keep the parts that are not 'BCE' in a table
			dateparts[#dateparts + 1] = word
		end
	end
	if postchrist then bc = "" end -- set AD dates to no suffix *** internationalise later ***

	local sep = "&amp;nbsp;" -- separator is nbsp
	local fdate = table.concat(dateparts, sep) -- set formatted date to same order as input

	-- if we have day month year, check dateformat
	if #dateparts == 3 then
		if dateformat == "y" then
			fdate = dateparts[3]
		elseif dateformat == "mdy" then
			fdate = dateparts[2] .. sep .. dateparts[1] .. "," .. sep .. dateparts[3]
		end
	elseif #dateparts == 2 and dateformat == "y" then
		fdate = dateparts[2]
	end

	return fdate .. bc
end


-------------------------------------------------------------------------------
-- dateFormat is the handler for properties that are of type "time"
-- It takes timestamp, precision (6 to 11 per mediawiki), dateformat (y/dmy/mdy), BC format (BC/BCE),
-- a plaindate switch (yes/no/adj) to en/disable "sourcing circumstances"/use adjectival form,
-- any qualifiers for the property, the language, and any adjective to use like 'before'.
-- It passes the date through the "complex date" function
-- and returns a string with the internatonalised date formatted according to preferences.
-------------------------------------------------------------------------------
-- Dependencies: findLang(); cdate(); dp[]
-------------------------------------------------------------------------------
local dateFormat = function(timestamp, dprec, df, bcf, pd, qualifiers, lang, adj, model)
	-- output formatting according to preferences (y/dmy/mdy/ymd)
	df = (df or ""):lower()
	-- if ymd is required, return the part of the timestamp in YYYY-MM-DD form
	-- but apply Year zero#Astronomers fix: 1 BC = 0000; 2 BC = -0001; etc.
	if df == "ymd" then
		if timestamp:sub(1,1) == "+" then
			return timestamp:sub(2,11)
		else
			local yr = tonumber(timestamp:sub(2,5)) - 1
			yr = ("000" .. yr):sub(-4)
			if yr ~= "0000" then yr = "-" .. yr end
			return yr .. timestamp:sub(6,11)
		end
	end
	-- A year can be stored like this: "+1872-00-00T00:00:00Z",
	-- which is processed here as if it were the day before "+1872-01-01T00:00:00Z",
	-- and that's the last day of 1871, so the year is wrong.
	-- So fix the month 0, day 0 timestamp to become 1 January instead:
	timestamp = timestamp:gsub("%-00%-00T", "-01-01T")
	-- just in case date precision is missing
	dprec = dprec or 11
	-- override more precise dates if required dateformat is year alone:
	if df == "y" and dprec &gt; 9 then dprec = 9 end
	-- complex date only deals with precisions from 6 to 11, so clip range
	dprec = dprec&gt;11 and 11 or dprec
	dprec = dprec&lt;6 and 6 or dprec
	-- BC format is "BC" or "BCE"
	bcf = (bcf or ""):upper()
	-- plaindate only needs the first letter (y/n/a)
	pd = (pd or ""):sub(1,1):lower()
	if pd == "" or pd == "n" or pd == "f" or pd == "0" then pd = false end
	-- in case language isn't passed
	lang = lang or findLang().code
	-- set adj as empty if nil
	adj = adj or ""
	-- extract the day, month, year from the timestamp
	local bc = timestamp:sub(1, 1)=="-" and "BC" or ""
	local year, month, day = timestamp:match("[+-](%d*)-(%d*)-(%d*)T")
	local iso = tonumber(year) -- if year is missing, let it throw an error
	-- this will adjust the date format to be compatible with cdate
	-- possible formats are Y, YY, YYY0, YYYY, YYYY-MM, YYYY-MM-DD
	if dprec == 6 then iso = math.floor( (iso - 1) / 1000 ) + 1 end
	if dprec == 7 then iso = math.floor( (iso - 1) / 100 ) + 1 end
	if dprec == 8 then iso = math.floor( iso / 10 ) .. "0" end
	if dprec == 10 then iso = year .. "-" .. month end
	if dprec == 11 then iso = year .. "-" .. month .. "-" .. day end
	-- add "circa" (Q5727902) from "sourcing circumstances" (P1480)
	local sc = not pd and qualifiers and qualifiers.P1480
	if sc then
		for k1, v1 in pairs(sc) do
			if v1.datavalue and v1.datavalue.value.id == "Q5727902" then
				adj = "circa"
				break
			end
		end
	end
	-- deal with Julian dates:
	-- no point in saying that dates before 1582 are Julian - they are by default
	-- doesn't make sense for dates less precise than year
	-- we can suppress it by setting |plaindate, e.g. for use in constructing categories.
	local calendarmodel = ""
	if tonumber(year) &gt; 1582
		and dprec &gt; 8
		and not pd
		and model == "http://www.wikidata.org/entity/Q1985786" then
		calendarmodel = "julian"
	end
	if not cdate then
		cdate = require("Module:Complex date")._complex_date
	end
	local fdate = cdate(calendarmodel, adj, tostring(iso), dp[dprec], bc, "", "", "", "", lang, 1)
	-- this may have QuickStatements info appended to it in a div, so remove that
	fdate = fdate:gsub(' &lt;div style="display: none;"&gt;[^&lt;]*&lt;/div&gt;', '')
	-- it may also be returned wrapped in a microformat, so remove that
	fdate = fdate:gsub("&lt;[^&gt;]*&gt;", "")
	-- there may be leading zeros that we should remove
	fdate = fdate:gsub("^0*", "")
	-- if a plain date is required, then remove any links (like BC linked)
	if pd then
		fdate = fdate:gsub("%[%[.*|", ""):gsub("]]", "")
	end
	-- if 'circa', use the abbreviated form *** internationalise later ***
	fdate = fdate:gsub('circa ', '&lt;abbr title="circa"&gt;c.&lt;/abbr&gt;&amp;nbsp;')
	-- deal with BC/BCE
	if bcf == "BCE" then
		fdate = fdate:gsub('BC', 'BCE')
	end
	-- deal with mdy format
	if df == "mdy" then
		fdate = fdate:gsub("(%d+) (%w+) (%d+)", "%2 %1, %3")
	end
	-- deal with adjectival form *** internationalise later ***
	if pd == "a" then
		fdate = fdate:gsub(' century', '-century')
	end
	return fdate
end


-------------------------------------------------------------------------------
-- parseParam takes a (string) parameter, e.g. from the list of frame arguments,
-- and makes "false", "no", and "0" into the (boolean) false
-- it makes the empty string and nil into the (boolean) value passed as default
-- allowing the parameter to be true or false by default.
-- It returns a boolean.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local parseParam = function(param, default)
	if type(param) == "boolean" then param = tostring(param) end
	if param and param ~= "" then
		param = param:lower()
		if (param == "false") or (param:sub(1,1) == "n") or (param == "0") then
			return false
		else
			return true
		end
	else
		return default
	end
end


-------------------------------------------------------------------------------
-- _getSitelink takes the qid of a Wikidata entity passed as |qid=
-- It takes an optional parameter |wiki= to determine which wiki is to be checked for a sitelink
-- If the parameter is blank, then it uses the local wiki.
-- If there is a sitelink to an article available, it returns the plain text link to the article
-- If there is no sitelink, it returns nil.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local _getSitelink = function(qid, wiki)
	qid = (qid or ""):upper()
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return nil end
	wiki = wiki or ""
	local sitelink
	if wiki == "" then
		sitelink = mw.wikibase.getSitelink(qid)
	else
		sitelink = mw.wikibase.getSitelink(qid, wiki)
	end
	return sitelink
end


-------------------------------------------------------------------------------
-- _getCommonslink takes an optional qid of a Wikidata entity passed as |qid=
-- It returns one of the following in order of preference:
-- 	the Commons sitelink of the Wikidata entity - but not if onlycat=true and it's not a category;
-- 	the Commons sitelink of the topic's main category of the Wikidata entity;
-- 	the Commons category of the Wikidata entity - unless fallback=false.
-------------------------------------------------------------------------------
-- Dependencies: _getSitelink(); parseParam()
-------------------------------------------------------------------------------
local _getCommonslink = function(qid, onlycat, fallback)
	qid = (qid or ""):upper()
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return nil end
	onlycat = parseParam(onlycat, false)
	if fallback == "" then fallback = nil end
	local sitelink = _getSitelink(qid, "commonswiki")
	if onlycat and sitelink and sitelink:sub(1,9) ~= "Category:" then sitelink = nil end
	if not sitelink then
		-- check for topic's main category
		local prop910 = mw.wikibase.getBestStatements(qid, "P910")[1]
		if prop910 then
			local tmcid = prop910.mainsnak.datavalue and prop910.mainsnak.datavalue.value.id
			sitelink = _getSitelink(tmcid, "commonswiki")
		end
		if not sitelink then
			-- check for list's main category
			local prop1754 = mw.wikibase.getBestStatements(qid, "P1754")[1]
			if prop1754 then
				local tmcid = prop1754.mainsnak.datavalue and prop1754.mainsnak.datavalue.value.id
				sitelink = _getSitelink(tmcid, "commonswiki")
			end
		end
	end
	if not sitelink and fallback then
		-- check for Commons category (string value)
		local prop373 = mw.wikibase.getBestStatements(qid, "P373")[1]
		if prop373 then
			sitelink = prop373.mainsnak.datavalue and prop373.mainsnak.datavalue.value
			if sitelink then sitelink = "Category:" .. sitelink end
		end
	end
	return sitelink
end


-------------------------------------------------------------------------------
-- The label in a Wikidata item is subject to vulnerabilities
-- that an attacker might try to exploit.
-- It needs to be 'sanitised' by removing any wikitext before use.
-- If it doesn't exist, return the id for the item
-- a second (boolean) value is also returned, value is true when the label exists
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local labelOrId = function(id, lang)
	if lang == "default" then lang = findLang().code end
	local label
	if lang then
		label = mw.wikibase.getLabelByLang(id, lang)
	else
		label = mw.wikibase.getLabel(id)
	end
	if label then
		return mw.text.nowiki(label), true
	else
		return id, false
	end
end


-------------------------------------------------------------------------------
-- linkedItem takes an entity-id and returns a string, linked if possible.
-- This is the handler for "wikibase-item". Preferences:
-- 1. Display linked disambiguated sitelink if it exists
-- 2. Display linked label if it is a redirect
-- 3. TBA: Display an inter-language link for the label if it exists other than in default language
-- 4. Display unlinked label if it exists
-- 5. Display entity-id for now to indicate a label could be provided
-- dtxt is text to be used instead of label, or nil.
-- shortname is boolean switch to use P1813 (short name) instead of label if true.
-- lang is the current language code.
-------------------------------------------------------------------------------
-- Dependencies: labelOrId(); donotlink[]
-------------------------------------------------------------------------------
local linkedItem = function(id, lprefix, lpostfix, prefix, postfix, dtxt, shortname, lang)
	lprefix = lprefix or "" -- toughen against nil values passed
	lpostfix = lpostfix or ""
	prefix = prefix or ""
	postfix = postfix or ""
	lang = lang or "en" -- fallback to default if missing
	-- see if item might need italics or quotes
	local fmt = ""
	for k, v in ipairs( mw.wikibase.getBestStatements(id, "P31") ) do
		if v.mainsnak.datavalue and formats[v.mainsnak.datavalue.value.id] then
			fmt = formats[v.mainsnak.datavalue.value.id]
			break -- pick the first match
		end
	end
	local disp
	local sitelink = mw.wikibase.getSitelink(id)
	local label, islabel
	if dtxt then
		label, islabel = dtxt, true
	elseif shortname then
		-- see if there is a shortname in our language, and set label to it
		for k, v in ipairs( mw.wikibase.getBestStatements(id, "P1813") ) do
			if v.mainsnak.datavalue.value.language == lang then
				label, islabel = v.mainsnak.datavalue.value.text, true
				break
			end -- test for language match
		end -- loop through values of short name
		-- if we have no label set, then there was no shortname available
		if not islabel then
			label, islabel = labelOrId(id)
			shortname = false
		end
	else
		label, islabel = labelOrId(id)
	end
	if mw.site.siteName ~= "Wikimedia Commons" then
		if sitelink then
			if not (dtxt or shortname) then
				-- strip any namespace or dab from the sitelink
				local pos = sitelink:find(":") or 0
				local slink = sitelink
				if pos &gt; 0 then
					local prefix = sitelink:sub(1,pos-1)
					if mw.site.namespaces[prefix] then -- that prefix is a valid namespace, so remove it
						slink = sitelink:sub(pos+1)
					end
				end
				-- remove stuff after commas or inside parentheses - ie. dabs
				slink = slink:gsub("%s%(.+%)$", ""):gsub(",.+$", "")
				--  use that as label, preserving label case - find("^%u") is true for 1st char uppercase
				if label:find("^%u") then
					label = slink:gsub("^(%l)", string.upper)
				else
					label = slink:gsub("^(%u)", string.lower)
				end
			end
			if donotlink[label] then
				disp = prefix .. fmt .. label .. fmt .. postfix
			else
				disp = "[[" .. lprefix .. sitelink .. lpostfix .. "|" .. prefix .. fmt .. label .. fmt .. postfix .. "]]"
			end
		elseif islabel then
			-- no sitelink, label exists, so check if a redirect with that title exists
			local artitle = mw.title.new(label, 0) -- only nil if label has invalid chars
			if not donotlink[label] and artitle and artitle.redirectTarget then
				-- there's a redirect with the same title as the label, so let's link to that
				disp = "[[".. lprefix .. label .. lpostfix .. "|" .. prefix .. fmt .. label .. fmt .. postfix .. "]]"
			else
				-- either (donotlink is true) or (no sitelink, label exists, not redirect)
				-- so output unlinked label with italics or quotes as needed
				disp = prefix .. fmt .. label .. fmt .. postfix
			end -- test if article title exists as redirect on current Wiki
		else
			-- no sitelink and no label, so return whatever was returned from labelOrId for now
			-- add tracking category [[Category:Articles with missing Wikidata information]]
			disp = prefix .. label .. postfix .. i18n.missinginfocat
		end
	else
		local ccat = mw.wikibase.getBestStatements(id, "P373")[1]
		if ccat and ccat.mainsnak.datavalue then
			ccat = ccat.mainsnak.datavalue.value
			disp = "[[" .. lprefix .. "Category:" .. ccat .. lpostfix .. "|" .. prefix .. label .. postfix .. "]]"
		elseif sitelink then
			-- this asumes that if a sitelink exists, then a label also exists
			disp = "[[" .. lprefix .. sitelink .. lpostfix .. "|" .. prefix .. label .. postfix .. "]]"
		else
			-- no sitelink and no Commons cat, so return label from labelOrId for now
			disp = prefix .. label .. postfix
		end
	end
	return disp
end


-------------------------------------------------------------------------------
-- sourced takes a table representing a statement that may or may not have references
-- it counts how many references are sourced to something not containing the word "wikipedia"
-- it returns a boolean = true if there are any sourced references.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local sourced = function(claim)
	if claim.references then
		for kr, vr in pairs(claim.references) do
			local ref = mw.wikibase.renderSnaks(vr.snaks)
			if not ref:find("Wikipedia") then
				return true
			end
		end
	end
end


-------------------------------------------------------------------------------
-- setRanks takes a flag (parameter passed) that requests the values to return
-- "b[est]" returns preferred if available, otherwise normal
-- "p[referred]" returns preferred
-- "n[ormal]" returns normal
-- "d[eprecated]" returns deprecated
-- multiple values are allowed, e.g. "preferred normal" (which is the default)
-- "best" will override the other flags, and set p and n
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local setRanks = function(rank)
	rank = (rank or ""):lower()
	-- if nothing passed, return preferred and normal
	-- if rank == "" then rank = "p n" end
	local ranks = {}
	for w in string.gmatch(rank, "%a+") do
		w = w:sub(1,1)
		if w == "b" or w == "p" or w == "n" or w == "d" then
			ranks[w] = true
		end
	end
	-- check if "best" is requested or no ranks requested; and if so, set preferred and normal
	if ranks.b or not next(ranks) then
		ranks.p = true
		ranks.n = true
	end
	return ranks
end


-------------------------------------------------------------------------------
-- parseInput processes the Q-id , the blacklist and the whitelist
-- if an input parameter is supplied, it returns that and ends the call.
-- it returns (1) either the qid or nil indicating whether or not the call should continue
-- and (2) a table containing all of the statements for the propertyID and relevant Qid
-- if "best" ranks are requested, it returns those instead of all non-deprecated ranks
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
local parseInput = function(frame, input_parm, property_id)
	-- There may be a local parameter supplied, if it's blank, set it to nil
	input_parm = mw.text.trim(input_parm or "")
	if input_parm == "" then input_parm = nil end

	-- return nil if Wikidata is not available
	if not mw.wikibase then return false, input_parm end

	local args = frame.args

	-- can take a named parameter |qid which is the Wikidata ID for the article.
	-- if it's not supplied, use the id for the current page
	local qid = args.qid or ""
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	-- if there's no Wikidata item for the current page return nil
	if not qid then return false, input_parm end

	-- The blacklist is passed in named parameter |suppressfields
	local blacklist = args.suppressfields or args.spf

	-- The whitelist is passed in named parameter |fetchwikidata
	local whitelist = args.fetchwikidata or args.fwd
	if not whitelist or whitelist == "" then whitelist = "NONE" end

	-- The name of the field that this function is called from is passed in named parameter |name
	local fieldname = args.name or ""

	if blacklist then
		-- The name is compulsory when blacklist is used, so return nil if it is not supplied
		if not fieldname or fieldname == "" then return false, nil end
		-- If this field is on the blacklist, then return nil
		if blacklist:find(fieldname) then return false, nil end
	end

	-- If we got this far then we're not on the blacklist
	-- The blacklist overrides any locally supplied parameter as well
	-- If a non-blank input parameter was supplied return it
	if input_parm then return false, input_parm end

	-- We can filter out non-valid properties
	if property_id:sub(1,1):upper() ~="P" or property_id == "P0" then return false, nil end

	-- Otherwise see if this field is on the whitelist:
	-- needs a bit more logic because find will return its second value = 0 if fieldname is ""
	-- but nil if fieldname not found on whitelist
	local _, found = whitelist:find(fieldname)
	found = ((found or 0) &gt; 0)
	if whitelist ~= 'ALL' and (whitelist:upper() == "NONE" or not found) then
		return false, nil
	end

	-- See what's on Wikidata (the call always returns a table, but it may be empty):
	local props = {}
	if args.reqranks.b then
		props = mw.wikibase.getBestStatements(qid, property_id)
	else
		props = mw.wikibase.getAllStatements(qid, property_id)
	end
	if props[1] then
		return qid, props
	end
	-- no property on Wikidata
	return false, nil
end


-------------------------------------------------------------------------------
-- createicon assembles the "Edit at Wikidata" pen icon.
-- It returns a wikitext string inside a span class="penicon"
-------------------------------------------------------------------------------
-- Dependencies: i18n[];
-------------------------------------------------------------------------------
local createicon = function(langcode, entityID, propertyID)
	local icon = "&amp;nbsp;&lt;span class='penicon'&gt;[["
	-- "&amp;nbsp;&lt;span data-bridge-edit-flow='overwrite' class='penicon'&gt;[[" -&gt; enable Wikidata Bridge
	.. i18n["filespace"]
	.. ":OOjs UI icon edit-ltr-progressive.svg |frameless |text-top |10px |alt="
	.. i18n["editonwikidata"]
	.. "|link=https://www.wikidata.org/wiki/" .. entityID
	.. "?uselang=" .. langcode
	if propertyID then icon = icon .. "#" .. propertyID end
	icon = icon .. "|" .. i18n["editonwikidata"] .. "]]&lt;/span&gt;"
	return icon
end


-------------------------------------------------------------------------------
-- assembleoutput takes the sequence table containing the property values
-- and formats it according to switches given. It returns a string or nil.
-- It needs the entityID and propertyID to create a link in the pen icon.
-------------------------------------------------------------------------------
-- Dependencies: parseParam();
-------------------------------------------------------------------------------
local assembleoutput = function(out, args, entityID, propertyID)

	-- sorted is a boolean passed to enable sorting of the values returned
	-- if nothing or an empty string is passed set it false
	-- if "false" or "no" or "0" is passed set it false
	local sorted = parseParam(args.sorted, false)

	-- noicon is a boolean passed to suppress the trailing "edit at Wikidata" icon
	-- for use when the value is processed further by the infobox
	-- if nothing or an empty string is passed set it false
	-- if "false" or "no" or "0" is passed set it false
	local noic = parseParam(args.noicon, false)

	-- list is the name of a template that a list of multiple values is passed through
	-- examples include "hlist" and "ubl"
	-- setting it to "prose" produces something like "1, 2, 3, and 4"
	local list = args.list or ""

	-- sep is a string that is used to separate multiple returned values
	-- if nothing or an empty string is passed set it to the default
	-- any double-quotes " are stripped out, so that spaces may be passed
	-- e.g. |sep=" - "
	local sepdefault = i18n["list separator"]
	local separator = args.sep or ""
	separator = string.gsub(separator, '"', '')
	if separator == "" then
		separator = sepdefault
	end

	-- collapse is a number that determines the maximum number of returned values
	-- before the output is collapsed.
	-- Zero or not a number result in no collapsing (default becomes 0).
	local collapse = tonumber(args.collapse) or 0

	-- if there's anything to return, then return a list
	-- comma-separated by default, but may be specified by the sep parameter
	-- optionally specify a hlist or ubl or a prose list, etc.
	local strout
	if #out &gt; 0 then
		if sorted then table.sort(out) end
		-- if a pen icon is wanted add it the end of the last value
		if not noic then
			out[#out] = out[#out] .. createicon(args.langobj.code, entityID, propertyID)
		end
		if list == "" then
			strout = table.concat(out, separator)
		elseif list:lower() == "prose" then
			strout = mw.text.listToText( out )
		else
			strout = mw.getCurrentFrame():expandTemplate{title = list, args = out}
		end
		if collapse &gt;0 and #out &gt; collapse then
			strout = collapsediv .. strout .. "&lt;/div&gt;"
		end
	else
		strout = nil -- no items had valid reference
	end
	return strout
end


-------------------------------------------------------------------------------
-- rendersnak takes a table (propval) containing the information stored on one property value
-- and returns the value as a string and its language if monolingual text.
-- It handles data of type:
--		wikibase-item
--		time
--		string, url, commonsMedia, external-id
--		quantity
--		globe-coordinate
--		monolingualtext
-- It also requires linked, the link/pre/postfixes, uabbr, and the arguments passed from frame.
-- The optional filter parameter allows quantities to be be filtered by unit Qid.
-------------------------------------------------------------------------------
-- Dependencies: parseParam(); labelOrId(); i18n[]; dateFormat();
-- roundto(); decimalPrecision(); decimalToDMS(); linkedItem();
-------------------------------------------------------------------------------
local rendersnak = function(propval, args, linked, lpre, lpost, pre, post, uabbr, filter)
	lpre = lpre or ""
	lpost = lpost or ""
	pre = pre or ""
	post = post or ""
	args.lang = args.lang or findLang().code
	-- allow values to display a fixed text instead of label
	local dtxt = args.displaytext or args.dt
	if dtxt == "" then dtxt = nil end
	-- switch to use display of short name (P1813) instead of label
	local shortname = args.shortname or args.sn
	shortname = parseParam(shortname, false)
	local snak = propval.mainsnak or propval
	local dtype = snak.datatype
	local dv = snak.datavalue
	dv = dv and dv.value
	-- value and monolingual text language code returned
	local val, mlt
	if propval.rank and not args.reqranks[propval.rank:sub(1, 1)] then
		-- val is nil: value has a rank that isn't requested
		------------------------------------
	elseif snak.snaktype == "somevalue" then -- value is unknown
		val = i18n["Unknown"]
		------------------------------------
	elseif snak.snaktype == "novalue" then -- value is none
		-- val = "No value" -- don't return anything
		------------------------------------
	elseif dtype == "wikibase-item" then -- data type is a wikibase item:
		-- it's wiki-linked value, so output as link if enabled and possible
		local qnumber = dv.id
		if linked then
			val = linkedItem(qnumber, lpre, lpost, pre, post, dtxt, shortname, args.lang)
		else -- no link wanted so check for display-text, otherwise test for lang code
			local label, islabel
			if dtxt then
				label = dtxt
			else
				label, islabel = labelOrId(qnumber)
				local langlabel = mw.wikibase.getLabelByLang(qnumber, args.lang)
				if langlabel then
					label = mw.text.nowiki( langlabel )
				end
			end
			val = pre .. label .. post
		end -- test for link required
		------------------------------------
	elseif dtype == "time" then -- data type is time:
		-- time is in timestamp format
		-- date precision is integer per mediawiki
		-- output formatting according to preferences (y/dmy/mdy)
		-- BC format as BC or BCE
		-- plaindate is passed to disable looking for "sourcing cirumstances"
		-- or to set the adjectival form
		-- qualifiers (if any) is a nested table or nil
		-- lang is given, or user language, or site language
		--
		-- Here we can check whether args.df has a value
		-- If not, use code from Module:Sandbox/RexxS/Getdateformat to set it from templates like {{Use mdy dates}}
		val = dateFormat(dv.time, dv.precision, args.df, args.bc, args.pd, propval.qualifiers, args.lang, "", dv.calendarmodel)
		------------------------------------
	-- data types which are strings:
	elseif dtype == "commonsMedia" or dtype == "external-id" or dtype == "string" or dtype == "url" then
		-- commonsMedia or external-id or string or url
		-- all have mainsnak.datavalue.value as string
		if (lpre == "" or lpre == ":") and lpost == "" then
			-- don't link if no linkpre/postfix or linkprefix is just ":"
			val = pre .. dv .. post
		elseif dtype == "external-id" then
			val = "[" .. lpre .. dv .. lpost .. " " .. pre .. dv .. post .. "]"
		else
			val = "[[" .. lpre .. dv .. lpost .. "|" .. pre .. dv .. post .. "]]"
		end -- check for link requested (i.e. either linkprefix or linkpostfix exists)
		------------------------------------
	-- data types which are quantities:
	elseif dtype == "quantity" then
		-- quantities have mainsnak.datavalue.value.amount and mainsnak.datavalue.value.unit
		-- the unit is of the form http://www.wikidata.org/entity/Q829073
		--
		-- implement a switch to turn on/off numerical formatting later
		local fnum = true
		--
		-- a switch to turn on/off conversions - only for en-wiki
		local conv = parseParam(args.conv or args.convert, false)
		-- if we have conversions, we won't have formatted numbers or scales
		if conv then
			uabbr = true
			fnum = false
			args.scale = "0"
		end
		--
		-- a switch to turn on/off showing units, default is true
		local showunits = parseParam(args.su or args.showunits, true)
		--
		-- convert amount to a number
		local amount = tonumber(dv.amount) or i18n["NaN"]
		--
		-- scale factor for millions, billions, etc.
		local sc = tostring(args.scale or ""):sub(1,1):lower()
		local scale
		if sc == "a" then
			-- automatic scaling
			if amount &gt; 1e15 then
				scale = 12
			elseif amount &gt; 1e12 then
				scale = 9
			elseif amount &gt; 1e9 then
				scale = 6
			elseif amount &gt; 1e6 then
				scale = 3
			else
				scale = 0
			end
		else
			scale = tonumber(args.scale) or 0
			if scale &lt; 0 or scale &gt; 12 then scale = 0 end
			scale = math.floor(scale/3) * 3
		end
		local factor = 10^scale
		amount = amount / factor
		-- ranges:
		local range = ""
		-- check if upper and/or lower bounds are given and significant
		local upb = tonumber(dv.upperBound)
		local lowb = tonumber(dv.lowerBound)
		if upb and lowb then
			-- differences rounded to 2 sig fig:
			local posdif = roundto(upb - amount, 2) / factor
			local negdif = roundto(amount - lowb, 2) / factor
			upb, lowb = amount + posdif, amount - negdif
			-- round scaled numbers to integers or 4 sig fig
			if (scale &gt; 0 or sc == "a") then
				if amount &lt; 1e4 then
					amount = roundto(amount, 4)
				else
					amount = math.floor(amount + 0.5)
				end
			end
			if fnum then amount = args.langobj:formatNum( amount ) end
			if posdif ~= negdif then
				-- non-symmetrical
				range = " +" .. posdif .. " -" .. negdif
			elseif posdif ~= 0 then
				-- symmetrical and non-zero
				range = " ±" .. posdif
			else
				-- otherwise range is zero, so leave it as ""
			end
		else
			-- round scaled numbers to integers or 4 sig fig
			if (scale &gt; 0 or sc == "a") then
				if amount &lt; 1e4 then
					amount = roundto(amount, 4)
				else
					amount = math.floor(amount + 0.5)
				end
			end
			if fnum then amount = args.langobj:formatNum( amount ) end
		end
		-- unit names and symbols:
		-- extract the qid in the form 'Qnnn' from the value.unit url
		-- and then fetch the label from that - or symbol if unitabbr is true
		local unit = ""
		local usep = ""
		local usym = ""
		local unitqid = string.match( dv.unit, "(Q%d+)" )
		if filter and unitqid ~= filter then return nil end
		if unitqid and showunits then
			local uname = mw.wikibase.getLabelByLang(unitqid, args.lang) or ""
			if uname ~= "" then usep, unit = " ", uname end
			if uabbr then
				-- see if there's a unit symbol (P5061)
				local unitsymbols = mw.wikibase.getBestStatements(unitqid, "P5061")
				-- construct fallback table, add local lang and multiple languages
				local fbtbl = mw.language.getFallbacksFor( args.lang )
				table.insert( fbtbl, 1, args.lang )
				table.insert( fbtbl, 1, "mul" )
				local found = false
				for idx1, us in ipairs(unitsymbols) do
					for idx2, fblang in ipairs(fbtbl) do
						if us.mainsnak.datavalue.value.language == fblang then
							usym = us.mainsnak.datavalue.value.text
							found = true
							break
						end
					if found then break end
					end -- loop through fallback table
				end -- loop through values of P5061
				if found then usep, unit = "&amp;nbsp;", usym end
			end
		end
		-- format display:
		if conv then
			if range == "" then
				val = mw.getCurrentFrame():expandTemplate{title = "cvt", args = {amount, unit}}
			else
				val = mw.getCurrentFrame():expandTemplate{title = "cvt", args = {lowb, "to", upb, unit}}
			end
		elseif unit == "$" or unit == "£" then
			val = unit .. amount .. range .. i18n.multipliers[scale]
		else
			val = amount .. range .. i18n.multipliers[scale] .. usep .. unit
		end
		------------------------------------
	-- datatypes which are global coordinates:
	elseif dtype == "globe-coordinate" then
		-- 'display' parameter defaults to "inline, title" *** unused for now ***
		-- local disp = args.display or ""
		-- if disp == "" then disp = "inline, title" end
		--
		-- format parameter switches from deg/min/sec to decimal degrees
		-- default is deg/min/sec -- decimal degrees needs |format = dec
		local form = (args.format or ""):lower():sub(1,3)
		if form ~= "dec" then form = "dms" end -- not needed for now
		--
		-- show parameter allows just the latitude, or just the longitude, or both
		-- to be returned as a signed decimal, ignoring the format parameter.
		local show = (args.show or ""):lower()
		if show ~= "longlat" then show = show:sub(1,3) end
		--
		local lat, long, prec = dv.latitude, dv.longitude, dv.precision
		if show == "lat" then
			val = decimalPrecision(lat, prec)
		elseif show == "lon" then
			val = decimalPrecision(long, prec)
		elseif show == "longlat" then
			val = decimalPrecision(long, prec) .. ", " .. decimalPrecision(lat, prec)
		else
			local ns = "N"
			local ew = "E"
			if lat &lt; 0 then
				ns = "S"
				lat = - lat
			end
			if long &lt; 0 then
				ew = "W"
				long = - long
			end
			if form == "dec" then
				lat = decimalPrecision(lat, prec)
				long = decimalPrecision(long, prec)
				val = lat .. "°" .. ns .. " " .. long ..  "°" .. ew
			else
				local latdeg, latmin, latsec = decimalToDMS(lat, prec)
				local longdeg, longmin, longsec = decimalToDMS(long, prec)

				if latsec == 0 and longsec == 0 then
					if latmin == 0 and longmin == 0 then
						val = latdeg .. "°" .. ns .. " " .. longdeg ..  "°" .. ew
					else
						val = latdeg .. "°" .. latmin .. "′" .. ns .. " "
						val = val .. longdeg .. "°".. longmin .. "′" .. ew
					end
				else
					val = latdeg .. "°" .. latmin .. "′" .. latsec .. "″" .. ns .. " "
					val = val .. longdeg .. "°" .. longmin .. "′" .. longsec .. "″" .. ew
				end
			end
		end
		------------------------------------
	elseif dtype == "monolingualtext" then -- data type is Monolingual text:
		-- has mainsnak.datavalue.value as a table containing language/text pairs
		-- collect all the values in 'out' and languages in 'mlt' and process them later
		val = pre .. dv.text .. post
		mlt = dv.language
		------------------------------------
	else
		-- some other data type so write a specific handler
		val = "unknown data type: " .. dtype
	end -- of datatype/unknown value/sourced check
	return val, mlt
end


-------------------------------------------------------------------------------
-- propertyvalueandquals takes a property object, the arguments passed from frame,
-- and a qualifier propertyID.
-- It returns a sequence (table) of values representing the values of that property
-- and qualifiers that match the qualifierID if supplied.
-------------------------------------------------------------------------------
-- Dependencies: parseParam(); sourced(); labelOrId(); i18n.latestdatequalifier(); format_Date();
-- makeOrdinal(); roundto(); decimalPrecision(); decimalToDMS(); assembleoutput();
-------------------------------------------------------------------------------
local function propertyvalueandquals(objproperty, args, qualID)
	-- needs this style of declaration because it's re-entrant

	-- onlysourced is a boolean passed to return only values sourced to other than Wikipedia
	-- if nothing or an empty string is passed set it true
	local onlysrc = parseParam(args.onlysourced or args.osd, true)

	-- linked is a a boolean that enables the link to a local page via sitelink
	-- if nothing or an empty string is passed set it true
	local linked = parseParam(args.linked, true)

	-- prefix is a string that may be nil, empty (""), or a string of characters
	-- this is prefixed to each value
	-- useful when when multiple values are returned
	-- any double-quotes " are stripped out, so that spaces may be passed
	local prefix = (args.prefix or ""):gsub('"', '')

	-- postfix is a string that may be nil, empty (""), or a string of characters
	-- this is postfixed to each value
	-- useful when when multiple values are returned
	-- any double-quotes " are stripped out, so that spaces may be passed
	local postfix = (args.postfix or ""):gsub('"', '')

	-- linkprefix is a string that may be nil, empty (""), or a string of characters
	-- this creates a link and is then prefixed to each value
	-- useful when when multiple values are returned and indirect links are needed
	-- any double-quotes " are stripped out, so that spaces may be passed
	local lprefix = (args.linkprefix or args.lp or ""):gsub('"', '')

	-- linkpostfix is a string that may be nil, empty (""), or a string of characters
	-- this is postfixed to each value when linking is enabled with lprefix
	-- useful when when multiple values are returned
	-- any double-quotes " are stripped out, so that spaces may be passed
	local lpostfix = (args.linkpostfix or ""):gsub('"', '')

	-- wdlinks is a boolean passed to enable links to Wikidata when no article exists
	-- if nothing or an empty string is passed set it false
	local wdl = parseParam(args.wdlinks or args.wdl, false)

	-- unitabbr is a boolean passed to enable unit abbreviations for common units
	-- if nothing or an empty string is passed set it false
	local uabbr = parseParam(args.unitabbr or args.uabbr, false)

	-- qualsonly is a boolean passed to return just the qualifiers
	-- if nothing or an empty string is passed set it false
	local qualsonly = parseParam(args.qualsonly or args.qo, false)

	-- maxvals is a string that may be nil, empty (""), or a number
	-- this determines how many items may be returned when multiple values are available
	-- setting it = 1 is useful where the returned string is used within another call, e.g. image
	local maxvals = tonumber(args.maxvals) or 0

	-- pd (plain date) is a string: yes/true/1 | no/false/0 | adj
	-- to disable/enable "sourcing cirumstances" or use adjectival form for the plain date
	local pd = args.plaindate or args.pd or "no"
	args.pd = pd

	-- allow qualifiers to have a different date format; default to year
	args.qdf = args.qdf or args.qualifierdateformat or args.df or "y"

	local lang = args.lang or findlang().code
	-- all proper values of a Wikidata property will be the same type as the first
	-- qualifiers don't have a mainsnak, properties do

	local datatype = objproperty[1].datatype or objproperty[1].mainsnak.datatype
	-- out[] holds the values for this property
	-- mlt[] holds the language code if the datatype is monolingual text
	local out = {}
	local mlt = {}
	for k, v in ipairs(objproperty) do
		local hasvalue = true
		if (onlysrc and not sourced(v)) then
			-- no value: it isn't sourced when onlysourced=true
			hasvalue = false
		else
			local val, lcode = rendersnak(v, args, linked, lprefix, lpostfix, prefix, postfix, uabbr)
			if not val then
				hasvalue = false -- rank doesn't match
			elseif qualsonly and qualID then
				-- suppress value returned: only qualifiers are requested
			else
				out[#out+1], mlt[#out+1] = val, lcode
			end
		end

		-- See if qualifiers are to be returned:
		local snak = v.mainsnak or v
		if hasvalue and v.qualifiers and qualID and snak.snaktype~="novalue" then
			local qsep = (args.qsep or ""):gsub('"', '')
			local qargs = {
				["osd"]         = "false",
				["linked"]      = tostring(linked),
				["prefix"]      = args.qprefix,
				["postfix"]     = args.qpostfix,
				["linkprefix"]  = args.qlinkprefix or args.qlp,
				["linkpostfix"] = args.qlinkpostfix,
				["wdl"]         = "false",
				["unitabbr"]    = tostring(uabbr),
				["maxvals"]     = 0,
				["sorted"]      = tostring(args.qsorted),
				["noicon"]      = "true",
				["list"]        = args.qlist,
				["sep"]         = qsep,
				["langobj"]     = args.langobj,
				["lang"]        = args.langobj.code,
				["df"]          = args.qdf
			}
			local qlist = {}
			local t1, t2 = "", ""
			-- see if we want all qualifiers
			if qualID == "ALL" then
				if v["qualifiers-order"] then
					-- the values in the order table are the keys for the qualifiers table:
					for k1, v1 in ipairs(v["qualifiers-order"]) do
						if v1 == "P1326" then
							local ts = v.qualifiers[v1][1].datavalue.value.time
							local dp = v.qualifiers[v1][1].datavalue.value.precision
							qlist[#qlist + 1] = dateFormat(ts, dp, args.qdf, args.bc, pd, "", lang, "before")
						elseif v1 == "P1319" then
							local ts = v.qualifiers[v1][1].datavalue.value.time
							local dp = v.qualifiers[v1][1].datavalue.value.precision
							qlist[#qlist + 1] = dateFormat(ts, dp, args.qdf, args.bc, pd, "", lang, "after")
						else
							local q = assembleoutput(propertyvalueandquals(v.qualifiers[v1], qargs), qargs)
							-- we already deal with circa via 'sourcing circumstances' if the datatype was time
							-- circa may be either linked or unlinked *** internationalise later ***
							if datatype ~= "time" or q ~= "circa" and not (type(q) == "string" and q:find("circa]]")) then
								qlist[#qlist + 1] = q
							end
						end
					end
				else
					-- are there cases where qualifiers-order doesn't exist?
					local ql = propertyvalueandquals(v.qualifiers, qargs)
					for k1, v1 in ipairs(ql) do
						-- we already deal with circa via 'sourcing circumstances' if the datatype was time
						-- circa may be either linked or unlinked *** internationalise later ***
						if datatype ~= "time" or v1 ~= "circa" and not (type(v1) == "string" and v1:find("circa]]")) then
							qlist[#qlist + 1] = v1
						end
					end
				end
			-- see if we want date/range
			elseif qualID == "DATES" then
				qargs.maxvals = 1
				for k1, v1 in pairs(v.qualifiers) do
					if k1 == "P580" then -- P580 is "start time"
						t1 = propertyvalueandquals(v1, qargs)[1] or ""
					elseif k1 == "P582" then -- P582 is "end time"
						t2 = propertyvalueandquals(v1, qargs)[1] or ""
					end
				end
			-- otherwise process qualID as a list of qualifiers
			else
				for q in mw.text.gsplit(qualID, "%p") do -- split at punctuation and iterate
					q = mw.text.trim(q):upper() -- remove whitespace and capitalise
					if q == "P1326" then
						-- latest date, so supply 'before' as well. Assume one date value.
						for k1, v1 in pairs(v.qualifiers) do
							if k1 == "P1326" then
								local ts = v1[1].datavalue.value.time
								local dp = v1[1].datavalue.value.precision
								qlist[#qlist + 1] = dateFormat(ts, dp, args.qdf, args.bc, pd, "", lang, "before")
							end
						end
					else
						for k1, v1 in pairs(v.qualifiers) do
							if k1 == q then
								local ql = propertyvalueandquals(v1, qargs)
								for k2, v2 in ipairs(ql) do
									qlist[#qlist + 1] = v2
								end
							end
						end
					end
				end -- of loop through list of qualifiers in qualID
			end -- of testing for what qualID is
			local t = t1 .. t2
			-- *** internationalise date separators later ***
			local dsep = "&amp;ndash;"
			if t:find("%s") or t:find("&amp;nbsp;") then dsep = " &amp;ndash; " end
			if #qlist &gt; 0 then
				local qstr = assembleoutput(qlist, qargs)
				if qualsonly then
					out[#out+1] = qstr
				else
					out[#out] = out[#out] .. " (" .. qstr .. ")"
				end
			elseif t &gt; "" then
				if qualsonly then
					out[#out+1] = t1 .. dsep .. t2
				else
					out[#out] = out[#out] .. " (" .. t1 .. dsep .. t2 .. ")"
				end
			end
		end -- of test for qualifiers wanted

		if maxvals &gt; 0 and #out &gt;= maxvals then break end
	end -- of for each value loop

	-- we need to pick one value to return if the datatype was "monolingualtext"
	-- if there's only one value, use that
	-- otherwise look through the fallback languages for a match
	if datatype == "monolingualtext" and #out &gt;1 then
		lang = mw.text.split( lang, '-', true )[1]
		local fbtbl = mw.language.getFallbacksFor( lang )
		table.insert( fbtbl, 1, lang )
		local bestval = ""
		local found = false
		for idx1, lang1 in ipairs(fbtbl) do
			for idx2, lang2 in ipairs(mlt) do
				if (lang1 == lang2) and not found then
					bestval = out[idx2]
					found = true
					break
				end
			end -- loop through values of property
		end -- loop through fallback languages
		if found then
			-- replace output table with a table containing the best value
			out = { bestval }
		else
			-- more than one value and none of them on the list of fallback languages
			-- sod it, just give them the first one
			out = { out[1] }
		end
	end
	return out
end


-------------------------------------------------------------------------------
-- Common code for p.getValueByQual and p.getValueByLang
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced; assembleoutput;
-------------------------------------------------------------------------------
local _getvaluebyqual = function(frame, qualID, checkvalue)

	-- The property ID that will have a qualifier is the first unnamed parameter
	local propertyID = mw.text.trim(frame.args[1] or "")
	if propertyID == "" then return "no property supplied" end

	if qualID == "" then return "no qualifier supplied" end

	-- onlysourced is a boolean passed to return property values
	-- only when property values are sourced to something other than Wikipedia
	-- if nothing or an empty string is passed set it true
	-- if "false" or "no" or 0 is passed set it false
	local onlysrc = parseParam(frame.args.onlysourced or frame.args.osd, true)

	-- set the requested ranks flags
	frame.args.reqranks = setRanks(frame.args.rank)

	-- set a language object and code in the frame.args table
	frame.args.langobj = findLang(frame.args.lang)
	frame.args.lang = frame.args.langobj.code

	local args = frame.args

	-- check for locally supplied parameter in second unnamed parameter
	-- success means no local parameter and the property exists
	local qid, props = parseInput(frame, args[2], propertyID)

	local linked = parseParam(args.linked, true)
	local lpre = (args.linkprefix or args.lp or ""):gsub('"', '')
	local lpost = (args.linkpostfix or ""):gsub('"', '')
	local pre = (args.prefix or ""):gsub('"', '')
	local post = (args.postfix or ""):gsub('"', '')
	local uabbr = parseParam(args.unitabbr or args.uabbr, false)
	local filter = (args.unit or ""):upper()
	if filter == "" then filter = nil end

	if qid then
		local out = {}
		-- Scan through the values of the property
		-- we want something like property is "pronunciation audio (P443)" in propertyID
		-- with a qualifier like "language of work or name (P407)" in qualID
		-- whose value has the required ID, like "British English (Q7979)", in qval
		for k1, v1 in ipairs(props) do
			if v1.mainsnak.snaktype == "value" then
				-- check if it has the right qualifier
				local v1q = v1.qualifiers
				if v1q and v1q[qualID] then
					if onlysrc == false or sourced(v1) then
						-- if we've got this far, we have a (sourced) claim with qualifiers
						-- so see if matches the required value
						-- We'll only deal with wikibase-items and strings for now
						if v1q[qualID][1].datatype == "wikibase-item" then
							if checkvalue(v1q[qualID][1].datavalue.value.id) then
								out[#out + 1] = rendersnak(v1, args, linked, lpre, lpost, pre, post, uabbr, filter)
							end
						elseif v1q[qualID][1].datatype == "string" then
							if checkvalue(v1q[qualID][1].datavalue.value) then
								out[#out + 1] = rendersnak(v1, args, linked, lpre, lpost, pre, post, uabbr, filter)
							end
						end
					end -- of check for sourced
				end -- of check for matching required value and has qualifiers
			else
				return nil
			end -- of check for string
		end -- of loop through values of propertyID
		return assembleoutput(out, frame.args, qid, propertyID)
	else
		return props -- either local parameter or nothing
	end -- of test for success
	return nil
end


-------------------------------------------------------------------------------
-- _location takes Q-id and follows P276 (location)
-- or P131 (located in the administrative territorial entity) or P706 (located on terrain feature)
-- from the initial item to higher level territories/locations until it reaches the highest.
-- An optional boolean, 'first', determines whether the first item is returned (default: false).
-- An optional boolean 'skip' toggles the display to skip to the last item (default: false).
-- It returns a table containing the locations - linked where possible, except for the highest.
-------------------------------------------------------------------------------
-- Dependencies: findLang(); labelOrId(); linkedItem
-------------------------------------------------------------------------------
local _location = function(qid, first, skip)
	first = parseParam(first, false)
	skip = parseParam(skip, false)
	local locs = {"P276", "P131", "P706"}
	local out = {}
	local langcode = findLang():getCode()
	local finished = false
	local count = 0
	local prevqid = "Q0"
	repeat
		local prop
		for i1, v1 in ipairs(locs) do
			local proptbl = mw.wikibase.getBestStatements(qid, v1)
			if #proptbl &gt; 1 then
				-- there is more than one higher location
				local prevP131, prevP131id
				if prevqid ~= "Q0" then
					prevP131 = mw.wikibase.getBestStatements(prevqid, "P131")[1]
					prevP131id = prevP131
					and prevP131.mainsnak.datavalue
					and prevP131.mainsnak.datavalue.value.id
				end
				for i2, v2 in ipairs(proptbl) do
					parttbl = v2.qualifiers and v2.qualifiers.P518
					if parttbl then
						-- this higher location has qualifier 'applies to part' (P518)
						for i3, v3 in ipairs(parttbl) do
							if v3.snaktype == "value" and v3.datavalue.value.id == prevqid then
								-- it has a value equal to the previous location
								prop = proptbl[i2]
								break
							end -- of test for matching last location
						end -- of loop through values of 'applies to part'
					else
						-- there's no qualifier 'applies to part' (P518)
						-- so check if the previous location had a P131 that matches this alternate
						if qid == prevP131id then
								prop = proptbl[i2]
								break
						end -- of test for matching previous P131
					end
				end -- of loop through parent locations
				-- fallback to second value if match not found
				prop = prop or proptbl[2]
			elseif #proptbl &gt; 0 then
				prop = proptbl[1]
			end
			if prop then break end
		end

		-- check if it's an instance of (P31) a country (Q6256) and terminate the chain if it is
		local inst = mw.wikibase.getAllStatements(qid, "P31")
		if #inst &gt; 0 then
			for k, v in ipairs(inst) do
				local instid = v.mainsnak.datavalue.value.id
				-- stop if it's a country (or a country within the United Kingdom if skip is true)
				if instid == "Q6256" or (skip and instid == "Q3336843") then
					prop = nil -- this will ensure this is treated as top-level location
					break
				end
			end
		end

		-- get the name of this location and update qid to point to the parent location
		if prop and prop.mainsnak.datavalue then
			if not skip or count == 0 then
				out[#out+1] = linkedItem(qid, ":", "", "", "") -- get a linked value if we can
			end
			qid, prevqid = prop.mainsnak.datavalue.value.id, qid
		else
			-- This is top-level location, so get short name except when this is the first item
			-- Use full label if there's no short name or this is the first item
			local prop1813 = mw.wikibase.getAllStatements(qid, "P1813")
			-- if there's a short name and this isn't the only item
			if prop1813[1] and (#out &gt; 0)then
				local shortname
				-- short name is monolingual text, so look for match to the local language
				-- choose the shortest 'short name' in that language
				for k, v in pairs(prop1813) do
					if v.mainsnak.datavalue.value.language == langcode then
						local name = v.mainsnak.datavalue.value.text
						if (not shortname) or (#name &lt; #shortname) then
							shortname = name
						end
					end
				end
				-- add the shortname if one is found, fallback to the label
				-- but skip it if it's "USA"
				if shortname ~= "USA" then
					out[#out+1] = shortname or labelOrId(qid)
				else
					if skip then out[#out+1] = "US" end
				end
			else
				-- no shortname, so just add the label
				local loc = labelOrId(qid)
				-- exceptions go here:
				if loc == "United States of America" then
					out[#out+1] = "United States"
				else
					out[#out+1] = loc
				end
			end
			finished = true
		end
		count = count + 1
	until finished or count &gt;= 10 -- limit to 10 levels to avoid infinite loops

	-- remove the first location if not required
	if not first then table.remove(out, 1) end

	-- we might have duplicate text for consecutive locations, so remove them
	if #out &gt; 2 then
		local plain = {}
		for i, v in ipairs(out) do
			-- strip any links
			plain[i] = v:gsub("^%[%[[^|]*|", ""):gsub("]]$", "")
		end
		local idx = 2
		repeat
			if plain[idx] == plain[idx-1] then
				-- duplicate found
				local removeidx = 0
				if (plain[idx] ~= out[idx]) and (plain[idx-1] == out[idx-1]) then
					-- only second one is linked, so drop the first
					removeidx = idx - 1
				elseif (plain[idx] == out[idx]) and (plain[idx-1] ~= out[idx-1]) then
					-- only first one is linked, so drop the second
					removeidx = idx
				else
					-- pick one
					removeidx = idx - (os.time()%2)
				end
				table.remove(out, removeidx)
				table.remove(plain, removeidx)
			else
				idx = idx +1
			end
		until idx &gt;= #out
	end
	return out
end


-------------------------------------------------------------------------------
-- _getsumofparts scans the property 'has part' (P527) for values matching a list.
-- The list (args.vlist) consists of a string of Qids separated by spaces or any usual punctuation.
-- If the matched values have a qualifer 'quantity' (P1114), those quantites are summed.
-- The sum is returned as a number (i.e. 0 if none)
-- a table of arguments is supplied implementing the usual parameters.
-------------------------------------------------------------------------------
-- Dependencies: setRanks; parseParam; parseInput; sourced; assembleoutput;
-------------------------------------------------------------------------------
local _getsumofparts = function(args)
	local vallist = (args.vlist or ""):upper()
	if vallist == "" then return end
	args.reqranks = setRanks(args.rank)
	local f = {}
	f.args = args
	local qid, props = parseInput(f, "", "P527")
	if not qid then return 0 end
	local onlysrc = parseParam(args.onlysourced or args.osd, true)
	local sum = 0
	for k1, v1 in ipairs(props) do
		if (onlysrc == false or sourced(v1))
			and v1.mainsnak.snaktype == "value"
			and v1.mainsnak.datavalue.type == "wikibase-entityid"
			and vallist:match( v1.mainsnak.datavalue.value.id )
			and v1.qualifiers
			then
			local quals = v1.qualifiers["P1114"]
			if quals then
				for k2, v2 in ipairs(quals) do
					sum = sum + v2.datavalue.value.amount
				end
			end
		end
	end
	return sum
end


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Public functions
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- _getValue makes the functionality of getValue available to other modules
-------------------------------------------------------------------------------
-- Dependencies: setRanks; parseInput; propertyvalueandquals; assembleoutput; parseParam; sourced;
-- labelOrId; i18n.latestdatequalifier; format_Date; makeOrdinal; roundto; decimalPrecision; decimalToDMS;
-------------------------------------------------------------------------------
p._getValue = function(args)
	-- parameter sets for commonly used groups of parameters
	local paraset = tonumber(args.ps or args.parameterset or 0)
	if paraset == 1 then
		-- a common setting
		args.rank = "best"
		args.fetchwikidata = "ALL"
		args.onlysourced = "no"
		args.noicon = "true"
	elseif paraset == 2 then
		-- equivalent to raw
		args.rank = "best"
		args.fetchwikidata = "ALL"
		args.onlysourced = "no"
		args.noicon = "true"
		args.linked = "no"
		args.pd = "true"
	elseif paraset == 3 then
		-- third set goes here
	end

	-- implement eid parameter
	local eid = args.eid
	if eid == "" then
		return nil
	elseif eid then
		args.qid = eid
	end

	local propertyID = mw.text.trim(args[1] or "")

	args.reqranks = setRanks(args.rank)

	local f = {}
	f.args = args
	local entityid, props = parseInput(f, f.args[2], propertyID)

	if not entityid then
		return props -- either the input parameter or nothing
	end

	-- qual is a string containing the property ID of the qualifier(s) to be returned
	-- if qual == "ALL" then all qualifiers returned
	-- if qual == "DATES" then qualifiers P580 (start time) and P582 (end time) returned
	-- if nothing or an empty string is passed set it nil -&gt; no qualifiers returned
	local qualID = mw.text.trim(args.qual or ""):upper()
	if qualID == "" then qualID = nil end

	-- set a language object and code in the args table
	args.langobj = findLang(args.lang)
	args.lang = args.langobj.code

	-- table 'out' stores the return value(s):
	local out = propertyvalueandquals(props, args, qualID)

	-- format the table of values and return it as a string:
	return assembleoutput(out, args, entityid, propertyID)
end


-------------------------------------------------------------------------------
-- getValue is used to get the value(s) of a property
-- The property ID is passed as the first unnamed parameter and is required.
-- A locally supplied parameter may optionaly be supplied as the second unnamed parameter.
-- The function will now also return qualifiers if parameter qual is supplied
-------------------------------------------------------------------------------
-- Dependencies: _getValue; setRanks; parseInput; propertyvalueandquals; assembleoutput; parseParam; sourced;
-- labelOrId; i18n.latestdatequalifier; format_Date; makeOrdinal; roundto; decimalPrecision; decimalToDMS;
-------------------------------------------------------------------------------
p.getValue = function(frame)
	local args= frame.args
	if not args[1] then
		args = frame:getParent().args
		if not args[1] then return i18n.errors["No property supplied"] end
	end

	return p._getValue(args)
end


-------------------------------------------------------------------------------
-- getPreferredValue is used to get a value,
-- (or a comma separated list of them if multiple values exist).
-- If preferred ranks are set, it will return those values, otherwise values with normal ranks
-- now redundant to getValue with |rank=best
-------------------------------------------------------------------------------
-- Dependencies: p.getValue; setRanks; parseInput; propertyvalueandquals; assembleoutput;
-- parseParam; sourced; labelOrId; i18n.latestdatequalifier; format_Date;
-- makeOrdinal; roundto; decimalPrecision; decimalToDMS;
-------------------------------------------------------------------------------
p.getPreferredValue = function(frame)
	frame.args.rank = "best"
	return p.getValue(frame)
end


-------------------------------------------------------------------------------
-- getCoords is used to get coordinates for display in an infobox
-- whitelist and blacklist are implemented
-- optional 'display' parameter is allowed, defaults to "inline, title"
-------------------------------------------------------------------------------
-- Dependencies: setRanks(); parseInput(); decimalPrecision();
-------------------------------------------------------------------------------
p.getCoords = function(frame)
	local propertyID = "P625"

	-- if there is a 'display' parameter supplied, use it
	-- otherwise default to "inline, title"
	local disp = frame.args.display or ""
	if disp == "" then
		disp = "inline, title"
	end

	-- there may be a format parameter to switch from deg/min/sec to decimal degrees
	-- default is deg/min/sec
	-- decimal degrees needs |format = dec
	local form = (frame.args.format or ""):lower():sub(1,3)
	if form ~= "dec" then
		form = "dms"
	end

	-- just deal with best values
	frame.args.reqranks = setRanks("best")

	local qid, props = parseInput(frame, frame.args[1], propertyID)
	if not qid then
		return props -- either local parameter or nothing
	else
		local dv = props[1].mainsnak.datavalue.value
		local lat, long, prec = dv.latitude, dv.longitude, dv.precision
		lat = decimalPrecision(lat, prec)
		long = decimalPrecision(long, prec)
		local lat_long = { lat, long }
		lat_long["display"] = disp
		lat_long["format"] = form
		-- invoke template Coord with the values stored in the table
		return frame:expandTemplate{title = 'coord', args = lat_long}
	end
end


-------------------------------------------------------------------------------
-- getQualifierValue is used to get a formatted value of a qualifier
--
-- The call needs:	a property (the unnamed parameter or 1=)
-- 					a target value for that property (pval=)
--					a qualifier for that target value (qual=)
-- The usual whitelisting and blacklisting of the property is implemented
-- The boolean onlysourced= parameter can be set to return nothing
-- when the property is unsourced (or only sourced to Wikipedia)
-------------------------------------------------------------------------------
-- Dependencies: parseParam(); setRanks(); parseInput(); sourced();
-- propertyvalueandquals(); assembleoutput();
-- labelOrId(); i18n.latestdatequalifier(); format_Date();
-- findLang(); makeOrdinal(); roundto(); decimalPrecision(); decimalToDMS();
-------------------------------------------------------------------------------
p.getQualifierValue = function(frame)

	-- The property ID that will have a qualifier is the first unnamed parameter
	local propertyID = mw.text.trim(frame.args[1] or "")

	-- The value of the property we want to match whose qualifier value is to be returned
	-- is passed in named parameter |pval=
	local propvalue = frame.args.pval

	-- The property ID of the qualifier
	-- whose value is to be returned is passed in named parameter |qual=
	local qualifierID = frame.args.qual

	-- onlysourced is a boolean passed to return qualifiers
	-- only when property values are sourced to something other than Wikipedia
	-- if nothing or an empty string is passed set it true
	-- if "false" or "no" or 0 is passed set it false
	local onlysrc = parseParam(frame.args.onlysourced or frame.args.osd, true)

	-- set a language object and language code in the frame.args table
	frame.args.langobj = findLang(frame.args.lang)
	frame.args.lang = frame.args.langobj.code

	-- set the requested ranks flags
	frame.args.reqranks = setRanks(frame.args.rank)

	-- check for locally supplied parameter in second unnamed parameter
	-- success means no local parameter and the property exists
	local qid, props = parseInput(frame, frame.args[2], propertyID)
	if qid then
		local out = {}
		-- Scan through the values of the property
		-- we want something like property is P793, significant event (in propertyID)
		-- whose value is something like Q385378, construction (in propvalue)
		-- then we can return the value(s) of a qualifier such as P580, start time (in qualifierID)
		for k1, v1 in pairs(props) do
			if v1.mainsnak.snaktype == "value" and v1.mainsnak.datavalue.type == "wikibase-entityid" then
				-- It's a wiki-linked value, so check if it's the target (in propvalue)
				-- and if it has qualifiers
				if v1.mainsnak.datavalue.value.id == propvalue and v1.qualifiers then
					if onlysrc == false or sourced(v1) then
						-- if we've got this far, we have a (sourced) claim with qualifiers
						-- which matches the target, so find the value(s) of the qualifier we want
						local quals = v1.qualifiers[qualifierID]
						if quals then
							-- can't reference qualifer, so set onlysourced = "no" (not boolean)
							local qargs = frame.args
							qargs.onlysourced = "no"
							local vals = propertyvalueandquals(quals, qargs, qid)
							for k, v in ipairs(vals) do
								out[#out + 1] = v
							end
						end
					end -- of check for sourced
				end -- of check for matching required value and has qualifiers
			end -- of check for wikibase entity
		end -- of loop through values of propertyID
		return assembleoutput(out, frame.args, qid, propertyID)
	else
		return props -- either local parameter or nothing
	end -- of test for success
	return nil
end


-------------------------------------------------------------------------------
-- getSumOfParts scans the property 'has part' (P527) for values matching a list.
-- The list is passed in parameter vlist.
-- It consists of a string of Qids separated by spaces or any usual punctuation.
-- If the matched values have a qualifier 'quantity' (P1114), those quantities are summed.
-- The sum is returned as a number or nothing if zero.
-------------------------------------------------------------------------------
-- Dependencies: _getsumofparts;
-------------------------------------------------------------------------------
p.getSumOfParts = function(frame)
	local sum = _getsumofparts(frame.args)
	if sum == 0 then return end
	return sum
end


-------------------------------------------------------------------------------
-- getValueByQual gets the value of a property which has a qualifier with a given entity value
-- The call needs:
--					a property ID (the unnamed parameter or 1=Pxxx)
--					the ID of a qualifier for that property (qualID=Pyyy)
--					either the Wikibase-entity ID of a value for that qualifier (qvalue=Qzzz)
--					or a string value for that qualifier (qvalue=abc123)
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented
-------------------------------------------------------------------------------
-- Dependencies: _getvaluebyqual; parseParam; setRanks; parseInput; sourced;
-- assembleoutput;
-------------------------------------------------------------------------------
p.getValueByQual = function(frame)
	local qualID = frame.args.qualID
	-- The Q-id of the value for the qualifier we want to match is in named parameter |qvalue=
	local qval = frame.args.qvalue or ""
	if qval == "" then return "no qualifier value supplied" end
	local function checkQID(id)
		return id == qval
	end
	return _getvaluebyqual(frame, qualID, checkQID)
end


-------------------------------------------------------------------------------
-- getValueByLang gets the value of a property which has a qualifier P407
-- ("language of work or name") whose value has the given language code
-- The call needs:
--					a property ID (the unnamed parameter or 1=Pxxx)
--					the MediaWiki language code to match the language (lang=xx[-yy])
--					(if no code is supplied, it uses the default language)
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented
-------------------------------------------------------------------------------
-- Dependencies: _getvaluebyqual; parseParam; setRanks; parseInput; sourced; assembleoutput;
-------------------------------------------------------------------------------
p.getValueByLang = function(frame)
	-- The language code for the qualifier we want to match is in named parameter |lang=
	local langcode = findLang(frame.args.lang).code
	local function checkLanguage(id)
		-- id should represent a language like "British English (Q7979)"
		-- it should have string property "Wikimedia language code (P424)"
		-- qlcode will be a table:
		local qlcode = mw.wikibase.getBestStatements(id, "P424")
		if (#qlcode &gt; 0) and (qlcode[1].mainsnak.datavalue.value == langcode) then
			return true
		end
	end
	return _getvaluebyqual(frame, "P407", checkLanguage)
end


-------------------------------------------------------------------------------
-- getValueByRefSource gets the value of a property which has a reference "stated in" (P248)
-- whose value has the given entity-ID.
-- The call needs:
--					a property ID (the unnamed parameter or 1=Pxxx)
--					the entity ID of a value to match where the reference is stated in (match=Qzzz)
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced; propertyvalueandquals assembleoutput;
-------------------------------------------------------------------------------
p.getValueByRefSource = function(frame)
	-- The property ID that we want to check is the first unnamed parameter
	local propertyID = mw.text.trim(frame.args[1] or ""):upper()
	if propertyID == "" then return "no property supplied" end

	-- The Q-id of the value we want to match is in named parameter |qvalue=
	local qval = (frame.args.match or ""):upper()
	if qval == "" then qval = "Q21540096" end

	local unit = (frame.args.unit or ""):upper()
	if unit == "" then unit = "Q4917" end

	local onlysrc = parseParam(frame.args.onlysourced or frame.args.osd, true)

	-- set the requested ranks flags
	frame.args.reqranks = setRanks(frame.args.rank)

	-- set a language object and code in the frame.args table
	frame.args.langobj = findLang(frame.args.lang)
	frame.args.lang = frame.args.langobj.code

	local linked = parseParam(frame.args.linked, true)

	local uabbr = parseParam(frame.args.uabbr or frame.args.unitabbr, false)

	-- qid not nil means no local parameter and the property exists
	local qid, props = parseInput(frame, frame.args[2], propertyID)

	if qid then
		local out = {}
		local mlt= {}
		for k1, v1 in ipairs(props) do
			if onlysrc == false or sourced(v1) then
				if v1.references then
					for k2, v2 in ipairs(v1.references) do
						if v2.snaks.P248 then
							for k3, v3 in ipairs(v2.snaks.P248) do
								if v3.datavalue.value.id == qval then
									out[#out+1], mlt[#out+1] = rendersnak(v1, frame.args, linked, "", "", "", "", uabbr, unit)
									if not mlt[#out] then
										-- we only need one match per property value
										-- unless datatype was monolingual text
										break
									end
								end -- of test for match
							end -- of loop through values "stated in"
						end -- of test that "stated in" exists
					end -- of loop through references
				end -- of test that references exist
			end -- of test for sourced
		end -- of loop through values of propertyID
		if #mlt &gt; 0 then
			local langcode = frame.args.lang
			langcode = mw.text.split( langcode, '-', true )[1]
			local fbtbl = mw.language.getFallbacksFor( langcode )
			table.insert( fbtbl, 1, langcode )
			local bestval = ""
			local found = false
			for idx1, lang1 in ipairs(fbtbl) do
				for idx2, lang2 in ipairs(mlt) do
					if (lang1 == lang2) and not found then
						bestval = out[idx2]
						found = true
						break
					end
				end -- loop through values of property
			end -- loop through fallback languages
			if found then
				-- replace output table with a table containing the best value
				out = { bestval }
			else
				-- more than one value and none of them on the list of fallback languages
				-- sod it, just give them the first one
				out = { out[1] }
			end
		end
		return assembleoutput(out, frame.args, qid, propertyID)
	else
		return props -- no property or local parameter supplied
	end -- of test for success
end


-------------------------------------------------------------------------------
-- getPropertyIDs takes most of the usual parameters.
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented.
-- It returns the Entity-IDs (Qids) of the values of a property if it is a Wikibase-Entity.
-- Otherwise it returns nothing.
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced; propertyvalueandquals assembleoutput;
-------------------------------------------------------------------------------
p.getPropertyIDs = function(frame)
	local args = frame.args
	args.reqranks = setRanks(args.rank)
	args.langobj = findLang(args.lang)
	args.lang = args.langobj.code
	-- change default for noicon to true
	args.noicon = tostring(parseParam(args.noicon or "", true))
	local f = {}
	f.args = args
	local pid = mw.text.trim(args[1] or "")

	-- get the qid and table of claims for the property, or nothing and the local value passed
	local qid, props = parseInput(f, args[2], pid)
	if not qid then return props end
	if not props[1] then return nil end
	local onlysrc = parseParam(args.onlysourced or args.osd, true)
	local maxvals = tonumber(args.maxvals) or 0

	out = {}
	for i, v in ipairs(props) do
		local snak = v.mainsnak
		if ( snak.datatype == "wikibase-item" )
			and ( v.rank and args.reqranks[v.rank:sub(1, 1)] )
			and ( snak.snaktype == "value" )
			and ( sourced(v) or not onlysrc )
			then
			out[#out+1] = snak.datavalue.value.id
		end
		if maxvals &gt; 0 and #out &gt;= maxvals then break end
	end

	return assembleoutput(out, args, qid, pid)
end


-------------------------------------------------------------------------------
-- getPropOfProp takes two propertyIDs: prop1 and prop2 (as well as the usual parameters)
-- If the value(s) of prop1 are of type "wikibase-item" then it returns the value(s) of prop2
-- of each of those wikibase-items.
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced; propertyvalueandquals assembleoutput;
-------------------------------------------------------------------------------
p.getPropOfProp = function(frame)
	frame.args.reqranks = setRanks(frame.args.rank)
	frame.args.langobj = findLang(frame.args.lang)
	frame.args.lang = frame.args.langobj.code
	local args = frame.args
	local pid1 = args.prop1 or args.pid1 or ""
	local pid2 = args.prop2 or args.pid2 or ""
	local localval = mw.text.trim(args[1] or "")
	if pid1 == "" or pid2 == "" then return nil end
	local qid1, statements1 = parseInput(frame, localval, pid1)
	if not qid1 then return localval end
	local onlysrc = parseParam(args.onlysourced or args.osd, true)
	local maxvals = tonumber(args.maxvals) or 0
	local qualID = mw.text.trim(args.qual or ""):upper()
	if qualID == "" then qualID = nil end
	local out = {}
	for k, v in ipairs(statements1) do
		if not onlysrc or sourced(v) then
			local snak = v.mainsnak
			if snak.datatype == "wikibase-item" and snak.snaktype == "value" then
				local qid2 = snak.datavalue.value.id
				local statements2 = {}
				if args.reqranks.b then
					statements2 = mw.wikibase.getBestStatements(qid2, pid2)
				else
					statements2 = mw.wikibase.getAllStatements(qid2, pid2)
				end
				if statements2[1] then
					local out2 = propertyvalueandquals(statements2, args, qualID)
					out[#out+1] = assembleoutput(out2, args, qid2, pid2)
				end
			end -- of test for valid property1 value
		end -- of test for sourced
		if maxvals &gt; 0 and #out &gt;= maxvals then break end
	end -- of loop through values of property1
	return assembleoutput(out, args, qid1, pid1)
end


-------------------------------------------------------------------------------
-- getAwardCat takes most of the usual parameters. If the item has values of P166 (award received),
-- then it examines each of those awards for P2517 (category for recipients of this award).
-- If it exists, it returns the corresponding category,
-- with the item's P734 (family name) as sort key, or no sort key if there is no family name.
-- The sort key may be overridden by the parameter |sortkey (alias |sk).
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced; propertyvalueandquals assembleoutput;
-------------------------------------------------------------------------------
p.getAwardCat = function(frame)
	frame.args.reqranks = setRanks(frame.args.rank)
	frame.args.langobj = findLang(frame.args.lang)
	frame.args.lang = frame.args.langobj.code
	local args = frame.args
	args.sep = " "
	local pid1 = args.prop1 or "P166"
	local pid2 = args.prop2 or "P2517"
	if pid1 == "" or pid2 == "" then return nil end
	-- locally supplied value:
	local localval = mw.text.trim(args[1] or "")
	local qid1, statements1 = parseInput(frame, localval, pid1)
	if not qid1 then return localval end
	-- linkprefix (strip quotes)
	local lp = (args.linkprefix or args.lp or ""):gsub('"', '')
	-- sort key (strip quotes, hyphens and periods):
	local sk = (args.sortkey or args.sk or ""):gsub('["-.]', '')
	-- family name:
	local famname = ""
	if sk == "" then
		local p734 = mw.wikibase.getBestStatements(qid1, "P734")[1]
		local p734id = p734 and p734.mainsnak.snaktype == "value" and p734.mainsnak.datavalue.value.id or ""
		famname = mw.wikibase.getSitelink(p734id) or ""
		-- strip namespace and disambigation
		local pos = famname:find(":") or 0
		famname = famname:sub(pos+1):gsub("%s%(.+%)$", "")
		if famname == "" then
			local lbl = mw.wikibase.getLabel(p734id)
			famname = lbl and mw.text.nowiki(lbl) or ""
		end
	end
	local onlysrc = parseParam(args.onlysourced or args.osd, true)
	local maxvals = tonumber(args.maxvals) or 0
	local qualID = mw.text.trim(args.qual or ""):upper()
	if qualID == "" then qualID = nil end
	local out = {}
	for k, v in ipairs(statements1) do
		if not onlysrc or sourced(v) then
			local snak = v.mainsnak
			if snak.datatype == "wikibase-item" and snak.snaktype == "value" then
				local qid2 = snak.datavalue.value.id
				local statements2 = {}
				if args.reqranks.b then
					statements2 = mw.wikibase.getBestStatements(qid2, pid2)
				else
					statements2 = mw.wikibase.getAllStatements(qid2, pid2)
				end
				if statements2[1] and statements2[1].mainsnak.snaktype == "value" then
					local qid3 = statements2[1].mainsnak.datavalue.value.id
					local sitelink = mw.wikibase.getSitelink(qid3)
					-- if there's no local sitelink, create the sitelink from English label
					if not sitelink then
						local lbl = mw.wikibase.getLabelByLang(qid3, "en")
						if lbl then
							if lbl:sub(1,9) == "Category:" then
								sitelink = mw.text.nowiki(lbl)
							else
								sitelink = "Category:" .. mw.text.nowiki(lbl)
							end
						end
					end
					if sitelink then
						if sk ~= "" then
							out[#out+1] = "[[" .. lp .. sitelink .. "|" .. sk .. "]]"
						elseif famname ~= "" then
							out[#out+1] = "[[" .. lp .. sitelink .. "|" .. famname .. "]]"
						else
							out[#out+1] = "[[" .. lp .. sitelink .. "]]"
						end -- of check for sort keys
					end -- of test for sitelink
				end -- of test for category
			end -- of test for wikibase item has a value
		end -- of test for sourced
		if maxvals &gt; 0 and #out &gt;= maxvals then break end
	end -- of loop through values of property1
	return assembleoutput(out, args, qid1, pid1)
end


-------------------------------------------------------------------------------
-- getIntersectCat takes most of the usual parameters.
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented
-- It takes two properties, |prop1 and |prop2 (e.g. occupation and country of citizenship)
-- Each property's value is a wiki-base entity
-- For each value of the first parameter (ranks implemented) it fetches the value's main category
-- and then each value of the second parameter (possibly substituting a simpler description)
-- then it returns all of the categories representing the intersection of those properties,
-- (e.g. Category:Actors from Canada). A joining term may be supplied (e.g. |join=from).
-- The item's P734 (family name) is the sort key, or no sort key if there is no family name.
-- The sort key may be overridden by the parameter |sortkey (alias |sk).
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced; propertyvalueandquals assembleoutput;
-------------------------------------------------------------------------------
p.getIntersectCat = function(frame)
	frame.args.reqranks = setRanks(frame.args.rank)
	frame.args.langobj = findLang(frame.args.lang)
	frame.args.lang = frame.args.langobj.code
	local args = frame.args
	args.sep = " "
	args.linked = "no"
	local pid1 = args.prop1 or "P106"
	local pid2 = args.prop2 or "P27"
	if pid1 == "" or pid2 == "" then return nil end
	local qid, statements1 = parseInput(frame, "", pid1)
	if not qid then return nil end
	local qid, statements2 = parseInput(frame, "", pid2)
	if not qid then return nil end
	-- topics like countries may have different names in categories from their label in Wikidata
	local subs_exists, subs = pcall(mw.loadData, "Module:WikidataIB/subs")
	local join = args.join or ""
	local onlysrc = parseParam(args.onlysourced or args.osd, true)
	local maxvals = tonumber(args.maxvals) or 0
	-- linkprefix (strip quotes)
	local lp = (args.linkprefix or args.lp or ""):gsub('"', '')
	-- sort key (strip quotes, hyphens and periods):
	local sk = (args.sortkey or args.sk or ""):gsub('["-.]', '')
	-- family name:
	local famname = ""
	if sk == "" then
		local p734 = mw.wikibase.getBestStatements(qid, "P734")[1]
		local p734id = p734 and p734.mainsnak.snaktype == "value" and p734.mainsnak.datavalue.value.id or ""
		famname = mw.wikibase.getSitelink(p734id) or ""
		-- strip namespace and disambigation
		local pos = famname:find(":") or 0
		famname = famname:sub(pos+1):gsub("%s%(.+%)$", "")
		if famname == "" then
			local lbl = mw.wikibase.getLabel(p734id)
			famname = lbl and mw.text.nowiki(lbl) or ""
		end
	end
	local cat1 = {}
	for k, v in ipairs(statements1) do
		if not onlysrc or sourced(v) then
			-- get the ID representing the value of the property
			local pvalID = (v.mainsnak.snaktype == "value") and v.mainsnak.datavalue.value.id
			if pvalID then
				-- get the topic's main category (P910) for that entity
				local p910 = mw.wikibase.getBestStatements(pvalID, "P910")[1]
				if p910 and p910.mainsnak.snaktype == "value" then
					local tmcID = p910.mainsnak.datavalue.value.id
					-- use sitelink or the English label for the cat
					local cat = mw.wikibase.getSitelink(tmcID)
					if not cat then
						local lbl = mw.wikibase.getLabelByLang(tmcID, "en")
						if lbl then
							if lbl:sub(1,9) == "Category:" then
								cat = mw.text.nowiki(lbl)
							else
								cat = "Category:" .. mw.text.nowiki(lbl)
							end
						end
					end
					cat1[#cat1+1] = cat
				end -- of test for topic's main category exists
			end -- of test for property has vaild value
		end -- of test for sourced
		if maxvals &gt; 0 and #cat1 &gt;= maxvals then break end
	end
	local cat2 = {}
	for k, v in ipairs(statements2) do
		if not onlysrc or sourced(v) then
			local cat = rendersnak(v, args)
			if subs[cat] then cat = subs[cat] end
			cat2[#cat2+1] = cat
		end
		if maxvals &gt; 0 and #cat2 &gt;= maxvals then break end
	end
	out = {}
	for k1, v1 in ipairs(cat1) do
		for k2, v2 in ipairs(cat2) do
			if sk ~= "" then
				out[#out+1] = "[[" .. lp .. v1 .. " " .. join .. " " .. v2 .. "|" .. sk .. "]]"
			elseif famname ~= "" then
				out[#out+1] = "[[" .. lp .. v1 .. " " .. join .. " " .. v2 .. "|" .. famname .. "]]"
			else
				out[#out+1] = "[[" .. lp .. v1 .. " " .. join .. " " .. v2 .. "]]"
			end -- of check for sort keys
		end
	end
	args.noicon = "true"
	return assembleoutput(out, args, qid, pid1)
end


-------------------------------------------------------------------------------
-- qualsToTable takes most of the usual parameters.
-- The usual whitelisting, blacklisting, onlysourced, etc. are implemented.
-- A qid may be given, and the first unnamed parameter is the property ID, which is of type wikibase item.
-- It takes a list of qualifier property IDs as |quals=
-- For a given qid and property, it creates the rows of an html table,
-- each row being a value of the property (optionally only if the property matches the value in |pval= )
-- each cell being the first value of the qualifier corresponding to the list in |quals
-------------------------------------------------------------------------------
-- Dependencies: parseParam; setRanks; parseInput; sourced;
-------------------------------------------------------------------------------
p.qualsToTable = function(frame)
	local args = frame.args

	local quals = args.quals or ""
	if quals == "" then return "" end

	args.reqranks = setRanks(args.rank)

	local propertyID = mw.text.trim(args[1] or "")
	local f = {}
	f.args = args
	local entityid, props = parseInput(f, "", propertyID)
	if not entityid then return "" end

	args.langobj = findLang(args.lang)
	args.lang = args.langobj.code

	local pval = args.pval or ""

	local qplist = mw.text.split(quals, "%p") -- split at punctuation and make a sequential table
	for i, v in ipairs(qplist) do
		qplist[i] = mw.text.trim(v):upper() -- remove whitespace and capitalise
	end

	local col1 = args.firstcol or ""
	if col1 ~= "" then
		col1 = col1 .. "&lt;/td&gt;&lt;td&gt;"
	end

	local emptycell = args.emptycell or "&amp;nbsp;"

	-- construct a 2-D array of qualifier values in qvals
	local qvals = {}
	for i, v in ipairs(props) do
		local skip = false
		if pval ~= "" then
			local pid = v.mainsnak.datavalue and v.mainsnak.datavalue.value.id
			if pid ~= pval then skip = true end
		end
		if not skip then
			local qval = {}
			local vqualifiers = v.qualifiers or {}
			-- go through list of wanted qualifier properties
			for i1, v1 in ipairs(qplist) do
				-- check for that property ID in the statement's qualifiers
				local qv, qtype
				if vqualifiers[v1] then
					qtype = vqualifiers[v1][1].datatype
					if qtype == "time" then
						if vqualifiers[v1][1].snaktype == "value" then
							qv = mw.wikibase.renderSnak(vqualifiers[v1][1])
							qv = frame:expandTemplate{title="dts", args={qv}}
						else
							qv = "?"
						end
					elseif qtype == "url" then
						qv = mw.wikibase.renderSnak(vqualifiers[v1][1])
						local display = mw.ustring.match( mw.uri.decode(qv, "WIKI"), "([%w ]+)$" )
						if display then
							qv = "[" .. qv .. " " .. display .. "]"
						end
					else
						qv = mw.wikibase.formatValue(vqualifiers[v1][1])
					end
				end
				-- record either the value or a placeholder
				qval[i1] = qv or emptycell
			end -- of loop through list of qualifiers
			-- add the list of qualifier values as a "row" in the main list
			qvals[#qvals+1] = qval
		end
	end -- of for each value loop

	local out = {}
	for i, v in ipairs(qvals) do
		out[i] = "&lt;tr&gt;&lt;td&gt;" .. col1 .. table.concat(qvals[i], "&lt;/td&gt;&lt;td&gt;") .. "&lt;/td&gt;&lt;/tr&gt;"
	end
	return table.concat(out, "\n")
end


-------------------------------------------------------------------------------
-- getGlobe takes an optional qid of a Wikidata entity passed as |qid=
-- otherwise it uses the linked item for the current page.
-- If returns the Qid of the globe used in P625 (coordinate location),
-- or nil if there isn't one.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getGlobe = function(frame)
	local qid = frame.args.qid or frame.args[1] or ""
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	local coords = mw.wikibase.getBestStatements(qid, "P625")[1]
	local globeid
	if coords and coords.mainsnak.snaktype == "value" then
		globeid = coords.mainsnak.datavalue.value.globe:match("(Q%d+)")
	end
	return globeid
end


-------------------------------------------------------------------------------
-- getCommonsLink takes an optional qid of a Wikidata entity passed as |qid=
-- It returns one of the following in order of preference:
-- the Commons sitelink of the linked Wikidata item;
-- the Commons sitelink of the topic's main category of the linked Wikidata item;
-------------------------------------------------------------------------------
-- Dependencies: _getCommonslink(); _getSitelink(); parseParam()
-------------------------------------------------------------------------------
p.getCommonsLink = function(frame)
	local oc = frame.args.onlycat or frame.args.onlycategories
	local fb = parseParam(frame.args.fallback or frame.args.fb, true)
	return _getCommonslink(frame.args.qid, oc, fb)
end


-------------------------------------------------------------------------------
-- getSitelink takes the qid of a Wikidata entity passed as |qid=
-- It takes an optional parameter |wiki= to determine which wiki is to be checked for a sitelink
-- If the parameter is blank, then it uses the local wiki.
-- If there is a sitelink to an article available, it returns the plain text link to the article
-- If there is no sitelink, it returns nil.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getSiteLink = function(frame)
	return _getSitelink(frame.args.qid, frame.args.wiki or mw.text.trim(frame.args[1] or ""))
end


-------------------------------------------------------------------------------
-- getLink has the qid of a Wikidata entity passed as the first unnamed parameter or as |qid=
-- If there is a sitelink to an article on the local Wiki, it returns a link to the article
-- with the Wikidata label as the displayed text.
-- If there is no sitelink, it returns the label as plain text.
-- If there is no label in the local language, it displays the qid instead.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getLink = function(frame)
	local itemID = mw.text.trim(frame.args[1] or frame.args.qid or "")
	if itemID == "" then return end
	local sitelink = mw.wikibase.getSitelink(itemID)
	local label = labelOrId(itemID)
	if sitelink then
		return "[[:" .. sitelink .. "|" .. label .. "]]"
	else
		return label
	end
end


-------------------------------------------------------------------------------
-- getLabel has the qid of a Wikidata entity passed as the first unnamed parameter or as |qid=
-- It returns the Wikidata label for the local language as plain text.
-- If there is no label in the local language, it displays the qid instead.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getLabel = function(frame)
	local itemID = mw.text.trim(frame.args[1] or frame.args.qid or "")
	if itemID == "" then return end
	local lang = frame.args.lang or ""
	if lang == "" then lang = nil end
	local label = labelOrId(itemID, lang)
	return label
end


-------------------------------------------------------------------------------
-- label has the qid of a Wikidata entity passed as the first unnamed parameter or as |qid=
-- if no qid is supplied, it uses the qid associated with the current page.
-- It returns the Wikidata label for the local language as plain text.
-- If there is no label in the local language, it returns nil.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.label = function(frame)
	local qid = mw.text.trim(frame.args[1] or frame.args.qid or "")
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return end
	local lang = frame.args.lang or ""
	if lang == "" then lang = nil end
	local label, success = labelOrId(qid, lang)
	if success then return label end
end


-------------------------------------------------------------------------------
-- getAT (Article Title)
-- has the qid of a Wikidata entity passed as the first unnamed parameter or as |qid=
-- If there is a sitelink to an article on the local Wiki, it returns the sitelink as plain text.
-- If there is no sitelink, it returns nothing.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getAT = function(frame)
	local itemID = mw.text.trim(frame.args[1] or frame.args.qid or "")
	if itemID == "" then return end
	return mw.wikibase.getSitelink(itemID)
end


-------------------------------------------------------------------------------
-- getDescription has the qid of a Wikidata entity passed as |qid=
-- (it defaults to the associated qid of the current article if omitted)
-- and a local parameter passed as the first unnamed parameter.
-- Any local parameter passed (other than "Wikidata" or "none") becomes the return value.
-- It returns the article description for the Wikidata entity if the local parameter is "Wikidata".
-- Nothing is returned if the description doesn't exist or "none" is passed as the local parameter.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getDescription = function(frame)
	local desc = mw.text.trim(frame.args[1] or "")
	local itemID = mw.text.trim(frame.args.qid or "")
	if itemID == "" then itemID = nil end
	if desc:lower() == 'wikidata' then
		return mw.wikibase.getDescription(itemID)
	elseif desc:lower() == 'none' then
		return nil
	else
		return desc
	end
end


-------------------------------------------------------------------------------
-- getAliases has the qid of a Wikidata entity passed as |qid=
-- (it defaults to the associated qid of the current article if omitted)
-- and a local parameter passed as the first unnamed parameter.
-- It implements blacklisting and whitelisting with a field name of "alias" by default.
-- Any local parameter passed becomes the return value.
-- Otherwise it returns the aliases for the Wikidata entity with the usual list options.
-- Nothing is returned if the aliases do not exist.
-------------------------------------------------------------------------------
-- Dependencies: findLang(); assembleoutput()
-------------------------------------------------------------------------------
p.getAliases = function(frame)
	local args = frame.args

	local fieldname = args.name or ""
	if fieldname == "" then fieldname = "alias" end

	local blacklist = args.suppressfields or args.spf or ""
	if blacklist:find(fieldname) then return nil end

	local localval = mw.text.trim(args[1] or "")
	if localval ~= "" then return localval end

	local whitelist = args.fetchwikidata or args.fwd or ""
	if whitelist == "" then whitelist = "NONE" end
	if not (whitelist == 'ALL' or whitelist:find(fieldname)) then return nil end

	local qid = mw.text.trim(args.qid or "")
	if qid == "" then qid = nil end

	local entity = mw.wikibase.getEntity(qid)
	if not entity then return nil end
	local aliases = entity.aliases
	if not aliases then return nil end
	if not qid then qid= mw.wikibase.getEntityIdForCurrentPage() end

	args.langobj = findLang(args.lang)
	local langcode = args.langobj.code
	args.lang = langcode

	local out = {}
	for k1, v1 in pairs(aliases) do
		if v1[1].language == langcode then
			for k1, v2 in ipairs(v1) do
				out[#out+1] = v2.value
			end
			break
		end
	end

	return assembleoutput(out, args, qid)
end


-------------------------------------------------------------------------------
-- pageId returns the page id (entity ID, Qnnn) of the current page
-- returns nothing if the page is not connected to Wikidata
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.pageId = function(frame)
	return mw.wikibase.getEntityIdForCurrentPage()
end


-------------------------------------------------------------------------------
-- formatDate is a wrapper to export the private function format_Date
-------------------------------------------------------------------------------
-- Dependencies: format_Date();
-------------------------------------------------------------------------------
p.formatDate = function(frame)
	return format_Date(frame.args[1], frame.args.df, frame.args.bc)
end


-------------------------------------------------------------------------------
-- location is a wrapper to export the private function _location
-- it takes the entity-id as qid or the first unnamed parameter
-- optional boolean parameter first toggles the display of the first item
-- optional boolean parameter skip toggles the display to skip to the last item
-- parameter debug=&lt;y/n&gt; (default 'n') adds error msg if not a location
-------------------------------------------------------------------------------
-- Dependencies: _location();
-------------------------------------------------------------------------------
p.location = function(frame)
	local debug = (frame.args.debug or ""):sub(1, 1):lower()
	if debug == "" then debug = "n" end
	local qid = mw.text.trim(frame.args.qid or frame.args[1] or ""):upper()
	if qid == "" then qid=mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then
		if debug ~= "n" then
			return i18n.errors["entity-not-found"]
		else
			return nil
		end
	end
	local first = mw.text.trim(frame.args.first or "")
	local skip = mw.text.trim(frame.args.skip or "")
	return table.concat( _location(qid, first, skip), ", " )
end


-------------------------------------------------------------------------------
-- checkBlacklist implements a test to check whether a named field is allowed
-- returns true if the field is not blacklisted (i.e. allowed)
-- returns false if the field is blacklisted (i.e. disallowed)
-- {{#if:{{#invoke:WikidataIB |checkBlacklist |name=Joe |suppressfields=Dave; Joe; Fred}} | not blacklisted | blacklisted}}
-- displays "blacklisted"
-- {{#if:{{#invoke:WikidataIB |checkBlacklist |name=Jim |suppressfields=Dave; Joe; Fred}} | not blacklisted | blacklisted}}
-- displays "not blacklisted"
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.checkBlacklist = function(frame)
	local blacklist = frame.args.suppressfields or frame.args.spf or ""
	local fieldname = frame.args.name or ""
	if blacklist ~= "" and fieldname ~= "" then
		if blacklist:find(fieldname) then
			return false
		else
			return true
		end
	else
		-- one of the fields is missing: let's call that "not on the list"
		return true
	end
end


-------------------------------------------------------------------------------
-- emptyor returns nil if its first unnamed argument is just punctuation, whitespace or html tags
-- otherwise it returns the argument unchanged (including leading/trailing space).
-- If the argument may contain "=", then it must be called explicitly:
-- |1=arg
-- (In that case, leading and trailing spaces are trimmed)
-- It finds use in infoboxes where it can replace tests like:
-- {{#if: {{#invoke:WikidatIB |getvalue |P99 |fwd=ALL}} | &lt;span class="xxx"&gt;{{#invoke:WikidatIB |getvalue |P99 |fwd=ALL}}&lt;/span&gt; | }}
-- with a form that uses just a single call to Wikidata:
-- {{#invoke |WikidataIB |emptyor |1= &lt;span class="xxx"&gt;{{#invoke:WikidataIB |getvalue |P99 |fwd=ALL}}&lt;/span&gt; }}
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.emptyor = function(frame)
	local s = frame.args[1] or ""
	if s == "" then return nil end
	local sx = s:gsub("%s", ""):gsub("&lt;[^&gt;]*&gt;", ""):gsub("%p", "")
	if sx == "" then
		return nil
	else
		return s
	end
end


-------------------------------------------------------------------------------
-- labelorid is a public function to expose the output of labelOrId()
-- Pass the Q-number as |qid= or as an unnamed parameter.
-- It returns the Wikidata label for that entity or the qid if no label exists.
-------------------------------------------------------------------------------
-- Dependencies: labelOrId
-------------------------------------------------------------------------------
p.labelorid = function(frame)
	return (labelOrId(frame.args.qid or frame.args[1]))
end


-------------------------------------------------------------------------------
-- getLang returns the MediaWiki language code of the current content.
-- If optional parameter |style=full, it returns the language name.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getLang = function(frame)
	local style = (frame.args.style or ""):lower()
	local langcode = mw.language.getContentLanguage().code
	if style == "full" then
		return mw.language.fetchLanguageName( langcode )
	end
	return langcode
end


-------------------------------------------------------------------------------
-- getItemLangCode takes a qid parameter (using the current page's qid if blank)
-- If the item for that qid has property country (P17) it looks at the first preferred value
-- If the country has an official language (P37), it looks at the first preferred value
-- If that official language has a language code (P424), it returns the first preferred value
-- Otherwise it returns nothing.
-------------------------------------------------------------------------------
-- Dependencies: _getItemLangCode()
-------------------------------------------------------------------------------
p.getItemLangCode = function(frame)
	return _getItemLangCode(frame.args.qid or frame.args[1])
end


-------------------------------------------------------------------------------
-- findLanguage exports the local findLang() function
-- It takes an optional language code and returns, in order of preference:
-- the code if a known language;
-- the user's language, if set;
-- the server's content language.
-------------------------------------------------------------------------------
-- Dependencies: findLang
-------------------------------------------------------------------------------
p.findLanguage = function(frame)
	return findLang(frame.args.lang or frame.args[1]).code
end


-------------------------------------------------------------------------------
-- getQid returns the qid, if supplied
-- failing that, the Wikidata entity ID of the "category's main topic (P301)", if it exists
-- failing that, the Wikidata entity ID associated with the current page, if it exists
-- otherwise, nothing
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getQid = function(frame)
	local qid = (frame.args.qid or ""):upper()
	-- check if a qid was passed; if so, return it:
	if qid ~= "" then return qid end
	-- check if there's a "category's main topic (P301)":
	qid = mw.wikibase.getEntityIdForCurrentPage()
	if qid then
		local prop301 = mw.wikibase.getBestStatements(qid, "P301")
		if prop301[1] then
			local mctid = prop301[1].mainsnak.datavalue.value.id
			if mctid then return mctid end
		end
	end
	-- otherwise return the page qid (if any)
	return qid
end


-------------------------------------------------------------------------------
-- followQid takes three optional parameters: qid, props, and all.
-- If qid is not given, it uses the qid for the connected page
-- or returns nil if there isn't one.
-- props is a list of properties, separated by punctuation.
-- If props is given, the Wikidata item for the qid is examined for each property in turn.
-- If that property contains a value that is another Wikibase-item, that item's qid is returned,
-- and the search terminates, unless |all=y when all of the qids are returned, sparated by spaces.
-- If props is not given, the qid is returned.
-------------------------------------------------------------------------------
-- Dependencies: parseParam()
-------------------------------------------------------------------------------
p.followQid = function(frame)
	local qid = (frame.args.qid or ""):upper()
	local all = parseParam(frame.args.all, false)
	if qid == "" then
		qid = mw.wikibase.getEntityIdForCurrentPage()
	end
	if not qid then return nil end
	local out = {}
	local props = (frame.args.props or ""):upper()
	if props ~= "" then
		for p in mw.text.gsplit(props, "%p") do -- split at punctuation and iterate
			p = mw.text.trim(p)
			for i, v in ipairs( mw.wikibase.getBestStatements(qid, p) ) do
				local linkedid = v.mainsnak.datavalue and v.mainsnak.datavalue.value.id
				if linkedid then
					if all then
						out[#out+1] = linkedid
					else
						return linkedid
					end -- test for all or just the first one found
				end -- test for value exists for that property
			end -- loop through values of property to follow
		end -- loop through list of properties to follow
	end
	if #out &gt; 0 then
		return table.concat(out, " ")
	else
		return qid
	end
end


-------------------------------------------------------------------------------
-- globalSiteID returns the globalSiteID for the current wiki
-- e.g. returns "enwiki" for the English Wikipedia, "enwikisource" for English Wikisource, etc.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.globalSiteID = function(frame)
	return mw.wikibase.getGlobalSiteId()
end


-------------------------------------------------------------------------------
-- siteID returns the root of the globalSiteID
-- e.g. "en" for "enwiki", "enwikisource", etc.
-- treats "en-gb" as "en", etc.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.siteID = function(frame)
	local txtlang = frame:preprocess( "{{int:lang}}" ) or ""
	-- This deals with specific exceptions: be-tarask -&gt; be-x-old
	if txtlang == "be-tarask" then
		return "be_x_old"
	end
	local pos = txtlang:find("-")
	local ret = ""
	if pos then
		ret = txtlang:sub(1, pos-1)
	else
		ret = txtlang
	end
	return ret
end


-------------------------------------------------------------------------------
-- projID returns the code used to link to the reader's language's project
-- e.g "en" for [[:en:WikidataIB]]
-- treats "en-gb" as "en", etc.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.projID = function(frame)
	local txtlang = frame:preprocess( "{{int:lang}}" ) or ""
	-- This deals with specific exceptions: be-tarask -&gt; be-x-old
	if txtlang == "be-tarask" then
		return "be-x-old"
	end
	local pos = txtlang:find("-")
	local ret = ""
	if pos then
		ret = txtlang:sub(1, pos-1)
	else
		ret = txtlang
	end
	return ret
end


-------------------------------------------------------------------------------
-- formatNumber formats a number according to the the supplied language code ("|lang=")
-- or the default language if not supplied.
-- The number is the first unnamed parameter or "|num="
-------------------------------------------------------------------------------
-- Dependencies: findLang()
-------------------------------------------------------------------------------
p.formatNumber = function(frame)
	local lang
	local num = tonumber(frame.args[1] or frame.args.num) or 0
	lang = findLang(frame.args.lang)
	return lang:formatNum( num )
end


-------------------------------------------------------------------------------
-- examine dumps the property (the unnamed parameter or pid)
-- from the item given by the parameter 'qid' (or the other unnamed parameter)
-- or from the item corresponding to the current page if qid is not supplied.
-- e.g. {{#invoke:WikidataIB |examine |pid=P26 |qid=Q42}}
-- or {{#invoke:WikidataIB |examine |P26 |Q42}} or any combination of these
-- or {{#invoke:WikidataIB |examine |P26}} for the current page.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.examine = function( frame )
	local args
	if frame.args[1] or frame.args.pid or frame.args.qid then
		args = frame.args
	else
		args = frame:getParent().args
	end
	local par = {}
	local pid = (args.pid or ""):upper()
	local qid = (args.qid or ""):upper()
	par[1] = mw.text.trim( args[1] or "" ):upper()
	par[2] = mw.text.trim( args[2] or "" ):upper()
	table.sort(par)
	if par[2]:sub(1,1) == "P" then par[1], par[2] = par[2], par[1] end
	if pid == "" then pid = par[1] end
	if qid == "" then qid = par[2] end
	local q1 = qid:sub(1,1)
	if pid:sub(1,1) ~= "P" then return "No property supplied" end
	if q1 ~= "Q" and q1 ~= "M" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return "No item for this page" end
	return "&lt;pre&gt;" .. mw.dumpObject( mw.wikibase.getAllStatements( qid, pid ) ) .. "&lt;/pre&gt;"
end


-------------------------------------------------------------------------------
-- checkvalue looks for 'val' as a wikibase-item value of a property (the unnamed parameter or pid)
-- from the item given by the parameter 'qid'
-- or from the Wikidata item associated with the current page if qid is not supplied.
-- If property is not supplied, then P31 (instance of) is assumed.
-- It returns val if found or nothing if not found.
-- e.g. {{#invoke:WikidataIB |checkvalue |val=Q5 |pid=P31 |qid=Q42}}
-- or {{#invoke:WikidataIB |checkvalue |val=Q5 |P31 |qid=Q42}}
-- or {{#invoke:WikidataIB |checkvalue |val=Q5 |qid=Q42}}
-- or {{#invoke:WikidataIB |checkvalue |val=Q5 |P31}} for the current page.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.checkvalue = function( frame )
	local args
	if frame.args.val then
		args = frame.args
	else
		args = frame:getParent().args
	end
	local val = args.val
	if not val then return nil end
	local pid = mw.text.trim(args.pid or args[1] or "P31"):upper()
	local qid = (args.qid or ""):upper()
	if pid:sub(1,1) ~= "P" then return nil end
	if qid:sub(1,1) ~= "Q" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return nil end
	local stats = mw.wikibase.getAllStatements( qid, pid )
	if not stats[1] then return nil end
	if stats[1].mainsnak.datatype == "wikibase-item" then
		for k, v in pairs( stats ) do
			if v.mainsnak.snaktype == "value" and v.mainsnak.datavalue.value.id == val then
				return val
			end
		end
	end
	return nil
end


-------------------------------------------------------------------------------
-- url2 takes a parameter url= that is a proper url and formats it for use in an infobox.
-- If no parameter is supplied, it returns nothing.
-- This is the equivalent of Template:URL
-- but it keeps the "edit at Wikidata" pen icon out of the microformat.
-- Usually it will take its url parameter directly from a Wikidata call:
-- e.g. {{#invoke:WikidataIB |url2 |url={{wdib |P856 |qid=Q23317 |fwd=ALL |osd=no}}
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.url2 = function(frame)
	local txt = frame.args.url or ""
	if txt == "" then return nil end
	local url, icon = txt:match("(.+)&amp;nbsp;(.+)")
	url = url or txt
	icon = icon or ""
	local prot, addr = url:match("(http[s]*://)(.+)")
	prot = prot or url
	addr = addr or ""
	local disp, n = addr:gsub("%.", "&lt;wbr/&gt;%.")
	return '&lt;span class="url"&gt;[' .. prot .. addr .. " " .. disp .. "]&lt;/span&gt;&amp;nbsp;" .. icon
end


-------------------------------------------------------------------------------
-- getWebsite fetches the Official website (P856) and formats it for use in an infobox.
-- This is similar to Template:Official website but with a url displayed,
-- and it adds the "edit at Wikidata" pen icon beyond the microformat if enabled.
-- A local value will override the Wikidata value. "NONE" returns nothing.
-- e.g. {{#invoke:WikidataIB |getWebsite |qid= |noicon= |lang= |url= }}
-------------------------------------------------------------------------------
-- Dependencies: findLang(); parseParam();
-------------------------------------------------------------------------------
p.getWebsite = function(frame)
	local url = frame.args.url or ""
	if url:upper() == "NONE" then return nil end

	local qid = frame.args.qid or ""
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	if not qid then return nil end

	local urls = {}
	local quals = {}
	if url == "" then
		local prop856 = mw.wikibase.getBestStatements(qid, "P856")
		for k, v in pairs(prop856) do
			if v.mainsnak.snaktype == "value" then
				urls[#urls+1] = v.mainsnak.datavalue.value
				if v.qualifiers and v.qualifiers["P1065"] then
					 -- just take the first archive url (P1065)
					local au = v.qualifiers["P1065"][1]
					if au.snaktype == "value" then
						quals[#urls] = au.datavalue.value
					end -- test for archive url having a value
				end -- test for qualifers
			end -- test for website having a value
		end -- loop through website(s)
	else
		urls[1] = url
	end
	if #urls == 0 then return nil end

	local out = {}
	for i, u in ipairs(urls) do
		local link = quals[i] or u
		local prot, addr = u:match("(http[s]*://)(.+)")
		addr = addr or u
		local disp, n = addr:gsub("%.", "&lt;wbr/&gt;%.")
		out[#out+1] = '&lt;span class="url"&gt;[' .. link .. " " .. disp .. "]&lt;/span&gt;"
	end

	local langcode = findLang(frame.args.lang).code
	local noicon = parseParam(frame.args.noicon, false)
	if url == "" and not noicon then
		out[#out] = out[#out] .. createicon(langcode, qid, "P856")
	end

	local ret = ""
	if #out &gt; 1 then
		ret = mw.getCurrentFrame():expandTemplate{title = "ubl", args = out}
	else
		ret = out[1]
	end

	return ret
end


-------------------------------------------------------------------------------
-- getAllLabels fetches the set of labels and formats it for display as wikitext.
-- It takes a parameter 'qid' for arbitrary access, otherwise it uses the current page.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getAllLabels = function(frame)
	local args = frame.args or frame:getParent().args or {}

	local qid = args.qid
	if qid == "" then qid = nil end

	local entity = mw.wikibase.getEntity(qid)
	if not entity then return i18n["entity-not-found"] end

	local labels = entity.labels
	if not labels then return i18n["labels-not-found"] end

	local out = {}
	for k, v in pairs(labels) do
		out[#out+1] = v.value .. " (" .. v.language .. ")"
	end

	return table.concat(out, "; ")
end


-------------------------------------------------------------------------------
-- getAllDescriptions fetches the set of descriptions and formats it for display as wikitext.
-- It takes a parameter 'qid' for arbitrary access, otherwise it uses the current page.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getAllDescriptions = function(frame)
	local args = frame.args or frame:getParent().args or {}

	local qid = args.qid
	if qid == "" then qid = nil end

	local entity = mw.wikibase.getEntity(qid)
	if not entity then return i18n["entity-not-found"] end

	local descriptions = entity.descriptions
	if not descriptions then return i18n["descriptions-not-found"] end

	local out = {}
	for k, v in pairs(descriptions) do
		out[#out+1] = v.value .. " (" .. v.language .. ")"
	end

	return table.concat(out, "; ")
end


-------------------------------------------------------------------------------
-- getAllAliases fetches the set of aliases and formats it for display as wikitext.
-- It takes a parameter 'qid' for arbitrary access, otherwise it uses the current page.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.getAllAliases = function(frame)
	local args = frame.args or frame:getParent().args or {}

	local qid = args.qid
	if qid == "" then qid = nil end

	local entity = mw.wikibase.getEntity(qid)
	if not entity then return i18n["entity-not-found"] end

	local aliases = entity.aliases
	if not aliases then return i18n["aliases-not-found"] end

	local out = {}
	for k1, v1 in pairs(aliases) do
		local lang = v1[1].language
		local val = {}
		for k1, v2 in ipairs(v1) do
			val[#val+1] = v2.value
		end
		out[#out+1] = table.concat(val, ", ") .. " (" .. lang .. ")"
	end

	return table.concat(out, "; ")
end


-------------------------------------------------------------------------------
-- showNoLinks displays the article titles that should not be linked.
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
p.showNoLinks = function(frame)
	local out = {}
	for k, v in pairs(donotlink) do
		out[#out+1] = k
	end
	table.sort( out )
	return table.concat(out, "; ")
end


-------------------------------------------------------------------------------
-- checkValidity checks whether the first unnamed parameter represents a valid entity-id,
-- that is, something like Q1235 or P123.
-- It returns the strings "true" or "false".
-- Change false to nil to return "true" or "" (easier to test with #if:).
-------------------------------------------------------------------------------
-- Dependencies: none
-------------------------------------------------------------------------------
function p.checkValidity(frame)
	local id = mw.text.trim(frame.args[1] or "")
	if mw.wikibase.isValidEntityId(id) then
		return true
	else
		return false
	end
end


-------------------------------------------------------------------------------
-- getEntityFromTitle returns the Entity-ID (Q-number) for a given title.
-- Modification of Module:ResolveEntityId
-- The title is the first unnamed parameter.
-- The site parameter determines the site/language for the title. Defaults to current wiki.
-- The showdab parameter determines whether dab pages should return the Q-number or nil. Defaults to true.
-- Returns the Q-number or nil if it does not exist.
-------------------------------------------------------------------------------
-- Dependencies: parseParam
-------------------------------------------------------------------------------
function p.getEntityFromTitle(frame)
	local args=frame.args
	if not args[1] then args=frame:getParent().args end
	if not args[1] then return nil end
	local title = mw.text.trim(args[1])
	local site = args.site or ""
	local showdab = parseParam(args.showdab, true)
	qid = mw.wikibase.getEntityIdForTitle(title, site)
	if qid then
		local prop31 = mw.wikibase.getBestStatements(qid, "P31")[1]
		if not showdab and prop31 and prop31.mainsnak.datavalue.value.id == "Q4167410" then
			return nil
		else
			return qid
		end
	end
end

-------------------------------------------------------------------------------
-- getDatePrecision returns the number representing the precision of the first best date value
-- for the given property.
-- It takes the qid and property ID
-- The meanings are given at https://www.mediawiki.org/wiki/Wikibase/DataModel#Dates_and_times
-- 0 = 1 billion years .. 6 = millennium, 7 = century, 8 = decade, 9 = year, 10 = month, 11 = day
-- Returns nil if it does not exist.
-------------------------------------------------------------------------------
-- Dependencies: parseParam
-------------------------------------------------------------------------------
function p.getDatePrecision(frame)
	local args=frame.args
	if not args[1] then args=frame:getParent().args end
	local prop = mw.text.trim(args[1] or "")
	if prop == "" then return nil end
	local qid = args.qid or ""
	if qid == "" then qid = mw.wikibase.getEntityIdForCurrentPage() end
	local onlysrc = parseParam(args.onlysourced or args.osd, true)
	local stat = mw.wikibase.getBestStatements(qid, prop)
	for i, v in ipairs(stat) do
		local prec = (onlysrc == false or sourced(v))
			and v.mainsnak.datavalue
			and v.mainsnak.datavalue.value
			and v.mainsnak.datavalue.value.precision
		if prec then return prec end
	end
end


return p


-------------------------------------------------------------------------------
-- List of exported functions
-------------------------------------------------------------------------------
--[[
_getValue
getValue
getPreferredValue
getCoords
getQualifierValue
getSumOfParts
getValueByQual
getValueByLang
getValueByRefSource
getPropertyIDs
getPropOfProp
getAwardCat
getIntersectCat
getGlobe
getCommonsLink
getSiteLink
getLink
getLabel
label
getAT
getDescription
getAliases
pageId
formatDate
location
checkBlacklist
emptyor
labelorid
getLang
getItemLangCode
findLanguage
getQID
followQid
globalSiteID
siteID
projID
formatNumber
examine
checkvalue
url2
getWebsite
getAllLabels
getAllDescriptions
getAllAliases
showNoLinks
checkValidity
getEntityFromTitle
getDatePrecision
--]]
-------------------------------------------------------------------------------</text>
      <sha1>tjt0c8etriax7782okr9f84es94lsku</sha1>
    </revision>
  </page>
  <page>
    <title>Module:WikidataIB/nolinks</title>
    <ns>828</ns>
    <id>59544223</id>
    <revision>
      <id>881124610</id>
      <parentid>879960300</parentid>
      <timestamp>2019-01-31T16:27:33Z</timestamp>
      <contributor>
        <username>RexxS</username>
        <id>6112901</id>
      </contributor>
      <comment>add abbreviations UK and USA</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="832" xml:space="preserve">local p ={}

--[[
The values here are the English sitelinks for items that should not be linked.
These 36 are not definitive and may be altered to suit.
--]]
p.items = {
	"Australia",
	"Austria",
	"Belgium",
	"Canada",
	"China",
	"Denmark",
	"England",
	"France",
	"Germany",
	"Greece",
	"Hungary",
	"Iceland",
	"India",
	"Republic of Ireland",
	"Israel",
	"Italy",
	"Jamaica",
	"Japan",
	"Luxembourg",
	"Mexico",
	"Netherlands",
	"New Zealand",
	"Northern Ireland",
	"Norway",
	"Poland",
	"Portugal",
	"Russia",
	"Scotland",
	"South Africa",
	"Spain",
	"Sweden",
	"Switzerland",
	"Turkey",
	"United Kingdom",
	"UK",
	"United States",
	"USA",
	"Wales",
}

--[[
This provides a convenient way to create a test whether an item is on the list.
--]]
p.itemsindex = {}
for i, v in ipairs(p.items) do
	p.itemsindex[v] = true
end

return p</text>
      <sha1>os706fxg7ivfr0wq2o2z1afni11n93q</sha1>
    </revision>
  </page>
  <page>
    <title>Module:WikidataIB/titleformats</title>
    <ns>828</ns>
    <id>61785414</id>
    <revision>
      <id>954085206</id>
      <parentid>917831402</parentid>
      <timestamp>2020-04-30T16:11:19Z</timestamp>
      <contributor>
        <username>RexxS</username>
        <id>6112901</id>
      </contributor>
      <comment>add magazine</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1061" xml:space="preserve">--[[
To satisfy Wikipedia:Manual of Style/Titles, certain types of items are italicised,
and others are quoted.
This submodule lists the entity-ids used in 'instance of' (P31),
which allows a module to identify the values that should be formatted.
The table p.formats is indexed by entity-id, and contains the value " or ''
--]]

local p = {}

p.italics = {
	"Q571",			-- book
	"Q13593966",	-- literary trilogy
	"Q277759",		-- book series
	"Q2188189",		-- musical work
	"Q11424",		-- film
	"Q13593818",	-- film trilogy
	"Q24856",		-- film series
	"Q5398426",		-- television series
	"Q482994",		-- album
	"Q169930",		-- extended play
	"Q1760610",		-- comic book
	"Q7889",		-- video game
	"Q7058673",		-- video game series
	"Q25379",		-- play
	"Q2743",		-- musical
	"Q37484",		-- epic poem
	"Q41298",		-- magazine
}

p.quotes = { 
	"Q207628",		-- musical composition
}

p.size = 0
p.formats = {}

for i, v in ipairs(p.italics) do
	p.formats[v] = "''"
	p.size = p.size + 1
end

for i, v in ipairs(p.quotes) do
	p.formats[v] = '"'
	p.size = p.size + 1
end

return p</text>
      <sha1>kf27lmax414v7k61jzza3jomkstxn1m</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Yesno</title>
    <ns>828</ns>
    <id>38665046</id>
    <revision>
      <id>948473803</id>
      <parentid>948472535</parentid>
      <timestamp>2020-04-01T06:27:55Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <comment>Undid revision 948472533 by [[Special:Contributions/w&gt;Vogone|w&gt;Vogone]] ([[User talk:w&gt;Vogone|talk]])</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="745" xml:space="preserve">-- Function allowing for consistent treatment of boolean-like wikitext input.
-- It works similarly to the template {{yesno}}.

return function (val, default)
	-- If your wiki uses non-ascii characters for any of "yes", "no", etc., you
	-- should replace "val:lower()" with "mw.ustring.lower(val)" in the
	-- following line.
	val = type(val) == 'string' and val:lower() or val
	if val == nil then
		return nil
	elseif val == true 
		or val == 'yes'
		or val == 'y'
		or val == 'true'
		or val == 't'
		or val == 'on'
		or tonumber(val) == 1
	then
		return true
	elseif val == false
		or val == 'no'
		or val == 'n'
		or val == 'false'
		or val == 'f'
		or val == 'off'
		or tonumber(val) == 0
	then
		return false
	else
		return default
	end
end</text>
      <sha1>swdskn7svew8i9wuydn9uj5l3r2ghcs</sha1>
    </revision>
  </page>
  <page>
    <title>Networked</title>
    <ns>0</ns>
    <id>12592275</id>
    <redirect title="Software" />
    <revision>
      <id>469783092</id>
      <parentid>149161164</parentid>
      <timestamp>2012-01-05T20:49:08Z</timestamp>
      <contributor>
        <username>AvicBot</username>
        <id>11952314</id>
      </contributor>
      <minor/>
      <comment>Robot: Fixing double redirect to [[Software]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="22" xml:space="preserve">#REDIRECT [[Software]]</text>
      <sha1>oik97hmdqdj0ou8itpvus3y2hiwwm4w</sha1>
    </revision>
  </page>
  <page>
    <title>Template:As of</title>
    <ns>10</ns>
    <id>16011254</id>
    <revision>
      <id>947492172</id>
      <parentid>890110284</parentid>
      <timestamp>2020-03-26T17:17:01Z</timestamp>
      <contributor>
        <username>Jonesey95</username>
        <id>9755426</id>
      </contributor>
      <comment>Adding unknown parameter tracking through [[:Category:Pages using as of with unknown parameters]] using [[Module:check for unknown parameters]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2592" xml:space="preserve">&lt;!--{{As of}} begin--&gt;&lt;includeonly&gt;&lt;!--

## param 1 is the year
## optional param 2 is the month
## optional param 3 is the day of the month
## optional named parameter alt=[text] is alternative display text (may include wiki markup)
## optional named parameter df=US produces American date format in displayed text
## optional named parameter lc=on gives lower-case-first output
## optional named parameter url=[URL] gives statement reference

## displayed text ([A/a]s of [Start date] by default)
--&gt;{{#if: {{{alt|}}} | {{{alt}}} | {{#if:{{{since|}}}|{{#ifeq: {{{lc}}} | {{{lc|}}} | s | S }}ince | {{#ifeq: {{{lc}}} | {{{lc|}}} | a | A }}s of}} {{#if:{{{pre|}}}|{{{pre}}}&amp;#32;}}{{#if: {{{3|}}} | {{#ifeq:{{lc:{{{df|}}}}}|us|{{MONTHNAME|{{{2}}}}}&amp;nbsp;{{#expr:{{{3}}}}},&amp;#32;|{{#expr:{{{3}}}}}&amp;nbsp;{{MONTHNAME|{{{2}}}}}&amp;nbsp;}}{{{1}}}|{{#if: {{{2|}}} |{{MONTHNAME|{{{2}}}}}&amp;nbsp;}}{{{1}}}}}}}{{#if:{{{post|}}}|&lt;nowiki /&gt;{{{post}}}}}&lt;!--
#### That nowiki is required or, various characters (:, ;, #, and *} will be parsed as wikisyntax for list items.
## ref/update inline banner (hidden by default)
--&gt;&lt;sup class="plainlinks noexcerpt noprint asof-tag {{#if:{{{url|}}}|ref|update}}" style="display:none;"&gt;[{{#if:{{{url|}}}|{{{url}}} &amp;#91;ref&amp;#93;|{{fullurl:{{PAGENAME}}|action=edit}} &amp;#91;update&amp;#93;}}]&lt;/sup&gt;&lt;!--

## categorisation disabled outside main namespace
--&gt;{{DMCA|Articles containing potentially dated statements|from|&lt;!--

## temporal category for template (word method)
--&gt;{{#if: {{#ifexpr: {{{1}}} = 1 }} | {{#ifexpr: {{#time:Y|{{{1}}}}} &gt; 2004 | {{{1}}} | {{#ifexpr: {{#time:Y|{{{1}}}}} &gt; 1989 | {{#time:Y|{{{1}}}}} | before 1990 }}}} | &lt;!--

## temporal category for template (parameter method)
--&gt;{{#ifexpr: {{{1}}} &gt; 2004 | {{#if:{{{2|}}} | {{MONTHNAME|{{{2}}}}} }} {{{1}}} | {{#ifexpr:{{{1}}} &gt; 1989 | {{{1}}} | before 1990 }}}}}}|&lt;!--

## global category for template
--&gt;All articles containing potentially dated statements}}&lt;/includeonly&gt;&lt;!--{{As of}} end--&gt;&lt;noinclude&gt;&lt;!-- 

## dynamic example (as of today, self ref)

--&gt;{{As of|{{CURRENTYEAR}}|{{CURRENTMONTH}}|{{CURRENTDAY}}}}&lt;sup class="plainlinks"&gt;[https://en.wikipedia.org/wiki/Template:As_of &amp;#91;ref&amp;#93;]&lt;/sup&gt;

{{documentation}}

&lt;!-- Add categories and inter-wikis to the /doc subpage, not here! --&gt; 

&lt;/noinclude&gt;{{#invoke:Check for unknown parameters|check|unknown={{main other|[[Category:Pages using as of template with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:As of]] with unknown parameter "_VALUE_"|ignoreblank=y| 1 | 2 | 3 | alt | df | lc | post | pre | since | url }}</text>
      <sha1>rbu66w7vdpj3sc0horac0flimmb0in7</sha1>
    </revision>
  </page>
  <page>
    <title>Template:CODEN</title>
    <ns>10</ns>
    <id>49845649</id>
    <revision>
      <id>951733362</id>
      <parentid>719479900</parentid>
      <timestamp>2020-04-18T16:05:22Z</timestamp>
      <contributor>
        <username>Matthiaspaul</username>
        <id>13467261</id>
      </contributor>
      <comment>deliberately going through (identifier) redirect for consistency with CS1 citation templates and to improve reverse lookup functionality</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="237" xml:space="preserve">{{Catalog lookup link|{{{coden|{{{1|}}}}}}|{{{2|}}}|{{{3|}}}|{{{4|}}}|{{{5|}}}|{{{6|}}}|{{{7|}}}|{{{8|}}}|{{{9|}}}|article-link=CODEN (identifier)|article-name=CODEN|list-leadout={{{leadout|}}}}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>he6di6naj5lodjitpy6eeg447j26rde</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Catalog lookup link</title>
    <ns>10</ns>
    <id>50392128</id>
    <revision>
      <id>862301591</id>
      <parentid>855471681</parentid>
      <timestamp>2018-10-03T13:51:48Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>Undid revision 855471681 by [[Special:Contributions/Trappist the monk|Trappist the monk]] ([[User talk:Trappist the monk|talk]]) restore the change now that the cs1|2 modules have been updated;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="133" xml:space="preserve">&lt;templatestyles src="Module:Citation/CS1/styles.css" /&gt;{{#invoke:Catalog lookup link|main}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>464h1jyus0m20p4x31lf2k2pqgseen5</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Clarify</title>
    <ns>10</ns>
    <id>7774601</id>
    <revision>
      <id>784083754</id>
      <parentid>692035460</parentid>
      <timestamp>2017-06-06T10:55:55Z</timestamp>
      <contributor>
        <username>UsuallyNonviolentBot</username>
        <id>31197275</id>
      </contributor>
      <minor/>
      <comment>/* top */Remove deprecated parameter $N from [[Module:Unsubst]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="424" xml:space="preserve">{{ {{{|safesubst:}}}#invoke:Unsubst||date=__DATE__ |$B=
{{Fix-span
|link=Wikipedia:Please clarify
|text=clarification needed
|title={{delink|{{{reason|The text near this tag may need clarification or removal of jargon.}}}}}
|date={{{date|}}}
|pre-text={{{pre-text|}}}
|post-text={{{post-text|}}}
|cat-date=Category:Wikipedia articles needing clarification
|content={{{text|}}}
}}
}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>ews7q9prv01iuwm618rmojilerinpjx</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Curlie</title>
    <ns>10</ns>
    <id>2559871</id>
    <revision>
      <id>897252023</id>
      <parentid>895724629</parentid>
      <timestamp>2019-05-15T19:58:05Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <comment>TFD closed as keep ([[WP:XFDC|XFDcloser]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="322" xml:space="preserve">{{#switch: {{{3|}}}|#default=[https://curlie.org/{{{1|&lt;includeonly&gt;{{PAGENAME}}&lt;/includeonly&gt;}}} {{{2|{{PAGENAME}}}}}] at [[Curlie]]
|user=[https://curlie.org/public/profile?editor={{{1}}} {{{2|{{PAGENAME}}}}}] at [[Curlie]]}}{{main other|[[Category:Articles with Curlie links]]|}}&lt;noinclude&gt;
{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>3k7z2r5srutmqgcsz3azl16x1a15q5n</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Distinguish</title>
    <ns>10</ns>
    <id>3406012</id>
    <revision>
      <id>828660796</id>
      <parentid>826539975</parentid>
      <timestamp>2018-03-03T23:40:51Z</timestamp>
      <contributor>
        <username>Plastikspork</username>
        <id>5075409</id>
      </contributor>
      <comment>[[Wikipedia:Templates for discussion/Log/2018 February 19#Template:Distinguish2]] closed as merge ([[WP:XFDC|XFDcloser]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="290" xml:space="preserve">{{#invoke:Distinguish|distinguish}}&lt;noinclude&gt;&lt;!-- splitting these lines causes {{Documentation}} template to terminate green shading when Distinguish is used in /doc pages. --&gt;
{{Documentation}}
&lt;!-- Add categories to the /doc subpage and interwikis to Wikidata, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>t4az5q8zekjr0kpgvlz6fgo7i77psk8</sha1>
    </revision>
  </page>
  <page>
    <title>Template:E-commerce</title>
    <ns>10</ns>
    <id>14059270</id>
    <revision>
      <id>942396010</id>
      <parentid>939329638</parentid>
      <timestamp>2020-02-24T12:07:27Z</timestamp>
      <contributor>
        <ip>31.60.28.156</ip>
      </contributor>
      <comment>Undid revision 939329638 by [[Special:Contributions/2001:B07:6461:447A:1910:D03F:5D92:53C|2001:B07:6461:447A:1910:D03F:5D92:53C]] ([[User talk:2001:B07:6461:447A:1910:D03F:5D92:53C|talk]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1315" xml:space="preserve">{{ sidebar
| name     = E-commerce
| pretitle =  series on
| title    = [[E-commerce]]
| class    = hlist
| topimage = [[File:Shopping cart icon.svg|42px]]

| heading1 = Online goods and services
| content1 = 
* [[Digital distribution]]
* [[E-book]]s
* [[Software]]
* [[Streaming media]]

| heading2 = Retail services
| content2 = 
* [[Online banking|Banking]]
* [[DVD-by-mail]]
* [[Flower delivery]]
* [[Online food ordering|Food ordering]]
* [[Online grocer|Grocery]]
* [[Online pharmacy|Pharmacy]]
* [[Travel website|Travel]]

| heading3 = Marketplace services
| content3 = 
* [[Online advertising|Advertising]]
* [[Online auction|Auctions]]
* [[Comparison shopping website|Comparison shopping]]
* [[Social commerce]]
* [[Online trading community|Trading communities]]
* [[Online wallet|Wallet]]

| heading4 = [[Mobile commerce]]
| content4 = 
* [[Mobile payment|Payment]]
* [[Mobile ticketing|Ticketing]]

| heading5 = [[Customer service]]
| content5 = 
* [[Call centre]]
* [[Help desk]]
* [[Online chat|Live support software]]

| heading6 = [[E-procurement]]

| heading7 = [[Purchase-to-pay]]

}}&lt;noinclude&gt;{{doc|content=
{{DEFAULTSORT:E-Commerce}}
[[Category:Economics navigational boxes]]
[[Category:"Part of a series on" sidebar templates]]
[[Category:Business and finance sidebar templates]]
}}&lt;/noinclude&gt;</text>
      <sha1>8u3hbhj3kbdl81hd9jy2n3vl15mr2c9</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ecommerce</title>
    <ns>10</ns>
    <id>37355907</id>
    <redirect title="Template:E-commerce" />
    <revision>
      <id>518295829</id>
      <timestamp>2012-10-17T10:25:12Z</timestamp>
      <contributor>
        <username>Thumperward</username>
        <id>545027</id>
      </contributor>
      <comment>Thumperward moved page [[Template:Ecommerce]] to [[Template:E-commerce]]: canonical title</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="33" xml:space="preserve">#REDIRECT [[Template:E-commerce]]</text>
      <sha1>ly3bhcwp2nktsyyqf0j0f6ftsixno0b</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Fix-span</title>
    <ns>10</ns>
    <id>29459344</id>
    <revision>
      <id>849479086</id>
      <parentid>711464884</parentid>
      <timestamp>2018-07-09T09:01:29Z</timestamp>
      <contributor>
        <username>DMacks</username>
        <id>712163</id>
      </contributor>
      <comment>Do not display the highlighted box if there is no text to put in it</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1271" xml:space="preserve">{{#if:{{{content|}}}|&lt;span class="{{{span-class|cleanup-needed-content}}}" style="padding-left:0.1em; padding-right:0.1em; color:#595959; border:1px solid #DDD;"&gt;{{{content|}}}&lt;/span&gt;}}{{#switch:{{{subst|¬}}}
 |¬={{category handler
  |template=[[Category:Templates needing substitution checking]]
  |nocat={{{nocat|&lt;noinclude&gt;true&lt;/noinclude&gt;}}}
 }}
 |SUBST=[[Category:Pages with incorrectly substituted templates]]
}}{{Category handler
 |main={{Fix/category
  |cat-date={{{cat-date|}}} 
  |cat={{{cat|}}} 
  |cat-date2={{{cat-date2|}}} 
  |cat2={{{cat2|}}} 
  |cat-date3={{{cat-date3|}}} 
  |cat3={{{cat3|}}} 
  |date={{{date|}}}
 }}
 |template={{#if:{{{name|}}}|{{#ifeq:{{{name}}}|{{ROOTPAGENAME}}||{{#if:{{{date|}}}||[[Category:Templates including undated clean-up tags]]}}}}}} 
 |subpage=no
}}{{#if:{{{special|}}}
 |{{{special|}}}
 |&lt;sup class="noprint Inline-Template {{{class|}}}" style="margin-left:0.1em; white-space:nowrap;"&gt;&amp;#91;&lt;i&gt;{{#if:{{{pre-text|}}}
  |{{{pre-text}}}&amp;#32;
 }}[[{{{link|Wikipedia:Cleanup}}}|&lt;span title="{{replace|{{{title|{{{link|Wikipedia:Cleanup}}}}}}|"|&amp;quot;}}{{#if:{{{date|}}}|&lt;nowiki/&gt; ({{{date}}})}}"&gt;{{{text|}}}&lt;/span&gt;]]{{#if:{{{post-text|}}}
  |&amp;#32;{{{post-text}}}
 }}&lt;/i&gt;&amp;#93;&lt;/sup&gt;
}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>97w2vqjl105xlyzz2gg3klse64yaeqc</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Portal bar</title>
    <ns>10</ns>
    <id>30675152</id>
    <revision>
      <id>754105365</id>
      <parentid>573112947</parentid>
      <timestamp>2016-12-10T22:05:10Z</timestamp>
      <contributor>
        <username>Renamed user mou89p43twvqcvm8ut9w3</username>
        <id>25420061</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Portal bar]]": [[WP:High-risk templates|Highly visible template]] ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="144" xml:space="preserve">{{#invoke:Portal bar|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>2e7c1lv0yixzmy178249a9kefzw3mbg</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Pp</title>
    <ns>10</ns>
    <id>43132240</id>
    <revision>
      <id>761735106</id>
      <parentid>695624743</parentid>
      <timestamp>2017-01-24T15:07:04Z</timestamp>
      <contributor>
        <username>Xaosflux</username>
        <id>502540</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Pp]]": is linked from cascaded main page, moving would be very disruptive ([Edit=Require template editor access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="76" xml:space="preserve">{{#invoke:Protection banner|main}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>8rt1snyv5yit3jnuzrbl00negaj27e5</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Pp-protected</title>
    <ns>10</ns>
    <id>10226552</id>
    <redirect title="Template:Pp" />
    <revision>
      <id>902374016</id>
      <parentid>667600903</parentid>
      <timestamp>2019-06-18T11:25:34Z</timestamp>
      <contributor>
        <username>Paine Ellsworth</username>
        <id>9092818</id>
      </contributor>
      <comment>add [[WP:RCAT|rcat]]s</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="164" xml:space="preserve">#REDIRECT [[Template:Pp]]

{{Rcat shell|
{{R from move}}
{{R from long name}}
{{R with history}}
{{R for convenience}}
}}
[[Category:Top icon protection templates]]</text>
      <sha1>faqi1ai9n8c7mo2k340w9h2ecfy57hm</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Redirect</title>
    <ns>10</ns>
    <id>1649987</id>
    <revision>
      <id>827943535</id>
      <parentid>826439889</parentid>
      <timestamp>2018-02-27T17:34:09Z</timestamp>
      <contributor>
        <username>Primefac</username>
        <id>11508456</id>
      </contributor>
      <comment>[[Wikipedia:Templates for discussion/Log/2018 February 18#Template:Redirect3_and_Template:About2]] closed as merge ([[WP:XFDC|XFDcloser]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="183" xml:space="preserve">&lt;includeonly&gt;{{#invoke:redirect hatnote|redirect|1}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>nahryqse47xqenividwc88opp02rhjv</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sidebar</title>
    <ns>10</ns>
    <id>1960394</id>
    <revision>
      <id>953755641</id>
      <parentid>952702869</parentid>
      <timestamp>2020-04-28T22:25:45Z</timestamp>
      <contributor>
        <username>Paine Ellsworth</username>
        <id>9092818</id>
      </contributor>
      <comment>both merge proposals closed as "do not merge"</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="68" xml:space="preserve">{{#invoke:Sidebar|sidebar}}&lt;noinclude&gt;
{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>jzouzofoaugku1umcgwhk1sk23s7qrm</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sister project links</title>
    <ns>10</ns>
    <id>2226074</id>
    <revision>
      <id>945935102</id>
      <parentid>945933916</parentid>
      <timestamp>2020-03-17T01:30:08Z</timestamp>
      <contributor>
        <username>Koavf</username>
        <id>205121</id>
      </contributor>
      <comment>???</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9374" xml:space="preserve">&lt;includeonly&gt;&lt;div role="navigation" aria-labelledby="sister-projects" class="metadata plainlinks sistersitebox plainlist mbox-small{{#ifeq:{{lc:{{{position|}}}}}|left|-left}} {{#if:{{{collapsible|}}}|mw-collapsible {{#ifeq:{{{collapsible|}}}|collapsed |mw-collapsed}}}}" style="border:1px solid #aaa; padding:0; background:#f9f9f9; {{{style|}}}"&gt;&lt;!--
 --&gt;&lt;div style="{{#if:{{{collapsible|}}}|clear: both;}} padding: 0.75em 0; text-align: center;"&gt;&lt;!--
     --&gt;&lt;b style="display:block;"&gt;{{{display|{{{1|{{PAGENAME}}}}}}}}&lt;/b&gt;&lt;!--
     --&gt;at Wikipedia's [[Wikipedia:Wikimedia sister projects|&lt;span id="sister-projects"&gt;sister projects&lt;/span&gt;]]&lt;!--
 --&gt;&lt;/div&gt;&lt;!--
 --&gt;&lt;ul {{#if:{{{collapsible|}}}|class="mw-collapsible-content"}} style="border-top:1px solid #aaa; padding: 0.75em 0; width:217px; margin:0 auto;"&gt;&lt;!--
     --&gt;{{#ifeq:{{{wikt|}}}|no||
            &lt;li style="min-height: 31px;"&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Wiktionary-logo-v2.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[wikt:{{{wikt|Special:Search/{{{1|{{PAGENAME}}}}}}}}|Definitions]] from Wiktionary&lt;/span&gt;
            &lt;/li&gt;
        }}&lt;!--
     --&gt;{{#ifeq:{{{c|{{{commons|}}}}}}|no||
            &lt;li style="min-height: 31px;"&gt;&lt;!--
             --&gt;{{#ifeq:{{{commonscat|no}}}|yes|
                    &lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Commons-logo.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
                 --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[c:Special:Search/Category:{{{c|{{{commons|{{{1|{{PAGENAME}}}}}}}}}}}|Media]] from Wikimedia Commons&lt;/span&gt;
                |
                    &lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Commons-logo.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
                 --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[c:{{{c|{{{commons|Special:Search/{{{1|{{PAGENAME}}}}}}}}}}}|Media]] from Wikimedia Commons&lt;/span&gt;
                }}
            &lt;/li&gt;
        }}&lt;!--
     --&gt;{{#ifeq:{{{n|}}}|no||
            &lt;li style="min-height: 31px;"&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Wikinews-logo.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[n:{{{n|Special:Search/{{{1|{{PAGENAME}}}}}}}}|News]] from Wikinews&lt;/span&gt;
            &lt;/li&gt;
        }}&lt;!--
     --&gt;{{#ifeq:{{{q|}}}|no||
            &lt;li style="min-height: 31px;"&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Wikiquote-logo.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[q:{{{q|Special:Search/{{{1|{{PAGENAME}}}}}}}}|Quotations]] from Wikiquote&lt;/span&gt;
            &lt;/li&gt;
        }}&lt;!--
     --&gt;{{#ifeq:{{{s|}}}|no||
            &lt;li style="min-height: 31px;"&gt;&lt;!--
             --&gt;{{#ifeq:{{{author|no}}}|yes|
                    &lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Wikisource-logo.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
                 --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[s:Special:Search/Author:{{{s|{{{1|{{PAGENAME}}}}}}}}|Texts]] from Wikisource&lt;/span&gt;
                |
                    &lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Wikisource-logo.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
                 --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[s:{{{s|Special:Search/{{{1|{{PAGENAME}}}}}}}}|Texts]] from Wikisource&lt;/span&gt;
                }}
            &lt;/li&gt;
        }}&lt;!--
     --&gt;{{#ifeq:{{{b|}}}|no||
            &lt;li style="min-height: 31px;"&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Wikibooks-logo.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[b:{{{b|Special:Search/{{{1|{{PAGENAME}}}}}}}}|Textbooks]] from Wikibooks&lt;/span&gt;
            &lt;/li&gt;
        }}&lt;!--
     --&gt;{{#ifeq:
            &lt;!-- Show Wikivoyage if the "voy" parameter is anything other than blank, empty or "no" --&gt;
            {{#switch: {{{voy|&lt;noinclude&gt;yes&lt;/noinclude&gt;}}}
            | | no     = false
            | #default = true
            }}
            | true |
            &lt;li style="min-height: 31px;"&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Wikivoyage-Logo-v3-icon.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[voy:{{#if:{{{voy|}}}|{{{voy}}}|Special:Search/{{{1|{{PAGENAME}}}}}}}|Travel {{#if: {{{voy|}}}| guide| information}}]] from Wikivoyage&lt;/span&gt;
            &lt;/li&gt;
        }}&lt;!--
     --&gt;{{#ifeq:{{{v|}}}|no||
            &lt;li style="min-height: 31px;"&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Wikiversity-logo-Snorky.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[v:{{{v|Special:Search/{{{1|{{PAGENAME}}}}}}}}|Resources]] from Wikiversity&lt;/span&gt;
            &lt;/li&gt;
        }}&lt;!--
     --&gt;{{#ifeq:{{{d|no}}}|no||
            &lt;li style="min-height: 31px;"&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Wikidata-logo.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[d:{{{d&lt;noinclude&gt;|{{{1|Special:ItemByTitle/enwiki/{{PAGENAME}}}}}&lt;/noinclude&gt;}}}|Data]] from Wikidata&lt;/span&gt;
            &lt;/li&gt;
        }}&lt;!--
     --&gt;{{#ifeq:{{{species|no}}}|no||
            &lt;li style="min-height: 31px;"&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Wikispecies-logo.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[species:{{{species&lt;noinclude&gt;|Special:Search/{{{1|{{PAGENAME}}}}}&lt;/noinclude&gt;}}}|Taxonomy]] from Wikispecies&lt;/span&gt;
            &lt;/li&gt;
        }}&lt;!--
     --&gt;{{#ifeq:{{{species_author|no}}}|no||
            &lt;li style="min-height: 31px;"&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Wikispecies-logo.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[species:{{{species_author&lt;noinclude&gt;|Special:Search/{{{1|{{PAGENAME}}}}}&lt;/noinclude&gt;}}}|Species author {{{species_author&lt;noinclude&gt;|&lt;/noinclude&gt;}}}]] on Wikispecies&lt;/span&gt;
            &lt;/li&gt;
        }}&lt;!--
     --&gt;{{#ifeq:{{lc:{{{m|no}}}}}|no||
            &lt;li style="min-height: 31px;"&gt;&lt;!--
             --&gt;{{#ifeq:{{lc:{{{m}}}}}|yes|
                    &lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Wikimedia Community Logo.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
                 --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[m:Special:Search/{{{1|{{PAGENAME}}}}}|Discussion]] from Meta-Wiki&lt;/span&gt;
                |
                    &lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:Wikimedia Community Logo.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
                 --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[m:{{{m}}}|Discussion]] from Meta-Wiki&lt;/span&gt;
                }}
            &lt;/li&gt;
        }}&lt;!--
     --&gt;{{#ifeq:{{{mw|no}}}|no||
            &lt;li style="min-height: 31px;"&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; width: 31px; line-height: 31px; vertical-align: middle; text-align: center;"&gt;[[File:MediaWiki-logo.svg|27x27px|middle|link=|alt=]]&lt;/span&gt;&lt;!--
             --&gt;&lt;span style="display: inline-block; margin-left: 4px; width: 182px; vertical-align: middle;"&gt;[[mw:{{{mw&lt;noinclude&gt;|{{{1|Special:Search/{{PAGENAME}}}}}&lt;/noinclude&gt;}}}|Documentation]] from MediaWiki&lt;/span&gt;
            &lt;/li&gt;
        }}&lt;!--
 --&gt;&lt;/ul&gt;
&lt;/div&gt;&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>9fm35zaygr11gtv44fdj7qk4xtftj4p</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Software digital distribution platforms</title>
    <ns>10</ns>
    <id>47142094</id>
    <revision>
      <id>953047533</id>
      <parentid>943059807</parentid>
      <timestamp>2020-04-25T12:30:38Z</timestamp>
      <contributor>
        <username>Avram25</username>
        <id>39056453</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2750" xml:space="preserve">{{Navbox
| name  = Software digital distribution platforms
| title = [[Software]] [[digital distribution|distribution platforms]] and [[content delivery network]]s
| bodyclass = hlist
| state = {{{state|autocollapse}}}

| above = 
* [[App store]]
* [[Cloud gaming]]
* [[Digital library]]
* [[Digital distribution in video games|Online game store]]
* [[Package manager]]
* [[Software distribution]]
* [[Streaming media]]

| group1 = Active
| list1  = {{navbox|subgroup|group1 = [[Personal computer|Personal&lt;br /&gt;computer]]
 |list1  =
* [[Amazon Digital Game Store]]
* [[Battle.net]]
* [[Big Fish Games]]
* [[Chrome Web Store]]
* [[Digital River]]
* [[Direct2Drive]]
* [[Discord (software)|Discord]]
* [[DMM.com]]
* [[Epic Games Store]]
* [[GOG.com]]
* [[GameHouse]]
* [[GamersGate]]
* [[Game Jolt]]
* [[GNOME Software]]
* [[Green Man Gaming]]
* [[Humble Bundle|Humble Store]]
* [[Inside Mac Games|Mac Games Arcade]]
* [[itch.io]]
* [[App Store (macOS)|Mac App Store]]
* [[MacUpdate]]
* [[Metaboli|Metaboli/GamesPlanet]]
* [[Microsoft Store (digital)|Microsoft Store]]
* [[MSN Games]]
* [[Origin (service)|Origin]]
* [[Playism]]
* [[Pogo.com]]
* [[Pokki]]
* [[Steam (service)|Steam]]
* [[Uplay]]
* [[WeGame]]
* [[WildTangent]]

 |group2 = [[Video game console|Video game&lt;br /&gt;consoles]]
 |list2  =
* [[GameFly]]
* [[Microsoft Store (digital)|Microsoft Store]]
* [[Nintendo eShop]]
* [[PlayStation Now]]
* [[PlayStation Store]]
* [[Xbox Games Store|Xbox Store]]
* [[Xbox Live Arcade]]

 |group3 = [[List of mobile app distribution platforms|Mobile]]
 |list3  =
* [[Amazon Appstore]]
* [[App Store (iOS)|Apple App Store]]
* [[Aptoide]]
* [[Cafe Bazaar]]
* [[Cydia]]
* [[F-Droid]]
* [[GamersGate]]
* [[GetJar]]
* [[Google Play]]
* [[Microsoft Store (digital)|Microsoft Store]]
* [[Samsung Galaxy Store]]
* [[SlideME]]
* [[Opera Mobile Store]]

 |group4 = [[Arcade system board|Arcade]]
 |list4  =
* [[ALL.Net]]
* [[NESiCAxLive]]
* [[E-Amusement]]
}}

| group2 = Discontinued
| list2  =
* [[Allmyapps]]
* [[BlackBerry World]]
* [[Club Nokia]]
* [[Desura]]
* [[DotEmu]]
* [[GameAgent]]
* [[GameShadow]]
* [[GameTap]]
* [[Games for Windows – Live]]
* [[Games for Windows Marketplace]]
* [[Handango]]
* [[Impulse (software)|Impulse]]
* [[Intel AppUp]]
* [[Jumboplay]]
* [[Kazaa]]
* [[N-Gage (service)|N-Gage]]
* [[Download!|Nokia Download!]]
* [[Nokia Store|Nokia (Ovi) Store]]
* [[OnLive]]
* [[PlayNow Arena]]
* [[Stardock Central]]
* [[Triton (content delivery)|Triton]]
* [[Ubuntu Software Center]]
* [[Ubuntu App Store]]
* [[Vodafone live!]]
* [[Wii Shop Channel]]
* [[Windows Marketplace]]
* [[Windows Marketplace for Mobile]]
* [[Windows Phone Store]]
* [[Yahoo! Games]]
* [[Zune software|Zune Marketplace]]

}}&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>qkyob5ngu0sp84d79za92kwegtfzo7a</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Spaced en dash</title>
    <ns>10</ns>
    <id>10708380</id>
    <revision>
      <id>772120914</id>
      <parentid>670108726</parentid>
      <timestamp>2017-03-25T12:38:47Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Spaced en dash]]": Allowing template editors on some templates with full protection dating back to pre-[[WP:TPROT|TPROT]] times which aren't too often or too sensitively used. ([Edit=Require template editor acce...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="131" xml:space="preserve">&amp;nbsp;&amp;ndash;&amp;#32;&lt;noinclude&gt;

{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>44od3v3hy3o7813hgbduh1peb2790sz</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Spaced ndash</title>
    <ns>10</ns>
    <id>47162372</id>
    <redirect title="Template:Spaced en dash" />
    <revision>
      <id>776817710</id>
      <parentid>670108728</parentid>
      <timestamp>2017-04-23T13:25:27Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Spaced ndash]]": Matching redirect target ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="53" xml:space="preserve">#REDIRECT [[Template:Spaced en dash]]
{{R from move}}</text>
      <sha1>hbdby128eyit278hmwuoxqarf6zy63m</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Specify</title>
    <ns>10</ns>
    <id>6357631</id>
    <revision>
      <id>784069995</id>
      <parentid>713310318</parentid>
      <timestamp>2017-06-06T08:55:52Z</timestamp>
      <contributor>
        <username>UsuallyNonviolentBot</username>
        <id>31197275</id>
      </contributor>
      <minor/>
      <comment>/* top */Remove deprecated parameter $N from [[Module:Unsubst]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="461" xml:space="preserve">{{ {{{|safesubst:}}}#invoke:Unsubst||date=__DATE__ |$B=
&lt;!--{{Specify}} begin--&gt;{{Fix
| subst = &lt;includeonly&gt;{{subst:substcheck}}&lt;/includeonly&gt;
| link  = Wikipedia:Citing sources
| text  = specify
| title = {{delink|{{{reason|Statement needs to be more specific about the content to which it refers.}}}}}
| date  = {{{date|}}}
| cat   = [[Category:Articles needing more detailed references]]
}}&lt;!--{{Specify}} end--&gt;
}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>e72dpquwi2w9czf2cetba98qeywfl00</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Catalog lookup link</title>
    <ns>828</ns>
    <id>57923154</id>
    <revision>
      <id>884931331</id>
      <parentid>871035268</parentid>
      <timestamp>2019-02-24T22:51:20Z</timestamp>
      <contributor>
        <username>Swarm</username>
        <id>7274040</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Module:Catalog lookup link]]": [[WP:High-risk templates|Highly visible template]] - match to template ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="9510" xml:space="preserve">--[[
|1=, |2=, |3=, |4=, |5=, |6=, |7=, |8=, |9=: Optional unnamed parameters for 0 to 9 items to be listed.
	Whitespace is trimmed off both ends and the strings are urlencoded as if they were query strings.
|article-link=: Optional Wikipedia article name to link to.
|article-name=: Optional alternative text to be displayed for |article-link= link in front of catalog link.
	If not specified, |article-link= is used for display as well. If both parameters are not specified, the prefix is omitted completely.
|article-suffix=: Optional symbol to be displayed after article name or link (f.e. ":"; omitted, if not defined).
|link-prefix=: Optional prefix portion of url to external catalog item(s).
|link-suffix=: Optional suffix portion of url to external catalog item(s).
|item-prefix=: Optional text displayed in front of each external link (omitted, if not defined)
|item-suffix=: Optional text displayed immediately after each external link (omitted, if not defined)
|list-separator=: Optional alternative separator displayed between list items (default: ", ", if not specified). Whitespace must be encoded.
|list-leadout=: Optional alternative leadout text displayed between the last two list items (f.e. "and", "or", "as well as", etc., default is the |list-separator= or ", ".)
|leadout-suffix=: Optional alternative suffix text of the leadout (see |list-leadout=) displayed between the last two list items.
	This gets added in front of the last list item instead of the default whitespace which is added without this parameter.
	This may be necessary if |list-separator= is used not only to define the list separator but also parts of the item prefix
	(except for the first one). (At present, this is used only to cope with format oddities of the {{MR}} template.)


new parameters that support access icons:
|allowed_icons= – comma-separated list of keywords: free, limited, registration, subscription, none, all (default; 'all' implied when this parameter empty or omitted)
	the icons specified in the following parameters are checked agains the list in |allowed-icons=; not in the list? not displayed
|url-access-all= – applies specified icon to all items in the list; accepted keywords: free, limited, registration, subscription;
|url-accessn= – applies specified icon to item n of the list (the nth positional parameter); accepted keywords: free, limited, registration, subscription;

]]

require('Module:No globals');
local getArgs = require ('Module:Arguments').getArgs;
local lock_icons = {															--icon classes are defined in Module:Citation/CS1/styles.css
	['free'] = {'cs1-lock-free', 'Freely accessible'},
	['registration'] = {'cs1-lock-registration', 'Free registration required'},
	['limited'] = {'cs1-lock-limited', 'Free access subject to limited trial, subscription normally required'},
	['subscription'] = {'cs1-lock-subscription', 'Paid subscription required'},
	}


--[[--------------------------&lt; I S _ S E T &gt;------------------------------------------------------------------

Returns true if argument is set; false otherwise. Argument is 'set' when it exists (not nil) or when it is not an empty string.

]]

local function is_set( var )
	return not (var == nil or var == '');
end


--[=[-------------------------&lt; M A K E _ L A B E L &gt;----------------------------------------------------------

Makes a wikilinked or plain text label from arguments; when both link and display text is provided, makes a
wikilink in the form [[L|D]]; if only link is provided, makes a wikilinked label in the form [[L]]; if only display
is provided, makes a plain-text label; if neither are provided makes a label from suffix, returns an empty string else.

]=]

local function make_label (link, display, suffix)
local label = '';
	if is_set (link) then
		if is_set (display) then
			label = table.concat ({'[[', link, '|', display, ']]'});			-- make [[L|D]] wikilinked label
		else
			label = table.concat ({'[[', link, ']]'});							-- make [[L]] wikilinked label
		end
	elseif is_set (display) then
		label = display;														-- plain-text label
	end

	if is_set (label) then														
		return table.concat ({label, suffix, '&amp;nbsp;'});						-- assemble the complete label
	else
		return suffix;															-- no space after suffix if no label
	end
end


--[[--------------------------&lt; I C O N _ I N D E X _ G E T &gt;--------------------------------------------------

returns index into lock_icons[] if value assigned to |url-access= or |url-access-all= is a valid icon selector
(free, limited, registration, subscription)

icon selection may be limited to a subset of the icons with:
	|allow_icons=&lt;comma-separated list of allowed icons&gt;
&lt;comma-separated list of allowed icons&gt; may be any of the keywords: free, limited, registration, subscription, none, all

keyword 'all' is default condition; 'all' is implied when |allowed=icons= is empty or omitted

keyword 'none' for use with identifiers where icons are inappropriate (isbn, issn, oclc)

Templates using this module should set:
	|allow_icons=free for most identifiers;
	|allow_icons=none for isbn, issn, oclc, etc

|url-access= is alias of |url-access1=

]]

local function icon_index_get (args, k)
	local icon;
	local param_name = (1 == k and is_set (args['url-access']) and 'url-access') or table.concat ({'url-access', k});	-- make an enumerated parameter name

	if is_set (args['url-access-all']) and lock_icons[args['url-access-all']] then	-- if set and valid
		icon = args['url-access-all'];											-- tentatively 

	elseif is_set (args[param_name]) and lock_icons[args[param_name]] then		-- if set and valid
		icon = args[param_name];												-- tentatively

	else
		return nil;																-- neither |url-access-all= nor |url-accessn= set so return nil
	end

	if args['allow_icons'] and args['allow_icons']:find ('none') then			-- if 'none' keyword is present
		return nil;																-- icons display not allowed
	end

	if not is_set (args['allow_icons']) or args['allow_icons']:find ('all') or args['allow_icons']:find (icon) then	--if all allowed or specified icon is allowed
		return icon;															-- return selected icon as index into icon table
	end
end


--[[--------------------------&lt; M A I N &gt;----------------------------------------------------------------------

Template entrypoint to this module; arguments come primarily from the parent frame though in templates that use
this module, |allowed-icons= is typically set, if needed, in the {{#invoke:}}.

]]

local function main (frame)
	local args = getArgs (frame);
	local out_text = '';

	if is_set(args[1]) then
		local result = {};
		local label;
		
		local article_suffix = args['article-suffix'] or args['article-postfix'] or '';
		local link_prefix = args['link-prefix'] or '';
		local link_suffix = args['link-suffix'] or args['link-postfix'] or '';
		local item_prefix = args['item-prefix'] or '';
		local item_suffix = args['item-suffix'] or args['item-postfix'] or '';
		local list_separator = args['list-separator'] or ', ';
		local leadout_suffix = args['leadout-suffix'] or args['leadout-postfix'] or ' ';
		local list_leadout;

		local icon_index;
		
		if is_set (args['list-leadout']) then
			list_leadout = table.concat ({
				mw.ustring.gsub (args['list-leadout'], '^(%a)', ' %1'),			-- insert leading space if first character is a letter
				leadout_suffix,
			});
		else
			list_leadout = '';
		end
		
		label = make_label (args['article-link'], args['article-name'], article_suffix);

		for k, item in ipairs (args) do											-- for each of the positional parameters
			item = mw.text.trim (item);											-- remove extraneous whitespace
			if is_set (link_prefix) then										-- if there is link prefix...
				item = table.concat ({											-- create an external link item
					'[',														-- open ext link markup
					link_prefix,												-- url prefix
					mw.uri.encode (item),										-- item is part of url
					link_suffix,												-- url suffix
					' ',														-- required space between url and label
					item_prefix,												-- label prefix
					item,														-- item as label
					item_suffix,												-- item suffix
					']'															-- close ext link markup
				});

				icon_index = icon_index_get (args, k);							-- set if icon specified and allowed for this item; nil else
				if icon_index then
					item = table.concat ({										-- add access icon markup to this item
						'&lt;span class="',										-- open the opening span tag; icon classes are defined in Module:Citation/CS1/styles.css
						lock_icons[icon_index][1],								-- add the appropriate lock icon class
						'" title="',											-- and the title attribute
						lock_icons[icon_index][2],								-- for an appropriate tool tip
						'"&gt;',													-- close the opening span tag
						item,
						'&lt;/span&gt;',												-- and close the span
					});
				end	
			else
				item = table.concat ({											-- create an unlinked item
					item_prefix,												-- label prefix
					item,														-- item as label
					item_suffix,												-- item suffix
				});
			end
	
			table.insert (result, item);										-- add the item to the result list
		end
	
		if is_set (args['list-leadout']) then
			out_text = table.concat ({label, mw.text.listToText (result, list_separator, list_leadout)});
		else
			out_text = table.concat ({label, table.concat (result, list_separator)});
		end

	end	--is_set (args[1])
	
	return out_text
end

return {main = main};</text>
      <sha1>n299uh6h04ym5bcsx9iehhpn6bdllyn</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Distinguish</title>
    <ns>828</ns>
    <id>50437969</id>
    <revision>
      <id>833561758</id>
      <parentid>833559553</parentid>
      <timestamp>2018-04-01T10:06:10Z</timestamp>
      <contributor>
        <username>Galobtter</username>
        <id>19502780</id>
      </contributor>
      <comment>fixed with text and selfref</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="897" xml:space="preserve">local mHatnote = require('Module:Hatnote')
local mHatlist = require('Module:Hatnote list')
local mArguments --initialize lazily
local mTableTools --initialize lazily
local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType
local p = {}

function p.distinguish(frame)
	mArguments = require('Module:Arguments')
	mTableTools = require('Module:TableTools')
	local args = mArguments.getArgs(frame)
	local selfref = args.selfref
	local text = args.text
	args = mTableTools.compressSparseArray(args)
	return p._distinguish(args, text, selfref)
end

function p._distinguish(args, text, selfref)
	checkType("_distinguish", 1, args, 'table')
	if #args == 0 and not text then return '' end
	local text = string.format(
		'Not to be confused with %s.',
		text or mHatlist.orList(args, true)
	)
	hnOptions = {selfref = selfref}
	return mHatnote._hatnote(text, hnOptions)
end

return p</text>
      <sha1>0e9s40s10w9aih1qwh96v3jypzotm48</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Portal</title>
    <ns>828</ns>
    <id>38965350</id>
    <revision>
      <id>936638108</id>
      <parentid>916435633</parentid>
      <timestamp>2020-01-20T02:26:25Z</timestamp>
      <contributor>
        <username>Izno</username>
        <id>2927383</id>
      </contributor>
      <comment>per tper</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="13773" xml:space="preserve">--[==[ This module is a Lua implementation of the old {{Portal}} template. As of February 2019 it is used on nearly 7,900,000 articles.
-- Please take care when updating it! It outputs two functions: p.portal, which generates a list of portals, and p.image, which
-- produces the image name for an individual portal.

-- The portal image data is kept in submodules of [[Module:Portal/images]], listed below:
-- [[Module:Portal/images/a]]		- for portal names beginning with "A".
-- [[Module:Portal/images/b]]		- for portal names beginning with "B".
-- [[Module:Portal/images/c]]		- for portal names beginning with "C".
-- [[Module:Portal/images/d]]		- for portal names beginning with "D".
-- [[Module:Portal/images/e]]		- for portal names beginning with "E".
-- [[Module:Portal/images/f]]		- for portal names beginning with "F".
-- [[Module:Portal/images/g]]		- for portal names beginning with "G".
-- [[Module:Portal/images/h]]		- for portal names beginning with "H".
-- [[Module:Portal/images/i]]		- for portal names beginning with "I".
-- [[Module:Portal/images/j]]		- for portal names beginning with "J".
-- [[Module:Portal/images/k]]		- for portal names beginning with "K".
-- [[Module:Portal/images/l]]		- for portal names beginning with "L".
-- [[Module:Portal/images/m]]		- for portal names beginning with "M".
-- [[Module:Portal/images/n]]		- for portal names beginning with "N".
-- [[Module:Portal/images/o]]		- for portal names beginning with "O".
-- [[Module:Portal/images/p]]		- for portal names beginning with "P".
-- [[Module:Portal/images/q]]		- for portal names beginning with "Q".
-- [[Module:Portal/images/r]]		- for portal names beginning with "R".
-- [[Module:Portal/images/s]]		- for portal names beginning with "S".
-- [[Module:Portal/images/t]]		- for portal names beginning with "T".
-- [[Module:Portal/images/u]]		- for portal names beginning with "U".
-- [[Module:Portal/images/v]]		- for portal names beginning with "V".
-- [[Module:Portal/images/w]]		- for portal names beginning with "W".
-- [[Module:Portal/images/x]]		- for portal names beginning with "X".
-- [[Module:Portal/images/y]]		- for portal names beginning with "Y".
-- [[Module:Portal/images/z]]		- for portal names beginning with "Z".
-- [[Module:Portal/images/other]]	- for portal names beginning with any other letters. This includes numbers,
-- 									  letters with diacritics, and letters in non-Latin alphabets.
-- [[Module:Portal/images/aliases]]	- for adding aliases for existing portal names. Use this page for variations
-- 									  in spelling and diacritics, etc., no matter what letter the portal begins with.
--
-- The images data pages are separated by the first letter to reduce server load when images are added, changed, or removed.
-- Previously all the images were on one data page at [[Module:Portal/images]], but this had the disadvantage that all
-- 5,000,000 pages using this module needed to be refreshed every time an image was added or removed.
]==]

local p = {}

local trackingEnabled = true

local templatestyles = 'Module:Portal/styles.css'

-- Check whether to do tracking in this namespace
-- Returns true unless the page is one of the banned namespaces
local function checkTrackingNamespace()
	local thisPage = mw.title.getCurrentTitle()
	if (thisPage.namespace == 1) -- Talk
		or (thisPage.namespace == 2) -- User
		or (thisPage.namespace == 3) -- User talk
		or (thisPage.namespace == 5) -- Wikipedia talk
		or (thisPage.namespace == 7) -- File talk
		or (thisPage.namespace == 11) -- Template talk
		or (thisPage.namespace == 15) -- Category talk
		or (thisPage.namespace == 101) -- Portal talk
		or (thisPage.namespace == 109) -- Book talk
		or (thisPage.namespace == 118) -- Draft
		or (thisPage.namespace == 119) -- Draft talk
		or (thisPage.namespace == 829) -- Module talk
		then
		return false
	end
	return true
end

-- Check whether to do tracking on this pagename
-- Returns false if the page title matches one of the banned strings
-- Otherwise returns true
local function checkTrackingPagename()
	local thisPage = mw.title.getCurrentTitle()
	local thisPageLC = mw.ustring.lower(thisPage.text)
	if (string.match(thisPageLC, "/archive") ~= nil) then
		return false
	end
	if (string.match(thisPageLC, "/doc") ~= nil) then
		return false
	end
	if (string.match(thisPageLC, "/test") ~= nil) then
		return false
	end
	return true
end


local function matchImagePage(s)
	-- Finds the appropriate image subpage given a lower-case
	-- portal name plus the first letter of that portal name.
	if type(s) ~= 'string' or #s &lt; 1 then return end
	local firstLetter = mw.ustring.sub(s, 1, 1)
	local imagePage
	if mw.ustring.find(firstLetter, '^[a-z]') then
		imagePage = 'Module:Portal/images/' .. firstLetter
	else
		imagePage = 'Module:Portal/images/other'
	end
	return mw.loadData(imagePage)[s]
end

local function getAlias(s)
	-- Gets an alias from the image alias data page.
	local aliasData = mw.loadData('Module:Portal/images/aliases')
	for portal, aliases in pairs(aliasData) do
		for _, alias in ipairs(aliases) do
			if alias == s then
				return portal
			end
		end
	end
end

local function getImageName(s)
	-- Gets the image name for a given string.
	local default = 'Portal-puzzle.svg|link=|alt='
	if type(s) ~= 'string' or #s &lt; 1 then
		return default
	end
	s = mw.ustring.lower(s)
	return matchImagePage(s) or matchImagePage(getAlias(s)) or default
end

local function checkPortalExists(portal)
	return not (mw.title.makeTitle(100, portal).id == 0)
end

function p._portal(portals, args)
	-- This function builds the portal box used by the {{portal}} template.
	local root = mw.html.create('div')
		:attr('role', 'navigation')
		:attr('aria-label', 'Portals')
		:addClass('noprint portal plainlist')
		:addClass(args.left and 'tleft' or 'tright')
		:css('margin', args.margin or nil)
		:newline()

	-- Tracking is on by default.
	-- It is disabled if any of the following is true
	-- 1/ the parameter "tracking" is set to 'no, 'n', or 'false'
	-- 2/ the current page fails the namespace tests in checkTrackingNamespace()
	-- 3/ the current page fails the pagename tests in checkTrackingPagename()
	if (args.tracking == 'no') or (args.tracking == 'n') or (args.tracking == 'false') then
		trackingEnabled = false
	end
	if (checkTrackingNamespace() == false) then
		trackingEnabled = false
	end
	if (checkTrackingPagename() == false) then
		trackingEnabled = false
	end

	-- If no portals have been specified, display an error and add the page to a tracking category.
	if not portals[1] then
		if (args.nominimum == 'yes') or (args.nominimum == 'y') or (args.nominimum == 'true') then
		-- if nominimum as been set to yes (or similar), omit the warning
			
		else
			root:wikitext('&lt;strong class="error"&gt;No portals specified: please specify at least one portal&lt;/strong&gt;')
		end
		if (trackingEnabled) then
			root:wikitext('[[Category:Portal templates without a parameter]]')
		end
		return tostring(root)
	end
	
	-- scan for nonexistent portals, if they exist remove them from the portals table. If redlinks=yes, then don't remove
	local portallen = #portals
	-- traverse the list backwards to ensure that no portals are missed (table.remove also moves down the portals in the list, so that the next portal isn't checked if going fowards.
	-- going backwards allows us to circumvent this issue
	for i=portallen,1,-1 do
		-- the use of pcall here catches any errors that may occour when attempting to locate pages when the page name is invalid
		-- if pcall returns true, then rerun the function to find if the page exists
		if not pcall(checkPortalExists, portals[i]) or not checkPortalExists(portals[i]) then
			-- Getting here means a redlinked portal has been found
			if (args.redlinks == 'yes') or (args.redlinks == 'y') or (args.redlinks == 'true') or (args.redlinks == 'include') then
				-- if redlinks as been set to yes (or similar), add the cleanup category and then break the loop before the portal is removed from the list
				if (trackingEnabled) then
					root:wikitext('[[Category:Portal templates with redlinked portals]]')
				end
				break
			end
			-- remove the portal (this does not happen if redlinks=yes)
			table.remove(portals,i)
		end
	end
	
	-- if the length of the table is different, then rows were removed from the table, so portals were removed. If this is the case add the cleanup category
	if not (portallen == #portals) then
		if (trackingEnabled) then
			if #portals == 0 then
				return '[[Category:Portal templates with all redlinked portals]]'
			else
				root:wikitext('[[Category:Portal templates with redlinked portals]]')
			end
		end
	end

	-- Start the list. This corresponds to the start of the wikitext table in the old [[Template:Portal]].
	local listroot = root:tag('ul')
		:css('width', type(args.boxsize) == 'string' and (args.boxsize .. 'px') or nil)

	-- Display the portals specified in the positional arguments.
	for _, portal in ipairs(portals) do
		local image = getImageName(portal)

		-- Generate the html for the image and the portal name.
		listroot
			:newline()
			:tag('li')
				:tag('span')
					:wikitext(string.format('[[File:%s|32x28px|class=noviewer]]', image))
					:done()
				:tag('span')
					:wikitext(string.format('[[Portal:%s|%s%sportal]]', portal, portal, args['break'] and '&lt;br /&gt;' or ' '))
	end
	return tostring(root)
end

function p._image(portals)
	-- Wrapper function to allow getImageName() to be accessed through #invoke.
	local name = getImageName(portals[1])
	return name:match('^(.-)|') or name -- FIXME: use a more elegant way to separate borders etc. from the image name
end

local function getAllImageTables()
	-- Returns an array containing all image subpages (minus aliases) as loaded by mw.loadData.
	local images = {}
	for i, subpage in ipairs{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'other'} do
		images[i] = mw.loadData('Module:Portal/images/' .. subpage)
	end
	return images
end

function p._displayAll(portals, args)
	-- This function displays all portals that have portal images. This function is for maintenance purposes and should not be used in
	-- articles, for two reasons: 1) there are over 1500 portals with portal images, and 2) the module doesn't record how the portal
	-- names are capitalized, so the portal links may be broken.
	local lang = mw.language.getContentLanguage()
	local count = 1
	for _, imageTable in ipairs(getAllImageTables()) do
		for portal in pairs(imageTable) do
			portals[count] = lang:ucfirst(portal)
			count = count + 1
		end
	end
	return p._portal(portals, args)
end

function p._imageDupes()
	-- This function searches the image subpages to find duplicate images. If duplicate images exist, it is not necessarily a bad thing,
	-- as different portals might just happen to choose the same image. However, this function is helpful in identifying images that
	-- should be moved to a portal alias for ease of maintenance.
	local exists, dupes = {}, {}
	for _, imageTable in ipairs(getAllImageTables()) do
		for portal, image in pairs(imageTable) do
			if not exists[image] then
				exists[image] = portal
			else
				table.insert(dupes, string.format('The image "[[:File:%s|%s]]" is used for both portals "%s" and "%s".', image, image, exists[image], portal))
			end
		end
	end
	if #dupes &lt; 1 then
		return 'No duplicate images found.'
	else
		return 'The following duplicate images were found:\n* ' .. table.concat(dupes, '\n* ')
	end
end

local function processPortalArgs(args)
	-- This function processes a table of arguments and returns two tables: an array of portal names for processing by ipairs, and a table of
	-- the named arguments that specify style options, etc. We need to use ipairs because we want to list all the portals in the order
	-- they were passed to the template, but we also want to be able to deal with positional arguments passed explicitly, for example
	-- {{portal|2=Politics}}. The behaviour of ipairs is undefined if nil values are present, so we need to make sure they are all removed.
	args = type(args) == 'table' and args or {}
	local portals = {}
	local namedArgs = {}
	for k, v in pairs(args) do
		if type(k) == 'number' and type(v) == 'string' then -- Make sure we have no non-string portal names.
			table.insert(portals, k)
		elseif type(k) ~= 'number' then
			namedArgs[k] = v
		end
	end
	table.sort(portals)
	for i, v in ipairs(portals) do
		portals[i] = args[v]
	end
	return portals, namedArgs
end

local function makeWrapper(funcName)
	-- Processes external arguments and sends them to the other functions.
	return function (frame)
		-- If called via #invoke, use the args passed into the invoking
		-- template, or the args passed to #invoke if any exist. Otherwise
		-- assume args are being passed directly in from the debug console
		-- or from another Lua module.
		local origArgs
		if type(frame.getParent) == 'function' then
			origArgs = frame:getParent().args
			for k, v in pairs(frame.args) do
				origArgs = frame.args
				break
			end
		else
			origArgs = frame
		end
		-- Trim whitespace and remove blank arguments.
		local args = {}
		for k, v in pairs(origArgs) do
			if type(v) == 'string' then
				v = mw.text.trim(v)
			end
			if v ~= '' then
				args[k] = v
			end
		end
		
		local results = ''
		if funcName == '_portal' or funcName == '_displayAll' then
			results = frame:extensionTag{ name = 'templatestyles', args = { src = templatestyles} }
		end
		return results .. p[funcName](processPortalArgs(args)) -- passes two tables to func: an array of portal names, and a table of named arguments.
	end
end

for _, funcName in ipairs{'portal', 'image', 'imageDupes', 'displayAll'} do
	p[funcName] = makeWrapper('_' .. funcName)
end

return p</text>
      <sha1>d228q5eahsty3jgixxfb7nnw68be9y1</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Portal/images/f</title>
    <ns>828</ns>
    <id>40416149</id>
    <revision>
      <id>905492315</id>
      <parentid>905492111</parentid>
      <timestamp>2019-07-09T13:20:57Z</timestamp>
      <contributor>
        <username>Xaosflux</username>
        <id>502540</id>
      </contributor>
      <comment>["fantasy"] = "Masked man.svg|link=|alt=icon",</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="7678" xml:space="preserve">--[==[ This is the "F" list of portal image names. It contains a list of portal images for use with [[Module:Portal]]
-- for portal names that start with the letter "F". For aliases to existing portal names, and for portal names that
-- start with other letters, please use the appropriate page from the following list:
 
-- [[Module:Portal/images/a]]       - for portal names beginning with "A".
-- [[Module:Portal/images/b]]       - for portal names beginning with "B".
-- [[Module:Portal/images/c]]       - for portal names beginning with "C".
-- [[Module:Portal/images/d]]       - for portal names beginning with "D".
-- [[Module:Portal/images/e]]       - for portal names beginning with "E".
-- [[Module:Portal/images/g]]       - for portal names beginning with "G".
-- [[Module:Portal/images/h]]       - for portal names beginning with "H".
-- [[Module:Portal/images/i]]       - for portal names beginning with "I".
-- [[Module:Portal/images/j]]       - for portal names beginning with "J".
-- [[Module:Portal/images/k]]       - for portal names beginning with "K".
-- [[Module:Portal/images/l]]       - for portal names beginning with "L".
-- [[Module:Portal/images/m]]       - for portal names beginning with "M".
-- [[Module:Portal/images/n]]       - for portal names beginning with "N".
-- [[Module:Portal/images/o]]       - for portal names beginning with "O".
-- [[Module:Portal/images/p]]       - for portal names beginning with "P".
-- [[Module:Portal/images/q]]       - for portal names beginning with "Q".
-- [[Module:Portal/images/r]]       - for portal names beginning with "R".
-- [[Module:Portal/images/s]]       - for portal names beginning with "S".
-- [[Module:Portal/images/t]]       - for portal names beginning with "T".
-- [[Module:Portal/images/u]]       - for portal names beginning with "U".
-- [[Module:Portal/images/v]]       - for portal names beginning with "V".
-- [[Module:Portal/images/w]]       - for portal names beginning with "W".
-- [[Module:Portal/images/x]]       - for portal names beginning with "X".
-- [[Module:Portal/images/y]]       - for portal names beginning with "Y".
-- [[Module:Portal/images/z]]       - for portal names beginning with "Z".
-- [[Module:Portal/images/other]]   - for portal names beginning with any other letters. This includes numbers,
--                                    letters with diacritics, and letters in non-Latin alphabets.
-- [[Module:Portal/images/aliases]] - for adding aliases for existing portal names. Use this page for variations
--                                    in spelling and diacritics, etc., no matter what letter the portal begins with.
 
-- When adding entries, please use alphabetical order. The format of the images table entries is as follows:
--          ["portal name"] = "image.svg",
-- The portal name should be the name of your portal, in lower case. For example, the portal name for 
-- "Portal:United Kingdom" would be "united kingdom". The image name should be capitalised normally, and the "File:"
-- namespace prefix should be omitted.
]==]
 
return {
	["faisalabad"] = "Flag of Punjab.svg|border|link=|alt=flag",
	["falkland islands"] = "Flag of the Falkland Islands.svg|border|link=|alt=flag",
	["falun gong"] = "Falun Gong Logo.svg|alt=icon",
	["family guy"] = "Family Guy television set.svg|alt=icon",
	["fantasy"] = "Masked man.svg|link=|alt=icon",
	["faroe islands"] = "Flag of the Faroe Islands.svg|border|link=|alt=flag",
	["fascism"] = "Fasces lictoriae.svg|link=|alt=",
	["fashion"] = "BathingSuit1920s.jpg|link=|alt=",
	["fast food"] = "Fries.svg|link=|alt=",
	["fatimid caliphate"] = "Calif al Muizz Misr Cairo 969 CE.png|alt=logo",
	["fbi"] = "Seal of the Federal Bureau of Investigation.svg|link=|alt=seal",
	["federated states of micronesia"] = "Flag of the Federated States of Micronesia.svg|border|link=|alt=flag",
	["feminism"] = "Woman-power emblem.svg|link=|alt=",
	["fencing"] = "Fencing pictogram.svg|link=|alt=",
	["fergie (singer)"] = "Fergie 2012.png|alt=icon",
	["ferrari"] = "Scarsdale Concours Enzo 2.jpg|alt=icon",
	["fictional characters"] = "Friendly stickman.svg|link=|alt=",
	["figure skating"] = "Figure-skates-1.jpg|link=|alt=",
	["fiji"] = "Flag of Fiji.svg|border|link=|alt=flag",
	["film"] = "Video-x-generic.svg|link=|alt=",
	["film in the united states"] = "United States film.svg|alt=icon",
	["film/canadian cinema task force"] = "Canadafilm.svg|alt=icon",
	["final fantasy"] = "Final Fantasy wordmark.svg|link=|alt=",
	["finance"] = "10k Coins.png|border|link=|alt=flag",
	["finger lakes"] = "Fingerlakesmap2.PNG|alt=icon",
	["finland"] = "Flag of Finland.svg|border|link=|alt=flag",
	["fire"] = "Large bonfire.jpg|alt=icon",
	["fish"] = "Antennarius striatus.jpg|link=|alt=",
	["fishing"] = "Fish icon.svg|link=|alt=",
	["flatbread"] = "Fladenbrot-2.jpg|link=|alt=",
	["flatbreads"] = "Fladenbrot-2.jpg|link=|alt=",
	["florence"] = "FlorenceCoA.svg|alt=icon",
	["florida"] = "Flag of Florida.svg|border|link=|alt=flag",
	["florida international university"] = "Florida International University FIU logo.svg|link=|alt=logo",
	["flute"] = "Flute (1843) - The Noun Project.svg|link=|alt=",
	["flutes"] = "Flute (1843) - The Noun Project.svg|link=|alt=",
	["flutes and whistles"] = "Flute (1843) - The Noun Project.svg|link=|alt=",
	["folklore"] = "Horseshoe and devil.svg|link=|alt=",
	["food"] = "Foodlogo2.svg|alt=icon",
	["food preservation"] = "Boite de conserve.svg|link=|alt=",
	["football in africa"] = "Africa Football 3.svg|link=|alt=",
	["football in argentina"] = "ArgentinaFootball.png|link=|alt=",
	["football in germany"] = "Football Germany.png|link=|alt=icon",
	["football in india"] = "Football India.png|link=|alt=icon",
	["fordham university"] = "Initial fordham.svg|link=|alt=",
	["forestry"] = "Pine forest in Sweden.jpg|alt=icon",
	["formula one"] = "Motorsport current event.svg|alt=icon",
	["france"] = "Flag of France.svg|border|link=|alt=flag",
	["franco-americans"] = "Drapeau Franco-Américain.svg|border|alt=icon",
	["frank zappa"] = "Zappa.jpg|alt=icon",
	["free and open-source software"] = "Free and open-source software logo (2009).svg|link=|alt=",
	["freedom of speech"] = "Sample 09-F9 protest art, Free Speech Flag by John Marcotte.svg|link=|alt=",
	["freemasonry"] = "Square compasses.svg|alt=icon",
	["french"] = "New-Map-Francophone World.PNG|border|link=|alt=map",
	["french africa"] = "Flag of France.svg|border|link=|alt=flag",
	["french and francophone literature"] = "Open book nae French flag.png|link=|alt=",
	["french guiana"] = "Flag of French Guiana.svg|border|link=|alt=flag",
	["french language and french-speaking world"] = "New-Map-Francophone World.PNG|link=|alt=",
	["french military history"] = "Flag of France.svg|border|link=|alt=flag",
	["french politics"] = "Hémicycle 2 Palais Bourbon scropped and smaller.jpg|alt=icon",
	["french polynesia"] = "Flag of French Polynesia.svg|border|link=|alt=flag",
	["french southern and antarctic lands"] = "Flag of the French Southern and Antarctic Lands.svg|border|link=|alt=flag",
	["friends"] = "Friends logo.svg|link=|alt=",
	["frogs"] = "Variegated golden frog (Mantella baroni) Ranomafana.jpg|link=|alt=",
	["frogs and toads"] = "Variegated golden frog (Mantella baroni) Ranomafana.jpg|link=|alt=",
	["fruit"] = "Apples and Bananas.JPG|link=|alt=",
	["fruits"] = "Apples and Bananas.JPG|link=|alt=",
	["fujairah"] = "Flag of Fujairah.svg|border|link=|alt=flag",
	["fungi"] = "Karl Johanssvamp, Iduns kokbok.png|link=|alt=",
	["furry"] = "Furry blue paw logo.png|alt=icon",
	["futurama"] = "Futurama flag of Earth.svg|border|link=|alt=flag",
	["futures studies"] = "Stanford Torus interior.jpg|link=|alt=illustration"
}</text>
      <sha1>ckgg5mb30bb5109vns7a1tmehv3p1k1</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Portal bar</title>
    <ns>828</ns>
    <id>40526099</id>
    <revision>
      <id>916435756</id>
      <parentid>915718426</parentid>
      <timestamp>2019-09-18T22:21:28Z</timestamp>
      <contributor>
        <username>BrownHairedGirl</username>
        <id>754619</id>
      </contributor>
      <comment>add Book talk to list of banned namespaces</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6948" xml:space="preserve">-- This module implements {{portal bar}}.

require('Module:No globals')

local p = {}
local function checkPortalExists(portal)
	return not (mw.title.makeTitle(100, portal).id == 0)
end
local getImageName = require( 'Module:Portal' ).image
local yesno = require( 'Module:Yesno' )

local trackingEnabled = true

-- Check whether to do tracking in this namespace
-- Returns true unless the page is one of the banned namespaces
local function checkTrackingNamespace()
	local thisPage = mw.title.getCurrentTitle()
	if (thisPage.namespace == 1) -- Talk
		or (thisPage.namespace == 2) -- User
		or (thisPage.namespace == 3) -- User talk
		or (thisPage.namespace == 5) -- Wikipedia talk
		or (thisPage.namespace == 7) -- File talk
		or (thisPage.namespace == 11) -- Template talk
		or (thisPage.namespace == 15) -- Category talk
		or (thisPage.namespace == 101) -- Portal talk
		or (thisPage.namespace == 109) -- Book talk
		or (thisPage.namespace == 118) -- Draft
		or (thisPage.namespace == 119) -- Draft talk
		or (thisPage.namespace == 829) -- Module talk
		then
		return false
	end
	return true
end

-- Check whether to do tracking on this pagename
-- Returns false if the page title matches one of the banned strings
-- Otherwise returns true
local function checkTrackingPagename()
	local thisPage = mw.title.getCurrentTitle()
	local thisPageLC = mw.ustring.lower(thisPage.text)
	if (string.match(thisPageLC, "/archive") ~= nil) then
		return false
	end
	if (string.match(thisPageLC, "/doc") ~= nil) then
		return false
	end
	if (string.match(thisPageLC, "/test") ~= nil) then
		return false
	end
	return true
end


-- Builds the portal bar used by {{portal bar}}.
function p._main( portals, args )
	
	if #portals &lt; 1 then return '' end -- Don't display a blank navbox if no portals were specified.
	
	local nav = mw.html.create( 'div' )
		:addClass( 'noprint metadata' )
		:attr( 'role', 'navigation' )
		:attr( 'aria-label' , 'Portals' )
		:css( 'font-weight', 'bold' )
	if yesno( args.border ) == false then
		nav
			:css( 'padding', '0.3em 1.7em 0.1em' )
			:css( 'font-size', '88%' )
			:css( 'text-align', 'center' )
	else
		nav
			:addClass( 'navbox' )
			:css( 'padding', '0.4em 2em' )
	end
	
	if (args.tracking == 'no') or (args.tracking == 'n') or (args.tracking == 'false') then
		trackingEnabled = false
	end
	if (checkTrackingNamespace() == false) then
		trackingEnabled = false
	end
	if (checkTrackingPagename() == false) then
		trackingEnabled = false
	end

	-- If no portals have been specified, display an error and add the page to a tracking category.
	if not portals[1] then
		if (args.nominimum == 'yes') or (args.nominimum == 'y') or (args.nominimum == 'true') then
		-- if nominimum as been set to yes (or similar), omit the warning
			
		else
			root:wikitext('&lt;strong class="error"&gt;No portals specified: please specify at least one portal&lt;/strong&gt;')
		end
		if (trackingEnabled) then
			root:wikitext('[[Category:Portal templates without a parameter]]')
		end
		return tostring(root)
	end

	-- scan for nonexistent portals, if they exist remove them from the portals table. If redlinks=yes, then don't remove
	local portallen = #portals
	-- traverse the list backwards to ensure that no portals are missed (table.remove also moves down the portals in the list, so that the next portal isn't checked if going fowards.
	-- going backwards allows us to circumvent this issue
	for i=portallen,1,-1 do
		-- the use of pcall here catches any errors that may occour when attempting to locate pages when the page name is invalid
		-- if pcall returns true, then rerun the function to find if the page exists
		if not pcall(checkPortalExists, portals[i]) or not checkPortalExists(portals[i]) then
			-- Getting here means a redlinked portal has been found
			if (args.redlinks == 'yes') or (args.redlinks == 'y') or (args.redlinks == 'true') or (args.redlinks == 'include') then
				-- if redlinks as been set to yes (or similar), add the cleanup category and then break the loop before the portal is removed from the list
				if trackingEnabled then
					nav:wikitext('[[Category:Portal templates with redlinked portals]]')
				end
				break
			end
			-- remove the portal (this does not happen if redlinks=yes)
			table.remove(portals,i)
		end
	end
	
	-- if the length of the table is different, then rows were removed from the table, so portals were removed. If this is the case add the cleanup category
	if not (portallen == #portals) then
		if #portals == 0 then
        	if trackingEnabled then
				return '[[Category:Portal templates with all redlinked portals]]'
			else
				return ""
			end
        end
		if trackingEnabled then
			nav:wikitext('[[Category:Portal templates with redlinked portals]]')
		end
	end
	
	local list = mw.html.create( 'ul' )
		:css( 'margin', '0.1em 0 0' )
	for _, portal in ipairs( portals ) do
		list
			:tag( 'li' )
				:css( 'display', 'inline' )
				:tag( 'span' ) -- Inline-block on inner span for IE6-7 compatibility.
					:css( 'display', 'inline-block' )
					:css( 'white-space', 'nowrap' )
					:tag( 'span' )
						:css( 'margin', '0 0.5em' )
						:wikitext( string.format( '[[File:%s|24x21px]]', getImageName{ portal } ) )
						:done()
					:wikitext( string.format( '[[Portal:%s|%s portal]]', portal, portal ) )
	end
	
	nav
		:node( list )
	
	return tostring( nav )
end

-- Processes external arguments and sends them to the other functions.
function p.main( frame )
	-- If called via #invoke, use the args passed into the invoking
	-- template, or the args passed to #invoke if any exist. Otherwise
	-- assume args are being passed directly in from the debug console
	-- or from another Lua module.
	local origArgs
	if type( frame.getParent ) == 'function' then
		origArgs = frame:getParent().args
		for k, v in pairs( frame.args ) do
			origArgs = frame.args
			break
		end
	else
		origArgs = frame
	end
	-- Process the args to make an array of portal names that can be used with ipairs. We need to use ipairs because we want to list
	-- all the portals in the order they were passed to the template, but we also want to be able to deal with positional arguments
	-- passed explicitly, for example {{portal|2=Politics}}. The behaviour of ipairs is undefined if nil values are present, so we
	-- need to make sure they are all removed.
	local portals, args = {}, {}
	for k, v in pairs( origArgs ) do
		if type( k ) == 'number' and type( v ) == 'string' then -- Make sure we have no non-string portal names.
			if mw.ustring.find( v, '%S' ) then -- Remove blank values.
				table.insert( portals, k )
				end
			elseif type( k ) ~= 'number' then -- Separate named arguments from portals.
			if type( v ) == 'string' then
				v = mw.text.trim( v )
			end
			args[ k ] = v
		end
	end
	table.sort( portals )
	for i, v in ipairs( portals ) do
		portals[ i ] = mw.text.trim( origArgs[ v ] ) -- Swap keys with values, trimming whitespace.
	end
	return p._main( portals, args )
end

return p</text>
      <sha1>hhcitye9cqzf5mza0dn088avzk32kzp</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Redirect</title>
    <ns>828</ns>
    <id>38849415</id>
    <revision>
      <id>885089475</id>
      <parentid>773537701</parentid>
      <timestamp>2019-02-25T22:06:47Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Module:Redirect]]": [[Wikipedia:High-risk templates|High-risk template or module]]; used in system message ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3689" xml:space="preserve">-- This module provides functions for getting the target of a redirect page.

local p = {}

-- Gets a mw.title object, using pcall to avoid generating script errors if we
-- are over the expensive function count limit (among other possible causes).
local function getTitle(...)
	local success, titleObj = pcall(mw.title.new, ...)
	if success then
		return titleObj
	else
		return nil
	end
end

-- Gets the name of a page that a redirect leads to, or nil if it isn't a
-- redirect.
function p.getTargetFromText(text)
	return string.match(
		text,
		"^%s*#[Rr][Ee][Dd][Ii][Rr][Ee][Cc][Tt]%s*:?%s*%[%[([^%[%]|]-)%]%]"
	) or string.match(
		text,
		"^%s*#[Rr][Ee][Dd][Ii][Rr][Ee][Cc][Tt]%s*:?%s*%[%[([^%[%]|]-)|[^%[%]]-%]%]"
	)
end

-- Gets the target of a redirect. If the page specified is not a redirect,
-- returns nil.
function p.getTarget(page, fulltext)
	-- Get the title object. Both page names and title objects are allowed
	-- as input.
	local titleObj
	if type(page) == 'string' or type(page) == 'number' then
		titleObj = getTitle(page)
	elseif type(page) == 'table' and type(page.getContent) == 'function' then
		titleObj = page
	else
		error(string.format(
			"bad argument #1 to 'getTarget'"
				.. " (string, number, or title object expected, got %s)",
			type(page)
		), 2)
	end
	if not titleObj or not titleObj.isRedirect then
		return nil
	end
	
	-- Find the target by using string matching on the page content.
	local target = p.getTargetFromText(titleObj:getContent() or "")
	if target then
		local targetTitle = getTitle(target)
		if targetTitle then
			if fulltext then
				return targetTitle.fullText
			else
				return targetTitle.prefixedText
			end
		else
			return nil
		end
	else
		-- The page is a redirect, but matching failed. This indicates a bug in
		-- the redirect matching pattern, so throw an error.
		error(string.format(
			'could not parse redirect on page "%s"',
			fulltext and titleObj.fullText or titleObj.prefixedText
		))
	end
end

--[[
-- Given a single page name determines what page it redirects to and returns the
-- target page name, or the passed page name when not a redirect. The passed
-- page name can be given as plain text or as a page link.
-- 
-- Returns page name as plain text, or when the bracket parameter is given, as a
-- page link. Returns an error message when page does not exist or the redirect
-- target cannot be determined for some reason.
--]]
function p.luaMain(rname, bracket, fulltext)
	if type(rname) ~= "string" or not rname:find("%S") then
		return nil
	end
	bracket = bracket and "[[%s]]" or "%s"
	rname = rname:match("%[%[(.+)%]%]") or rname
	local target = p.getTarget(rname, fulltext)
	local ret = target or rname
	ret = getTitle(ret)
	if ret then
		if fulltext then
			ret = ret.fullText
		else
			ret = ret.prefixedText
		end
		return bracket:format(ret)
	else
		return nil
	end
end

-- Provides access to the luaMain function from wikitext.
function p.main(frame)
	local args = require('Module:Arguments').getArgs(frame, {frameOnly = true})
	return p.luaMain(args[1], args.bracket, args.fulltext) or ''
end

-- Returns true if the specified page is a redirect, and false otherwise.
function p.luaIsRedirect(page)
	local titleObj = getTitle(page)
	if not titleObj then
		return false
	end
	if titleObj.isRedirect then
		return true
	else
		return false
	end
end

-- Provides access to the luaIsRedirect function from wikitext, returning 'yes'
-- if the specified page is a redirect, and the blank string otherwise.
function p.isRedirect(frame)
	local args = require('Module:Arguments').getArgs(frame, {frameOnly = true})
	if p.luaIsRedirect(args[1]) then
		return 'yes'
	else
		return ''
	end
end

return p</text>
      <sha1>ada8ml76e2w9edlkodgxumwd5ucz0bf</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Redirect hatnote</title>
    <ns>828</ns>
    <id>42680232</id>
    <revision>
      <id>833409182</id>
      <parentid>726676462</parentid>
      <timestamp>2018-03-31T10:45:06Z</timestamp>
      <contributor>
        <username>Galobtter</username>
        <id>19502780</id>
      </contributor>
      <comment>text= option</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3910" xml:space="preserve">--[[
-- This module produces a "redirect" hatnote. It looks like this:
-- '"X" redirects here. For other uses, see Y.'
-- It implements the {{redirect}} template.
--]]

local mHatnote = require('Module:Hatnote')
local mHatList = require('Module:Hatnote list')
local mArguments --lazily initialize
local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType
local checkTypeMulti = libraryUtil.checkTypeMulti

local p = {}

local function getTitle(...)
	local success, titleObj = pcall(mw.title.new, ...)
	if success then
		return titleObj
	else
		return nil
	end
end

function p.redirect(frame)
	mArguments = require('Module:Arguments')
	local args = mArguments.getArgs(frame, {parentOnly=true})
	--Get number of redirects
	local numRedirects = tonumber(frame.args[1]) or 1
	-- Create the options table.
	local options = {}
	options.selfref = args.selfref
	return p._redirect(args, numRedirects, options)
end

function p._redirect(args, numRedirects, options, currentTitle, redirectTitle, targetTitle)
	-- Validate the input. Don't bother checking currentTitle, redirectTitle or
	-- targetTitle, as they are only used in testing.
	checkType('_redirect', 1, args, 'table')
	checkType('_redirect', 2, numRedirects, 'number', true)
	numRedirects = numRedirects or 1
	checkType('_redirect', 3, options, 'table', true)
	options = options or {}
	currentTitle = currentTitle or mw.title.getCurrentTitle()
	-- Get the table of redirects
	local redirect = {}
	for i = 1, numRedirects do
		-- Return an error if a redirect parameter is missing.
		if not args[i] then
			return mHatnote.makeWikitextError(
				'missing redirect parameter',
				'Template:Redirect#Errors',
				args.category
			)
		end
		redirect[i] = args[i]
	end
	-- Generate the text.
	local formattedRedirect = {}
	for k,v in pairs(redirect) do
		formattedRedirect[k] = '"' .. v .. '"'
	end
	local text = {
		mHatList.andList(formattedRedirect) .. ' ' .. (#redirect == 1 and 'redirects' or 'redirect') .. ' here.',
		mHatList._forSee(args, #redirect + 1, {title = redirect[1], extratext = args.text})
	}
	text = table.concat(text, ' ')
	-- Functionality for adding categories	
	local categoryTable = {}
	function addCategory(cat)
		if cat and cat ~= '' then
			-- Add by index to avoid duplicates
			categoryTable[string.format('[[Category:%s]]', cat)] = true
		end
	end
	--Generate tracking categories
	local mhOptions = {}
	for k,v in pairs(redirect) do
		-- We don't need a tracking category if the template invocation has been
		-- copied directly from the docs, or if we aren't in main- or category-space.
		if not v:find('^REDIRECT%d*$') and v ~= 'TERM' -- 
			and currentTitle.namespace == 0 or currentTitle.namespace == 14
		then
			redirectTitle = redirectTitle or getTitle(v)
			if not redirectTitle or not redirectTitle.exists then
				addCategory('Missing redirects')
			elseif not redirectTitle.isRedirect then
				addCategory('Articles with redirect hatnotes needing review')
			else
				local mRedirect = require('Module:Redirect')
				local target = mRedirect.getTarget(redirectTitle)
				targetTitle = targetTitle or target and getTitle(target)
				if targetTitle and targetTitle ~= currentTitle then
					addCategory('Articles with redirect hatnotes needing review')
				end
			end
		end

		-- Generate the options to pass to [[Module:Hatnote]].
		if currentTitle.namespace == 0 and not mhOptions.selfref
			and redirectTitle and redirectTitle.namespace ~= 0
		then
			-- We are on a mainspace page, and the hatnote starts with something
			-- like "Wikipedia:Foo redirects here", so automatically label it as
			-- a self-reference.
			mhOptions.selfref = true
		else
			mhOptions.selfref = options.selfref
		end
	end
	--concatenate all the categories
	local category = ''
	for k,v in pairs(categoryTable) do
		category = category .. k
	end

	return mHatnote._hatnote(text, mhOptions) .. category
end
 
return p</text>
      <sha1>shg1gl73yd4p5wk0fnxak9sr5559490</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Sidebar</title>
    <ns>828</ns>
    <id>38866323</id>
    <revision>
      <id>953293775</id>
      <parentid>953293631</parentid>
      <timestamp>2020-04-26T17:45:10Z</timestamp>
      <contributor>
        <username>Plastikspork</username>
        <id>5075409</id>
      </contributor>
      <comment>Undid revision 953293631 by [[Special:Contributions/Plastikspork|Plastikspork]] ([[User talk:Plastikspork|talk]])</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="8090" xml:space="preserve">--
-- This module implements {{Sidebar}}
--
require('Module:No globals')

local p = {}

local getArgs = require('Module:Arguments').getArgs
local navbar = require('Module:Navbar')._navbar

local function trimAndAddAutomaticNewline(s)
	-- For compatibility with the original {{sidebar with collapsible lists}}
	-- implementation, which passed some parameters through {{#if}} to trim
	-- their whitespace. This also triggered the automatic newline behavior.
	-- ([[meta:Help:Newlines and spaces#Automatic newline]])
	s = mw.ustring.gsub(s, "^%s*(.-)%s*$", "%1")
	if mw.ustring.find(s, '^[#*:;]') or mw.ustring.find(s, '^{|') then
		return '\n' .. s
	else
		return s
	end
end

local function hasSubgroup(s)
	if mw.ustring.find(s, 'vertical%-navbox%-subgroup') then
		return true
	else
		return false
	end
end

function p.sidebar(frame, args)
	if not args then
		args = getArgs(frame)
	end
	local root = mw.html.create()
	local child = args.child and mw.text.trim(args.child) == 'yes'

	root = root:tag('table')
	if not child then
		root 
			:addClass('vertical-navbox')
			:addClass(args.wraplinks ~= 'true' and 'nowraplinks' or nil)
			:addClass(args.bodyclass or args.class)
			:css('float', args.float or 'right')
			:css('clear', (args.float == 'none' and 'both') or args.float or 'right')
			:css('width', args.width or '22.0em')
			:css('margin', args.float == 'left' and '0 1.0em 1.0em 0' or '0 0 1.0em 1.0em')
			:css('background', '#f9f9f9')
			:css('border', '1px solid #aaa')
			:css('padding', '0.2em')
			:css('border-spacing', '0.4em 0')
			:css('text-align', 'center')
			:css('line-height', '1.4em')
			:css('font-size', '88%')
			:cssText(args.bodystyle or args.style)

		if args.outertitle then
			root
				:tag('caption')
					:addClass(args.outertitleclass)
					:css('padding-bottom', '0.2em')
					:css('font-size', '125%')
					:css('line-height', '1.2em')
					:css('font-weight', 'bold')
					:cssText(args.outertitlestyle)
					:wikitext(args.outertitle)
		end

		if args.topimage then
			local imageCell = root:tag('tr'):tag('td')

			imageCell
				:addClass(args.topimageclass)
				:css('padding', '0.4em 0')
				:cssText(args.topimagestyle)
				:wikitext(args.topimage)

			if args.topcaption then
				imageCell
					:tag('div')
						:css('padding-top', '0.2em')
						:css('line-height', '1.2em')
						:cssText(args.topcaptionstyle)
						:wikitext(args.topcaption)
			end
		end

		if args.pretitle then
			root
				:tag('tr')
					:tag('td')
						:addClass(args.pretitleclass)
						:cssText(args.basestyle)
						:css('padding-top', args.topimage and '0.2em' or '0.4em')
						:css('line-height', '1.2em')
						:cssText(args.pretitlestyle)
						:wikitext(args.pretitle)
		end
	else
		root
			:addClass('vertical-navbox-subgroup')
			:css('width', '100%')
			:css('margin', '0px')
			:css('border-spacing', '0px')
			:addClass(args.bodyclass or args.class)
			:cssText(args.bodystyle or args.style)
	end

	if args.title then
		if child then
			root
				:wikitext(args.title)
		else
			root
				:tag('tr')
					:tag('th')
						:addClass(args.titleclass)
						:cssText(args.basestyle)
						:css('padding', '0.2em 0.4em 0.2em')
						:css('padding-top', args.pretitle and 0)
						:css('font-size', '145%')
						:css('line-height', '1.2em')
						:cssText(args.titlestyle)
						:wikitext(args.title)
		end
	end

	if args.image then
		local imageCell = root:tag('tr'):tag('td')

		imageCell
			:addClass(args.imageclass)
			:css('padding', '0.2em 0 0.4em')
			:cssText(args.imagestyle)
			:wikitext(args.image)

		if args.caption then
			imageCell
				:tag('div')
					:css('padding-top', '0.2em')
					:css('line-height', '1.2em')
					:cssText(args.captionstyle)
					:wikitext(args.caption)
		end
	end

	if args.above then
		root
			:tag('tr')
				:tag('td')
					:addClass(args.aboveclass)
					:css('padding', '0.3em 0.4em 0.3em')
					:css('font-weight', 'bold')
					:cssText(args.abovestyle)
					:newline() -- newline required for bullet-points to work
					:wikitext(args.above)
	end

	local rowNums = {}
	for k, v in pairs(args) do
		k = '' .. k
		local num = k:match('^heading(%d+)$') or k:match('^content(%d+)$')
		if num then table.insert(rowNums, tonumber(num)) end
	end
	table.sort(rowNums)
	-- remove duplicates from the list (e.g. 3 will be duplicated if both heading3 and content3 are specified)
	for i = #rowNums, 1, -1 do
		if rowNums[i] == rowNums[i - 1] then
			table.remove(rowNums, i)
		end
	end

	for i, num in ipairs(rowNums) do
		local heading = args['heading' .. num]
		if heading then
			root
				:tag('tr')
					:tag('th')
						:addClass(args.headingclass)
						:css('padding', '0.1em')
						:cssText(args.basestyle)
						:cssText(args.headingstyle)
						:cssText(args['heading' .. num .. 'style'])
						:newline()
						:wikitext(heading)
		end

		local content = args['content' .. num]
		if content then
			root
				:tag('tr')
					:tag('td')
						:addClass(args.contentclass)
						:css('padding', hasSubgroup(content) and '0.1em 0 0.2em' or '0 0.1em 0.4em')
						:cssText(args.contentstyle)
						:cssText(args['content' .. num .. 'style'])
						:newline()
						:wikitext(content)
						:done()
					:newline() -- Without a linebreak after the &lt;/td&gt;, a nested list like "* {{hlist| ...}}" doesn't parse correctly.
		end
	end

	if args.below then
		root
			:tag('tr')
				:tag('td')
					:addClass(args.belowclass)
					:css('padding', '0.3em 0.4em 0.3em')
					:css('font-weight', 'bold')
					:cssText(args.belowstyle)
					:newline()
					:wikitext(args.below)
	end

	if not child then
		local navbarArg = args.navbar or args.tnavbar
		if navbarArg ~= 'none' and navbarArg ~= 'off' and (args.name or frame:getParent():getTitle():gsub('/sandbox$', '') ~= 'Template:Sidebar') then
			root
				:tag('tr')
					:tag('td')
						:css('text-align', 'right')
						:css('font-size', '115%')
						:cssText(args.navbarstyle or args.tnavbarstyle)
						:wikitext(navbar{
							args.name,
							mini = 1,
							fontstyle = args.navbarfontstyle or args.tnavbarfontstyle
						})
		end
	end

	return tostring(root) .. (child and '[[Category:Pages using sidebar with the child parameter]]' or '')
end

function p.collapsible(frame)
	local args = getArgs(frame)

	args.abovestyle = 'border-top: 1px solid #aaa; border-bottom: 1px solid #aaa;' .. (args.abovestyle or '')
	args.belowstyle = 'border-top: 1px solid #aaa; border-bottom: 1px solid #aaa;' .. (args.belowstyle or '')
	args.navbarstyle = 'padding-top: 0.6em;' .. (args.navbarstyle or args.tnavbarstyle or '')
	if not args.name and frame:getParent():getTitle():gsub('/sandbox$', '') == 'Template:Sidebar with collapsible lists' then
		args.navbar = 'none'
	end

	local contentArgs = {}

	for k, v in pairs(args) do
		local num = string.match(k, '^list(%d+)$')
		if num then
			local expand = args.expanded and (args.expanded == 'all' or args.expanded == args['list' .. num .. 'name'])

			local row = mw.html.create('div')
			row
				:addClass('NavFrame')
				:addClass((not expand) and 'collapsed' or nil)
				:css('border', 'none')
				:css('padding', 0)
				:cssText(args.listframestyle)
				:cssText(args['list' .. num .. 'framestyle'])
				:tag('div')
					:addClass('NavHead')
					:addClass(args.listtitleclass)
					:css('font-size', '105%')
					:css('background', 'transparent')
					:css('text-align', 'left')
					:cssText(args.basestyle)
					:cssText(args.listtitlestyle)
					:cssText(args['list' .. num .. 'titlestyle'])
					:wikitext(trimAndAddAutomaticNewline(args['list' .. num .. 'title'] or 'List'))
					:done()
				:tag('div')
					:addClass('NavContent')
					:addClass(args.listclass)
					:addClass(args['list' .. num .. 'class'])
					:css('font-size', '105%')
					:css('padding', '0.2em 0 0.4em')
					:css('text-align', 'center')
					:cssText(args.liststyle)
					:cssText(args['list' .. num .. 'style'])
					:wikitext(trimAndAddAutomaticNewline(args['list' .. num]))

			contentArgs['content' .. num] = tostring(row)
		end
	end

	for k, v in pairs(contentArgs) do
		args[k] = v
	end

	return p.sidebar(frame, args)
end

return p</text>
      <sha1>nl0z60vm1dqd1n1127n1i9l5mn67p0m</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Disambiguation</title>
    <ns>10</ns>
    <id>9950598</id>
    <revision>
      <id>904781077</id>
      <parentid>900033329</parentid>
      <timestamp>2019-07-04T13:58:10Z</timestamp>
      <contributor>
        <username>DannyS712</username>
        <id>34581532</id>
      </contributor>
      <comment>Undid revision 900033329 by [[Special:Contributions/Wbm1058|Wbm1058]] ([[User talk:Wbm1058|talk]]) - revert, per [[Template talk:Disambiguation#Template-protected edit request on 4 July 2019|talk]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1857" xml:space="preserve">{{Dmbox
| type = disambig
| text = &lt;includeonly&gt;{{#if:{{{nocat|}}}||{{Disambiguation page short description}}}}&lt;/includeonly&gt;This [[Help:Disambiguation|disambiguation]] page lists {{{type|{{#if:{{{ignore_parentheses|}}}||{{Title disambig text|{{trim|{{Str rep|{{{page-title|{{FULLPAGENAME}}}}}|(disambiguation)|}}}}}}}}}}} &lt;includeonly&gt;{{template other|templates|&lt;/includeonly&gt;articles&lt;includeonly&gt;}}&lt;/includeonly&gt; associated with the title '''{{#if:{{{ignore_parentheses|}}}|{{{page-title|{{FULLPAGENAME}}}}}|{{PAGENAMEBASE|{{{page-title|{{FULLPAGENAME}}}}}}}}}'''. &lt;br /&gt; &lt;small&gt;If an [{{fullurl:Special:WhatLinksHere/{{{page-title|{{FULLPAGENAME}}}}}|namespace=0}} internal link] led you here, you may wish to change the link to point directly to the intended article.&lt;/small&gt;
| nocat = {{{nocat|}}}   &lt;!--So "nocat=true" works--&gt;
}}{{main other
| demospace = {{{demospace|}}}
| [[Category:Disambiguation pages]]{{disambiguation/cat|{{{1|}}}}}{{disambiguation/cat|{{{2|}}}}}{{disambiguation/cat|{{{3|}}}}}{{disambiguation/cat|{{{4|}}}}}{{disambiguation/cat|{{{5|}}}}}{{disambiguation/cat|{{{6|}}}}}{{disambiguation/cat|{{{7|}}}}}{{disambiguation/cat|{{{8|}}}}}{{disambiguation/cat|{{{9|}}}}}{{disambiguation/cat|{{{10|}}}}}{{#if:{{Title disambig text|{{trim|{{Str rep|{{FULLPAGENAME}}|(disambiguation)|}}}}}}|[[Category:Disambiguation pages with (qualified) titles]]|}}
| &lt;!-- Don't categorise when not in main (article) space. However, note that {{Dmbox}} categorises pages into Category:All disambiguation pages and Category:All article disambiguation pages--&gt;
}}&lt;includeonly&gt;{{#if:{{{nocat|}}}||{{#ifeq:{{#invoke:redirect|isRedirect|{{TALKPAGENAME}}}}|yes|[[Category:Unsynchronized disambiguation talk pages]]}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;!-- Add categories to the /doc subpage and interwikis to Wikidata, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>pzjmiqh497exc24c0yx57f276yqkwob</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Disambiguation/cat</title>
    <ns>10</ns>
    <id>21250838</id>
    <revision>
      <id>822433989</id>
      <parentid>815189385</parentid>
      <timestamp>2018-01-26T10:20:29Z</timestamp>
      <contributor>
        <username>MSGJ</username>
        <id>42630</id>
      </contributor>
      <comment>add category for stations, per request</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3328" xml:space="preserve">{{#switch:{{lc:{{{1|}}}}}
| split      = [[Category:Disambiguation pages in need of being split]]
| clean up
| clean-up
| cleanup    = [[Category:Disambiguation pages in need of cleanup]]
| airports
| airport    = [[Category:Airport disambiguation]]
| bird       = [[Category:Bird common name disambiguation pages]]
| call sign
| call signs
| broadcast call sign
| broadcast call signs
| callsign   = [[Category:Broadcast call sign disambiguation pages]]
| caselaw    = [[Category:Case law disambiguation pages]]
| chinese char
| chinese-char
| chinesechar
| chinese character 
| chinese    = [[Category:Disambiguation pages with Chinese character titles]]
| churches
| church building
| church buildings
| church     = [[Category:Church building disambiguation pages]]
| fish       = [[Category:Fish common name disambiguation pages]]
| geodis
| geography
| geographical
| place name
| place names
| place
| places
| geo        = [[Category:Place name disambiguation pages]]
| county     = [[Category:County name disambiguation pages]]
| uscounty   = [[Category:United States county name disambiguation pages]]
| township   = [[Category:Township name disambiguation pages]]
| name
| names
| human name
| human names
| hndis
| hn         = [[Category:Human name disambiguation pages]]
| surnames   = [[Category:Disambiguation pages with surname-holder lists]]
| surname    = [[Category:Disambiguation pages with surname-holder lists]]
| given names =[[Category:Disambiguation pages with given-name-holder lists]]
| given name = [[Category:Disambiguation pages with given-name-holder lists]]
| hospital name
| hospital names
| hospitals
| hospital   = [[Category:Hospital disambiguation pages]]
| latin name
| latin names
| latin      = [[Category:Latin name disambiguation pages]]
| letter-number
| letter number = [[Category:Letter-number combination disambiguation pages]]
| mathdab
| maths
| mathematics
| mathematical
| math       = [[Category:Mathematics disambiguation pages]]
| numberdis
| numbers
| ambiguous number
| ambiguous numbers
| number     = [[Category:Lists of ambiguous numbers]]
| plants
| plant      = [[Category:Plant common name disambiguation pages]]
| roaddis
| roads
| road       = [[Category:Road disambiguation pages]]
| schooldis
| schools
| educational institution
| educational institutions
| college
| colleges
| university
| universities
| school     = [[Category:Educational institution disambiguation pages]]
| station    = [[Category:Station disambiguation pages]]
| tndis      = [[Category:Title and name disambiguation pages]]
| political
| party      = [[Category:Political party disambiguation pages]]
| genus      = [[Category:Genus disambiguation pages]]
| ship       = [[Category:Ship disambiguation pages]]
|            = &lt;!-- No value fed, is also valid input --&gt;
| #default   = &lt;!-- &lt;div style="text-align: center;"&gt;This disambiguation box is using an invalid category parameter "{{{1|}}}" and needs fixing. &lt;small&gt;([[:Category:Wikipedia disambig or set index box parameter needs fixing|learn more]])&lt;/small&gt;&lt;/div&gt; --&gt;[[Category:Wikipedia disambig or set index box parameter needs fixing|{{main other|Main:}}{{FULLPAGENAME}}]]&lt;!-- Sort on namespace --&gt;
}}&lt;noinclude&gt;
{{Documentation}}
&lt;!--Please add this template's categories to the /doc subpage, not here - thanks!--&gt;
&lt;/noinclude&gt;</text>
      <sha1>au8eqndwlrbrvemnaoskkutu1g32y1b</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Disambiguation page short description</title>
    <ns>10</ns>
    <id>57298612</id>
    <revision>
      <id>882782963</id>
      <parentid>876201420</parentid>
      <timestamp>2019-02-11T08:46:39Z</timestamp>
      <contributor>
        <username>Jonesey95</username>
        <id>9755426</id>
      </contributor>
      <comment>cat moved to documentation page</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="228" xml:space="preserve">&lt;includeonly&gt;{{short description|Disambiguation page providing links to topics that could be referred to by the same search term|noreplace|pagetype = Disambiguation page}}&lt;/includeonly&gt;&lt;noinclude&gt;

{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>gf1yoxoylflrjmebo306o719l7z1hea</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Dmbox</title>
    <ns>10</ns>
    <id>19662365</id>
    <revision>
      <id>888336095</id>
      <parentid>843328035</parentid>
      <timestamp>2019-03-18T13:54:00Z</timestamp>
      <contributor>
        <username>WOSlinker</username>
        <id>3138265</id>
      </contributor>
      <comment>use templatestyles</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2347" xml:space="preserve">&lt;templatestyles src="Dmbox/styles.css" /&gt;
&lt;table id="
{{#switch:{{{type|}}}
| setindex = setindexbox
| disambig      
| #default = disambigbox
}}" class="metadata plainlinks dmbox 
{{#switch:{{{type|}}}
| setindex = dmbox-setindex
| disambig      
| #default = dmbox-disambig
}} {{{class|}}}" style="{{{style|}}}" role="presentation"&gt;
&lt;tr&gt;
{{#ifeq:{{{image|}}}|none
| &lt;!-- No image. Cell with some width or padding necessary for text cell to have 100% width. --&gt;&lt;td class="mbox-empty-cell"&gt;&lt;/td&gt;
| &lt;td class="mbox-image" style="padding: 2px 0 2px 0.4em;"&gt; {{#if:{{{image|}}}
  | {{{image}}}
  | [[File:{{#switch:{{{type|}}}
    | setindex = DAB list gray.svg
    | disambig      &lt;!-- disambig = default --&gt;
    | #default = Disambig gray.svg
    }}|30px|alt=Disambiguation icon]]
  }}&lt;/td&gt;
}}
&lt;td class="mbox-text" style="padding: 0.25em 0.4em; font-style: italic; {{{textstyle|}}}"&gt; {{{text}}} &lt;/td&gt;
{{#if:{{{imageright|}}}
| &lt;td class="mbox-imageright" style="padding: 2px 0.4em 2px 0;"&gt; {{{imageright}}} &lt;/td&gt;
}}
&lt;/tr&gt;
&lt;/table&gt;&lt;!-- 
  Detect and report usage with faulty "type" parameter:
--&gt;{{#switch:{{{type|}}}
|   &lt;!-- No type fed, is also valid input --&gt;
| disambig
| setindex =    &lt;!-- Do nothing, valid "type" --&gt;
| #default = &lt;div style="text-align: center;"&gt;This message box is using an invalid "type={{{type|}}}" parameter and needs fixing.&lt;/div&gt;[[Category:Wikipedia message box parameter needs fixing|{{main other|Main:}}{{FULLPAGENAME}}]]&lt;!-- Sort on namespace --&gt;
}}&lt;!-- 
  Magic word for disambiguation pages:
--&gt;{{#if:{{{nocat|}}}||{{#ifeq:{{{type|}}}|disambig|__DISAMBIG__|}}}}&lt;!-- 
  Categorization:
--&gt;{{#switch:{{{type|}}}
| setindex = 
  {{category handler
  | main = [[Category:All set index articles]]
  | nocat = {{{nocat|}}}   &lt;!--So "nocat=true" works--&gt;
  | page = {{{page|}}}   &lt;!--For testing--&gt;
  }}
| disambig    &lt;!-- disambig = default --&gt;
| #default = 
  {{category handler
  | main = [[Category:All article disambiguation pages]][[Category:All disambiguation pages]]
  | template =    &lt;!-- Don't categorize on template pages. --&gt;
  | other = [[Category:All disambiguation pages]]
  | nocat = {{{nocat|}}}   &lt;!--So "nocat=true" works--&gt;
  | page = {{{page|}}}   &lt;!--For testing--&gt;
  }}
}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories to the /doc subpage and interwikis to Wikidata, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>n6r7u9qq70c0wdfbtg7ybyimkk47x0t</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Dmbox/styles.css</title>
    <ns>10</ns>
    <id>60263071</id>
    <revision>
      <id>889293728</id>
      <parentid>888336019</parentid>
      <timestamp>2019-03-24T19:45:25Z</timestamp>
      <contributor>
        <username>Pppery</username>
        <id>28032115</id>
      </contributor>
      <comment>Adding protection template</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="204" xml:space="preserve">/* {{pp-template}} */
/* Disambig and set index box styles */
table.dmbox {
	clear: both;
	margin: 0.9em 1em;
	border-top: 1px solid #ccc;
	border-bottom: 1px solid #ccc;
	background-color: transparent;
}</text>
      <sha1>4bbtwwsktvsnu5e12016swv258jrt5j</sha1>
    </revision>
  </page>
  <page>
    <title>Template:In title</title>
    <ns>10</ns>
    <id>20031948</id>
    <revision>
      <id>886859922</id>
      <parentid>862947180</parentid>
      <timestamp>2019-03-09T00:31:22Z</timestamp>
      <contributor>
        <username>SMcCandlish</username>
        <id>378390</id>
      </contributor>
      <comment>grammar</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="465" xml:space="preserve">&lt;span class="selfreference"&gt;[[Special:Search/intitle:"{{#invoke:String|replace|{{{1|{{PAGENAME}}}}}|"}}"{{#switch:{{{plural}}}|yes={{sp}}OR intitle:"{{{1|{{PAGENAME}}}}}s"}}|{{{2|All pages with titles containing ''{{#invoke:String|replace|{{{1|{{PAGENAME}}}}}|"}}''{{#switch:{{{plural}}}|yes={{sp}}or ''{{{1|{{PAGENAME}}}}}s''}}}}}]]&lt;/span&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories to the /doc subpage; interwikis go to Wikidata, thank you! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>2h1cxp6e93xgdbmxd4f4fx2ry5rprfr</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Intitle</title>
    <ns>10</ns>
    <id>34876767</id>
    <redirect title="Template:In title" />
    <revision>
      <id>827245412</id>
      <parentid>810908619</parentid>
      <timestamp>2018-02-23T16:30:04Z</timestamp>
      <contributor>
        <username>Primefac</username>
        <id>11508456</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Intitle]]": [[WP:HIGHRISK|high-risk]] template with 4000+ transclusions ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="81" xml:space="preserve">#REDIRECT [[Template:In title]]

{{Rcat shell|{{R from move}}{{R from spacing}}}}</text>
      <sha1>sh2u1n3pm46mkzqscwqgo8ndkt4g0kc</sha1>
    </revision>
  </page>
  <page>
    <title>Template:PAGENAMEBASE</title>
    <ns>10</ns>
    <id>29780699</id>
    <revision>
      <id>708575225</id>
      <parentid>636280634</parentid>
      <timestamp>2016-03-06T09:37:56Z</timestamp>
      <contributor>
        <username>Cabayi</username>
        <id>6561336</id>
      </contributor>
      <comment>per edit request &amp; discussion</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="141" xml:space="preserve">{{{{{|safesubst:}}}#Invoke:String|replace|{{{1|{{{{{|safesubst:}}}PAGENAME}}}}}|%s+%b()$||1|false}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>sam8aetb68ekom4findu6pp900ngldr</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Pp-semi</title>
    <ns>10</ns>
    <id>10596961</id>
    <redirect title="Template:Pp" />
    <revision>
      <id>774346835</id>
      <parentid>667569400</parentid>
      <timestamp>2017-04-07T20:34:19Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Pp-semi]]": Matching redirect target ([Edit=Require autoconfirmed or confirmed access] (indefinite) [Move=Require autoconfirmed or confirmed access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="81" xml:space="preserve">#REDIRECT [[Template:Pp]]
[[Category:Top icon protection templates|{{PAGENAME}}]]</text>
      <sha1>dmjz94i05ph4b95q6wjtqxnd2h9bph5</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Side box</title>
    <ns>10</ns>
    <id>20504849</id>
    <revision>
      <id>774482268</id>
      <parentid>611333719</parentid>
      <timestamp>2017-04-08T19:24:23Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Side box]]": [[WP:High-risk templates|Highly visible template]]: Allowing template editors ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="142" xml:space="preserve">{{#invoke:Side box|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>s1zpy5c500y28mjgve7gykq14088u4e</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sister project</title>
    <ns>10</ns>
    <id>20505184</id>
    <revision>
      <id>787938066</id>
      <parentid>777927888</parentid>
      <timestamp>2017-06-28T13:37:35Z</timestamp>
      <contributor>
        <username>Train2104</username>
        <id>10341578</id>
      </contributor>
      <minor/>
      <comment>wkt logo renamed</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1403" xml:space="preserve">{{Side box
| metadata=no
| position = {{{position|}}}
| image    = 
  {{#switch: {{{image|}}}
  | none =    &lt;!-- "image=none", do nothing --&gt;
  |      =    &lt;!-- No image fed, select an image --&gt;
    [[File:{{#switch: {{lc: {{{project|}}} }}
    | commons                = Commons-logo.svg
    | meta|metawiki|m        = Wikimedia Community Logo.svg
    | wikibooks|wbk|wb|b     = Wikibooks-logo-en-noslogan.svg
    | wikidata|data          = Wikidata-logo.svg
    | wikiquote|quote|wqt|q  = Wikiquote-logo.svg
    | wikipedia|wp|w         = Wikipedia-logo-v2.svg
    | wikisource|source|ws|s = Wikisource-logo.svg
    | wiktionary|wkt|wdy|d   = Wiktionary-logo-en-v2.svg
    | wikinews|news|wnw|n    = Wikinews-logo.svg
    | wikispecies|species    = Wikispecies-logo.svg
    | wikiversity|wvy|v      = Wikiversity-logo.svg
    | wikivoyage|voyage|voy  = Wikivoyage-Logo-v3-icon.svg
    | mediawiki|mw           = Mediawiki.png
    | outreachwiki|outreach  = Wikimedia Outreach.png
    | incubator              = Incubator-notext.svg
    | #default               = Wikimedia-logo.svg
    }}|40x40px|class=noviewer|alt=|link=
    ]]
  | #default = {{{image|}}}
  }}
| text       = {{{text}}}
| below      = {{{below|}}}
| imageright = {{{imageright|}}}
| class      = plainlinks sistersitebox
}}&lt;noinclude&gt;{{Documentation}}&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;&lt;/noinclude&gt;</text>
      <sha1>ourm3r954byna7jozjp47ggyjuoy2zn</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Str rep</title>
    <ns>10</ns>
    <id>24238435</id>
    <revision>
      <id>656461393</id>
      <parentid>656457182</parentid>
      <timestamp>2015-04-14T16:35:55Z</timestamp>
      <contributor>
        <username>Redrose64</username>
        <id>9612106</id>
      </contributor>
      <minor/>
      <comment>Protected Template:Str rep: [[WP:High-risk templates|Highly visible template]]: 167176 transclusions ([Edit=Allow only template editors and admins] (indefinite) [Move=Allow only template editors and admins] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="100" xml:space="preserve">{{#invoke:String|replace|source={{{1}}}|{{{2}}}|{{{3}}}|1}}&lt;noinclude&gt;
{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>8aojqr2n3b0gv6drwu3safb8kuckf72</sha1>
    </revision>
  </page>
  <page>
    <title>Template:TOC right</title>
    <ns>10</ns>
    <id>1242749</id>
    <revision>
      <id>872693416</id>
      <parentid>690361935</parentid>
      <timestamp>2018-12-08T16:11:35Z</timestamp>
      <contributor>
        <username>TheDJ</username>
        <id>244887</id>
      </contributor>
      <comment>switch to template styles</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="434" xml:space="preserve">&lt;templatestyles src="Template:TOC_right/styles.css" /&gt;{{#if:{{{limit|}}}|&lt;templatestyles src="Template:TOC limit/styles.css" /&gt;}}&lt;!--
--&gt;&lt;div class="tocright {{#if:{{{clear|}}}|tocright-clear-{{{clear|}}}}} {{#if:{{{limit|}}}|toclimit-{{{limit}}}}}" style="{{#if:{{{width|{{{1|}}}}}}|width: {{{width|{{{1}}}}}};}}"&gt;__TOC__&lt;/div&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add cats and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>mt15wq5aepioouqvgukw37ap6fawb01</sha1>
    </revision>
  </page>
  <page>
    <title>Template:TOC right/styles.css</title>
    <ns>10</ns>
    <id>59323150</id>
    <revision>
      <id>886049878</id>
      <parentid>872693300</parentid>
      <timestamp>2019-03-04T00:02:08Z</timestamp>
      <contributor>
        <username>Pppery</username>
        <id>28032115</id>
      </contributor>
      <comment>Adding protection template</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="267" xml:space="preserve">/* {{pp-template}} */
.tocright {
	float: right;
	clear: right;
	width: auto;
	background: none;
	padding: .5em 0 .8em 1.4em;
	margin-bottom: .5em; 
}
.tocright-clear-left {
	clear: left;
}
.tocright-clear-both {
	clear: both;
}
.tocright-clear-none {
	clear: none;
}</text>
      <sha1>ahbm3qa6ych3s7m5nymbfe32voxs9fk</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Title disambig text</title>
    <ns>10</ns>
    <id>23313287</id>
    <revision>
      <id>828662492</id>
      <parentid>649039363</parentid>
      <timestamp>2018-03-03T23:53:50Z</timestamp>
      <contributor>
        <username>Plastikspork</username>
        <id>5075409</id>
      </contributor>
      <comment>Add a sensible default</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="121" xml:space="preserve">{{#invoke:String|match|{{{1|{{PAGENAME}}}}}|%s%((.-)%)||-1|ignore_errors=true}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>4gnlprh3ybnnh7v1mecolj95b4hslq3</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Trim</title>
    <ns>10</ns>
    <id>21815705</id>
    <revision>
      <id>668935791</id>
      <parentid>412919929</parentid>
      <timestamp>2015-06-27T18:27:45Z</timestamp>
      <contributor>
        <username>Plastikspork</username>
        <id>5075409</id>
      </contributor>
      <comment>Merging [[Template:Strip whitespace]] per TfD</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="114" xml:space="preserve">&lt;includeonly&gt;{{ {{{|safesubst:}}}#if:1|{{{x|{{{1|}}}}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;

{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>h9devvk8f6nt34tp7zb17s39ge5wquh</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Wiktionary</title>
    <ns>10</ns>
    <id>960068</id>
    <revision>
      <id>876212663</id>
      <parentid>663515553</parentid>
      <timestamp>2018-12-31T21:54:37Z</timestamp>
      <contributor>
        <username>Steel1943</username>
        <id>2952402</id>
      </contributor>
      <comment>Update template to be able to handle 10 entries</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1110" xml:space="preserve">{{Sister project
|position={{{position|}}}
|project=wiktionary
|text=Look up '''''[[wiktionary:{{{1|Special:Search/{{lc:{{SUBPAGENAME}}}}}}}|{{{1|{{lc:{{SUBPAGENAME}}}}}}}]]'''''{{#if:{{{2|}}}
  |{{#if:{{{3|}}}
   |,
   |&amp;nbsp;or
  }} '''''[[wiktionary:{{{2}}}|{{{2}}}]]'''''
 }}{{#if:{{{3|}}}
  |{{#if:{{{4|}}}
   |,
   |, or
  }} '''''[[wiktionary:{{{3}}}|{{{3}}}]]'''''
 }}{{#if:{{{4|}}}
  |{{#if:{{{5|}}}
   |,
   |, or
  }} '''''[[wiktionary:{{{4}}}|{{{4}}}]]'''''
 }}{{#if:{{{5|}}}
  |{{#if:{{{6|}}}
   |,
   |, or
  }} '''''[[wiktionary:{{{5}}}|{{{5}}}]]'''''
 }}{{#if:{{{6|}}}
  |{{#if:{{{7|}}}
   |,
   |, or
  }} '''''[[wiktionary:{{{6}}}|{{{6}}}]]'''''
 }}{{#if:{{{7|}}}
  |{{#if:{{{8|}}}
   |,
   |, or
  }} '''''[[wiktionary:{{{7}}}|{{{7}}}]]'''''
 }}{{#if:{{{8|}}}
  |{{#if:{{{9|}}}
   |,
   |, or
  }} '''''[[wiktionary:{{{8}}}|{{{8}}}]]'''''
 }}{{#if:{{{9|}}}
  |{{#if:{{{10|}}}
   |,
   |, or
  }} '''''[[wiktionary:{{{9}}}|{{{9}}}]]'''''
 }}{{#if:{{{10|}}}
  |, or '''''[[wiktionary:{{{10}}}|{{{10}}}]]'''''
 }} in Wiktionary, the free dictionary.
}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>6sulq40lr6vgf6cizbrvl1gy3gln14p</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Side box</title>
    <ns>828</ns>
    <id>42926982</id>
    <revision>
      <id>899337436</id>
      <parentid>765979084</parentid>
      <timestamp>2019-05-29T11:24:57Z</timestamp>
      <contributor>
        <username>WOSlinker</username>
        <id>3138265</id>
      </contributor>
      <comment>add newline before end of table</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2759" xml:space="preserve">-- This module implements {{side box}}.

local yesno = require('Module:Yesno')

local p = {}

function p.main(frame)
	local origArgs = frame:getParent().args
	local args = {}
	for k, v in pairs(origArgs) do
		v = v:match('%s*(.-)%s*$')
		if v ~= '' then
			args[k] = v
		end
	end
	return p._main(args)
end

function p._main(args)
	local data = p.makeData(args)
	return p.renderSidebox(data)
end

function p.makeData(args)
	local data = {}

	-- Main table classes
	data.classes = {}
	if yesno(args.metadata) ~= false then
		table.insert(data.classes, 'metadata')
	end
	if args.position and args.position:lower() == 'left' then
		table.insert(data.classes, 'mbox-small-left')
	else
		table.insert(data.classes, 'mbox-small')
	end
	table.insert(data.classes, args.class)
	
	-- Image
	if args.image and args.image ~= 'none' then
		data.image = args.image
	end

	-- Copy over data that doesn't need adjusting
	local argsToCopy = {
		-- Styles
		'style',
		'textstyle',

		-- Above row
		'above',
		'abovestyle',

		-- Body row
		'text',
		'imageright',

		-- Below row
		'below',
	}
	for i, key in ipairs(argsToCopy) do
		data[key] = args[key]
	end

	return data
end

function p.renderSidebox(data)
	-- Renders the sidebox HTML.

	-- Table root
	local root = mw.html.create('table')
	root:attr('role', 'presentation')
	for i, class in ipairs(data.classes or {}) do
		root:addClass(class)
	end
	root:css{border = '1px solid #aaa', ['background-color'] = '#f9f9f9', color = '#000'}
	if data.style then
		root:cssText(data.style)
	end

	-- The "above" row
	if data.above then
		local aboveCell = root:newline():tag('tr'):tag('td')
		aboveCell
			:attr('colspan', data.imageright and 3 or 2)
			:addClass('mbox-text')
		if data.textstyle then
			aboveCell:cssText(data.textstyle)
		end
		if data.abovestyle then
			aboveCell:cssText(data.abovestyle)
		end
		aboveCell
			:newline()
			:wikitext(data.above)
	end

	-- The body row
	local bodyRow = root:newline():tag('tr'):newline()
	if data.image then
		bodyRow:tag('td')
			:addClass('mbox-image')
			:wikitext(data.image)
	else
		bodyRow:tag('td'):css('width', '1px')
	end
	local textCell = bodyRow:newline():tag('td')
	textCell:addClass('mbox-text plainlist')
	if data.textstyle then
		textCell:cssText(data.textstyle)
	end
	textCell:wikitext(data.text)
	if data.imageright then
		bodyRow:newline():tag('td')
			:addClass('mbox-imageright')
			:wikitext(data.imageright)
	end

	-- The below row
	if data.below then
		local belowCell = root:newline():tag('tr'):tag('td')
		belowCell
			:attr('colspan', data.imageright and 3 or 2)
			:addClass('mbox-text')
		if data.textstyle then
			belowCell:cssText(data.textstyle)
		end
		belowCell:wikitext(data.below)
	end

	root:newline()
	return tostring(root)
end

return p</text>
      <sha1>dv8zqfc1qz5h1eftaqbuoxpfew96q44</sha1>
    </revision>
  </page>
  <page>
    <title>COVID-19</title>
    <ns>0</ns>
    <id>63089950</id>
    <redirect title="Coronavirus disease 2019" />
    <revision>
      <id>949265720</id>
      <parentid>948445534</parentid>
      <timestamp>2020-04-05T14:13:16Z</timestamp>
      <contributor>
        <username>Brainulator9</username>
        <id>11191612</id>
      </contributor>
      <comment>adding category</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="122" xml:space="preserve">#REDIRECT [[Coronavirus disease 2019]]

{{Redirect category shell|
{{R from move}}
{{R from acronym}}
{{R printworthy}}
}}</text>
      <sha1>l9msx1anfpin2d8ea299p9p4btzsxiz</sha1>
    </revision>
  </page>
  <page>
    <title>Template:If</title>
    <ns>10</ns>
    <id>15682776</id>
    <revision>
      <id>757998242</id>
      <parentid>757708691</parentid>
      <timestamp>2017-01-02T22:40:44Z</timestamp>
      <contributor>
        <username>Redrose64</username>
        <id>9612106</id>
      </contributor>
      <comment>Undid revision 757708691 by [[Special:Contributions/CambridgeBayWeather|CambridgeBayWeather]] ([[User talk:CambridgeBayWeather|talk]]) pointless, the {{Documentation}} handles any prot icons that may be appropriate</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="282" xml:space="preserve">{{ {{{|safesubst:}}}p{{ {{{|safesubst:}}}#ifeq:{{{1}}}|eq|1|2}}|{{ {{{|safesubst:}}}p{{ {{{|safesubst:}}}#ifeq:{{{2}}}|{{{3}}}|1|2}}|{{{4|}}}|{{{5|}}}}}|{{ {{{|safesubst:}}}p{{ {{{|safesubst:}}}#if{{{1}}}:{{{2}}}|1|2}}|{{{3}}}|{{{4|}}}}}}}&lt;noinclude&gt;

{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>dnw2ilti3nqno6b7fnldiv3r2adunua</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Mbox</title>
    <ns>10</ns>
    <id>13319244</id>
    <revision>
      <id>874063565</id>
      <parentid>772147376</parentid>
      <timestamp>2018-12-16T22:16:17Z</timestamp>
      <contributor>
        <username>Amorymeltzer</username>
        <id>141948</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Mbox]]": [[WP:High-risk templates|Highly visible template]]: 1M transclusions, used in the interface, cascade protected ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="145" xml:space="preserve">{{#invoke:Message box|mbox}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>mpflpb6s8l8gaoxaeypyuqyu2w7vc7i</sha1>
    </revision>
  </page>
  <page>
    <title>Template:P2</title>
    <ns>10</ns>
    <id>15682790</id>
    <revision>
      <id>772147423</id>
      <parentid>524740391</parentid>
      <timestamp>2017-03-25T16:04:18Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:P2]]": Allowing template editors on some templates with full protection dating back to pre-[[WP:TPROT]] times which aren't too often or too sensitively used. ([Edit=Require template editor access] (indefinite) [...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="120" xml:space="preserve">{{{2}}}&lt;noinclude&gt;

{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>duozeijtz6f7quc59lhhpe6ycu023mt</sha1>
    </revision>
  </page>
  <page>
    <title>Template:R avoided double redirect</title>
    <ns>10</ns>
    <id>46308094</id>
    <revision>
      <id>945009682</id>
      <parentid>944268988</parentid>
      <timestamp>2020-03-11T08:02:18Z</timestamp>
      <contributor>
        <username>Gonnym</username>
        <id>14984434</id>
      </contributor>
      <comment>update per [[Template_talk:R_avoided_double_redirect#Template-protected_edit_request_on_6_March_2020|talk page]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="429" xml:space="preserve">&lt;includeonly&gt;{{If ||{{{doc|}}} |&lt;!--Do nothing--&gt; |{{#invoke:R avoided double redirect|main|{{{1|}}}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{This is a redirect/rcat|text={{R avoided double redirect|(redirect page name)|thistarget=(target article)|othertarget=(target article)|noerror=1}}}}
{{R avoided double redirect|(redirect page name)|thistarget=(target article)|othertarget=(target article)|noerror=1}}
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>g1dco5yj6temsk0lkoy3dgxp7yvumfq</sha1>
    </revision>
  </page>
  <page>
    <title>Template:R from acronym</title>
    <ns>10</ns>
    <id>10523286</id>
    <revision>
      <id>861556620</id>
      <parentid>861554315</parentid>
      <timestamp>2018-09-28T09:13:43Z</timestamp>
      <contributor>
        <username>John Cline</username>
        <id>11987994</id>
      </contributor>
      <comment>undo self, unexpected consequences</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="616" xml:space="preserve">&lt;noinclude&gt;{{This is a redirect/rcat}}
&lt;/noinclude&gt;{{Redirect template
  |name=From an acronym
  |from=an [[acronym]]
  |to=a related topic, such as the expansion of the acronym
  |info=** Remember that an acronym is a special type of [[initialism]] that can be spoken as a word, such as "NATO" or "radar" or "[[ANOVA]]".
** Use {{tl|R from initialism}} for abbreviations that have letters that are pronounced separately, such as "OAU" or "USSR" or "[[DoD]]".
  |main category=Redirects from acronyms
}}&lt;noinclude&gt;
&lt;!-- Place categories on /doc subpage; interwikis go to Wikidata. --&gt;
{{Documentation}} 
&lt;/noinclude&gt;</text>
      <sha1>5lvaxuddq45tdwk30l77432ftnx5dv2</sha1>
    </revision>
  </page>
  <page>
    <title>Template:R from alternative capitalisation</title>
    <ns>10</ns>
    <id>4146219</id>
    <redirect title="Template:R from other capitalisation" />
    <revision>
      <id>819682653</id>
      <parentid>769984605</parentid>
      <timestamp>2018-01-10T18:59:39Z</timestamp>
      <contributor>
        <username>Primefac</username>
        <id>11508456</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:R from alternative capitalisation]]": [[WP:SEMI|semi-protecting]] highly-visible templates in response to recent template-space vandalism ([Edit=Require autoconfirmed or confirmed access] (indefinite) [Move=Require autoconfirmed o...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="136" xml:space="preserve">#Redirect [[Template:R from other capitalisation]]

{{Redirect category shell|
{{R from alternative name}}
{{R to redirect template}}
}}</text>
      <sha1>3dv4kxyxkwedmve5b680lkv8saj6bp4</sha1>
    </revision>
  </page>
  <page>
    <title>Template:R from other capitalisation</title>
    <ns>10</ns>
    <id>586123</id>
    <revision>
      <id>751846825</id>
      <parentid>733026918</parentid>
      <timestamp>2016-11-28T04:17:43Z</timestamp>
      <contributor>
        <username>Xaosflux</username>
        <id>502540</id>
      </contributor>
      <comment>typo fix from edit request on talk</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1219" xml:space="preserve">&lt;noinclude&gt;{{This is a redirect/rcat}}
&lt;/noinclude&gt;{{Redirect template
  |name=From other capitalisation
  |from=a title with another method of capitalisation{{#if:{{{2|{{{of|{{{reason|}}}}}}}}}|&amp;nbsp;of {{{2|{{{of|{{{reason|}}}}}}}}}}}. It leads
  |to=the title in accordance with the [[Wikipedia:Naming conventions (capitalization)|Wikipedia naming conventions for capitalisation]], or it leads to a title that is associated in some way with the conventional capitalisation of this redirect title.  This may help writing, searching and international language issues
  |info=** If this redirect is an incorrect capitalisation, then {{tl|R from miscapitalisation}} should be used ''instead'', and pages that use this link should be updated to link ''directly'' to the target.  Miscapitalisations can be tagged in ''any namespace''.
** Use this rcat to tag ''only'' [[WP:Mainspace|mainspace]] redirects; when other capitalisations are in other namespaces, use {{tl|R from modification}} ''instead''.
  |main category=Redirects from other capitalisations
  |printworthy={{#ifeq:{{{1}}}|printworthy|yes|no}}
}}&lt;noinclude&gt;
&lt;!-- Place categories on /doc subpage; interwikis go to Wikidata. --&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>mtoq77kbqx58jp6yhuysc24fwxbllnk</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Redirect category shell</title>
    <ns>10</ns>
    <id>51108920</id>
    <revision>
      <id>902429382</id>
      <parentid>902382644</parentid>
      <timestamp>2019-06-18T19:14:26Z</timestamp>
      <contributor>
        <username>Redrose64</username>
        <id>9612106</id>
      </contributor>
      <comment>Undid revision 902382644 by [[Special:Contributions/Paine Ellsworth|Paine Ellsworth]] ([[User talk:Paine Ellsworth|talk]]) no, that means that nothing shows for full and TE prot levels</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2135" xml:space="preserve">{{Mbox
| name  = Redirect category shell
| type  = move 
| image = none
| style = margin-top: 1.1em; border: solid 1px darkblue; border-left-width: 0.5em;
| textstyle = padding-top: 0.9em; padding-bottom: 0.9em;
| text  = [[File:Symbol redirect arrow with gradient.svg|25px|link=]] '''This page is a [[Wikipedia:Redirect|redirect]]:'''{{#if:{{{h|}}}
 |:: ''{{{h}}}''
 }}&lt;!--
  Automatically detect protected redirects:
--&gt;&lt;includeonly&gt;{{#switch: {{PROTECTIONLEVEL:move}}
   |sysop|templateeditor|extendedconfirmed={{pp-move|small=yes}}
 }}{{#switch: {{PROTECTIONLEVEL:edit}}
   |sysop={{pp-protected|small=yes}}{{R protected|embed=yes}}
   |templateeditor={{pp-protected|small=yes}}{{R template protected|embed=yes}}
   |extendedconfirmed={{pp-protected|small=yes}}{{R extended-protected|embed=yes}}
   |autoconfirmed={{pp-protected|small=yes}}{{R semi-protected|embed=yes}}
   | &lt;!--Not protected, or only semi-move-protected--&gt;
 }}&lt;/includeonly&gt;{{#if: {{{1|}}}||&lt;includeonly&gt;
* {{red|'''Important – Please Read! {{maroon|This template should {{em|not}} be applied without parameters by bot nor by any automated or semi-automated process. It should {{em|not}} be used without parameters {{em|unless you want to learn how to categorize redirects}}. For editors who want to learn how to categorize redirects, this template is a {{em|learning tool}}. {{em|Only}} those editors who intend to return to the redirect to learn which rcats to use should apply this template without parameters, or with an empty first parameter!}}'''}}&lt;/includeonly&gt;
* '''Manifold sort''':  If help is needed to determine appropriate categories, then this redirect populates '''{{Cat|Miscellaneous redirects}}'''.  Monitors of that category will check this redirect and add or remove [[WP:RCAT|rcat]]s as needed.{{#ifeq: {{lc:{{{nocat|false}}}}} | false |{{{category|&lt;includeonly&gt;[[Category:Miscellaneous redirects]]&lt;/includeonly&gt;}}}}}
}}
{{#if: {{{2|}}}|{{{2}}}|{{{1|}}}}}
''&lt;small&gt;When appropriate, [[Wikipedia:Protection policy|protection levels]] are automatically sensed, described and categorized.&lt;/small&gt;''
}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>gyx5kfnjtgojtaxu9qg71upsba6r2yf</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Redirect template</title>
    <ns>10</ns>
    <id>30505076</id>
    <revision>
      <id>672699497</id>
      <parentid>630853914</parentid>
      <timestamp>2015-07-23T08:16:39Z</timestamp>
      <contributor>
        <username>Paine Ellsworth</username>
        <id>9092818</id>
      </contributor>
      <minor/>
      <comment>for correct appearance of documentation page on template page</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="75" xml:space="preserve">{{#invoke:Redirect template|main}}&lt;noinclude&gt;
{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>1cl28dcwjsrtge5hedu653jwub1cll3</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Tl</title>
    <ns>10</ns>
    <id>1487430</id>
    <revision>
      <id>948474337</id>
      <parentid>948472478</parentid>
      <timestamp>2020-04-01T06:33:49Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <comment>Undid revision 948472477 by [[Special:Contributions/w&gt;Billinghurst|w&gt;Billinghurst]] ([[User talk:w&gt;Billinghurst|talk]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="168" xml:space="preserve">&amp;#123;&amp;#123;[[Template:{{{1}}}|{{{1}}}]]&amp;#125;&amp;#125;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>h0vr3yvr9jdyd17x82vnav21ngwmxuk</sha1>
    </revision>
  </page>
  <page>
    <title>Module:R avoided double redirect</title>
    <ns>828</ns>
    <id>46308063</id>
    <revision>
      <id>945009676</id>
      <parentid>884967780</parentid>
      <timestamp>2020-03-11T08:02:15Z</timestamp>
      <contributor>
        <username>Gonnym</username>
        <id>14984434</id>
      </contributor>
      <comment>update per [[Template_talk:R_avoided_double_redirect#Template-protected_edit_request_on_6_March_2020|talk page]]</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5927" xml:space="preserve">local p = {}

function p.main(frame)

local mRedirect = require("Module:Redirect")
local function noredir(page)
  local link = mw.title.new(page):fullUrl("redirect=no")
  return "&lt;span class=\"plainlinks\"&gt;["..link.." "..page.."]&lt;/span&gt;"
end
local function process(page)
  return mw.title.new(page).prefixedText
end
local function exists(page)
  return mw.title.new(page).exists
end

local args = require("Module:Arguments").getArgs(frame,{removeBlanks=false})
local thisPage = tostring(mw.title.getCurrentTitle())
local otherPage = args[1] or ""

--Demo parameters, for demonstrating behavior with certain redirect 
--targets and avoiding categorization (do not use in articles)
local thisDemoTarget = args.thistarget
local otherDemoTarget = args.othertarget
local noError = args.noerror
local demo = args.demo or noError or thisDemoTarget or otherDemoTarget

--"Process" pages to remove section links, standardize capitalization, etc.
otherPage = otherPage=="" and "" or process(otherPage)
thisDemoTarget = thisDemoTarget=="" and "" or thisDemoTarget and process(thisDemoTarget)
otherDemoTarget = otherDemoTarget=="" and "" or otherDemoTarget and process(otherDemoTarget)

--Determine redirect targets (getTarget returns nil if page is not a redirect)
local thisTarget = thisDemoTarget or mRedirect.getTarget(thisPage)
local otherTarget = otherDemoTarget or mRedirect.getTarget(otherPage)
--For double redirects
local thisDoubleTarget = thisTarget and mRedirect.getTarget(thisTarget)
local otherDoubleTarget = otherTarget and mRedirect.getTarget(otherTarget)
-- Allow setting demo parameters to empty string to demonstrate a non-redirect
thisTarget = thisDemoTarget~="" and thisTarget
otherTarget = otherDemoTarget~="" and otherTarget

--Errors
local err
if not thisTarget and exists(thisPage) then --Check existence of thisPage to avoid errors in preview mode
  err = "This page is not a redirect."
elseif otherPage=="" then
  err = "No other page was specified."
elseif not exists(otherPage) then
  err = "[["..otherPage.."]] does not exist."
elseif thisTarget==thisPage or (not exists(thisTarget) and exists(thisPage)) then
  err = "This is a broken redirect (it redirects to itself or to a non-existing page)."
elseif otherTarget and (otherTarget==otherPage or not exists(otherTarget)) then
  err = noredir(otherPage).." is a broken redirect (it redirects to itself or to a non-existing page)."
elseif otherPage==thisPage then
  err = "The current page was passed as parameter."
elseif not otherTarget and thisTarget==otherPage then
  err = "This page already redirects to [["..otherPage.."]]. Please remove this template."
elseif otherPage==thisTarget and otherTarget==thisPage then
  err = "This is a circular redirect. Please change the target of both this redirect and "..noredir(otherPage).." to the correct article."
elseif thisDoubleTarget and otherDoubleTarget and thisDoubleTarget==otherDoubleTarget then
  err = "Both this page and "..noredir(otherPage).." are double redirects. Please change the redirect target of both to "
        ..(mRedirect.luaIsRedirect(thisDoubleTarget) and "the correct article." or "[["..thisDoubleTarget.."]].")
elseif otherTarget and (thisTarget==otherPage or thisDoubleTarget==otherTarget) then
  err = "This is a [[Wikipedia:Double redirects|double redirect]]."
        .." Please change the redirect target to [["..otherTarget.."]]."
elseif otherTarget and thisDoubleTarget then
  err = "This is a [[Wikipedia:Double redirects|double redirect]] to [["..thisDoubleTarget.."]], while "
        ..noredir(otherPage).." redirects to [["..otherTarget.."]]."
elseif thisDoubleTarget then
  err = "This is a [[Wikipedia:Double redirects|double redirect]] to [["..thisDoubleTarget.."]]."
elseif otherTarget==thisPage then
  err = noredir(otherPage).." is a [[Wikipedia:Double redirects|double redirect]]."
        .." Please change its target to [["..thisTarget.."]]."
elseif otherDoubleTarget then
  err = noredir(otherPage).." is a [[Wikipedia:Double redirects|double redirect]]"
        .." to [["..otherDoubleTarget.."]] via [["..otherTarget.."]]."
elseif otherTarget and thisTarget~=otherTarget then
  err = "This page and "..noredir(otherPage).." redirect to different articles."
end

--Return either redirect template or error
local from, info, cat
if not err or noError then
  if otherTarget then
    from = "an alternative title for '''"..noredir(otherPage).."''', another redirect to the same title"
    info = "Because [[Wikipedia:Double redirects|double redirects]] are disallowed,"
           .." both pages currently point to [["..otherTarget.."]].\n"
           .."**If and when "..noredir(otherPage).." is expanded into a separate"
           .." article, or its target article is renamed to "..noredir(otherPage)..", this"
           .." redirect will be recategorized to be changed to target that article instead."
    cat = demo and "" or "Avoided double redirects"
  else
    from = "an alternative title for '''[["..otherPage.."]]''', a former redirect to the same title"
    info = "\n**Since [["..otherPage.."]] is now a separate article, please"
           .." update this redirect's target to [["..otherPage.."]] and remove the"
           .." {{[[Template:R avoided double redirect|R avoided double redirect]]}} template."
           .."\n**If [["..otherPage.."]] is the wrong target for this redirect,"
           .." edit this page and correct the page name in the template."
    cat = demo and "" or "Avoided double redirects to be updated"
  end
  return frame:expandTemplate({title="Redirect template",
                               args={from=from,info=info,["main category"]=cat,
                                     name="From an avoided double redirect"}})
else
  return "&lt;span class=\"error\"&gt;Error in [[Module:R avoided double redirect]]: "..err.."&lt;/span&gt;"
         ..(demo and "" or "[[Category:Avoided double redirects/error]]")
end

end

return p</text>
      <sha1>4xah1g6eblnx1k1xmolmwjy72el0pr5</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Redirect template</title>
    <ns>828</ns>
    <id>44195575</id>
    <revision>
      <id>876873353</id>
      <parentid>876522600</parentid>
      <timestamp>2019-01-05T01:46:24Z</timestamp>
      <contributor>
        <username>Paine Ellsworth</username>
        <id>9092818</id>
      </contributor>
      <comment>xfer from sandbox per edit request at [[Template talk:Redirect template#Template-protected edit request on 4 January 2019|template talk page]]</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2784" xml:space="preserve">require('Module:No globals')

local p = {}

-- key is beginning of arg name. value is table with namespace number and link
-- alternatively, a function taking the namespace number and returning a validity
-- can be used
local namespaceCategories = {
	all = { function() return true end },
	main = { 0, '[[wp:mainspace|main]]' },
	help = { 12, '[[wp:help namespace|help]]' },
	portal = { 100, '[[wp:portal|portal]]' },
	talk = { function(n) return n &gt; 0 and n%2 == 1 end, '[[Help:Using talk pages|talk]]' },
	template = { 10, '[[wp:template namespace|template]]' },
	wikipedia = { 4, '[[wp:project namespace|Wikipedia project]]' },
	category = { 14, '[[wp:categorization|category]]' },
	user = { 2, '[[wp:user pages|user]]' },
}

-- remove whitespaces from beginning and end of args
local function valueFunc(key, val)
	if type(val) == 'string' then
		val = val:match('^%s*(.-)%s*$')
		if val == '' then
			return nil
		end
	end
	return val
end

local function getPrettyName(args)
	for k in pairs(namespaceCategories) do
		if args[k .. ' category'] then
			return string.format("'''[[:Category:%s|%s]]''': ", args[k .. ' category'], args.name)
		end
	end
	return string.format("'''%s''': ", args.name)
end

function p.main(frame)
	local args = require('Module:Arguments').getArgs(frame, {wrappers = 'Template:Redirect template', valueFunc = valueFunc})
	local namespace = mw.title.getCurrentTitle().namespace

	--- XXX: this is a HORRIBLE HACK. kill it with fire as soon as https://bugzilla.wikimedia.org/show_bug.cgi?id=12974 is fixed
	local beCompatibleWithBug12974 = args.info and (args.info:find('^[:;#*]', 1) == 1 or args.info:find('{|', 1, true) == 1) and '\n' or ' '
	
	local content = string.format('\n&lt;div class="rcat %s"&gt;\n*%sThis is a redirect%s%s.%s%s&lt;/div&gt;',
		args.class or '',
		args.name and getPrettyName(args) or '',
		args.from and (' from ' .. args.from) or '',
		args.to and (' to ' .. args.to) or '',
		args.info and beCompatibleWithBug12974 or '',
		args.info or ''
	)
	
	for k,v in pairs(namespaceCategories) do
		if args[k .. ' category'] then
			if type(v[1]) == 'function' and v[1](namespace) or v[1] == namespace then
				content = content .. string.format('[[Category:%s]]', args[k .. ' category'])
			elseif args['other category'] then
				content = content .. string.format('[[Category:%s]]', args['other category'])
			else
				content = content .. frame:expandTemplate{title = 'Incorrect redirect template', args = {v[2]}}
			end
		end
	end

	if namespace == 0 then
		local yesno = require('Module:Yesno')
		if yesno(args.printworthy) == true then
			return content .. '[[Category:Printworthy redirects]]'
		elseif yesno(args.printworthy) == false then
			return content .. '[[Category:Unprintworthy redirects]]'
		end
	end
	return content
end

return p</text>
      <sha1>sahu4ltcd20h8g7fxy5xkl47mzk3vjp</sha1>
    </revision>
  </page>
</mediawiki>
